var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  AddPPToWindowComponent: () => AddPPToWindowComponent,
  AddWLToWindowComponent: () => AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent: () => AdjustHierarchyPhysXScaleComponent,
  AnalyticsManager: () => AnalyticsManager,
  AnalyticsManagerComponent: () => AnalyticsManagerComponent,
  AnalyticsUtils: () => AnalyticsUtils,
  ArrayUtils: () => ArrayUtils,
  AudioEvent: () => AudioEvent,
  AudioManager: () => AudioManager,
  AudioManagerComponent: () => AudioManagerComponent,
  AudioPlayer: () => AudioPlayer,
  AudioSetup: () => AudioSetup,
  AudioUtils: () => AudioUtils,
  BaseGamepad: () => BaseGamepad,
  BasePose: () => BasePose,
  BasePoseParams: () => BasePoseParams,
  BenchmarkMaxPhysXComponent: () => BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent: () => BenchmarkMaxVisibleTrianglesComponent,
  BrowserUtils: () => BrowserUtils,
  CADisplayLeaderboardComponent: () => CADisplayLeaderboardComponent,
  CADummyServer: () => CADummyServer,
  CAError: () => CAError,
  CAUtils: () => CAUtils,
  CharacterColliderAdditionalParams: () => CharacterColliderAdditionalParams,
  CharacterColliderDebugParams: () => CharacterColliderDebugParams,
  CharacterColliderHorizontalCheckParams: () => CharacterColliderHorizontalCheckParams,
  CharacterColliderHorizontalPositionVerticalCheckDirection: () => CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup: () => CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel: () => CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams: () => CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSetupUtils: () => CharacterColliderSetupUtils,
  CharacterColliderSlideFlickerPreventionMode: () => CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementParams: () => CharacterColliderSplitMovementParams,
  CharacterColliderSurfaceParams: () => CharacterColliderSurfaceParams,
  CharacterColliderVerticalCheckParams: () => CharacterColliderVerticalCheckParams,
  CharacterColliderWallSlideParams: () => CharacterColliderWallSlideParams,
  CharacterCollisionCheckTransformResults: () => CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType: () => CharacterCollisionCheckType,
  CharacterCollisionDebugResults: () => CharacterCollisionDebugResults,
  CharacterCollisionInternalResults: () => CharacterCollisionInternalResults,
  CharacterCollisionMovementResults: () => CharacterCollisionMovementResults,
  CharacterCollisionResults: () => CharacterCollisionResults,
  CharacterCollisionSplitMovementResults: () => CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo: () => CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults: () => CharacterCollisionSurfaceResults,
  CharacterCollisionSystem: () => CharacterCollisionSystem,
  CharacterCollisionSystemComponent: () => CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults: () => CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults: () => CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults: () => CharacterCollisionWallSlideResults,
  CharacterControllerUtils: () => CharacterControllerUtils,
  ClassicGamepadCore: () => ClassicGamepadCore,
  ClearConsoleOnXRSessionStartComponent: () => ClearConsoleOnXRSessionStartComponent,
  CloneParams: () => CloneParams,
  CollisionCheck: () => CollisionCheck,
  CollisionCheckBridge: () => CollisionCheckBridge,
  CollisionCheckParams: () => CollisionCheckParams,
  CollisionCheckUtils: () => CollisionCheckUtils,
  CollisionRuntimeParams: () => CollisionRuntimeParams,
  ColorUtils: () => ColorUtils,
  ComponentUtils: () => ComponentUtils,
  ConsoleOriginalFunctions: () => ConsoleOriginalFunctions,
  ConsoleVR: () => ConsoleVR,
  ConsoleVRToolComponent: () => ConsoleVRToolComponent,
  ConsoleVRWidget: () => ConsoleVRWidget,
  ConsoleVRWidgetConfig: () => ConsoleVRWidgetConfig,
  ConsoleVRWidgetConsoleFunction: () => ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage: () => ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType: () => ConsoleVRWidgetMessageType,
  ConsoleVRWidgetParams: () => ConsoleVRWidgetParams,
  ConsoleVRWidgetPulseOnNewMessage: () => ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender: () => ConsoleVRWidgetSender,
  ConsoleVRWidgetUI: () => ConsoleVRWidgetUI,
  CopyHandTransformComponent: () => CopyHandTransformComponent,
  CopyHeadTransformComponent: () => CopyHeadTransformComponent,
  CopyPlayerTransformComponent: () => CopyPlayerTransformComponent,
  CopyReferenceSpaceTransformComponent: () => CopyReferenceSpaceTransformComponent,
  CustomCloneParams: () => CustomCloneParams,
  DebugArrayFunctionsPerformanceAnalyzerComponent: () => DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults: () => DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter: () => DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams: () => DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger: () => DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams: () => DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer: () => DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent: () => DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams: () => DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder: () => DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager: () => DebugManager,
  DebugManagerComponent: () => DebugManagerComponent,
  DebugPPArrayCreationPerformanceAnalyzerComponent: () => DebugPPArrayCreationPerformanceAnalyzerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent: () => DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent: () => DebugTransformComponent,
  DebugVisualManager: () => DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent: () => DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent: () => DebugWLFunctionsPerformanceAnalyzerComponent,
  DeepCloneParams: () => DeepCloneParams,
  DefaultResources: () => DefaultResources,
  DefaultResourcesMaterials: () => DefaultResourcesMaterials,
  DefaultResourcesMeshes: () => DefaultResourcesMeshes,
  DefaultWLComponentCloneCallbacks: () => DefaultWLComponentCloneCallbacks,
  Direction2DTo3DConverter: () => Direction2DTo3DConverter,
  Direction2DTo3DConverterParams: () => Direction2DTo3DConverterParams,
  EasingFunction: () => EasingFunction,
  EasingSupportFunction: () => EasingSupportFunction,
  EasyLightAttenuation: () => EasyLightAttenuation,
  EasyLightAttenuationComponent: () => EasyLightAttenuationComponent,
  EasyLightColor: () => EasyLightColor,
  EasyLightColorComponent: () => EasyLightColorComponent,
  EasyMeshAmbientFactor: () => EasyMeshAmbientFactor,
  EasyMeshAmbientFactorComponent: () => EasyMeshAmbientFactorComponent,
  EasyMeshColor: () => EasyMeshColor,
  EasyMeshColorComponent: () => EasyMeshColorComponent,
  EasyObjectTuner: () => EasyObjectTuner,
  EasyScale: () => EasyScale,
  EasyScaleComponent: () => EasyScaleComponent,
  EasySetTuneTargeetGrabComponent: () => EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent: () => EasySetTuneTargetChildNumberComponent,
  EasyTextColor: () => EasyTextColor,
  EasyTextColorComponent: () => EasyTextColorComponent,
  EasyTransform: () => EasyTransform,
  EasyTransformComponent: () => EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector: () => EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget: () => EasyTuneBaseWidget,
  EasyTuneBaseWidgetConfig: () => EasyTuneBaseWidgetConfig,
  EasyTuneBaseWidgetParams: () => EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetUI: () => EasyTuneBaseWidgetUI,
  EasyTuneBool: () => EasyTuneBool,
  EasyTuneBoolArray: () => EasyTuneBoolArray,
  EasyTuneBoolArrayWidget: () => EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetConfig: () => EasyTuneBoolArrayWidgetConfig,
  EasyTuneBoolArrayWidgetSelector: () => EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetUI: () => EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent: () => EasyTuneImportVariablesComponent,
  EasyTuneInt: () => EasyTuneInt,
  EasyTuneIntArray: () => EasyTuneIntArray,
  EasyTuneNoneWidget: () => EasyTuneNoneWidget,
  EasyTuneNoneWidgetConfig: () => EasyTuneNoneWidgetConfig,
  EasyTuneNoneWidgetUI: () => EasyTuneNoneWidgetUI,
  EasyTuneNumber: () => EasyTuneNumber,
  EasyTuneNumberArray: () => EasyTuneNumberArray,
  EasyTuneNumberArrayWidget: () => EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetConfig: () => EasyTuneNumberArrayWidgetConfig,
  EasyTuneNumberArrayWidgetSelector: () => EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetUI: () => EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent: () => EasyTuneToolComponent,
  EasyTuneTransform: () => EasyTuneTransform,
  EasyTuneTransformWidget: () => EasyTuneTransformWidget,
  EasyTuneTransformWidgetConfig: () => EasyTuneTransformWidgetConfig,
  EasyTuneTransformWidgetUI: () => EasyTuneTransformWidgetUI,
  EasyTuneUtils: () => EasyTuneUtils,
  EasyTuneVariable: () => EasyTuneVariable,
  EasyTuneVariableArray: () => EasyTuneVariableArray,
  EasyTuneVariableExtraParams: () => EasyTuneVariableExtraParams,
  EasyTuneVariableType: () => EasyTuneVariableType,
  EasyTuneVariables: () => EasyTuneVariables,
  EasyTuneWidget: () => EasyTuneWidget,
  EasyTuneWidgetConfig: () => EasyTuneWidgetConfig,
  EasyTuneWidgetParams: () => EasyTuneWidgetParams,
  EnableDebugComponent: () => EnableDebugComponent,
  EnableToolComponent: () => EnableToolComponent,
  FSM: () => FSM,
  FingerCursorComponent: () => FingerCursorComponent,
  GamepadAxesEvent: () => GamepadAxesEvent,
  GamepadAxesID: () => GamepadAxesID,
  GamepadAxesInfo: () => GamepadAxesInfo,
  GamepadButtonEvent: () => GamepadButtonEvent,
  GamepadButtonID: () => GamepadButtonID,
  GamepadButtonInfo: () => GamepadButtonInfo,
  GamepadControlSchemeComponent: () => GamepadControlSchemeComponent,
  GamepadCore: () => GamepadCore,
  GamepadMeshAnimatorComponent: () => GamepadMeshAnimatorComponent,
  GamepadPulseInfo: () => GamepadPulseInfo,
  GamepadUtils: () => GamepadUtils,
  GamepadsManager: () => GamepadsManager,
  GetDefaultResourcesComponent: () => GetDefaultResourcesComponent,
  GetSceneObjectsComponent: () => GetSceneObjectsComponent,
  Globals: () => Globals,
  GrabbableComponent: () => GrabbableComponent,
  GrabberHandComponent: () => GrabberHandComponent,
  HandPose: () => HandPose,
  HandPoseParams: () => HandPoseParams,
  Handedness: () => Handedness,
  HandednessIndex: () => HandednessIndex,
  HeadPose: () => HeadPose,
  HowlerAudioPlayer: () => HowlerAudioPlayer,
  InitConsoleVRComponent: () => InitConsoleVRComponent,
  InitEasyTuneVariablesComponent: () => InitEasyTuneVariablesComponent,
  InputManager: () => InputManager,
  InputManagerComponent: () => InputManagerComponent,
  InputSourceType: () => InputSourceType,
  InputUtils: () => InputUtils,
  IntOverFactor: () => IntOverFactor,
  IntRangeOverFactor: () => IntRangeOverFactor,
  JSUtils: () => JSUtils,
  KeyID: () => KeyID,
  Keyboard: () => Keyboard,
  KeyboardGamepadCore: () => KeyboardGamepadCore,
  Mat3Utils: () => Mat3Utils,
  Mat4Utils: () => Mat4Utils,
  MaterialUtils: () => MaterialUtils,
  MathUtils: () => MathUtils,
  MeshCreationParams: () => MeshCreationParams,
  MeshCreationTriangleParams: () => MeshCreationTriangleParams,
  MeshCreationVertexParams: () => MeshCreationVertexParams,
  MeshUtils: () => MeshUtils,
  Mouse: () => Mouse,
  MouseButtonID: () => MouseButtonID,
  MuteEverythingComponent: () => MuteEverythingComponent,
  NonVRReferenceSpaceMode: () => NonVRReferenceSpaceMode,
  NumberOverFactor: () => NumberOverFactor,
  NumberRangeOverFactor: () => NumberRangeOverFactor,
  ObjectPool: () => ObjectPool,
  ObjectPoolManager: () => ObjectPoolManager,
  ObjectPoolManagerComponent: () => ObjectPoolManagerComponent,
  ObjectPoolParams: () => ObjectPoolParams,
  ObjectUtils: () => ObjectUtils,
  OverrideBrowserConsoleFunctions: () => OverrideBrowserConsoleFunctions,
  PPGatewayComponent: () => PPGatewayComponent,
  PerformDelayedMode: () => PerformDelayedMode,
  PerformMode: () => PerformMode,
  PhysicsCollisionCollector: () => PhysicsCollisionCollector,
  PhysicsLayerFlags: () => PhysicsLayerFlags,
  PhysicsUtils: () => PhysicsUtils,
  PlayerHeadManager: () => PlayerHeadManager,
  PlayerHeadManagerParams: () => PlayerHeadManagerParams,
  PlayerLocomotion: () => PlayerLocomotion,
  PlayerLocomotionComponent: () => PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType: () => PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionMovement: () => PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams: () => PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams: () => PlayerLocomotionParams,
  PlayerLocomotionRotate: () => PlayerLocomotionRotate,
  PlayerLocomotionRotateParams: () => PlayerLocomotionRotateParams,
  PlayerLocomotionSmooth: () => PlayerLocomotionSmooth,
  PlayerLocomotionSmoothParams: () => PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleport: () => PlayerLocomotionTeleport,
  PlayerLocomotionTeleportDetectionParams: () => PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams: () => PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState: () => PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer: () => PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams: () => PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable: () => PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams: () => PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams: () => PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState: () => PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState: () => PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams: () => PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState: () => PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState: () => PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType: () => PlayerLocomotionTeleportTeleportType,
  PlayerLocomotionType: () => PlayerLocomotionType,
  PlayerObjects: () => PlayerObjects,
  PlayerObscureManager: () => PlayerObscureManager,
  PlayerObscureManagerParams: () => PlayerObscureManagerParams,
  PlayerTransformManager: () => PlayerTransformManager,
  PlayerTransformManagerParams: () => PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag: () => PlayerTransformManagerSyncFlag,
  PluginUtils: () => PluginUtils,
  Quat2Utils: () => Quat2Utils,
  QuatUtils: () => QuatUtils,
  RaycastHit: () => RaycastHit,
  RaycastParams: () => RaycastParams,
  RaycastResults: () => RaycastResults,
  SaveManager: () => SaveManager,
  SaveManagerComponent: () => SaveManagerComponent,
  SaveUtils: () => SaveUtils,
  SceneObjects: () => SceneObjects,
  SceneUtils: () => SceneUtils,
  SetActiveComponent: () => SetActiveComponent,
  SetHandLocalTransformComponent: () => SetHandLocalTransformComponent,
  SetHeadLocalTransformComponent: () => SetHeadLocalTransformComponent,
  SetPlayerHeightComponent: () => SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent: () => SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent: () => ShowFPSComponent,
  SkipStateFunction: () => SkipStateFunction,
  SpatialAudioListenerComponent: () => SpatialAudioListenerComponent,
  State: () => State,
  StateData: () => StateData,
  SwitchHandObjectComponent: () => SwitchHandObjectComponent,
  TextUtils: () => TextUtils,
  Timer: () => Timer,
  TimerState: () => TimerState,
  ToolCursorComponent: () => ToolCursorComponent,
  ToolHandedness: () => ToolHandedness,
  ToolInputSourceType: () => ToolInputSourceType,
  TrackedHandDrawAllJointsComponent: () => TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent: () => TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent: () => TrackedHandDrawSkinComponent,
  TrackedHandJointID: () => TrackedHandJointID,
  TrackedHandJointIDIndex: () => TrackedHandJointIDIndex,
  TrackedHandJointPose: () => TrackedHandJointPose,
  TrackedHandPose: () => TrackedHandPose,
  TrackedHandPoseParams: () => TrackedHandPoseParams,
  Transition: () => Transition,
  TransitionData: () => TransitionData,
  UniversalGamepad: () => UniversalGamepad,
  Vec2Utils: () => Vec2Utils,
  Vec3Utils: () => Vec3Utils,
  Vec4Utils: () => Vec4Utils,
  VecUtils: () => VecUtils,
  VirtualGamepad: () => VirtualGamepad,
  VirtualGamepadButtonParams: () => VirtualGamepadButtonParams,
  VirtualGamepadComponent: () => VirtualGamepadComponent,
  VirtualGamepadGamepadCore: () => VirtualGamepadGamepadCore,
  VirtualGamepadIcon: () => VirtualGamepadIcon,
  VirtualGamepadIconParams: () => VirtualGamepadIconParams,
  VirtualGamepadIconType: () => VirtualGamepadIconType,
  VirtualGamepadParams: () => VirtualGamepadParams,
  VirtualGamepadThumbstickParams: () => VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton: () => VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick: () => VirtualGamepadVirtualThumbstick,
  VisualArrow: () => VisualArrow,
  VisualArrowParams: () => VisualArrowParams,
  VisualElementType: () => VisualElementType,
  VisualLine: () => VisualLine,
  VisualLineParams: () => VisualLineParams,
  VisualManager: () => VisualManager,
  VisualManagerComponent: () => VisualManagerComponent,
  VisualMesh: () => VisualMesh,
  VisualMeshParams: () => VisualMeshParams,
  VisualPoint: () => VisualPoint,
  VisualPointParams: () => VisualPointParams,
  VisualRaycast: () => VisualRaycast,
  VisualRaycastParams: () => VisualRaycastParams,
  VisualResources: () => VisualResources,
  VisualResourcesMaterials: () => VisualResourcesMaterials,
  VisualText: () => VisualText,
  VisualTextParams: () => VisualTextParams,
  VisualTorus: () => VisualTorus,
  VisualTorusParams: () => VisualTorusParams,
  VisualTransform: () => VisualTransform,
  VisualTransformParams: () => VisualTransformParams,
  WidgetFrame: () => WidgetFrame,
  WidgetFrameConfig: () => WidgetFrameConfig,
  WidgetFrameUI: () => WidgetFrameUI,
  WidgetParams: () => WidgetParams,
  XRGamepadCore: () => XRGamepadCore,
  XRUtils: () => XRUtils,
  initArrayExtension: () => initArrayExtension,
  initArrayExtensionProtoype: () => initArrayExtensionProtoype,
  initComponentMods: () => initComponentMods,
  initCursorComponentMod: () => initCursorComponentMod,
  initCursorComponentModPrototype: () => initCursorComponentModPrototype,
  initCursorTargetComponentMod: () => initCursorTargetComponentMod,
  initCursorTargetComponentModPrototype: () => initCursorTargetComponentModPrototype,
  initJSExtensions: () => initJSExtensions,
  initJSPlugins: () => initJSPlugins,
  initMathExtension: () => initMathExtension,
  initMathExtensionStatic: () => initMathExtensionStatic,
  initMouseLookComponentMod: () => initMouseLookComponentMod,
  initMouseLookComponentModPrototype: () => initMouseLookComponentModPrototype,
  initNumberExtension: () => initNumberExtension,
  initNumberExtensionPrototype: () => initNumberExtensionPrototype,
  initObjectExtension: () => initObjectExtension,
  initObjectExtensionProtoype: () => initObjectExtensionProtoype,
  initPP: () => initPP,
  initPlugins: () => initPlugins,
  initSceneExtension: () => initSceneExtension,
  initSceneExtensionPrototype: () => initSceneExtensionPrototype,
  initWLExtensions: () => initWLExtensions,
  initWLMods: () => initWLMods,
  initWLPlugins: () => initWLPlugins,
  mat3_create: () => mat3_create,
  mat4_create: () => mat4_create,
  quat2_create: () => quat2_create,
  quat_create: () => quat_create,
  registerPPComponents: () => registerPPComponents,
  registerWLComponents: () => registerWLComponents,
  vec2_create: () => vec2_create,
  vec3_create: () => vec3_create,
  vec4_create: () => vec4_create
});

// dist/cauldron/wl/register_wl_components.js
import { ARCamera8thwall, Cursor, CursorTarget, DebugObject, DeviceOrientationLook, FingerCursor, FixedFoveation, HandTracking, HitTestLocation, HowlerAudioListener, HowlerAudioSource, ImageTexture, MouseLookComponent, PlayerHeight, TargetFramerate, TeleportComponent, Trail, TwoJointIkSolver, VideoTexture, VrModeActiveSwitch, Vrm, WasdControlsComponent } from "@wonderlandengine/components";
function registerWLComponents(engine) {
  engine.registerComponent(ARCamera8thwall, Cursor, CursorTarget, DebugObject, DeviceOrientationLook, FingerCursor, FixedFoveation, HandTracking, HitTestLocation, HowlerAudioListener, HowlerAudioSource, ImageTexture, MouseLookComponent, PlayerHeight, TargetFramerate, TeleportComponent, Trail, TwoJointIkSolver, VideoTexture, VrModeActiveSwitch, Vrm, WasdControlsComponent);
}

// dist/cauldron/wl/utils/component_utils.js
import { AnimationComponent, CollisionComponent, InputComponent, LightComponent, MeshComponent as MeshComponent2, PhysXComponent, TextComponent as TextComponent2, ViewComponent } from "@wonderlandengine/api";
import { ARCamera8thwall as ARCamera8thwall2, Anchor, Cursor as Cursor2, CursorTarget as CursorTarget2, DebugObject as DebugObject2, DeviceOrientationLook as DeviceOrientationLook2, FingerCursor as FingerCursor2, FixedFoveation as FixedFoveation2, HandTracking as HandTracking2, HitTestLocation as HitTestLocation2, HowlerAudioListener as HowlerAudioListener2, HowlerAudioSource as HowlerAudioSource2, ImageTexture as ImageTexture2, MouseLookComponent as MouseLookComponent2, PlaneDetection, PlayerHeight as PlayerHeight2, TargetFramerate as TargetFramerate2, TeleportComponent as TeleportComponent2, Trail as Trail2, TwoJointIkSolver as TwoJointIkSolver2, VideoTexture as VideoTexture2, VrModeActiveSwitch as VrModeActiveSwitch2, Vrm as Vrm2, WasdControlsComponent as WasdControlsComponent2 } from "@wonderlandengine/components";

// dist/audio/audio_globals.js
var audio_globals_exports = {};
__export(audio_globals_exports, {
  getAudioManager: () => getAudioManager,
  hasAudioManager: () => hasAudioManager,
  removeAudioManager: () => removeAudioManager,
  setAudioManager: () => setAudioManager
});
var _myAudioManagers = /* @__PURE__ */ new WeakMap();
function getAudioManager(engine = Globals.getMainEngine()) {
  return _myAudioManagers.get(engine);
}
function setAudioManager(audioManager, engine = Globals.getMainEngine()) {
  _myAudioManagers.set(engine, audioManager);
}
function removeAudioManager(engine = Globals.getMainEngine()) {
  _myAudioManagers.delete(engine);
}
function hasAudioManager(engine = Globals.getMainEngine()) {
  return _myAudioManagers.has(engine);
}

// dist/cauldron/cauldron/analytics_globals.js
var analytics_globals_exports = {};
__export(analytics_globals_exports, {
  getAnalyticsManager: () => getAnalyticsManager,
  hasAnalyticsManager: () => hasAnalyticsManager,
  removeAnalyticsManager: () => removeAnalyticsManager,
  setAnalyticsManager: () => setAnalyticsManager
});
var _myAnalyticsManagers = /* @__PURE__ */ new WeakMap();
function getAnalyticsManager(engine = Globals.getMainEngine()) {
  return _myAnalyticsManagers.get(engine);
}
function setAnalyticsManager(analyticsManager, engine = Globals.getMainEngine()) {
  _myAnalyticsManagers.set(engine, analyticsManager);
}
function removeAnalyticsManager(engine = Globals.getMainEngine()) {
  _myAnalyticsManagers.delete(engine);
}
function hasAnalyticsManager(engine = Globals.getMainEngine()) {
  return _myAnalyticsManagers.has(engine);
}

// dist/cauldron/cauldron/save_globals.js
var save_globals_exports = {};
__export(save_globals_exports, {
  getSaveManager: () => getSaveManager,
  hasSaveManager: () => hasSaveManager,
  removeSaveManager: () => removeSaveManager,
  setSaveManager: () => setSaveManager
});
var _mySaveManagers = /* @__PURE__ */ new WeakMap();
function getSaveManager(engine = Globals.getMainEngine()) {
  return _mySaveManagers.get(engine);
}
function setSaveManager(saveManager, engine = Globals.getMainEngine()) {
  _mySaveManagers.set(engine, saveManager);
}
function removeSaveManager(engine = Globals.getMainEngine()) {
  _mySaveManagers.delete(engine);
}
function hasSaveManager(engine = Globals.getMainEngine()) {
  return _mySaveManagers.has(engine);
}

// dist/cauldron/cauldron/window_globals.js
var window_globals_exports = {};
__export(window_globals_exports, {
  getBody: () => getBody,
  getDocument: () => getDocument,
  getNavigator: () => getNavigator,
  getWindow: () => getWindow
});
function getWindow(engine = Globals.getMainEngine()) {
  return window;
}
function getNavigator(engine = Globals.getMainEngine()) {
  return getWindow(engine).navigator;
}
function getDocument(engine = Globals.getMainEngine()) {
  return getWindow(engine).document;
}
function getBody(engine = Globals.getMainEngine()) {
  return getDocument(engine).body;
}

// dist/cauldron/object_pool/object_pool_globals.js
var object_pool_globals_exports = {};
__export(object_pool_globals_exports, {
  getObjectPoolManager: () => getObjectPoolManager,
  hasObjectPoolManager: () => hasObjectPoolManager,
  removeObjectPoolManager: () => removeObjectPoolManager,
  setObjectPoolManager: () => setObjectPoolManager
});
var _myObjectPoolManagers = /* @__PURE__ */ new WeakMap();
function getObjectPoolManager(engine = Globals.getMainEngine()) {
  return _myObjectPoolManagers.get(engine);
}
function setObjectPoolManager(objectPoolManager, engine = Globals.getMainEngine()) {
  _myObjectPoolManagers.set(engine, objectPoolManager);
}
function removeObjectPoolManager(engine = Globals.getMainEngine()) {
  _myObjectPoolManagers.delete(engine);
}
function hasObjectPoolManager(engine = Globals.getMainEngine()) {
  return _myObjectPoolManagers.has(engine);
}

// dist/cauldron/visual/visual_globals.js
var visual_globals_exports = {};
__export(visual_globals_exports, {
  getVisualManager: () => getVisualManager,
  getVisualResources: () => getVisualResources,
  hasVisualManager: () => hasVisualManager,
  hasVisualResources: () => hasVisualResources,
  removeVisualManager: () => removeVisualManager,
  removeVisualResources: () => removeVisualResources,
  setVisualManager: () => setVisualManager,
  setVisualResources: () => setVisualResources
});
var _myVisualResourcesContainer = /* @__PURE__ */ new WeakMap();
var _myVisualManagers = /* @__PURE__ */ new WeakMap();
function getVisualResources(engine = Globals.getMainEngineinEngine()) {
  return _myVisualResourcesContainer.get(engine);
}
function setVisualResources(visualResources, engine = Globals.getMainEngine()) {
  _myVisualResourcesContainer.set(engine, visualResources);
}
function removeVisualResources(engine = Globals.getMainEngine()) {
  _myVisualResourcesContainer.delete(engine);
}
function hasVisualResources(engine = Globals.getMainEngine()) {
  return _myVisualResourcesContainer.has(engine);
}
function getVisualManager(engine = Globals.getMainEngine()) {
  return _myVisualManagers.get(engine);
}
function setVisualManager(visualManager, engine = Globals.getMainEngine()) {
  _myVisualManagers.set(engine, visualManager);
}
function removeVisualManager(engine = Globals.getMainEngine()) {
  _myVisualManagers.delete(engine);
}
function hasVisualManager(engine = Globals.getMainEngine()) {
  return _myVisualManagers.has(engine);
}

// dist/cauldron/wl/engine_globals.js
var engine_globals_exports = {};
__export(engine_globals_exports, {
  addEngine: () => addEngine,
  getCanvas: () => getCanvas,
  getEngines: () => getEngines,
  getMainEngine: () => getMainEngine,
  getPhysics: () => getPhysics,
  getRoot: () => getRoot2,
  getScene: () => getScene,
  getWASM: () => getWASM,
  getXR: () => getXR,
  hasEngine: () => hasEngine,
  initEngine: () => initEngine,
  removeEngine: () => removeEngine,
  removeMainEngine: () => removeMainEngine,
  setMainEngine: () => setMainEngine
});

// dist/cauldron/js/utils/math_utils.js
var EasingFunction = {
  linear: (valueToEase) => valueToEase,
  easeInVeryWeak: (valueToEase) => 1 - Math.cos(valueToEase * Math.PI / 2),
  easeInWeak: (valueToEase) => Math.pow(valueToEase, 2),
  easeIn: (valueToEase) => Math.pow(valueToEase, 3),
  easeInStrong: (valueToEase) => Math.pow(valueToEase, 4),
  easeInVeryStrong: (valueToEase) => Math.pow(valueToEase, 5),
  easeOutVeryWeak: (valueToEase) => Math.sin(valueToEase * Math.PI / 2),
  easeOutWeak: (valueToEase) => 1 - Math.pow(1 - valueToEase, 2),
  easeOut: (valueToEase) => 1 - Math.pow(1 - valueToEase, 3),
  easeOutStrong: (valueToEase) => 1 - Math.pow(1 - valueToEase, 4),
  easeOutVeryStrong: (valueToEase) => 1 - Math.pow(1 - valueToEase, 5),
  easeInOutVeryWeak: (valueToEase) => -(Math.cos(valueToEase * Math.PI) - 1) / 2,
  easeInOutWeak: (valueToEase) => valueToEase < 0.5 ? 2 * Math.pow(valueToEase, 2) : 1 - Math.pow(-2 * valueToEase + 2, 2) / 2,
  easeInOut: (valueToEase) => valueToEase < 0.5 ? 4 * Math.pow(valueToEase, 3) : 1 - Math.pow(-2 * valueToEase + 2, 3) / 2,
  easeInOutStrong: (valueToEase) => valueToEase < 0.5 ? 8 * Math.pow(valueToEase, 4) : 1 - Math.pow(-2 * valueToEase + 2, 4) / 2,
  easeInOutVeryStrong: (valueToEase) => valueToEase < 0.5 ? 16 * Math.pow(valueToEase, 5) : 1 - Math.pow(-2 * valueToEase + 2, 5) / 2
};
var EasingSupportFunction = {
  triangleWave: (inputValue) => 2 / Math.PI * Math.asin(Math.sin(Math.PI / 2 * inputValue)),
  positiveTriangleWave: (inputValue) => 1 - Math.abs(Math.abs(inputValue) % 2 - 1)
};
var EPSILON = 1e-6;
var EPSILON_SQUARED = EPSILON * EPSILON;
var EPSILON_DEGREES = 1e-5;
function clamp(value, start, end) {
  let fixedStart = start != null ? start : -Number.MAX_VALUE;
  let fixedEnd = end != null ? end : Number.MAX_VALUE;
  let min = Math.min(fixedStart, fixedEnd);
  let max = Math.max(fixedStart, fixedEnd);
  return Math.min(Math.max(value, min), max);
}
function sign(value, zeroSign = 1) {
  let sign2 = Math.sign(value);
  if (sign2 == 0) {
    sign2 = Math.sign(zeroSign);
  }
  return sign2;
}
function toDegrees(angle2) {
  return angle2 * (180 / Math.PI);
}
function toRadians(angle2) {
  return angle2 * (Math.PI / 180);
}
function roundDecimal(number, decimalPlaces) {
  let factor = Math.pow(10, decimalPlaces);
  number = Math.round(number * factor) / factor;
  return number;
}
function mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
  if (originRangeStart == originRangeEnd) {
    return newRangeStart;
  }
  let clampedValue = MathUtils.clamp(value, originRangeStart, originRangeEnd);
  if (clampedValue == originRangeStart) {
    return newRangeStart;
  } else if (clampedValue == originRangeEnd) {
    return newRangeEnd;
  }
  let newValue = newRangeStart + (newRangeEnd - newRangeStart) / (originRangeEnd - originRangeStart) * (clampedValue - originRangeStart);
  let clampedNewValue = MathUtils.clamp(newValue, newRangeStart, newRangeEnd);
  return clampedNewValue;
}
function random(start = 0, end = 1) {
  return Math.random() * (end - start) + start;
}
function randomInt(start, end) {
  let min = Math.min(start, end);
  let max = Math.max(start, end);
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function randomBool() {
  return MathUtils.randomInt(0, 1) == 0;
}
function randomSign() {
  return Math.random() < 0.5 ? 1 : -1;
}
function randomPick(...args) {
  let random2 = null;
  if (args.length > 0) {
    if (args.length == 1 && args[0].length != null) {
      if (args[0].length > 0) {
        let randomIndex = MathUtils.randomInt(0, args[0].length - 1);
        random2 = args[0][randomIndex];
      }
    } else {
      let randomIndex = MathUtils.randomInt(0, args.length - 1);
      random2 = args[randomIndex];
    }
  }
  return random2;
}
var randomUUID = function() {
  let uuidRandomValues = new Uint8Array(1);
  let uuidSkeleton = "10000000-1000-4000-8000-" + 1e11;
  let replaceUUIDSkeletonRegex = new RegExp("[018]", "g");
  let replaceUUIDSkeletonCallback = (c) => ((c ^ crypto.getRandomValues(uuidRandomValues)[0] & 15) >> c / 4).toString(16);
  return function randomUUID2() {
    let uuid = "";
    if (crypto.randomUUID != null) {
      uuid = crypto.randomUUID();
    } else {
      uuid = uuidSkeleton.replace(replaceUUIDSkeletonRegex, replaceUUIDSkeletonCallback);
    }
    return uuid;
  };
}();
function lerp(from, to, interpolationFactor) {
  if (interpolationFactor <= 0) {
    return from;
  } else if (interpolationFactor >= 1) {
    return to;
  }
  return interpolationFactor * (to - from) + from;
}
function interpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
  let lerpFactor = easingFunction(interpolationFactor);
  return MathUtils.lerp(from, to, lerpFactor);
}
function interpolatePeriodic(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
  let adjustedInterpolationFactor = EasingSupportFunction.positiveTriangleWave(interpolationFactor);
  return MathUtils.interpolate(from, to, adjustedInterpolationFactor, easingFunction);
}
function angleDistance(from, to) {
  return MathUtils.angleDistanceDegrees(from, to);
}
function angleDistanceDegrees(from, to) {
  return Math.abs(MathUtils.angleDistanceSignedDegrees(from, to));
}
function angleDistanceRadians(from, to) {
  return Math.abs(MathUtils.angleDistanceSignedRadians(from, to));
}
function angleDistanceSigned(from, to) {
  return MathUtils.angleDistanceSignedDegrees(from, to);
}
function angleDistanceSignedDegrees(from, to) {
  let clampedFrom = MathUtils.angleClampDegrees(from, true);
  let clampedTo = MathUtils.angleClampDegrees(to, true);
  let distance2 = clampedTo - clampedFrom;
  if (clampedTo - clampedFrom > 180) {
    distance2 = clampedTo - clampedFrom - 360;
  } else if (clampedTo - clampedFrom < -180) {
    distance2 = clampedTo - clampedFrom + 360;
  }
  return distance2;
}
function angleDistanceSignedRadians(from, to) {
  return MathUtils.toRadians(MathUtils.angleDistanceSignedDegrees(MathUtils.toDegrees(from), MathUtils.toDegrees(to)));
}
function angleClamp(angle2, usePositiveRange = false) {
  return MathUtils.angleClampDegrees(angle2, usePositiveRange);
}
function angleClampDegrees(angle2, usePositiveRange = false) {
  let clampedAngle = angle2 % 360;
  if (clampedAngle < 0) {
    clampedAngle += 360;
  }
  if (!usePositiveRange) {
    if (clampedAngle > 180) {
      clampedAngle -= 360;
    }
  }
  return clampedAngle;
}
function angleClampRadians(angle2, usePositiveRange = false) {
  return MathUtils.toRadians(MathUtils.angleClampDegrees(MathUtils.toDegrees(angle2), usePositiveRange));
}
function isInsideAngleRange(angle2, start, end, useShortestAngle = false) {
  return MathUtils.isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle);
}
function isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle = false) {
  let insideAngleRange = false;
  let anglePositive = MathUtils.angleClampDegrees(angle2, true);
  let startPositive = MathUtils.angleClampDegrees(start, true);
  let endPositive = MathUtils.angleClampDegrees(end, true);
  if (useShortestAngle) {
    if (MathUtils.angleDistanceSignedDegrees(startPositive, endPositive) < 0) {
      let temp = startPositive;
      startPositive = endPositive;
      endPositive = temp;
    }
  }
  if (startPositive < endPositive) {
    insideAngleRange = anglePositive >= startPositive && anglePositive <= endPositive;
  } else {
    insideAngleRange = anglePositive >= startPositive || anglePositive <= endPositive;
  }
  return insideAngleRange;
}
function isInsideAngleRangeRadians(angle2, start, end, useShortestAngle = false) {
  return MathUtils.isInsideAngleRangeDegrees(MathUtils.toDegrees(angle2), MathUtils.toDegrees(start), MathUtils.toDegrees(end), useShortestAngle);
}
var MathUtils = {
  EPSILON,
  EPSILON_SQUARED,
  EPSILON_DEGREES,
  clamp,
  sign,
  toDegrees,
  toRadians,
  roundDecimal,
  mapToRange,
  random,
  randomInt,
  randomBool,
  randomSign,
  randomPick,
  randomUUID,
  lerp,
  interpolate,
  interpolatePeriodic,
  angleDistance,
  angleDistanceDegrees,
  angleDistanceRadians,
  angleDistanceSigned,
  angleDistanceSignedDegrees,
  angleDistanceSignedRadians,
  angleClamp,
  angleClampDegrees,
  angleClampRadians,
  isInsideAngleRange,
  isInsideAngleRangeDegrees,
  isInsideAngleRangeRadians
};

// dist/cauldron/js/utils/mat3_utils.js
import { mat3 as gl_mat32, quat as gl_quat3 } from "gl-matrix";

// dist/cauldron/js/utils/quat_utils.js
import { mat3 as gl_mat3, quat as gl_quat } from "gl-matrix";

// dist/cauldron/js/utils/array_utils.js
function first(array) {
  return array.length > 0 ? array[0] : void 0;
}
function last(array) {
  return array.length > 0 ? array[array.length - 1] : void 0;
}
function has(array, callback) {
  return ArrayUtils.find(array, callback) != void 0;
}
function hasEqual(array, elementToFind, elementsEqualCallback = null) {
  return ArrayUtils.findEqual(array, elementToFind, elementsEqualCallback) != void 0;
}
function find(array, callback) {
  let elementFound = void 0;
  let index = array.findIndex(callback);
  if (index >= 0) {
    elementFound = array[index];
  }
  return elementFound;
}
function findIndex(array, callback) {
  return array.findIndex(callback);
}
function findAll(array, callback) {
  let elementsFound = array.filter(callback);
  return elementsFound;
}
function findAllIndexes(array, callback) {
  let indexes = [];
  for (let i = 0; i < array.length; i++) {
    let element = array[i];
    if (callback(element)) {
      indexes.push(i);
    }
  }
  return indexes;
}
function findEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    let index = ArrayUtils.findIndexEqual(array, elementToFind);
    return index < 0 ? void 0 : array[index];
  }
  let elementFound = void 0;
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      elementFound = currentElement;
      break;
    }
  }
  return elementFound;
}
function findAllEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    return _findAllEqualOptimized(array, elementToFind, false);
  }
  let elementsFound = [];
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      elementsFound.push(currentElement);
    }
  }
  return elementsFound;
}
function findIndexEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    return array.indexOf(elementToFind);
  }
  let indexFound = -1;
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      indexFound = i;
      break;
    }
  }
  return indexFound;
}
function findAllIndexesEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    return _findAllEqualOptimized(array, elementToFind, true);
  }
  let indexesFound = [];
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      indexesFound.push(i);
    }
  }
  return indexesFound;
}
function removeIndex(array, index) {
  let elementRemoved = void 0;
  if (index >= 0 && index < array.length) {
    let arrayRemoved = array.splice(index, 1);
    if (arrayRemoved.length == 1) {
      elementRemoved = arrayRemoved[0];
    }
  }
  return elementRemoved;
}
function removeAllIndexes(array, indexes) {
  let elementsRemoved = [];
  for (let index of indexes) {
    let elementRemoved = ArrayUtils.removeIndex(array, index);
    if (elementRemoved !== void 0) {
      elementsRemoved.push(elementRemoved);
    }
  }
  return elementsRemoved;
}
function remove(array, callback) {
  let elementRemoved = void 0;
  let index = array.findIndex(callback);
  if (index >= 0) {
    elementRemoved = ArrayUtils.removeIndex(array, index);
  }
  return elementRemoved;
}
function removeAll(array, callback) {
  let elementsRemoved = [];
  let currentElement = void 0;
  do {
    currentElement = ArrayUtils.remove(array, callback);
    if (currentElement !== void 0) {
      elementsRemoved.push(currentElement);
    }
  } while (currentElement !== void 0);
  return elementsRemoved;
}
function removeEqual(array, elementToRemove, elementsEqualCallback = null) {
  return ArrayUtils.removeIndex(array, ArrayUtils.findIndexEqual(array, elementToRemove, elementsEqualCallback));
}
function removeAllEqual(array, elementToRemove, elementsEqualCallback = null) {
  return ArrayUtils.removeAllIndexes(array, ArrayUtils.findAllIndexesEqual(array, elementToRemove, elementsEqualCallback));
}
function pushUnique(array, element, elementsEqualCallback = null) {
  let length5 = array.length;
  let hasElement = ArrayUtils.hasEqual(array, element, elementsEqualCallback);
  if (!hasElement) {
    length5 = array.push(element);
  }
  return length5;
}
function unshiftUnique(array, element, elementsEqualCallback = null) {
  let length5 = array.length;
  let hasElement = ArrayUtils.hasEqual(array, element, elementsEqualCallback);
  if (!hasElement) {
    length5 = array.unshift(element);
  }
  return length5;
}
function copy(from, to, copyCallback = null) {
  while (to.length > from.length) {
    to.pop();
  }
  for (let i = 0; i < from.length; i++) {
    if (copyCallback == null) {
      to[i] = from[i];
    } else {
      to[i] = copyCallback(to[i], from[i]);
    }
  }
  return to;
}
function clone(array, cloneCallback = null) {
  if (cloneCallback == null) {
    return array.slice(0);
  }
  let clone10 = null;
  switch (array.constructor.name) {
    case "Array":
      clone10 = new Array(array.length);
      break;
    case "Uint8ClampedArray":
      clone10 = new Uint8ClampedArray(array.length);
      break;
    case "Uint8Array":
      clone10 = new Uint8Array(array.length);
      break;
    case "Uint16Array":
      clone10 = new Uint16Array(array.length);
      break;
    case "Uint32Array":
      clone10 = new Uint32Array(array.length);
      break;
    case "Int8Array":
      clone10 = new Int8Array(array.length);
      break;
    case "Int16Array":
      clone10 = new Int16Array(array.length);
      break;
    case "Int32Array":
      clone10 = new Int32Array(array.length);
      break;
    case "Float32Array":
      clone10 = new Float32Array(array.length);
      break;
    case "Float64Array":
      clone10 = new Float64Array(array.length);
      break;
    default:
      clone10 = new Array(array.length);
      console.error("Cloned array type not supported!");
      break;
  }
  for (let i = 0; i < array.length; i++) {
    clone10[i] = ArrayUtils.cloneCallback(array[i]);
  }
  return clone10;
}
function equals(array, other, elementsEqualCallback = null) {
  let equals5 = true;
  if (other != null && array.length == other.length) {
    for (let i = 0; i < array.length; i++) {
      if (elementsEqualCallback != null && !elementsEqualCallback(array[i], other[i]) || elementsEqualCallback == null && array[i] != other[i]) {
        equals5 = false;
        break;
      }
    }
  } else {
    equals5 = false;
  }
  return equals5;
}
function clear(array) {
  array.length = 0;
  return array;
}
var ArrayUtils = {
  first,
  last,
  has,
  hasEqual,
  find,
  findIndex,
  findAll,
  findAllIndexes,
  findEqual,
  findAllEqual,
  findIndexEqual,
  findAllIndexesEqual,
  removeIndex,
  removeAllIndexes,
  remove,
  removeAll,
  removeEqual,
  removeAllEqual,
  pushUnique,
  unshiftUnique,
  copy,
  clone,
  equals,
  clear
};
function _findAllEqualOptimized(array, elementToFind, getIndexes) {
  let elementsFound = [];
  let index = -1;
  while ((index = array.indexOf(elementToFind, index + 1)) >= 0) {
    elementsFound.push(getIndexes ? index : array[index]);
  }
  return elementsFound;
}

// dist/cauldron/js/utils/vec3_utils.js
import { vec3 as gl_vec3 } from "gl-matrix";

// dist/cauldron/js/utils/mat4_utils.js
import { mat4 as gl_mat42 } from "gl-matrix";

// dist/cauldron/js/utils/quat2_utils.js
import { mat4 as gl_mat4, quat2 as gl_quat2 } from "gl-matrix";
function create4(x1, y1, z1, w1, x2, y2, z2, w2) {
  let out = gl_quat2.create();
  if (x1 !== void 0) {
    set(out, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return out;
}
function set(quat, x1, y1, z1, w1, x2, y2, z2, w2) {
  if (y1 === void 0) {
    gl_quat2.set(quat, x1, x1, x1, x1, x1, x1, x1, x1);
  } else {
    gl_quat2.set(quat, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return quat;
}
function normalize(quat, out = Quat2Utils.create()) {
  gl_quat2.normalize(out, quat);
  return out;
}
function invert(quat, out = Quat2Utils.create()) {
  gl_quat2.invert(out, quat);
  return out;
}
function conjugate(quat, out = Quat2Utils.create()) {
  gl_quat2.conjugate(out, quat);
  return out;
}
function copy2(from, to) {
  gl_quat2.copy(to, from);
  return to;
}
function identity(quat) {
  gl_quat2.identity(quat);
  return quat;
}
function getPosition(quat, out = Vec3Utils.create()) {
  gl_quat2.getTranslation(out, quat);
  return out;
}
function getRotation(quat, out) {
  return Quat2Utils.getRotationDegrees(quat, out);
}
var getRotationDegrees = function() {
  let rotationQuat = create2();
  return function getRotationDegrees4(quat, out = Vec3Utils.create()) {
    QuatUtils.toDegrees(Quat2Utils.getRotationQuat(quat, rotationQuat), out);
    return out;
  };
}();
var getRotationRadians = function() {
  let rotationQuat = create2();
  return function getRotationRadians4(quat, out = Vec3Utils.create()) {
    QuatUtils.toRadians(Quat2Utils.getRotationQuat(quat, rotationQuat), out);
    return out;
  };
}();
function getRotationQuat(quat, out = QuatUtils.create()) {
  QuatUtils.copy(quat, out);
  return out;
}
var setPosition = function() {
  let rotationQuat = create2();
  return function setPosition4(quat, position) {
    Quat2Utils.getRotationQuat(quat, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
function setRotation(quat, rotation) {
  return Quat2Utils.setRotationDegrees(quat, rotation);
}
var setRotationDegrees = function() {
  let position = create3();
  return function setRotationDegrees4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationDegrees(quat, position, rotation);
    return quat;
  };
}();
var setRotationRadians = function() {
  let position = create3();
  return function setRotationRadians4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationRadians(quat, position, rotation);
    return quat;
  };
}();
var setRotationQuat = function() {
  let position = create3();
  return function setRotationQuat4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationQuat(quat, position, rotation);
    return quat;
  };
}();
function setPositionRotation(quat, position, rotation) {
  return Quat2Utils.setPositionRotationDegrees(quat, position, rotation);
}
var setPositionRotationDegrees = function() {
  let rotationQuat = create2();
  return function setPositionRotationDegrees3(quat, position, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
var setPositionRotationRadians = function() {
  let rotationQuat = create2();
  return function setPositionRotationRadians3(quat, position, rotation) {
    Vec3Utils.radiansToQuat(rotation, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
function setPositionRotationQuat(quat, position, rotation) {
  gl_quat2.fromRotationTranslation(quat, rotation, position);
  return quat;
}
function isNormalized(quat, epsilon = MathUtils.EPSILON) {
  return Math.abs(Quat2Utils.lengthSquared(quat) - 1) < epsilon;
}
function length(quat) {
  return gl_quat2.length(quat);
}
function lengthSquared(quat) {
  return gl_quat2.squaredLength(quat);
}
function mul(first2, second, out = Quat2Utils.create()) {
  gl_quat2.mul(out, first2, second);
  return out;
}
function getAxes(quat, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  Quat2Utils.getLeft(quat, out[0]);
  Quat2Utils.getUp(quat, out[1]);
  Quat2Utils.getForward(quat, out[2]);
  return out;
}
var getForward = function() {
  let rotationMatrix = create();
  return function getForward5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
    return out;
  };
}();
function getBackward(quat, out) {
  out = Quat2Utils.getForward(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getLeft = function() {
  let rotationMatrix = create();
  return function getLeft5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
    return out;
  };
}();
function getRight(quat, out) {
  out = Quat2Utils.getLeft(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getUp = function() {
  let rotationMatrix = create();
  return function getUp5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
    return out;
  };
}();
function getDown(quat, out) {
  out = Quat2Utils.getUp(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
function toWorld(quat, parentTransformQuat, out = Quat2Utils.create()) {
  Quat2Utils.mul(parentTransformQuat, quat, out);
  return out;
}
var toLocal = function() {
  let invertQuat = create4();
  return function toLocal4(quat, parentTransformQuat, out = Quat2Utils.create()) {
    Quat2Utils.conjugate(parentTransformQuat, invertQuat);
    Quat2Utils.mul(invertQuat, quat, out);
    return out;
  };
}();
function rotateAxis(quat, angle2, axis, out) {
  return Quat2Utils.rotateAxisDegrees(quat, angle2, axis, out);
}
function rotateAxisDegrees(quat, angle2, axis, out) {
  return Quat2Utils.rotateAxisRadians(quat, MathUtils.toRadians(angle2), axis, out);
}
var rotateAxisRadians = function() {
  let rotationQuat = create2();
  return function rotateAxisRadians5(quat, angle2, axis, out = Quat2Utils.create()) {
    Quat2Utils.getRotationQuat(quat, rotationQuat);
    QuatUtils.rotateAxisRadians(rotationQuat, angle2, axis, rotationQuat);
    Quat2Utils.copy(quat, out);
    Quat2Utils.setRotationQuat(out, rotationQuat);
    return out;
  };
}();
function toMatrix(quat, out = Mat4Utils.create()) {
  _customGLMatrixFromQuat2(out, quat);
  return out;
}
function fromMatrix(matrix, out = Quat2Utils.create()) {
  Mat4Utils.toQuat(matrix, out);
  return out;
}
function lerp2(from, to, interpolationFactor, out = Quat2Utils.create()) {
  if (interpolationFactor <= 0) {
    Quat2Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Quat2Utils.copy(to, out);
    return out;
  }
  gl_quat2.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate2(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return Quat2Utils.lerp(from, to, lerpFactor, out);
}
var slerp = function() {
  let fromPosition = create3();
  let toPosition = create3();
  let interpolatedPosition = create3();
  let fromRotationQuat = create2();
  let toRotationQuat = create2();
  let interpolatedRotationQuat = create2();
  return function slerp3(from, to, interpolationFactor, out = Quat2Utils.create()) {
    if (interpolationFactor <= 0) {
      Quat2Utils.copy(from, out);
      return out;
    } else if (interpolationFactor >= 1) {
      Quat2Utils.copy(to, out);
      return out;
    }
    Quat2Utils.getPosition(from, fromPosition);
    Quat2Utils.getPosition(to, toPosition);
    Quat2Utils.getRotationQuat(from, fromRotationQuat);
    Quat2Utils.getRotationQuat(to, toRotationQuat);
    Vec3Utils.lerp(fromPosition, toPosition, interpolationFactor, interpolatedPosition);
    QuatUtils.slerp(fromRotationQuat, toRotationQuat, interpolationFactor, interpolatedRotationQuat);
    Quat2Utils.setPositionRotationQuat(out, interpolatedPosition, interpolatedRotationQuat);
    return out;
  };
}();
function sinterpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return Quat2Utils.slerp(from, to, lerpFactor, out);
}
var Quat2Utils = {
  create: create4,
  set,
  normalize,
  invert,
  conjugate,
  copy: copy2,
  identity,
  getPosition,
  getRotation,
  getRotationDegrees,
  getRotationRadians,
  getRotationQuat,
  setPosition,
  setRotation,
  setRotationDegrees,
  setRotationRadians,
  setRotationQuat,
  setPositionRotation,
  setPositionRotationDegrees,
  setPositionRotationRadians,
  setPositionRotationQuat,
  isNormalized,
  length,
  lengthSquared,
  mul,
  getAxes,
  getForward,
  getBackward,
  getLeft,
  getRight,
  getUp,
  getDown,
  toWorld,
  toLocal,
  rotateAxis,
  rotateAxisDegrees,
  rotateAxisRadians,
  toMatrix,
  fromMatrix,
  lerp: lerp2,
  interpolate: interpolate2,
  slerp,
  sinterpolate
};
var _customGLMatrixFromQuat2 = function() {
  let translation = create3();
  return function _customGLMatrixFromQuat22(out, a) {
    let bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    let magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    gl_mat4.fromRotationTranslation(out, a, translation);
    return out;
  };
}();

// dist/cauldron/js/utils/mat4_utils.js
function create5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = gl_mat42.create();
  if (m00 !== void 0) {
    set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
  }
  return out;
}
function set3(matrix, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  if (m01 === void 0) {
    gl_mat42.set(matrix, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00);
  } else {
    gl_mat42.set(matrix, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
  }
  return matrix;
}
function copy3(from, to) {
  gl_mat42.copy(to, from);
  return to;
}
function identity2(matrix) {
  gl_mat42.identity(matrix);
  return matrix;
}
function invert2(matrix, out = Mat4Utils.create()) {
  gl_mat42.invert(out, matrix);
  return out;
}
function mul2(first2, second, out = Mat4Utils.create()) {
  gl_mat42.mul(out, first2, second);
  return out;
}
function scale(matrix, vector, out = Mat4Utils.create()) {
  gl_mat42.scale(out, matrix, vector);
  return out;
}
function clone2(matrix, out = Mat4Utils.create()) {
  Mat4Utils.copy(matrix, out);
  return out;
}
function getPosition2(matrix, out = Vec3Utils.create()) {
  gl_mat42.getTranslation(out, matrix);
  return out;
}
function getRotation2(matrix, out = Vec3Utils.create()) {
  return Mat4Utils.getRotationDegrees(matrix, out);
}
var getRotationDegrees2 = function() {
  let quat = create2();
  return function getRotationDegrees4(matrix, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(matrix, quat);
    QuatUtils.toDegrees(quat, out);
    return out;
  };
}();
var getRotationRadians2 = function() {
  let quat = create2();
  return function getRotationRadians4(matrix, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(matrix, quat);
    QuatUtils.toRadians(quat, out);
    return out;
  };
}();
var getRotationQuat2 = function() {
  let tempScale = create3();
  let transformMatrixNoScale = create5();
  let inverseScale = create3();
  let one = create3();
  set2(one, 1, 1, 1);
  return function getRotationQuat4(matrix, out = QuatUtils.create()) {
    Mat4Utils.getScale(matrix, tempScale);
    Vec3Utils.div(one, tempScale, inverseScale);
    Mat4Utils.scale(matrix, inverseScale, transformMatrixNoScale);
    _customGLMatrixGetRotation(out, transformMatrixNoScale);
    return out;
  };
}();
function getScale(matrix, out = Vec3Utils.create()) {
  gl_mat42.getScaling(out, matrix);
  return out;
}
function setPosition2(matrix, position) {
  matrix[12] = position[0];
  matrix[13] = position[1];
  matrix[14] = position[2];
  return matrix;
}
function setRotation2(matrix, rotation) {
  Mat4Utils.setRotationDegrees(matrix, rotation);
  return matrix;
}
var setRotationDegrees2 = function() {
  let quat = create2();
  return function setRotationDegrees4(matrix, rotation) {
    Mat4Utils.setRotationQuat(matrix, Vec3Utils.degreesToQuat(rotation, quat));
    return matrix;
  };
}();
var setRotationRadians2 = function() {
  let vector = create3();
  return function setRotationRadians4(matrix, rotation) {
    Mat4Utils.setRotationDegrees(matrix, Vec3Utils.toDegrees(rotation, vector));
    return matrix;
  };
}();
var setRotationQuat2 = function() {
  let position = create3();
  let scale4 = create3();
  return function setRotationQuat4(matrix, rotation) {
    Mat4Utils.getPosition(matrix, position);
    Mat4Utils.getScale(matrix, scale4);
    Mat4Utils.setPositionRotationQuatScale(matrix, position, rotation, scale4);
    return matrix;
  };
}();
var setScale = function() {
  let tempScale = create3();
  return function setScale3(matrix, scaleToSet) {
    Mat4Utils.getScale(matrix, tempScale);
    Vec3Utils.div(scaleToSet, tempScale, tempScale);
    Mat4Utils.scale(matrix, tempScale, matrix);
    return matrix;
  };
}();
function setPositionRotationScale(matrix, position, rotation, scale4) {
  Mat4Utils.setPositionRotationDegreesScale(matrix, position, rotation, scale4);
  return matrix;
}
var setPositionRotationDegreesScale = function() {
  let quat = create2();
  return function setPositionRotationDegreesScale2(matrix, position, rotation, scale4) {
    Mat4Utils.setPositionRotationQuatScale(matrix, position, Vec3Utils.degreesToQuat(rotation, quat), scale4);
    return matrix;
  };
}();
var setPositionRotationRadiansScale = function() {
  let vector = create3();
  return function setPositionRotationRadiansScale2(matrix, position, rotation, scale4) {
    Mat4Utils.setPositionRotationDegreesScale(matrix, position, Vec3Utils.toDegrees(rotation, vector), scale4);
    return matrix;
  };
}();
function setPositionRotationQuatScale(matrix, position, rotation, scale4) {
  gl_mat42.fromRotationTranslationScale(matrix, rotation, position, scale4);
  return matrix;
}
function setPositionRotation2(matrix, position, rotation) {
  Mat4Utils.setPositionRotationDegrees(matrix, position, rotation);
  return matrix;
}
var setPositionRotationDegrees2 = function() {
  let quat = create2();
  return function setPositionRotationDegrees3(matrix, position, rotation) {
    Mat4Utils.setPositionRotationQuat(matrix, position, Vec3Utils.degreesToQuat(rotation, quat));
    return matrix;
  };
}();
var setPositionRotationRadians2 = function() {
  let vector = create3();
  return function setPositionRotationRadians3(matrix, position, rotation) {
    Mat4Utils.setPositionRotationDegrees(matrix, position, Vec3Utils.toDegrees(rotation, vector));
    return matrix;
  };
}();
function setPositionRotationQuat2(matrix, position, rotation) {
  gl_mat42.fromRotationTranslation(matrix, rotation, position);
  return matrix;
}
function getAxes2(matrix, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  Mat4Utils.getLeft(matrix, out[0]);
  Mat4Utils.getUp(matrix, out[1]);
  Mat4Utils.getForward(matrix, out[2]);
  return out;
}
function getForward2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[8], matrix[9], matrix[10]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getBackward2(matrix, out) {
  out = Mat4Utils.getForward(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
function getLeft2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[0], matrix[1], matrix[2]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getRight2(matrix, out) {
  out = Mat4Utils.getLeft(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
function getUp2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[4], matrix[5], matrix[6]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getDown2(matrix, out) {
  out = Mat4Utils.getUp(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
var toWorld2 = function() {
  let convertTransform = create5();
  let position = create3();
  let tempScale = create3();
  let inverseScale = create3();
  let one = create3();
  set2(one, 1, 1, 1);
  return function toWorld4(matrix, parentTransformMatrix, out = Mat4Utils.create()) {
    if (Mat4Utils.hasUniformScale(parentTransformMatrix)) {
      Mat4Utils.mul(parentTransformMatrix, matrix, out);
    } else {
      Vec3Utils.set(position, matrix[12], matrix[13], matrix[14]);
      Vec3Utils.convertPositionToWorldMatrix(position, parentTransformMatrix, position);
      Mat4Utils.getScale(parentTransformMatrix, tempScale);
      Vec3Utils.div(one, tempScale, inverseScale);
      Mat4Utils.scale(parentTransformMatrix, inverseScale, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
      Mat4Utils.scale(out, tempScale, out);
      out[12] = position[0];
      out[13] = position[1];
      out[14] = position[2];
      out[15] = 1;
    }
    return out;
  };
}();
var toLocal2 = function() {
  let convertTransform = create5();
  let position = create3();
  let tempScale = create3();
  let inverseScale = create3();
  let one = create3();
  set2(one, 1, 1, 1);
  return function toLocal4(matrix, parentTransformMatrix, out = Mat4Utils.create()) {
    if (Mat4Utils.hasUniformScale(parentTransformMatrix)) {
      Mat4Utils.invert(parentTransformMatrix, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
    } else {
      Vec3Utils.set(position, matrix[12], matrix[13], matrix[14]);
      Vec3Utils.convertPositionToLocalMatrix(position, parentTransformMatrix, position);
      Mat4Utils.getScale(parentTransformMatrix, tempScale);
      Vec3Utils.div(one, tempScale, inverseScale);
      Mat4Utils.scale(parentTransformMatrix, inverseScale, convertTransform);
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
      Mat4Utils.scale(out, inverseScale, out);
      out[12] = position[0];
      out[13] = position[1];
      out[14] = position[2];
      out[15] = 1;
    }
    return out;
  };
}();
var hasUniformScale = function() {
  let scale4 = create3();
  return function hasUniformScale3(matrix) {
    Mat4Utils.getScale(matrix, scale4);
    return Math.abs(scale4[0] - scale4[1]) < MathUtils.EPSILON && Math.abs(scale4[1] - scale4[2]) < MathUtils.EPSILON && Math.abs(scale4[0] - scale4[2]) < MathUtils.EPSILON;
  };
}();
var toQuat = function() {
  let position = create3();
  let rotation = create2();
  return function toQuat4(matrix, out = Quat2Utils.create()) {
    Mat4Utils.getPosition(matrix, position);
    Mat4Utils.getRotationQuat(matrix, rotation);
    Quat2Utils.setPositionRotationQuat(out, position, rotation);
    return out;
  };
}();
function fromQuat(quat, out = Mat4Utils.create()) {
  Quat2Utils.toMatrix(quat, out);
  return out;
}
var Mat4Utils = {
  create: create5,
  set: set3,
  copy: copy3,
  identity: identity2,
  invert: invert2,
  mul: mul2,
  scale,
  clone: clone2,
  getPosition: getPosition2,
  getRotation: getRotation2,
  getRotationDegrees: getRotationDegrees2,
  getRotationRadians: getRotationRadians2,
  getRotationQuat: getRotationQuat2,
  getScale,
  setPosition: setPosition2,
  setRotation: setRotation2,
  setRotationDegrees: setRotationDegrees2,
  setRotationRadians: setRotationRadians2,
  setRotationQuat: setRotationQuat2,
  setScale,
  setPositionRotationScale,
  setPositionRotationDegreesScale,
  setPositionRotationRadiansScale,
  setPositionRotationQuatScale,
  setPositionRotation: setPositionRotation2,
  setPositionRotationDegrees: setPositionRotationDegrees2,
  setPositionRotationRadians: setPositionRotationRadians2,
  setPositionRotationQuat: setPositionRotationQuat2,
  getAxes: getAxes2,
  getForward: getForward2,
  getBackward: getBackward2,
  getLeft: getLeft2,
  getRight: getRight2,
  getUp: getUp2,
  getDown: getDown2,
  toWorld: toWorld2,
  toLocal: toLocal2,
  hasUniformScale,
  toQuat,
  fromQuat
};
var _customGLMatrixGetRotation = function() {
  let scaling = create3();
  return function _customGLMatrixGetRotation2(out, mat) {
    gl_mat42.getScaling(scaling, mat);
    let is1 = 1 / scaling[0];
    let is2 = 1 / scaling[1];
    let is3 = 1 / scaling[2];
    let sm11 = mat[0] * is1;
    let sm12 = mat[1] * is2;
    let sm13 = mat[2] * is3;
    let sm21 = mat[4] * is1;
    let sm22 = mat[5] * is2;
    let sm23 = mat[6] * is3;
    let sm31 = mat[8] * is1;
    let sm32 = mat[9] * is2;
    let sm33 = mat[10] * is3;
    let trace = sm11 + sm22 + sm33;
    if (trace > 0) {
      let s = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * s;
      out[0] = (sm23 - sm32) / s;
      out[1] = (sm31 - sm13) / s;
      out[2] = (sm12 - sm21) / s;
    } else if (sm11 > sm22 && sm11 > sm33) {
      let s = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / s;
      out[0] = 0.25 * s;
      out[1] = (sm12 + sm21) / s;
      out[2] = (sm31 + sm13) / s;
    } else if (sm22 > sm33) {
      let s = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / s;
      out[0] = (sm12 + sm21) / s;
      out[1] = 0.25 * s;
      out[2] = (sm23 + sm32) / s;
    } else {
      let s = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / s;
      out[0] = (sm31 + sm13) / s;
      out[1] = (sm23 + sm32) / s;
      out[2] = 0.25 * s;
    }
    return out;
  };
}();

// dist/cauldron/js/utils/vec3_utils.js
function create3(x, y, z) {
  let out = gl_vec3.create();
  if (x !== void 0) {
    set2(out, x, y, z);
  }
  return out;
}
function set2(vector, x, y, z) {
  if (y === void 0) {
    gl_vec3.set(vector, x, x, x);
  } else {
    gl_vec3.set(vector, x, y, z);
  }
  return vector;
}
function normalize2(vector, out = Vec3Utils.create()) {
  gl_vec3.normalize(out, vector);
  return out;
}
function copy4(from, to) {
  gl_vec3.copy(to, from);
  return to;
}
function clone3(vector, out = Vec3Utils.create()) {
  Vec3Utils.copy(vector, out);
  return out;
}
function zero(vector) {
  gl_vec3.zero(vector);
  return vector;
}
function angle(first2, second) {
  return Vec3Utils.angleDegrees(first2, second);
}
function angleDegrees(first2, second) {
  return MathUtils.toDegrees(Vec3Utils.angleRadians(first2, second));
}
function angleRadians(first2, second) {
  let firstX = first2[0];
  let firstY = first2[1];
  let firstZ = first2[2];
  let secondX = second[0];
  let secondY = second[1];
  let secondZ = second[2];
  let firstLengthSquared = firstX * firstX + firstY * firstY + firstZ * firstZ;
  let secondLengthSquared = secondX * secondX + secondY * secondY + secondZ * secondZ;
  let lengthSquared4 = firstLengthSquared * secondLengthSquared;
  let angle2 = 0;
  if (lengthSquared4 > MathUtils.EPSILON_SQUARED) {
    let length5 = Math.sqrt(lengthSquared4);
    let cos = Vec3Utils.dot(first2, second) / length5;
    angle2 = Math.acos(MathUtils.clamp(cos, -1, 1));
  }
  return angle2;
}
function equals2(first2, second, epsilon = 0) {
  let equals5 = first2.length == second.length;
  if (equals5) {
    equals5 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals5 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals5 &&= Math.abs(first2[2] - second[2]) <= epsilon;
  }
  return equals5;
}
function length2(vector) {
  return gl_vec3.length(vector);
}
function lengthSquared2(vector) {
  return gl_vec3.squaredLength(vector);
}
function distance(first2, second) {
  return gl_vec3.dist(first2, second);
}
function distanceSquared(first2, second) {
  return gl_vec3.squaredDistance(first2, second);
}
function add(first2, second, out = Vec3Utils.create()) {
  gl_vec3.add(out, first2, second);
  return out;
}
function sub(first2, second, out = Vec3Utils.create()) {
  gl_vec3.sub(out, first2, second);
  return out;
}
function mul3(first2, second, out = Vec3Utils.create()) {
  gl_vec3.mul(out, first2, second);
  return out;
}
function div(first2, second, out = Vec3Utils.create()) {
  gl_vec3.div(out, first2, second);
  return out;
}
function scale2(vector, value, out = Vec3Utils.create()) {
  gl_vec3.scale(out, vector, value);
  return out;
}
function dot(first2, second) {
  return gl_vec3.dot(first2, second);
}
function negate(vector, out = Vec3Utils.create()) {
  gl_vec3.negate(out, vector);
  return out;
}
function cross(first2, second, out = Vec3Utils.create()) {
  gl_vec3.cross(out, first2, second);
  return out;
}
function transformQuat(vector, quat, out = Vec3Utils.create()) {
  gl_vec3.transformQuat(out, vector, quat);
  return out;
}
function transformMat3(vector, matrix, out = Vec3Utils.create()) {
  gl_vec3.transformMat3(out, vector, matrix);
  return out;
}
function transformMat4(vector, mat4, out = Vec3Utils.create()) {
  gl_vec3.transformMat4(out, vector, mat4);
  return out;
}
function lengthSigned(vector, positiveDirection) {
  let signedLength = Vec3Utils.length(vector);
  if (!Vec3Utils.isConcordant(vector, positiveDirection)) {
    signedLength *= -1;
  }
  return signedLength;
}
function angleSigned(first2, second, referenceAxis) {
  return Vec3Utils.angleSignedDegrees(first2, second, referenceAxis);
}
function angleSignedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.angleSignedRadians(first2, second, referenceAxis));
}
var angleSignedRadians = function() {
  let crossAxis = create3();
  return function angleSignedRadians2(first2, second, referenceAxis) {
    Vec3Utils.cross(first2, second, crossAxis);
    let angle2 = Vec3Utils.angleRadians(first2, second);
    if (!Vec3Utils.isConcordant(crossAxis, referenceAxis)) {
      angle2 = -angle2;
    }
    return angle2;
  };
}();
function anglePivoted(first2, second, referenceAxis) {
  return Vec3Utils.anglePivotedDegrees(first2, second, referenceAxis);
}
function anglePivotedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.anglePivotedRadians(first2, second, referenceAxis));
}
var anglePivotedRadians = function() {
  let flatFirst = create3();
  let flatSecond = create3();
  return function anglePivotedRadians2(first2, second, referenceAxis) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, flatFirst);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, flatSecond);
    return Vec3Utils.angleRadians(flatFirst, flatSecond);
  };
}();
function anglePivotedSigned(first2, second, referenceAxis) {
  return Vec3Utils.anglePivotedSignedDegrees(first2, second, referenceAxis);
}
function anglePivotedSignedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.anglePivotedSignedRadians(first2, second, referenceAxis));
}
var anglePivotedSignedRadians = function() {
  let flatFirst = create3();
  let flatSecond = create3();
  return function anglePivotedSignedRadians2(first2, second, referenceAxis) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, flatFirst);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, flatSecond);
    return Vec3Utils.angleSignedRadians(flatFirst, flatSecond, referenceAxis);
  };
}();
function toRadians2(vector, out = Vec3Utils.create()) {
  Vec3Utils.set(out, MathUtils.toRadians(vector[0]), MathUtils.toRadians(vector[1]), MathUtils.toRadians(vector[2]));
  return out;
}
function toDegrees2(vector, out = Vec3Utils.create()) {
  Vec3Utils.set(out, MathUtils.toDegrees(vector[0]), MathUtils.toDegrees(vector[1]), MathUtils.toDegrees(vector[2]));
  return out;
}
function toQuat2(vector, out) {
  return Vec3Utils.degreesToQuat(vector, out);
}
function radiansToQuat(vector, out = QuatUtils.create()) {
  QuatUtils.fromRadians(vector, out);
  return out;
}
function degreesToQuat(vector, out = QuatUtils.create()) {
  QuatUtils.fromDegrees(vector, out);
  return out;
}
function isNormalized2(vector, epsilon = MathUtils.EPSILON) {
  return Math.abs(Vec3Utils.lengthSquared(vector) - 1) < epsilon;
}
function isZero(vector, epsilon = 0) {
  return Vec3Utils.lengthSquared(vector) <= epsilon * epsilon;
}
function valueAlongAxis(vector, axis) {
  let valueAlongAxis2 = Vec3Utils.dot(vector, axis);
  return valueAlongAxis2;
}
var valueAlongPlane = function() {
  let componentAlong = create3();
  return function valueAlongPlane2(vector, planeNormal) {
    Vec3Utils.removeComponentAlongAxis(vector, planeNormal, componentAlong);
    return Vec3Utils.length(componentAlong);
  };
}();
function componentAlongAxis(vector, axis, out = Vec3Utils.create()) {
  let valueAlongAxis2 = Vec3Utils.valueAlongAxis(vector, axis);
  Vec3Utils.copy(axis, out);
  Vec3Utils.scale(out, valueAlongAxis2, out);
  return out;
}
var removeComponentAlongAxis = function() {
  let componentAlong = create3();
  return function removeComponentAlongAxis2(vector, axis, out = Vec3Utils.create()) {
    Vec3Utils.componentAlongAxis(vector, axis, componentAlong);
    Vec3Utils.sub(vector, componentAlong, out);
    return out;
  };
}();
var copyComponentAlongAxis = function() {
  let componentAlong = create3();
  return function copyComponentAlongAxis2(from, to, axis, out = Vec3Utils.create()) {
    Vec3Utils.removeComponentAlongAxis(to, axis, out);
    Vec3Utils.componentAlongAxis(from, axis, componentAlong);
    Vec3Utils.add(out, componentAlong, out);
    return out;
  };
}();
function isConcordant(first2, second) {
  return Vec3Utils.dot(first2, second) >= 0;
}
function isFartherAlongAxis(first2, second, axis) {
  return Vec3Utils.valueAlongAxis(first2, axis) > Vec3Utils.valueAlongAxis(second, axis);
}
function isToTheRight(first2, second, referenceAxis) {
  return Vec3Utils.signTo(first2, second, referenceAxis) >= 0;
}
var signTo = function() {
  let componentAlongThis = create3();
  let componentAlongVector = create3();
  return function signTo2(first2, second, referenceAxis, zeroSign = 1) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, componentAlongThis);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, componentAlongVector);
    let angleSignedResult = Vec3Utils.angleSigned(first2, second, referenceAxis);
    return angleSignedResult > 0 ? 1 : angleSignedResult == 0 ? zeroSign : -1;
  };
}();
function projectOnAxis(vector, axis, out = Vec3Utils.create()) {
  Vec3Utils.componentAlongAxis(vector, axis, out);
  return out;
}
var projectOnAxisAlongAxis = function() {
  let up = create3();
  let vectorProjectedToAxis = create3();
  let fixedProjectAlongAxis = create3();
  return function projectOnAxisAlongAxis2(vector, axis, projectAlongAxis, out = Vec3Utils.create()) {
    if (Vec3Utils.isOnAxis(vector, axis) || Vec3Utils.isOnAxis(projectAlongAxis, axis)) {
      Vec3Utils.copy(vector, out);
    } else {
      Vec3Utils.cross(projectAlongAxis, axis, up);
      Vec3Utils.normalize(up, up);
      if (Vec3Utils.isZero(up)) {
        Vec3Utils.perpendicularRandom(projectAlongAxis, up);
        Vec3Utils.normalize(up, up);
      }
      Vec3Utils.removeComponentAlongAxis(vector, up, out);
      if (!Vec3Utils.isOnAxis(out, axis)) {
        Vec3Utils.projectOnAxis(out, axis, vectorProjectedToAxis);
        Vec3Utils.sub(vectorProjectedToAxis, out, vectorProjectedToAxis);
        if (Vec3Utils.isConcordant(vectorProjectedToAxis, projectAlongAxis)) {
          Vec3Utils.copy(projectAlongAxis, fixedProjectAlongAxis);
        } else {
          Vec3Utils.negate(projectAlongAxis, fixedProjectAlongAxis);
        }
        let angleWithAlongAxis = Vec3Utils.angleRadians(fixedProjectAlongAxis, vectorProjectedToAxis);
        let lengthToRemove = Vec3Utils.length(vectorProjectedToAxis) / Math.cos(angleWithAlongAxis);
        Vec3Utils.scale(fixedProjectAlongAxis, lengthToRemove, fixedProjectAlongAxis);
        Vec3Utils.add(out, fixedProjectAlongAxis, out);
        Vec3Utils.projectOnAxis(out, axis, out);
      }
    }
    return out;
  };
}();
function projectOnPlane(vector, planeNormal, out = Vec3Utils.create()) {
  Vec3Utils.removeComponentAlongAxis(vector, planeNormal, out);
  return out;
}
var projectOnPlaneAlongAxis = function() {
  let vectorProjectedToPlane = create3();
  let fixedProjectAlongAxis = create3();
  return function projectOnPlaneAlongAxis2(vector, planeNormal, projectAlongAxis, out = Vec3Utils.create()) {
    if (Vec3Utils.isOnPlane(vector, planeNormal) || Vec3Utils.isOnPlane(projectAlongAxis, planeNormal)) {
      Vec3Utils.copy(vector, out);
    } else {
      Vec3Utils.copy(vector, out);
      Vec3Utils.projectOnPlane(out, planeNormal, vectorProjectedToPlane);
      Vec3Utils.sub(vectorProjectedToPlane, out, vectorProjectedToPlane);
      if (Vec3Utils.isConcordant(vectorProjectedToPlane, projectAlongAxis)) {
        Vec3Utils.copy(projectAlongAxis, fixedProjectAlongAxis);
      } else {
        Vec3Utils.negate(projectAlongAxis, fixedProjectAlongAxis);
      }
      let angleWithAlongAxis = Vec3Utils.angleRadians(fixedProjectAlongAxis, vectorProjectedToPlane);
      let lengthToRemove = Vec3Utils.length(vectorProjectedToPlane) / Math.cos(angleWithAlongAxis);
      Vec3Utils.scale(fixedProjectAlongAxis, lengthToRemove, fixedProjectAlongAxis);
      Vec3Utils.add(out, fixedProjectAlongAxis, out);
      Vec3Utils.projectOnPlane(out, planeNormal, out);
    }
    return out;
  };
}();
function isOnAxis(vector, axis) {
  let angleResult = Vec3Utils.angle(vector, axis);
  return Math.abs(angleResult) < MathUtils.EPSILON_DEGREES || Math.abs(angleResult - 180) < MathUtils.EPSILON_DEGREES;
}
function isOnPlane(vector, planeNormal) {
  let angleResult = Vec3Utils.angle(vector, planeNormal);
  return Math.abs(angleResult - 90) < MathUtils.EPSILON_DEGREES;
}
function rotate(vector, rotation, out) {
  return Vec3Utils.rotateDegrees(vector, rotation, out);
}
var rotateDegrees = function() {
  let zero4 = create3();
  return function rotateDegrees4(vector, rotation, out) {
    return Vec3Utils.rotateAroundDegrees(vector, rotation, zero4, out);
  };
}();
var rotateRadians = function() {
  let zero4 = create3();
  return function rotateRadians4(vector, rotation, out) {
    return Vec3Utils.rotateAroundRadians(vector, rotation, zero4, out);
  };
}();
var rotateQuat = function() {
  let zero4 = create3();
  return function rotateQuat4(vector, rotation, out) {
    return Vec3Utils.rotateAroundQuat(vector, rotation, zero4, out);
  };
}();
function rotateAxis2(vector, angle2, axis, out) {
  return Vec3Utils.rotateAxisDegrees(vector, angle2, axis, out);
}
var rotateAxisDegrees2 = function() {
  let zero4 = create3();
  return function rotateAxisDegrees5(vector, angle2, axis, out) {
    return Vec3Utils.rotateAroundAxisDegrees(vector, angle2, axis, zero4, out);
  };
}();
var rotateAxisRadians2 = function() {
  let zero4 = create3();
  return function rotateAxisRadians5(vector, angle2, axis, out) {
    return Vec3Utils.rotateAroundAxisRadians(vector, angle2, axis, zero4, out);
  };
}();
function rotateAround(vector, rotation, origin, out) {
  return Vec3Utils.rotateAroundDegrees(vector, rotation, origin, out);
}
var rotateAroundDegrees = function() {
  let quat = create2();
  return function rotateAroundDegrees3(vector, rotation, origin, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(rotation, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  };
}();
var rotateAroundRadians = function() {
  let quat = create2();
  return function rotateAroundRadians3(vector, rotation, origin, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(rotation, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  };
}();
function rotateAroundQuat(vector, rotation, origin, out = Vec3Utils.create()) {
  Vec3Utils.sub(vector, origin, out);
  Vec3Utils.transformQuat(out, rotation, out);
  Vec3Utils.add(out, origin, out);
  return out;
}
function rotateAroundAxis(vector, angle2, axis, origin, out) {
  return Vec3Utils.rotateAroundAxisDegrees(vector, angle2, axis, origin, out);
}
function rotateAroundAxisDegrees(vector, angle2, axis, origin, out) {
  return Vec3Utils.rotateAroundAxisRadians(vector, MathUtils.toRadians(angle2), axis, origin, out);
}
var rotateAroundAxisRadians = function() {
  let quat = create2();
  return function rotateAroundAxisRadians3(vector, angle2, axis, origin, out = Vec3Utils.create()) {
    QuatUtils.fromAxisRadians(angle2, axis, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  };
}();
function convertPositionToWorld(vector, parentTransform, out) {
  return Vec3Utils.convertPositionToWorldMatrix(vector, parentTransform, out);
}
function convertPositionToLocal(vector, parentTransform, out) {
  return Vec3Utils.convertPositionToLocalMatrix(vector, parentTransform, out);
}
function convertPositionToWorldMatrix(vector, parentTransform, out = Vec3Utils.create()) {
  Vec3Utils.transformMat4(vector, parentTransform, out);
  return out;
}
var convertPositionToLocalMatrix = function() {
  let inverse = create5();
  return function convertPositionToLocalMatrix2(vector, parentTransform, out = Vec3Utils.create()) {
    Mat4Utils.invert(parentTransform, inverse);
    Vec3Utils.transformMat4(vector, inverse, out);
    return out;
  };
}();
var convertPositionToWorldQuat = function() {
  let parentTransformMatrix = create5();
  let position = create3();
  let rotation = create2();
  let one = create3();
  set2(one, 1, 1, 1);
  return function convertPositionToWorldQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getPosition(parentTransform, position);
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Mat4Utils.setPositionRotationQuatScale(parentTransformMatrix, position, rotation, one);
    return Vec3Utils.convertPositionToWorldMatrix(vector, parentTransformMatrix, out);
  };
}();
var convertPositionToLocalQuat = function() {
  let parentTransformMatrix = create5();
  let position = create3();
  let rotation = create2();
  let one = create3();
  set2(one, 1, 1, 1);
  return function convertPositionToLocalQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getPosition(parentTransform, position);
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Mat4Utils.setPositionRotationQuatScale(parentTransformMatrix, position, rotation, one);
    return Vec3Utils.convertPositionToLocalMatrix(vector, parentTransformMatrix, out);
  };
}();
function convertDirectionToWorld(vector, parentTransform, out) {
  return Vec3Utils.convertDirectionToWorldMatrix(vector, parentTransform, out);
}
function convertDirectionToLocal(vector, parentTransform, out) {
  return Vec3Utils.convertDirectionToLocalMatrix(vector, parentTransform, out);
}
var convertDirectionToWorldMatrix = function() {
  let rotation = create2();
  return function convertDirectionToWorldMatrix2(vector, parentTransform, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(parentTransform, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
var convertDirectionToLocalMatrix = function() {
  let rotation = create2();
  return function convertDirectionToLocalMatrix2(vector, parentTransform, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(parentTransform, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
var convertDirectionToWorldQuat = function() {
  let rotation = create2();
  return function convertDirectionToWorldQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
var convertDirectionToLocalQuat = function() {
  let rotation = create2();
  return function convertDirectionToLocalQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
function addRotation(vector, rotation, out) {
  return Vec3Utils.degreesAddRotation(vector, rotation, out);
}
function addRotationDegrees(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationDegrees(vector, rotation, out);
}
function addRotationRadians(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationRadians(vector, rotation, out);
}
function addRotationQuat(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationQuat(vector, rotation, out);
}
function degreesAddRotation(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationDegrees(vector, rotation, out);
}
var degreesAddRotationDegrees = function() {
  let quat = create2();
  return function degreesAddRotationDegrees2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationDegrees(quat, rotation, quat), out);
  };
}();
var degreesAddRotationRadians = function() {
  let quat = create2();
  return function degreesAddRotationRadians2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationRadians(quat, rotation, quat), out);
  };
}();
var degreesAddRotationQuat = function() {
  let quat = create2();
  return function degreesAddRotationQuat2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationQuat(quat, rotation, quat), out);
  };
}();
function radiansAddRotation(vector, rotation, out) {
  return Vec3Utils.radiansAddRotationDegrees(vector, rotation, out);
}
var radiansAddRotationDegrees = function() {
  let quat = create2();
  return function radiansAddRotationDegrees2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationDegrees(quat, rotation, quat), out);
  };
}();
var radiansAddRotationRadians = function() {
  let quat = create2();
  return function radiansAddRotationRadians2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationRadians(quat, rotation, quat), out);
  };
}();
var radiansAddRotationQuat = function() {
  let quat = create2();
  return function radiansAddRotationQuat2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationQuat(quat, rotation, quat), out);
  };
}();
function toMatrix2(vector, out = Mat3Utils.create()) {
  return Vec3Utils.degreesToMatrix(vector, out);
}
var degreesToMatrix = function() {
  let quat = create2();
  return function degreesToMatrix2(vector, out = Mat3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toMatrix(quat, out);
  };
}();
var radiansToMatrix = function() {
  let quat = create2();
  return function radiansToMatrix2(vector, out = Mat3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toMatrix(quat, out);
  };
}();
function rotationTo(from, to, out) {
  return Vec3Utils.rotationToDegrees(from, to, out);
}
var rotationToDegrees = function() {
  let rotationQuat = create2();
  return function rotationToDegrees3(from, to, out = Vec3Utils.create()) {
    Vec3Utils.rotationToQuat(from, to, rotationQuat);
    QuatUtils.toDegrees(rotationQuat, out);
    return out;
  };
}();
var rotationToRadians = function() {
  let rotationQuat = create2();
  return function rotationToRadians3(from, to, out = Vec3Utils.create()) {
    Vec3Utils.rotationToQuat(from, to, rotationQuat);
    QuatUtils.toRadians(rotationQuat, out);
    return out;
  };
}();
var rotationToQuat = function() {
  let rotationAxis = create3();
  return function rotationToQuat3(from, to, out = QuatUtils.create()) {
    Vec3Utils.cross(from, to, rotationAxis);
    Vec3Utils.normalize(rotationAxis, rotationAxis);
    if (Vec3Utils.isZero(rotationAxis)) {
      Vec3Utils.perpendicularRandom(from, rotationAxis);
      Vec3Utils.normalize(rotationAxis, rotationAxis);
    }
    let signedAngle = Vec3Utils.angleSigned(from, to, rotationAxis);
    QuatUtils.fromAxisRadians(signedAngle, rotationAxis, out);
    return out;
  };
}();
function rotationToPivoted(from, to, pivotAxis, out) {
  return Vec3Utils.rotationToPivotedDegrees(from, to, pivotAxis, out);
}
var rotationToPivotedDegrees = function() {
  let rotationQuat = create2();
  return function rotationToPivotedDegrees2(from, to, pivotAxis, out = Vec3Utils.create()) {
    Vec3Utils.rotationToPivotedQuat(from, to, pivotAxis, rotationQuat);
    QuatUtils.toDegrees(rotationQuat, out);
    return out;
  };
}();
var rotationToPivotedRadians = function() {
  let rotationQuat = create2();
  return function rotationToPivotedRadians2(from, to, pivotAxis, out = Vec3Utils.create()) {
    Vec3Utils.rotationToPivotedQuat(from, to, pivotAxis, rotationQuat);
    QuatUtils.toRadians(rotationQuat, out);
    return out;
  };
}();
var rotationToPivotedQuat = function() {
  let fromFlat = create3();
  let toFlat = create3();
  let rotationAxis = create3();
  return function rotationToPivotedQuat2(from, to, pivotAxis, out = QuatUtils.create()) {
    Vec3Utils.removeComponentAlongAxis(from, pivotAxis, fromFlat);
    Vec3Utils.removeComponentAlongAxis(to, pivotAxis, toFlat);
    Vec3Utils.cross(fromFlat, toFlat, rotationAxis);
    Vec3Utils.normalize(rotationAxis, rotationAxis);
    if (Vec3Utils.isZero(rotationAxis)) {
      Vec3Utils.perpendicularRandom(fromFlat, rotationAxis);
      Vec3Utils.normalize(rotationAxis, rotationAxis);
    }
    let signedAngle = Vec3Utils.angleSignedRadians(fromFlat, toFlat, rotationAxis);
    QuatUtils.fromAxisRadians(signedAngle, rotationAxis, out);
    return out;
  };
}();
function lerp3(from, to, interpolationFactor, out = Vec3Utils.create()) {
  if (interpolationFactor <= 0) {
    Vec3Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Vec3Utils.copy(to, out);
    return out;
  }
  gl_vec3.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate3(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec3Utils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return Vec3Utils.lerp(from, to, lerpFactor, out);
}
var perpendicularRandom = function() {
  let notVector = create3();
  return function perpendicularRandom2(vector, out = Vec3Utils.create()) {
    if (Vec3Utils.isZero(vector)) {
      return Vec3Utils.zero(out);
    }
    Vec3Utils.copy(vector, notVector);
    let zeroAmount = false;
    for (let i = 0; i < 3; i++) {
      if (vector[i] == 0) {
        zeroAmount++;
      }
    }
    if (zeroAmount == 2) {
      if (notVector[0] == 0) {
        notVector[0] = 1;
      } else if (notVector[1] == 0) {
        notVector[1] = 1;
      } else if (notVector[2] == 0) {
        notVector[2] = 1;
      }
    } else {
      if (notVector[0] != 0) {
        notVector[0] = -notVector[0];
      } else if (notVector[1] != 0) {
        notVector[1] = -notVector[1];
      } else if (notVector[2] != 0) {
        notVector[2] = -notVector[2];
      }
    }
    Vec3Utils.cross(notVector, vector, out);
    return out;
  };
}();
var Vec3Utils = {
  create: create3,
  set: set2,
  normalize: normalize2,
  copy: copy4,
  clone: clone3,
  zero,
  angle,
  angleDegrees,
  angleRadians,
  equals: equals2,
  length: length2,
  lengthSquared: lengthSquared2,
  distance,
  distanceSquared,
  add,
  sub,
  mul: mul3,
  div,
  scale: scale2,
  dot,
  negate,
  cross,
  transformQuat,
  transformMat3,
  transformMat4,
  lengthSigned,
  angleSigned,
  angleSignedDegrees,
  angleSignedRadians,
  anglePivoted,
  anglePivotedDegrees,
  anglePivotedRadians,
  anglePivotedSigned,
  anglePivotedSignedDegrees,
  anglePivotedSignedRadians,
  toRadians: toRadians2,
  toDegrees: toDegrees2,
  toQuat: toQuat2,
  radiansToQuat,
  degreesToQuat,
  isNormalized: isNormalized2,
  isZero,
  valueAlongAxis,
  valueAlongPlane,
  componentAlongAxis,
  removeComponentAlongAxis,
  copyComponentAlongAxis,
  isConcordant,
  isFartherAlongAxis,
  isToTheRight,
  signTo,
  projectOnAxis,
  projectOnAxisAlongAxis,
  projectOnPlane,
  projectOnPlaneAlongAxis,
  isOnAxis,
  isOnPlane,
  rotate,
  rotateDegrees,
  rotateRadians,
  rotateQuat,
  rotateAxis: rotateAxis2,
  rotateAxisDegrees: rotateAxisDegrees2,
  rotateAxisRadians: rotateAxisRadians2,
  rotateAround,
  rotateAroundDegrees,
  rotateAroundRadians,
  rotateAroundQuat,
  rotateAroundAxis,
  rotateAroundAxisDegrees,
  rotateAroundAxisRadians,
  convertPositionToWorld,
  convertPositionToLocal,
  convertPositionToWorldMatrix,
  convertPositionToLocalMatrix,
  convertPositionToWorldQuat,
  convertPositionToLocalQuat,
  convertDirectionToWorld,
  convertDirectionToLocal,
  convertDirectionToWorldMatrix,
  convertDirectionToLocalMatrix,
  convertDirectionToWorldQuat,
  convertDirectionToLocalQuat,
  addRotation,
  addRotationDegrees,
  addRotationRadians,
  addRotationQuat,
  degreesAddRotation,
  degreesAddRotationDegrees,
  degreesAddRotationRadians,
  degreesAddRotationQuat,
  radiansAddRotation,
  radiansAddRotationDegrees,
  radiansAddRotationRadians,
  radiansAddRotationQuat,
  toMatrix: toMatrix2,
  degreesToMatrix,
  radiansToMatrix,
  rotationTo,
  rotationToDegrees,
  rotationToRadians,
  rotationToQuat,
  rotationToPivoted,
  rotationToPivotedDegrees,
  rotationToPivotedRadians,
  rotationToPivotedQuat,
  lerp: lerp3,
  interpolate: interpolate3,
  perpendicularRandom
};

// dist/cauldron/js/utils/quat_utils.js
function create2(x, y, z, w) {
  let out = gl_quat.create();
  if (x !== void 0) {
    QuatUtils.set(out, x, y, z, w);
  }
  return out;
}
function set4(quat, x, y, z, w) {
  if (y === void 0) {
    gl_quat.set(quat, x, x, x, x);
  } else {
    gl_quat.set(quat, x, y, z, w);
  }
  return quat;
}
function normalize3(quat, out = QuatUtils.create()) {
  gl_quat.normalize(out, quat);
  return out;
}
function copy5(from, to) {
  gl_quat.copy(to, from);
  return to;
}
function clone4(quat, out = QuatUtils.create()) {
  QuatUtils.copy(quat, out);
  return out;
}
function identity3(quat) {
  gl_quat.identity(quat);
  return quat;
}
function length3(quat) {
  return gl_quat.length(quat);
}
function lengthSquared3(quat) {
  return gl_quat.squaredLength(quat);
}
function invert3(quat, out = QuatUtils.create()) {
  gl_quat.invert(out, quat);
  return out;
}
function conjugate2(quat, out = QuatUtils.create()) {
  gl_quat.conjugate(out, quat);
  return out;
}
function mul4(first2, second, out = QuatUtils.create()) {
  gl_quat.mul(out, first2, second);
  return out;
}
var getAxis = function() {
  let zero4 = create3(0, 0, 0);
  return function getAxis2(quat, out = Vec3Utils.create()) {
    let angle2 = gl_quat.getAxisAngle(out, quat);
    if (angle2 <= MathUtils.EPSILON) {
      Vec3Utils.copy(zero4, out);
    }
    return out;
  };
}();
function getAngle(quat) {
  return QuatUtils.getAngleDegrees(quat);
}
function getAngleDegrees(quat) {
  let angle2 = QuatUtils.getAngleRadians(quat);
  return MathUtils.toDegrees(angle2);
}
var getAngleRadians = function() {
  let vector = create3();
  return function getAngleRadians2(quat) {
    let angle2 = gl_quat.getAxisAngle(vector, quat);
    return angle2;
  };
}();
function getAxisScaled(quat, out = Vec3Utils.create()) {
  return QuatUtils.getAxisScaledDegrees(quat, out);
}
function getAxisScaledDegrees(quat, out = Vec3Utils.create()) {
  QuatUtils.getAxis(quat, out);
  let angle2 = QuatUtils.getAngleDegrees(quat);
  Vec3Utils.scale(out, angle2, out);
  return out;
}
var getAxisScaledRadians = function() {
  let zero4 = create3(0, 0, 0);
  return function getAxisScaledRadians2(quat, out = Vec3Utils.create()) {
    QuatUtils.getAxis(quat, out);
    let angle2 = QuatUtils.getAngleRadians(quat);
    if (angle2 <= MathUtils.EPSILON) {
      Vec3Utils.copy(zero4, out);
    } else {
      Vec3Utils.scale(out, angle2, out);
    }
    return out;
  };
}();
function getAxes3(quat, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  QuatUtils.getLeft(quat, out[0]);
  QuatUtils.getUp(quat, out[1]);
  QuatUtils.getForward(quat, out[2]);
  return out;
}
var getForward3 = function() {
  let rotationMatrix = create();
  return function getForward5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
    return out;
  };
}();
function getBackward3(quat, out) {
  out = QuatUtils.getForward(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getLeft3 = function() {
  let rotationMatrix = create();
  return function getLeft5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
    return out;
  };
}();
function getRight3(quat, out) {
  out = QuatUtils.getLeft(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getUp3 = function() {
  let rotationMatrix = create();
  return function getUp5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
    return out;
  };
}();
function getDown3(quat, out) {
  out = QuatUtils.getUp(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
function setAxes(quat, left, up, forward) {
  if (forward != null) {
    return QuatUtils.setForward(quat, forward, up, left);
  } else if (up != null) {
    return QuatUtils.setUp(quat, up, forward, left);
  } else {
    return QuatUtils.setLeft(quat, left, up, forward);
  }
}
var setForward = function() {
  let axes = [null, null, null];
  let priority = [2, 1, 0];
  return function setForward3(quat, forward, up = null, left = null) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setBackward = function() {
  let forward = create3();
  let axes = [null, null, null];
  let priority = [2, 1, 0];
  return function setBackward3(quat, backward, up = null, left = null) {
    Vec3Utils.negate(backward, forward);
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setUp = function() {
  let axes = [null, null, null];
  let priority = [1, 2, 0];
  return function setUp3(quat, up, forward = null, left = null) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setDown = function() {
  let up = create3();
  let axes = [null, null, null];
  let priority = [1, 2, 0];
  return function setDown3(quat, down, forward = null, left = null) {
    Vec3Utils.negate(down, up);
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setLeft = function() {
  let axes = [null, null, null];
  let priority = [0, 1, 2];
  return function setLeft3(quat, left, up = null, forward = null) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setRight = function() {
  let left = create3();
  let axes = [null, null, null];
  let priority = [0, 1, 2];
  return function setRight3(quat, right, up = null, forward = null) {
    Vec3Utils.negate(right, left);
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
function toWorld3(quat, parentQuat, out = QuatUtils.create()) {
  QuatUtils.mul(parentQuat, quat, out);
  return out;
}
var toLocal3 = function() {
  let invertQuat = create2();
  return function toLocal4(quat, parentQuat, out = QuatUtils.create()) {
    QuatUtils.conjugate(parentQuat, invertQuat);
    QuatUtils.mul(invertQuat, quat, out);
    return out;
  };
}();
function fromAxis(angle2, axis, out = QuatUtils.create()) {
  return QuatUtils.fromAxisDegrees(angle2, axis, out);
}
function fromAxisDegrees(angle2, axis, out = QuatUtils.create()) {
  QuatUtils.fromAxisRadians(MathUtils.toRadians(angle2), axis, out);
  return out;
}
function fromAxisRadians(angle2, axis, out = QuatUtils.create()) {
  gl_quat.setAxisAngle(out, axis, angle2);
  return out;
}
var fromAxes = function() {
  let matrix = create();
  return function fromAxes3(leftAxis, upAxis, forwardAxis, out = QuatUtils.create()) {
    Mat3Utils.fromAxes(leftAxis, upAxis, forwardAxis, matrix);
    return Mat3Utils.toQuat(matrix, out);
  };
}();
var fromRadians = function() {
  let vector = create3();
  return function fromRadians2(radiansRotation, out = QuatUtils.create()) {
    Vec3Utils.toDegrees(radiansRotation, vector);
    return QuatUtils.fromDegrees(vector, out);
  };
}();
function fromDegrees(degreesRotation, out = QuatUtils.create()) {
  gl_quat.fromEuler(out, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
  return out;
}
var toRadians3 = function() {
  let matrix = create();
  return function toRadians5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, matrix);
    out[1] = Math.asin(-MathUtils.clamp(matrix[2], -1, 1));
    if (Math.abs(matrix[2]) < 1 - MathUtils.EPSILON) {
      out[0] = Math.atan2(matrix[5], matrix[8]);
      out[2] = Math.atan2(matrix[1], matrix[0]);
    } else {
      out[0] = 0;
      out[2] = Math.atan2(-matrix[3], matrix[4]);
    }
    return out;
  };
}();
function toDegrees3(quat, out = Vec3Utils.create()) {
  QuatUtils.toRadians(quat, out);
  Vec3Utils.toDegrees(out, out);
  return out;
}
function isNormalized3(quat, epsilon = MathUtils.EPSILON) {
  return Math.abs(QuatUtils.lengthSquared(quat) - 1) < epsilon;
}
function addRotation2(first2, second, out) {
  return QuatUtils.addRotationDegrees(first2, second, out);
}
var addRotationDegrees2 = function() {
  let secondQuat = create2();
  return function addRotationDegrees3(first2, second, out) {
    Vec3Utils.degreesToQuat(second, secondQuat);
    return QuatUtils.addRotationQuat(first2, secondQuat, out);
  };
}();
var addRotationRadians2 = function() {
  let secondQuat = create2();
  return function addRotationRadians3(first2, second, out) {
    Vec3Utils.radiansToQuat(second, secondQuat);
    return QuatUtils.addRotationQuat(first2, secondQuat, out);
  };
}();
function addRotationQuat2(first2, second, out = QuatUtils.create()) {
  QuatUtils.mul(second, first2, out);
  return out;
}
function subRotation(first2, second, out) {
  return QuatUtils.subRotationDegrees(first2, second, out);
}
var subRotationDegrees = function() {
  let secondQuat = create2();
  return function subRotationDegrees2(first2, second, out) {
    Vec3Utils.degreesToQuat(second, secondQuat);
    return QuatUtils.subRotationQuat(first2, secondQuat, out);
  };
}();
var subRotationRadians = function() {
  let secondQuat = create2();
  return function subRotationRadians2(first2, second, out) {
    Vec3Utils.radiansToQuat(second, secondQuat);
    return QuatUtils.subRotationQuat(first2, secondQuat, out);
  };
}();
var subRotationQuat = function() {
  let inverse = create2();
  return function subRotationQuat2(first2, second, out = QuatUtils.create()) {
    QuatUtils.invert(second, inverse);
    QuatUtils.mul(first2, inverse, out);
    return out;
  };
}();
function rotationTo2(from, to, out) {
  return QuatUtils.rotationToDegrees(from, to, out);
}
var rotationToDegrees2 = function() {
  let toQuat4 = create2();
  return function rotationToDegrees3(from, to, out) {
    Vec3Utils.degreesToQuat(to, toQuat4);
    return QuatUtils.rotationToQuat(from, toQuat4, out);
  };
}();
var rotationToRadians2 = function() {
  let toQuat4 = create2();
  return function rotationToRadians3(from, to, out) {
    Vec3Utils.radiansToQuat(to, toQuat4);
    return QuatUtils.rotationToQuat(from, toQuat4, out);
  };
}();
function rotationToQuat2(from, to, out) {
  return QuatUtils.normalize(QuatUtils.subRotationQuat(to, from, out), out);
}
function rotationAroundAxis(quat, axis, out) {
  return QuatUtils.rotationAroundAxisDegrees(quat, axis, out);
}
var rotationAroundAxisDegrees = function() {
  let rotationAroundQuat = create2();
  return function rotationAroundAxisDegrees2(quat, axis, out = Vec3Utils.create()) {
    QuatUtils.rotationAroundAxisQuat(quat, axis, rotationAroundQuat);
    return QuatUtils.toDegrees(rotationAroundQuat, out);
  };
}();
var rotationAroundAxisRadians = function() {
  let rotationAroundQuat = create2();
  return function rotationAroundAxisRadians2(quat, axis, out = Vec3Utils.create()) {
    QuatUtils.rotationAroundAxisQuat(quat, axis, rotationAroundQuat);
    return QuatUtils.toRadians(rotationAroundQuat, out);
  };
}();
function rotationAroundAxisQuat(quat, axis, out = QuatUtils.create()) {
  return QuatUtils.getTwist(quat, axis, out);
}
var getTwist = function() {
  let rotationAxis = create3();
  let projection = create3();
  let rotationAlongAxis = create2();
  return function getTwist2(quat, axis, out = QuatUtils.create()) {
    rotationAxis[0] = quat[0];
    rotationAxis[1] = quat[1];
    rotationAxis[2] = quat[2];
    let dotProd = Vec3Utils.dot(axis, rotationAxis);
    Vec3Utils.scale(axis, dotProd, projection);
    rotationAlongAxis[0] = projection[0];
    rotationAlongAxis[1] = projection[1];
    rotationAlongAxis[2] = projection[2];
    rotationAlongAxis[3] = quat[3];
    QuatUtils.normalize(rotationAlongAxis, rotationAlongAxis);
    if (dotProd < 0) {
      rotationAlongAxis[0] = -rotationAlongAxis[0];
      rotationAlongAxis[1] = -rotationAlongAxis[1];
      rotationAlongAxis[2] = -rotationAlongAxis[2];
      rotationAlongAxis[3] = -rotationAlongAxis[3];
    }
    return QuatUtils.copy(rotationAlongAxis, out);
  };
}();
var getSwing = function() {
  let twist = create2();
  return function getSwing2(quat, axis, out = QuatUtils.create()) {
    QuatUtils.getTwist(quat, axis, twist);
    QuatUtils.getSwingFromTwist(quat, twist, out);
    return out;
  };
}();
function getSwingFromTwist(quat, twist, out = QuatUtils.create()) {
  return QuatUtils.subRotationQuat(quat, twist, out);
}
var getTwistFromSwing = function() {
  let inverse = create2();
  return function getTwistFromSwing2(quat, swing, out = QuatUtils.create()) {
    QuatUtils.conjugate(swing, inverse);
    QuatUtils.addRotationQuat(quat, inverse, out);
    return out;
  };
}();
function fromTwistSwing(twist, swing, out = QuatUtils.create()) {
  return QuatUtils.addRotationQuat(twist, swing, out);
}
function toMatrix3(quat, out = Mat3Utils.create()) {
  gl_mat3.fromQuat(out, quat);
  return out;
}
function rotate2(first2, second, out) {
  return QuatUtils.rotateDegrees(first2, second, out);
}
function rotateDegrees2(first2, second, out) {
  return QuatUtils.addRotationDegrees(first2, second, out);
}
function rotateRadians2(first2, second, out) {
  return QuatUtils.addRotationRadians(first2, second, out);
}
function rotateQuat2(first2, second, out) {
  return QuatUtils.addRotationQuat(first2, second, out);
}
function rotateAxis3(quat, angle2, axis, out) {
  return QuatUtils.rotateAxisDegrees(quat, angle2, axis, out);
}
var rotateAxisDegrees3 = function() {
  let secondQuat = create2();
  return function rotateAxisDegrees5(quat, angle2, axis, out) {
    QuatUtils.fromAxisDegrees(angle2, axis, secondQuat);
    return QuatUtils.rotateQuat(quat, secondQuat, out);
  };
}();
var rotateAxisRadians3 = function() {
  let secondQuat = create2();
  return function rotateAxisRadians5(quat, angle2, axis, out) {
    QuatUtils.fromAxisRadians(angle2, axis, secondQuat);
    return QuatUtils.rotateQuat(quat, secondQuat, out);
  };
}();
function lerp4(from, to, interpolationFactor, out = QuatUtils.create()) {
  if (interpolationFactor <= 0) {
    QuatUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    QuatUtils.copy(to, out);
    return out;
  }
  gl_quat.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate4(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return QuatUtils.lerp(from, to, lerpFactor, out);
}
function slerp2(from, to, interpolationFactor, out = QuatUtils.create()) {
  if (interpolationFactor <= 0) {
    QuatUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    QuatUtils.copy(to, out);
    return out;
  }
  gl_quat.slerp(out, from, to, interpolationFactor);
  return out;
}
function sinterpolate2(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return QuatUtils.slerp(from, to, lerpFactor, out);
}
var QuatUtils = {
  create: create2,
  set: set4,
  normalize: normalize3,
  copy: copy5,
  clone: clone4,
  identity: identity3,
  length: length3,
  lengthSquared: lengthSquared3,
  invert: invert3,
  conjugate: conjugate2,
  mul: mul4,
  getAxis,
  getAngle,
  getAngleDegrees,
  getAngleRadians,
  getAxisScaled,
  getAxisScaledDegrees,
  getAxisScaledRadians,
  getAxes: getAxes3,
  getForward: getForward3,
  getBackward: getBackward3,
  getLeft: getLeft3,
  getRight: getRight3,
  getUp: getUp3,
  getDown: getDown3,
  setAxes,
  setForward,
  setBackward,
  setUp,
  setDown,
  setLeft,
  setRight,
  toWorld: toWorld3,
  toLocal: toLocal3,
  fromAxis,
  fromAxisDegrees,
  fromAxisRadians,
  fromAxes,
  fromRadians,
  fromDegrees,
  toRadians: toRadians3,
  toDegrees: toDegrees3,
  isNormalized: isNormalized3,
  addRotation: addRotation2,
  addRotationDegrees: addRotationDegrees2,
  addRotationRadians: addRotationRadians2,
  addRotationQuat: addRotationQuat2,
  subRotation,
  subRotationDegrees,
  subRotationRadians,
  subRotationQuat,
  rotationTo: rotationTo2,
  rotationToDegrees: rotationToDegrees2,
  rotationToRadians: rotationToRadians2,
  rotationToQuat: rotationToQuat2,
  rotationAroundAxis,
  rotationAroundAxisDegrees,
  rotationAroundAxisRadians,
  rotationAroundAxisQuat,
  getTwist,
  getSwing,
  getSwingFromTwist,
  getTwistFromSwing,
  fromTwistSwing,
  toMatrix: toMatrix3,
  rotate: rotate2,
  rotateDegrees: rotateDegrees2,
  rotateRadians: rotateRadians2,
  rotateQuat: rotateQuat2,
  rotateAxis: rotateAxis3,
  rotateAxisDegrees: rotateAxisDegrees3,
  rotateAxisRadians: rotateAxisRadians3,
  lerp: lerp4,
  interpolate: interpolate4,
  slerp: slerp2,
  sinterpolate: sinterpolate2
};
var _setAxes = function() {
  let fixedAxes = [create3(), create3(), create3()];
  let fixedAxesFixSignMap = [
    [1, -1, 1],
    [1, 1, -1],
    [-1, 1, -1]
  ];
  let fixedLeft = create3();
  let fixedUp = create3();
  let fixedForward = create3();
  let currentAxis = create3();
  let rotationAxis = create3();
  let rotationMat = create();
  let rotationQuat = create2();
  return function _setAxes2(quat, axes, priority) {
    let firstAxis = axes[priority[0]];
    let secondAxis = axes[priority[1]];
    let thirdAxis = axes[priority[2]];
    if (firstAxis == null || Vec3Utils.isZero(firstAxis, MathUtils.EPSILON)) {
      return;
    }
    let secondAxisValid = false;
    if (secondAxis != null) {
      let angleBetween = Vec3Utils.angleRadians(firstAxis, secondAxis);
      if (angleBetween > MathUtils.EPSILON) {
        secondAxisValid = true;
      }
    }
    let thirdAxisValid = false;
    if (thirdAxis != null) {
      let angleBetween = Vec3Utils.angleRadians(firstAxis, thirdAxis);
      if (angleBetween > MathUtils.EPSILON) {
        thirdAxisValid = true;
      }
    }
    if (secondAxisValid || thirdAxisValid) {
      let crossAxis = null;
      let secondAxisIndex = null;
      let thirdAxisIndex = null;
      if (secondAxisValid) {
        crossAxis = secondAxis;
        secondAxisIndex = 1;
        thirdAxisIndex = 2;
      } else {
        crossAxis = thirdAxis;
        secondAxisIndex = 2;
        thirdAxisIndex = 1;
      }
      let fixSignMap = fixedAxesFixSignMap[priority[0]];
      Vec3Utils.cross(firstAxis, crossAxis, fixedAxes[thirdAxisIndex]);
      Vec3Utils.scale(fixedAxes[thirdAxisIndex], fixSignMap[priority[thirdAxisIndex]], fixedAxes[thirdAxisIndex]);
      Vec3Utils.cross(firstAxis, fixedAxes[thirdAxisIndex], fixedAxes[secondAxisIndex]);
      Vec3Utils.scale(fixedAxes[secondAxisIndex], fixSignMap[priority[secondAxisIndex]], fixedAxes[secondAxisIndex]);
      Vec3Utils.cross(fixedAxes[1], fixedAxes[2], fixedAxes[0]);
      Vec3Utils.scale(fixedAxes[0], fixSignMap[priority[0]], fixedAxes[0]);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 0)], fixedLeft);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 1)], fixedUp);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 2)], fixedForward);
      Mat3Utils.set(rotationMat, fixedLeft[0], fixedLeft[1], fixedLeft[2], fixedUp[0], fixedUp[1], fixedUp[2], fixedForward[0], fixedForward[1], fixedForward[2]);
      Mat3Utils.toQuat(rotationMat, rotationQuat);
      QuatUtils.copy(rotationQuat, quat);
    } else {
      if (priority[0] == 0) {
        QuatUtils.getLeft(quat, currentAxis);
      } else if (priority[0] == 1) {
        QuatUtils.getUp(quat, currentAxis);
      } else {
        QuatUtils.getForward(quat, currentAxis);
      }
      let angleBetween = Vec3Utils.angleRadians(firstAxis, currentAxis);
      if (angleBetween > MathUtils.EPSILON) {
        Vec3Utils.cross(currentAxis, firstAxis, rotationAxis);
        Vec3Utils.normalize(rotationAxis, rotationAxis);
        if (Vec3Utils.isZero(rotationAxis)) {
          Vec3Utils.perpendicularRandom(currentAxis, rotationAxis);
          Vec3Utils.normalize(rotationAxis, rotationAxis);
        }
        QuatUtils.fromAxisRadians(angleBetween, rotationAxis, rotationQuat);
        QuatUtils.rotateQuat(quat, rotationQuat, quat);
      }
    }
    return quat;
  };
}();

// dist/cauldron/js/utils/mat3_utils.js
function create(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = gl_mat32.create();
  if (m00 !== void 0) {
    set5(out, m00, m01, m02, m10, m11, m12, m20, m21, m22);
  }
  return out;
}
function set5(matrix, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  if (m01 === void 0) {
    gl_mat32.set(matrix, m00, m00, m00, m00, m00, m00, m00, m00, m00);
  } else {
    gl_mat32.set(matrix, m00, m01, m02, m10, m11, m12, m20, m21, m22);
  }
  return matrix;
}
var toDegrees4 = function() {
  let quat = create2();
  return function toDegrees5(matrix, out = Vec3Utils.create()) {
    Mat3Utils.toQuat(matrix, quat);
    QuatUtils.toDegrees(quat, out);
    return out;
  };
}();
var toRadians4 = function() {
  let quat = create2();
  return function toRadians5(matrix, out = Vec3Utils.create()) {
    Mat3Utils.toQuat(matrix, quat);
    QuatUtils.toRadians(quat, out);
    return out;
  };
}();
function toQuat3(matrix, out = QuatUtils.create()) {
  gl_quat3.fromMat3(out, matrix);
  return out;
}
function fromAxes2(leftAxis, upAxis, forwardAxis, out = Mat3Utils.create()) {
  Mat3Utils.set(out, leftAxis[0], leftAxis[1], leftAxis[2], upAxis[0], upAxis[1], upAxis[2], forwardAxis[0], forwardAxis[1], forwardAxis[2]);
  return out;
}
var Mat3Utils = {
  create,
  set: set5,
  toDegrees: toDegrees4,
  toRadians: toRadians4,
  toQuat: toQuat3,
  fromAxes: fromAxes2
};

// dist/cauldron/wl/utils/object_utils.js
var CloneParams = class {
  constructor() {
    this.myCloneParent = void 0;
    this.myIgnoreNonCloneable = false;
    this.myIgnoreComponents = false;
    this.myIgnoreDescendants = false;
    this.myComponentsToIgnore = [];
    this.myComponentsToInclude = [];
    this.myIgnoreComponentCallback = null;
    this.myDescendantsToIgnore = [];
    this.myDescendantsToInclude = [];
    this.myIgnoreDescendantCallback = null;
    this.myUseDefaultComponentClone = false;
    this.myUseDefaultComponentCloneAsFallback = false;
    this.myDefaultComponentCloneAutoStartIfNotActive = true;
    this.myUseDefaultObjectClone = false;
    this.myUseDefaultObjectCloneAsFallback = false;
    this.myComponentDeepCloneParams = new DeepCloneParams();
    this.myComponentCustomCloneParams = new CustomCloneParams();
  }
};
function getPosition3(object, position) {
  return ObjectUtils.getPositionWorld(object, position);
}
function getPositionWorld(object, position = Vec3Utils.create()) {
  object.getPositionWorld(position);
  return position;
}
function getPositionLocal(object, position = Vec3Utils.create()) {
  object.getPositionLocal(position);
  return position;
}
function getRotation3(object, rotation) {
  return ObjectUtils.getRotationWorld(object, rotation);
}
function getRotationDegrees3(object, rotation) {
  return ObjectUtils.getRotationWorldDegrees(object, rotation);
}
function getRotationRadians3(object, rotation) {
  return ObjectUtils.getRotationWorldRadians(object, rotation);
}
function getRotationMatrix(object, rotation) {
  return ObjectUtils.getRotationWorldMatrix(object, rotation);
}
function getRotationQuat3(object, rotation) {
  return ObjectUtils.getRotationWorldQuat(object, rotation);
}
function getRotationWorld(object, rotation) {
  return ObjectUtils.getRotationWorldDegrees(object, rotation);
}
function getRotationWorldDegrees(object, rotation) {
  rotation = ObjectUtils.getRotationWorldRadians(object, rotation);
  rotation = Vec3Utils.toDegrees(rotation, rotation);
  return rotation;
}
var getRotationWorldRadians = function() {
  let quat = QuatUtils.create();
  return function getRotationWorldRadians2(object, rotation = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.toRadians(quat, rotation);
    return rotation;
  };
}();
var getRotationWorldMatrix = function() {
  let quat = QuatUtils.create();
  return function getRotationWorldMatrix2(object, rotation = Mat3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.toMatrix(quat, rotation);
    return rotation;
  };
}();
function getRotationWorldQuat(object, rotation = QuatUtils.create()) {
  object.getRotationWorld(rotation);
  return rotation;
}
function getRotationLocal(object, rotation) {
  return ObjectUtils.getRotationLocalDegrees(object, rotation);
}
function getRotationLocalDegrees(object, rotation) {
  rotation = ObjectUtils.getRotationLocalRadians(object, rotation);
  rotation = Vec3Utils.toDegrees(rotation, rotation);
  return rotation;
}
var getRotationLocalRadians = function() {
  let quat = QuatUtils.create();
  return function getRotationLocalRadians2(object, rotation = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.toRadians(quat, rotation);
    return rotation;
  };
}();
var getRotationLocalMatrix = function() {
  let quat = QuatUtils.create();
  return function getRotationLocalMatrix2(object, rotation = Mat3Utils.create()) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.toMatrix(quat, rotation);
    return rotation;
  };
}();
function getRotationLocalQuat(object, rotation = QuatUtils.create()) {
  object.getRotationLocal(rotation);
  return rotation;
}
function getScale2(object, scale4) {
  return ObjectUtils.getScaleWorld(object, scale4);
}
function getScaleWorld(object, scale4 = Vec3Utils.create()) {
  object.getScalingWorld(scale4);
  return scale4;
}
function getScaleLocal(object, scale4 = Vec3Utils.create()) {
  object.getScalingLocal(scale4);
  return scale4;
}
function getTransform(object, transform) {
  return ObjectUtils.getTransformWorld(object, transform);
}
function getTransformMatrix(object, transform) {
  return ObjectUtils.getTransformWorldMatrix(object, transform);
}
function getTransformQuat(object, transform) {
  return ObjectUtils.getTransformWorldQuat(object, transform);
}
function getTransformWorld(object, transform) {
  return ObjectUtils.getTransformWorldMatrix(object, transform);
}
var getTransformWorldMatrix = function() {
  let transformQuat2 = Quat2Utils.create();
  let scale4 = Vec3Utils.create();
  return function getTransformWorldMatrix2(object, transform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldQuat(object, transformQuat2);
    ObjectUtils.getScaleWorld(object, scale4);
    Mat4Utils.fromQuat(transformQuat2, transform);
    Mat4Utils.scale(transform, scale4, transform);
    return transform;
  };
}();
function getTransformWorldQuat(object, transform = Quat2Utils.create()) {
  object.getTransformWorld(transform);
  return transform;
}
function getTransformLocal(object, transform) {
  return ObjectUtils.getTransformLocalMatrix(object, transform);
}
var getTransformLocalMatrix = function() {
  let transformQuat2 = Quat2Utils.create();
  let scale4 = Vec3Utils.create();
  return function getTransformLocalMatrix2(object, transform = Mat4Utils.create()) {
    ObjectUtils.getTransformLocalQuat(object, transformQuat2);
    ObjectUtils.getScaleLocal(object, scale4);
    Mat4Utils.fromQuat(transformQuat2, transform);
    Mat4Utils.scale(transform, scale4, transform);
    return transform;
  };
}();
function getTransformLocalQuat(object, transform = Quat2Utils.create()) {
  object.getTransformLocal(transform);
  return transform;
}
function getAxes4(object, axes) {
  return ObjectUtils.getAxesWorld(object, axes);
}
function getAxesWorld(object, axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  ObjectUtils.getLeftWorld(object, axes[0]);
  ObjectUtils.getUpWorld(object, axes[1]);
  ObjectUtils.getForwardWorld(object, axes[2]);
  return axes;
}
function getAxesLocal(object, axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  ObjectUtils.getLeftLocal(object, axes[0]);
  ObjectUtils.getUpLocal(object, axes[1]);
  ObjectUtils.getForwardLocal(object, axes[2]);
  return axes;
}
function getForward4(object, forward) {
  return ObjectUtils.getForwardWorld(object, forward);
}
var getForwardWorld = function() {
  let rotation = Mat3Utils.create();
  return function getForwardWorld2(object, forward = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    forward[0] = rotation[6];
    forward[1] = rotation[7];
    forward[2] = rotation[8];
    return forward;
  };
}();
var getForwardLocal = function() {
  let rotation = Mat3Utils.create();
  return function getForwardLocal2(object, forward = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    forward[0] = rotation[6];
    forward[1] = rotation[7];
    forward[2] = rotation[8];
    return forward;
  };
}();
function getBackward4(object, backward) {
  return ObjectUtils.getBackwardWorld(object, backward);
}
var getBackwardWorld = function() {
  let rotation = Mat3Utils.create();
  return function getBackwardWorld2(object, backward = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    backward[0] = -rotation[6];
    backward[1] = -rotation[7];
    backward[2] = -rotation[8];
    return backward;
  };
}();
var getBackwardLocal = function() {
  let rotation = Mat3Utils.create();
  return function getBackwardLocal2(object, backward = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    backward[0] = -rotation[6];
    backward[1] = -rotation[7];
    backward[2] = -rotation[8];
    return backward;
  };
}();
function getUp4(object, up) {
  return ObjectUtils.getUpWorld(object, up);
}
var getUpWorld = function() {
  let rotation = Mat3Utils.create();
  return function getUpWorld2(object, up = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    up[0] = rotation[3];
    up[1] = rotation[4];
    up[2] = rotation[5];
    return up;
  };
}();
var getUpLocal = function() {
  let rotation = Mat3Utils.create();
  return function getUpLocal2(object, up = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    up[0] = rotation[3];
    up[1] = rotation[4];
    up[2] = rotation[5];
    return up;
  };
}();
function getDown4(object, down) {
  return ObjectUtils.getDownWorld(object, down);
}
var getDownWorld = function() {
  let rotation = Mat3Utils.create();
  return function getDownWorld2(object, down = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    down[0] = -rotation[3];
    down[1] = -rotation[4];
    down[2] = -rotation[5];
    return down;
  };
}();
var getDownLocal = function() {
  let rotation = Mat3Utils.create();
  return function getDownLocal2(object, down = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    down[0] = -rotation[3];
    down[1] = -rotation[4];
    down[2] = -rotation[5];
    return down;
  };
}();
function getLeft4(object, left) {
  return ObjectUtils.getLeftWorld(object, left);
}
var getLeftWorld = function() {
  let rotation = Mat3Utils.create();
  return function getLeftWorld2(object, left = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    left[0] = rotation[0];
    left[1] = rotation[1];
    left[2] = rotation[2];
    return left;
  };
}();
var getLeftLocal = function() {
  let rotation = Mat3Utils.create();
  return function getLeftLocal2(object, left = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    left[0] = rotation[0];
    left[1] = rotation[1];
    left[2] = rotation[2];
    return left;
  };
}();
function getRight4(object, right) {
  return ObjectUtils.getRightWorld(object, right);
}
var getRightWorld = function() {
  let rotation = Mat3Utils.create();
  return function getRightWorld2(object, right = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    right[0] = -rotation[0];
    right[1] = -rotation[1];
    right[2] = -rotation[2];
    return right;
  };
}();
var getRightLocal = function() {
  let rotation = Mat3Utils.create();
  return function getRightLocal2(object, right = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    right[0] = -rotation[0];
    right[1] = -rotation[1];
    right[2] = -rotation[2];
    return right;
  };
}();
function setPosition3(object, position) {
  ObjectUtils.setPositionWorld(object, position);
}
function setPositionWorld(object, position) {
  object.setTranslationWorld(position);
}
function setPositionLocal(object, position) {
  object.setTranslationLocal(position);
}
function setRotation3(object, rotation) {
  ObjectUtils.setRotationWorld(object, rotation);
}
function setRotationDegrees3(object, rotation) {
  ObjectUtils.setRotationWorldDegrees(object, rotation);
}
function setRotationRadians3(object, rotation) {
  ObjectUtils.setRotationWorldRadians(object, rotation);
}
function setRotationMatrix(object, rotation) {
  ObjectUtils.setRotationWorldMatrix(object, rotation);
}
function setRotationQuat3(object, rotation) {
  ObjectUtils.setRotationWorldQuat(object, rotation);
}
function setRotationWorld(object, rotation) {
  ObjectUtils.setRotationWorldDegrees(object, rotation);
}
var setRotationWorldDegrees = function() {
  let quat = QuatUtils.create();
  return function setRotationWorldDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, quat);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setRotationWorldRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function setRotationWorldRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.setRotationWorldDegrees(object, degreesRotation);
  };
}();
var setRotationWorldMatrix = function() {
  let quat = QuatUtils.create();
  return function setRotationWorldMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, quat);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
function setRotationWorldQuat(object, rotation) {
  object.setRotationWorld(rotation);
}
function setRotationLocal(object, rotation) {
  ObjectUtils.setRotationLocalDegrees(object, rotation);
}
var setRotationLocalDegrees = function() {
  let quat = QuatUtils.create();
  return function setRotationLocalDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, quat);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
var setRotationLocalRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function setRotationLocalRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.setRotationLocalDegrees(object, degreesRotation);
  };
}();
var setRotationLocalMatrix = function() {
  let quat = QuatUtils.create();
  return function setRotationLocalMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, quat);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setRotationLocalQuat(object, rotation) {
  object.setRotationLocal(rotation);
}
function setScale2(object, scale4) {
  ObjectUtils.setScaleWorld(object, scale4);
}
var setScaleWorld = function() {
  let vector = Vec3Utils.create();
  return function setScaleWorld2(object, scale4) {
    if (isNaN(scale4)) {
      object.setScalingWorld(scale4);
    } else {
      Vec3Utils.set(vector, scale4);
      object.setScalingWorld(vector);
    }
  };
}();
var setScaleLocal = function() {
  let vector = Vec3Utils.create();
  return function setScaleLocal2(object, scale4) {
    if (isNaN(scale4)) {
      object.setScalingLocal(scale4);
    } else {
      Vec3Utils.set(vector, scale4);
      object.setScalingLocal(vector);
    }
  };
}();
function setAxes2(object, left, up, forward) {
  ObjectUtils.setAxesWorld(object, left, up, forward);
}
function setAxesWorld(object, left, up, forward) {
  if (forward != null) {
    ObjectUtils.setForwardWorld(object, forward, up, left);
  } else if (up != null) {
    ObjectUtils.setUpWorld(object, up, forward, left);
  } else {
    ObjectUtils.setLeftWorld(object, left, up, forward);
  }
}
function setAxesLocal(object, left, up, forward) {
  if (forward != null) {
    ObjectUtils.setForwardLocal(object, forward, up, left);
  } else if (up != null) {
    ObjectUtils.setUpLocal(object, up, forward, left);
  } else {
    ObjectUtils.setLeftLocal(object, left, up, forward);
  }
}
function setForward2(object, forward, up, left) {
  ObjectUtils.setForwardWorld(object, forward, up, left);
}
var setForwardWorld = function() {
  let quat = QuatUtils.create();
  return function setForwardWorld2(object, forward, up = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setForward(quat, forward, up, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setForwardLocal = function() {
  let quat = QuatUtils.create();
  return function setForwardLocal2(object, forward, up = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setForward(quat, forward, up, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setBackward2(object, backward, up, left) {
  ObjectUtils.setBackwardWorld(object, backward, up, left);
}
var setBackwardWorld = function() {
  let quat = QuatUtils.create();
  return function setBackwardWorld2(object, backward, up = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setBackward(quat, backward, up, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setBackwardLocal = function() {
  let quat = QuatUtils.create();
  return function setBackwardLocal2(object, backward, up = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setBackward(quat, backward, up, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setUp2(object, up, forward, left) {
  ObjectUtils.setUpWorld(object, up, forward, left);
}
var setUpWorld = function() {
  let quat = QuatUtils.create();
  return function setUpWorld2(object, up, forward = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setUp(quat, up, forward, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setUpLocal = function() {
  let quat = QuatUtils.create();
  return function setUpLocal2(object, up, forward = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setUp(quat, up, forward, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setDown2(object, down, forward, left) {
  ObjectUtils.setDownWorld(object, down, forward, left);
}
var setDownWorld = function() {
  let quat = QuatUtils.create();
  return function setDownWorld2(object, down, forward = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setDown(quat, down, forward, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setDownLocal = function() {
  let quat = QuatUtils.create();
  return function setDownLocal2(object, down, forward = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setDown(quat, down, forward, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setLeft2(object, left, up, forward) {
  ObjectUtils.setLeftWorld(object, left, up, forward);
}
var setLeftWorld = function() {
  let quat = QuatUtils.create();
  return function setLeftWorld2(object, left, up = null, forward = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setLeft(quat, left, up, forward);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setLeftLocal = function() {
  let quat = QuatUtils.create();
  return function setLeftLocal2(object, left, up = null, forward = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setLeft(quat, left, up, forward);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setRight2(object, right, up, forward) {
  ObjectUtils.setRightWorld(object, right, up, forward);
}
var setRightWorld = function() {
  let quat = QuatUtils.create();
  return function setRightWorld2(object, right, up = null, forward = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setRight(quat, right, up, forward);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setRightLocal = function() {
  let quat = QuatUtils.create();
  return function setRightLocal2(object, right, up = null, forward = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setRight(quat, right, up, forward);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setTransform(object, transform) {
  ObjectUtils.setTransformWorld(object, transform);
}
function setTransformMatrix(object, transform) {
  ObjectUtils.setTransformWorldMatrix(object, transform);
}
function setTransformQuat(object, transform) {
  ObjectUtils.setTransformWorldQuat(object, transform);
}
function setTransformWorld(object, transform) {
  return ObjectUtils.setTransformWorldMatrix(object, transform);
}
var setTransformWorldMatrix = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  let scale4 = Vec3Utils.create();
  let transformMatrixNoScale = Mat4Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function setTransformWorldMatrix2(object, transform) {
    Mat4Utils.getPosition(transform, position);
    Mat4Utils.getScale(transform, scale4);
    Vec3Utils.div(one, scale4, inverseScale);
    Mat4Utils.scale(transform, inverseScale, transformMatrixNoScale);
    Mat4Utils.getRotationQuat(transformMatrixNoScale, rotation);
    QuatUtils.normalize(rotation, rotation);
    ObjectUtils.setScaleWorld(object, scale4);
    ObjectUtils.setRotationWorldQuat(object, rotation);
    ObjectUtils.setPositionWorld(object, position);
  };
}();
function setTransformWorldQuat(object, transform) {
  object.setTransformWorld(transform);
}
function setTransformLocal(object, transform) {
  return ObjectUtils.setTransformLocalMatrix(object, transform);
}
var setTransformLocalMatrix = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  let scale4 = Vec3Utils.create();
  let transformMatrixNoScale = Mat4Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function setTransformLocalMatrix2(object, transform) {
    Mat4Utils.getPosition(transform, position);
    Mat4Utils.getScale(transform, scale4);
    Vec3Utils.div(one, scale4, inverseScale);
    Mat4Utils.scale(transform, inverseScale, transformMatrixNoScale);
    Mat4Utils.getRotationQuat(transformMatrixNoScale, rotation);
    QuatUtils.normalize(rotation, rotation);
    ObjectUtils.setScaleLocal(object, scale4);
    ObjectUtils.setRotationLocalQuat(object, rotation);
    ObjectUtils.setPositionLocal(object, position);
  };
}();
function setTransformLocalQuat(object, transform) {
  object.setTransformLocal(transform);
}
function resetPosition(object) {
  ObjectUtils.resetPositionWorld(object);
}
var resetPositionWorld = function() {
  let zero4 = Vec3Utils.create();
  return function resetPositionWorld2(object) {
    ObjectUtils.setPositionWorld(object, zero4);
  };
}();
var resetPositionLocal = function() {
  let zero4 = Vec3Utils.create();
  return function resetPositionLocal2(object) {
    ObjectUtils.setPositionLocal(object, zero4);
  };
}();
function resetRotation(object) {
  ObjectUtils.resetRotationWorld(object);
}
var resetRotationWorld = function() {
  let identity4 = QuatUtils.create();
  return function resetRotationWorld2(object) {
    ObjectUtils.setRotationWorldQuat(object, identity4);
  };
}();
var resetRotationLocal = function() {
  let identity4 = QuatUtils.create();
  return function resetRotationLocal2(object) {
    ObjectUtils.setRotationLocalQuat(object, identity4);
  };
}();
function resetScale(object) {
  ObjectUtils.resetScaleWorld(object);
}
var resetScaleWorld = function() {
  let one = Vec3Utils.create(1);
  return function resetScaleWorld2(object) {
    ObjectUtils.setScaleWorld(object, one);
  };
}();
var resetScaleLocal = function() {
  let one = Vec3Utils.create(1);
  return function resetScaleLocal2(object) {
    ObjectUtils.setScaleLocal(object, one);
  };
}();
function resetTransform(object) {
  ObjectUtils.resetTransformWorld(object);
}
function resetTransformWorld(object) {
  ObjectUtils.resetScaleWorld(object);
  ObjectUtils.resetRotationWorld(object);
  ObjectUtils.resetPositionWorld(object);
}
function resetTransformLocal(object) {
  ObjectUtils.resetScaleLocal(object);
  ObjectUtils.resetRotationLocal(object);
  ObjectUtils.resetPositionLocal(object);
}
function translate(object, translation) {
  ObjectUtils.translateWorld(object, translation);
}
function translateWorld(object, translation) {
  object.translateWorld(translation);
}
function translateLocal(object, translation) {
  object.translate(translation);
}
function translateObject(object, translation) {
  object.translateObject(translation);
}
function translateAxis(object, amount, direction) {
  ObjectUtils.translateAxisWorld(object, amount, direction);
}
var translateAxisWorld = function() {
  let translation = Vec3Utils.create();
  return function translateAxisWorld2(object, amount, direction) {
    Vec3Utils.scale(direction, amount, translation);
    ObjectUtils.translateWorld(object, translation);
  };
}();
var translateAxisLocal = function() {
  let translation = Vec3Utils.create();
  return function translateAxisLocal2(object, amount, direction) {
    Vec3Utils.scale(direction, amount, translation);
    ObjectUtils.translateLocal(object, translation);
  };
}();
var translateAxisObject = function() {
  let translation = Vec3Utils.create();
  return function translateAxisObject2(object, amount, direction) {
    Vec3Utils.scale(direction, amount, translation);
    ObjectUtils.translateObject(object, translation);
  };
}();
function rotate3(object, rotation) {
  ObjectUtils.rotateWorld(object, rotation);
}
function rotateDegrees3(object, rotation) {
  ObjectUtils.rotateWorldDegrees(object, rotation);
}
function rotateRadians3(object, rotation) {
  ObjectUtils.rotateWorldRadians(object, rotation);
}
function rotateMatrix(object, rotation) {
  ObjectUtils.rotateWorldMatrix(object, rotation);
}
function rotateQuat3(object, rotation) {
  ObjectUtils.rotateWorldQuat(object, rotation);
}
function rotateWorld(object, rotation) {
  ObjectUtils.rotateWorldDegrees(object, rotation);
}
var rotateWorldDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateWorldDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateWorldQuat(object, rotationQuat);
  };
}();
var rotateWorldRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateWorldRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateWorldDegrees(object, degreesRotation);
  };
}();
var rotateWorldMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateWorldMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateWorldQuat(object, rotationQuat);
  };
}();
var rotateWorldQuat = function() {
  let currentRotationQuat = QuatUtils.create();
  return function rotateWorldQuat2(object, rotation) {
    ObjectUtils.getRotationWorldQuat(object, currentRotationQuat);
    QuatUtils.mul(rotation, currentRotationQuat, currentRotationQuat);
    QuatUtils.normalize(currentRotationQuat, currentRotationQuat);
    ObjectUtils.setRotationWorldQuat(object, currentRotationQuat);
  };
}();
function rotateLocal(object, rotation) {
  ObjectUtils.rotateLocalDegrees(object, rotation);
}
var rotateLocalDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateLocalDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateLocalQuat(object, rotationQuat);
  };
}();
var rotateLocalRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateLocalRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateLocalDegrees(object, degreesRotation);
  };
}();
var rotateLocalMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateLocalMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateLocalQuat(object, rotationQuat);
  };
}();
var rotateLocalQuat = function() {
  let currentRotationQuat = QuatUtils.create();
  return function rotateLocalQuat2(object, rotation) {
    ObjectUtils.getRotationLocalQuat(object, currentRotationQuat);
    QuatUtils.mul(rotation, currentRotationQuat, currentRotationQuat);
    QuatUtils.normalize(currentRotationQuat, currentRotationQuat);
    ObjectUtils.setRotationLocalQuat(object, currentRotationQuat);
  };
}();
function rotateObject(object, rotation) {
  ObjectUtils.rotateObjectDegrees(object, rotation);
}
var rotateObjectDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateObjectDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateObjectQuat(object, rotationQuat);
  };
}();
var rotateObjectRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateObjectRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateObjectDegrees(object, degreesRotation);
  };
}();
var rotateObjectMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateObjectMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateObjectQuat(object, rotationQuat);
  };
}();
function rotateObjectQuat(object, rotation) {
  object.rotateObject(rotation);
}
function rotateAxis4(object, angle2, axis) {
  ObjectUtils.rotateAxisWorld(object, angle2, axis);
}
function rotateAxisDegrees4(object, angle2, axis) {
  ObjectUtils.rotateAxisWorldDegrees(object, angle2, axis);
}
function rotateAxisRadians4(object, angle2, axis) {
  ObjectUtils.rotateAxisWorldRadians(object, angle2, axis);
}
function rotateAxisWorld(object, angle2, axis) {
  ObjectUtils.rotateAxisWorldDegrees(object, angle2, axis);
}
function rotateAxisWorldDegrees(object, angle2, axis) {
  ObjectUtils.rotateAxisWorldRadians(object, MathUtils.toRadians(angle2), axis);
}
var rotateAxisWorldRadians = function() {
  let rotation = QuatUtils.create();
  return function rotateAxisWorldRadians2(object, angle2, axis) {
    QuatUtils.fromAxisRadians(angle2, axis, rotation);
    ObjectUtils.rotateWorldQuat(object, rotation);
  };
}();
function rotateAxisLocal(object, angle2, axis) {
  ObjectUtils.rotateAxisLocalDegrees(object, angle2, axis);
}
function rotateAxisLocalDegrees(object, angle2, axis) {
  ObjectUtils.rotateAxisLocalRadians(object, MathUtils.toRadians(angle2), axis);
}
var rotateAxisLocalRadians = function() {
  let rotation = QuatUtils.create();
  return function rotateAxisLocalRadians2(object, angle2, axis) {
    QuatUtils.fromAxisRadians(angle2, axis, rotation);
    ObjectUtils.rotateLocalQuat(object, rotation);
  };
}();
function rotateAxisObject(object, angle2, axis) {
  ObjectUtils.rotateAxisObjectDegrees(object, angle2, axis);
}
function rotateAxisObjectDegrees(object, angle2, axis) {
  ObjectUtils.rotateAxisObjectRadians(object, MathUtils.toRadians(angle2), axis);
}
var rotateAxisObjectRadians = function() {
  let rotation = QuatUtils.create();
  return function rotateAxisObjectRadians2(object, angle2, axis) {
    QuatUtils.fromAxisRadians(angle2, axis, rotation);
    ObjectUtils.rotateObjectQuat(object, rotation);
  };
}();
function rotateAround2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorld(object, rotation, origin);
}
function rotateAroundDegrees2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldDegrees(object, rotation, origin);
}
function rotateAroundRadians2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldRadians(object, rotation, origin);
}
function rotateAroundMatrix(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldMatrix(object, rotation, origin);
}
function rotateAroundQuat2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldQuat(object, rotation, origin);
}
function rotateAroundWorld(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldDegrees(object, rotation, origin);
}
var rotateAroundWorldDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundWorldDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateAroundWorldQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundWorldRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateAroundWorldRadians2(object, rotation, origin) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateAroundWorldDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundWorldMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundWorldMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateAroundWorldQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundWorldQuat = function() {
  let axis = Vec3Utils.create();
  return function rotateAroundWorldQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    let angle2 = QuatUtils.getAngleRadians(rotation);
    ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, axis, origin);
  };
}();
function rotateAroundLocal(object, rotation, origin) {
  ObjectUtils.rotateAroundLocalDegrees(object, rotation, origin);
}
var rotateAroundLocalDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundLocalDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateAroundLocalQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundLocalRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateAroundLocalRadians2(object, rotation, origin) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateAroundLocalDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundLocalMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundLocalMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateAroundLocalQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundLocalQuat = function() {
  let axis = Vec3Utils.create();
  return function rotateAroundLocalQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    let angle2 = QuatUtils.getAngleRadians(rotation);
    ObjectUtils.rotateAroundAxisLocalRadians(object, angle2, axis, origin);
  };
}();
function rotateAroundObject(object, rotation, origin) {
  ObjectUtils.rotateAroundObjectDegrees(object, rotation, origin);
}
var rotateAroundObjectDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundObjectDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateAroundObjectQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundObjectRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateAroundObjectRadians2(object, rotation, origin) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateAroundObjectDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundObjectMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundObjectMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateAroundObjectQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundObjectQuat = function() {
  let axis = Vec3Utils.create();
  return function rotateAroundObjectQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    let angle2 = QuatUtils.getAngleRadians(rotation);
    ObjectUtils.rotateAroundAxisObjectRadians(object, angle2, axis, origin);
  };
}();
function rotateAroundAxis2(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisWorld(object, angle2, axis, origin);
}
function rotateAroundAxisDegrees2(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisRadians2(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, axis, origin);
}
function rotateAroundAxisWorld(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisWorldDegrees(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldRadians(object, MathUtils.toRadians(angle2), axis, origin);
}
var rotateAroundAxisWorldRadians = function() {
  let transformToRotate = Quat2Utils.create();
  let transformToRotateConjugate = Quat2Utils.create();
  let transformQuat2 = Quat2Utils.create();
  let defaultQuat = QuatUtils.create();
  return function rotateAroundAxisWorldRadians2(object, angle2, axis, origin) {
    Quat2Utils.setPositionRotationQuat(transformToRotate, origin, defaultQuat);
    ObjectUtils.getTransformWorldQuat(object, transformQuat2);
    Quat2Utils.conjugate(transformToRotate, transformToRotateConjugate);
    Quat2Utils.mul(transformToRotateConjugate, transformQuat2, transformQuat2);
    Quat2Utils.rotateAxisRadians(transformToRotate, angle2, axis, transformToRotate);
    Quat2Utils.mul(transformToRotate, transformQuat2, transformQuat2);
    ObjectUtils.setTransformWorldQuat(object, transformQuat2);
  };
}();
function rotateAroundAxisLocal(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisLocalDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisLocalDegrees(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisLocalRadians(object, MathUtils.toRadians(angle2), axis, origin);
}
var rotateAroundAxisLocalRadians = function() {
  let convertedPosition = Vec3Utils.create();
  let convertedAxis = Vec3Utils.create();
  return function rotateAroundAxisLocalRadians2(object, angle2, axis, origin) {
    ObjectUtils.convertPositionLocalToWorld(object, origin, convertedPosition);
    ObjectUtils.convertDirectionLocalToWorld(object, axis, convertedAxis);
    ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, convertedAxis, convertedPosition);
  };
}();
function rotateAroundAxisObject(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisObjectDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisObjectDegrees(object, angle2, axis, origin) {
  ObjectUtils.rotateAroundAxisObjectRadians(object, MathUtils.toRadians(angle2), axis, origin);
}
var rotateAroundAxisObjectRadians = function() {
  let convertedPosition = Vec3Utils.create();
  let convertedAxis = Vec3Utils.create();
  return function rotateAroundAxisObjectRadians2(object, angle2, axis, origin) {
    ObjectUtils.convertPositionObjectToWorld(object, origin, convertedPosition);
    ObjectUtils.convertDirectionObjectToWorld(object, axis, convertedAxis);
    ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, convertedAxis, convertedPosition);
  };
}();
var scaleObject = function() {
  let vector = Vec3Utils.create();
  return function scaleObject2(object, scale4) {
    if (isNaN(scale4)) {
      object.scale(scale4);
    } else {
      Vec3Utils.set(vector, scale4);
      object.scale(vector);
    }
  };
}();
function lookAt(object, position, up) {
  ObjectUtils.lookAtWorld(object, position, up);
}
var lookAtWorld = function() {
  let direction = Vec3Utils.create();
  return function lookAtWorld2(object, position, up) {
    ObjectUtils.getPositionWorld(object, direction);
    Vec3Utils.sub(position, direction, direction);
    ObjectUtils.lookToWorld(object, direction, up);
  };
}();
var lookAtLocal = function() {
  let direction = Vec3Utils.create();
  return function lookAtLocal2(object, position, up) {
    ObjectUtils.getPositionLocal(object, direction);
    Vec3Utils.sub(position, direction, direction);
    ObjectUtils.lookToLocal(object, direction, up);
  };
}();
function lookTo(object, direction, up) {
  ObjectUtils.lookToWorld(object, direction, up);
}
var lookToWorld = function() {
  let internalUp = Vec3Utils.create();
  return function lookToWorld2(object, direction, up = ObjectUtils.getUpWorld(object, internalUp)) {
    ObjectUtils.setForwardWorld(object, direction, up);
  };
}();
var lookToLocal = function() {
  let internalUp = Vec3Utils.create();
  return function lookToLocal2(object, direction, up = ObjectUtils.getUpLocal(object, internalUp)) {
    ObjectUtils.setForwardLocal(object, direction, up);
  };
}();
var setParent = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  let scale4 = Vec3Utils.create();
  return function setParent2(object, newParent, keepTransformWorld = true) {
    if (!keepTransformWorld) {
      object.parent = newParent;
    } else {
      ObjectUtils.getPositionWorld(object, position);
      ObjectUtils.getRotationWorldQuat(object, rotation);
      ObjectUtils.getScaleWorld(object, scale4);
      object.parent = newParent;
      ObjectUtils.setScaleWorld(object, scale4);
      ObjectUtils.setRotationWorldQuat(object, rotation);
      ObjectUtils.setPositionWorld(object, position);
    }
  };
}();
function getParent(object) {
  return object.parent;
}
var convertPositionObjectToWorld = function() {
  let matrix = Mat4Utils.create();
  return function convertPositionObjectToWorld2(object, position, resultPosition = Vec3Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, matrix);
    Vec3Utils.transformMat4(position, matrix, resultPosition);
    return resultPosition;
  };
}();
var convertDirectionObjectToWorld = function() {
  let rotation = QuatUtils.create();
  return function convertDirectionObjectToWorld2(object, direction, resultDirection = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    Vec3Utils.transformQuat(direction, rotation, resultDirection);
    return resultDirection;
  };
}();
var convertPositionWorldToObject = function() {
  let matrix = Mat4Utils.create();
  return function convertPositionWorldToObject2(object, position, resultPosition = Vec3Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, matrix);
    Mat4Utils.invert(matrix, matrix);
    Vec3Utils.transformMat4(position, matrix, resultPosition);
    return resultPosition;
  };
}();
var convertDirectionWorldToObject = function() {
  let rotation = QuatUtils.create();
  return function convertDirectionWorldToObject2(object, direction, resultDirection = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(direction, rotation, resultDirection);
    return resultDirection;
  };
}();
function convertPositionLocalToWorld(object, position, resultPosition = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertPositionObjectToWorld(ObjectUtils.getParent(object), position, resultPosition);
  } else {
    Vec3Utils.copy(position, resultPosition);
  }
  return resultPosition;
}
function convertDirectionLocalToWorld(object, direction, resultDirection = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertDirectionObjectToWorld(ObjectUtils.getParent(object), direction, resultDirection);
  } else {
    Vec3Utils.copy(direction, resultDirection);
  }
  return resultDirection;
}
function convertPositionWorldToLocal(object, position, resultPosition = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertPositionWorldToObject(ObjectUtils.getParent(object), position, resultPosition);
  } else {
    Vec3Utils.copy(position, resultPosition);
  }
  return resultPosition;
}
function convertDirectionWorldToLocal(object, direction, resultDirection = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertDirectionWorldToObject(ObjectUtils.getParent(object), direction, resultDirection);
  } else {
    Vec3Utils.copy(direction, resultDirection);
  }
  return resultDirection;
}
function convertPositionObjectToLocal(object, position, resultPosition = Vec3Utils.create()) {
  ObjectUtils.convertPositionObjectToWorld(object, position, resultPosition);
  ObjectUtils.convertPositionWorldToLocal(object, resultPosition, resultPosition);
  return resultPosition;
}
function convertDirectionObjectToLocal(object, direction, resultDirection = Vec3Utils.create()) {
  ObjectUtils.convertDirectionObjectToWorld(object, direction, resultDirection);
  ObjectUtils.convertDirectionWorldToLocal(object, resultDirection, resultDirection);
  return resultDirection;
}
function convertPositionLocalToObject(object, position, resultPosition = Vec3Utils.create()) {
  ObjectUtils.convertPositionLocalToWorld(object, position, resultPosition);
  ObjectUtils.convertPositionWorldToObject(object, resultPosition, resultPosition);
  return resultPosition;
}
function convertDirectionLocalToObject(object, direction, resultDirection = Vec3Utils.create()) {
  ObjectUtils.convertDirectionLocalToWorld(object, direction, resultDirection);
  ObjectUtils.convertDirectionWorldToObject(object, resultDirection, resultDirection);
  return resultDirection;
}
function convertTransformObjectToWorld(object, transform, resultTransform) {
  return ObjectUtils.convertTransformObjectToWorldMatrix(object, transform, resultTransform);
}
var convertTransformObjectToWorldMatrix = function() {
  let convertTransform = Mat4Utils.create();
  let position = Vec3Utils.create();
  let scale4 = Vec3Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function convertTransformObjectToWorldMatrix2(object, transform, resultTransform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, convertTransform);
    if (ObjectUtils.hasUniformScaleWorld(object)) {
      Mat4Utils.mul(convertTransform, transform, resultTransform);
    } else {
      Vec3Utils.set(position, transform[12], transform[13], transform[14]);
      ObjectUtils.convertPositionObjectToWorld(object, position, position);
      Mat4Utils.getScale(convertTransform, scale4);
      Vec3Utils.div(one, scale4, inverseScale);
      Mat4Utils.scale(convertTransform, inverseScale, convertTransform);
      Mat4Utils.mul(convertTransform, transform, resultTransform);
      Mat4Utils.scale(resultTransform, scale4, resultTransform);
      resultTransform[12] = position[0];
      resultTransform[13] = position[1];
      resultTransform[14] = position[2];
      resultTransform[15] = 1;
    }
    return resultTransform;
  };
}();
var convertTransformObjectToWorldQuat = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  return function convertTransformObjectToWorldQuat2(object, transform, resultTransform = Quat2Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.mul(rotation, transform, rotation);
    Quat2Utils.getPosition(transform, position);
    ObjectUtils.convertPositionObjectToWorld(object, position, position);
    Quat2Utils.setPositionRotationQuat(resultTransform, position, rotation);
    return resultTransform;
  };
}();
function convertTransformWorldToObject(object, transform, resultTransform) {
  return ObjectUtils.convertTransformWorldToObjectMatrix(object, transform, resultTransform);
}
var convertTransformWorldToObjectMatrix = function() {
  let convertTransform = Mat4Utils.create();
  let position = Vec3Utils.create();
  let scale4 = Vec3Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function convertTransformWorldToObjectMatrix2(object, transform, resultTransform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, convertTransform);
    if (ObjectUtils.hasUniformScaleWorld(object)) {
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, transform, resultTransform);
    } else {
      Vec3Utils.set(position, transform[12], transform[13], transform[14]);
      ObjectUtils.convertPositionWorldToObject(object, position, position);
      Mat4Utils.getScale(convertTransform, scale4);
      Vec3Utils.div(one, scale4, inverseScale);
      Mat4Utils.scale(convertTransform, inverseScale, convertTransform);
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, transform, resultTransform);
      Mat4Utils.scale(resultTransform, inverseScale, resultTransform);
      resultTransform[12] = position[0];
      resultTransform[13] = position[1];
      resultTransform[14] = position[2];
      resultTransform[15] = 1;
    }
    return resultTransform;
  };
}();
var convertTransformWorldToObjectQuat = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  return function convertTransformWorldToObjectQuat2(object, transform, resultTransform = Quat2Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.conjugate(rotation, rotation);
    QuatUtils.mul(rotation, transform, rotation);
    Quat2Utils.getPosition(transform, position);
    ObjectUtils.convertPositionWorldToObject(object, position, position);
    Quat2Utils.setPositionRotationQuat(resultTransform, position, rotation);
    return resultTransform;
  };
}();
function convertTransformLocalToWorld(object, transform, resultTransform) {
  return ObjectUtils.convertTransformLocalToWorldMatrix(object, transform, resultTransform);
}
function convertTransformLocalToWorldMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformObjectToWorldMatrix(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Mat4Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformLocalToWorldQuat(object, transform, resultTransform = Quat2Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformObjectToWorldQuat(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Quat2Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformWorldToLocal(object, transform, resultTransform) {
  return ObjectUtils.convertTransformWorldToLocalMatrix(object, transform, resultTransform);
}
function convertTransformWorldToLocalMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformWorldToObjectMatrix(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Mat4Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformWorldToLocalQuat(object, transform, resultTransform = Quat2Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformWorldToObjectQuat(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Quat2Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformObjectToLocal(object, transform, resultTransform) {
  return ObjectUtils.convertTransformObjectToLocalMatrix(object, transform, resultTransform);
}
function convertTransformObjectToLocalMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  ObjectUtils.convertTransformObjectToWorldMatrix(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToLocalMatrix(object, resultTransform, resultTransform);
  return resultTransform;
}
function convertTransformObjectToLocalQuat(object, transform, resultTransform = Quat2Utils.create()) {
  ObjectUtils.convertTransformObjectToWorldQuat(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToLocalQuat(object, resultTransform, resultTransform);
  return resultTransform;
}
function convertTransformLocalToObject(object, transform, resultTransform) {
  return ObjectUtils.convertTransformLocalToObjectMatrix(object, transform, resultTransform);
}
function convertTransformLocalToObjectMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  ObjectUtils.convertTransformLocalToWorldMatrix(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToObjectMatrix(object, resultTransform, resultTransform);
  return resultTransform;
}
function convertTransformLocalToObjectQuat(object, transform, resultTransform = Quat2Utils.create()) {
  ObjectUtils.convertTransformLocalToWorldQuat(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToObjectQuat(object, resultTransform, resultTransform);
  return resultTransform;
}
function addComponent(object, typeOrClass, paramsOrActive, active = null) {
  let params = null;
  if (typeof paramsOrActive == "boolean") {
    params = {};
    params["active"] = paramsOrActive;
  } else {
    params = paramsOrActive;
    if (active != null) {
      if (params == null) {
        params = {};
      }
      params["active"] = active;
    }
  }
  return object.addComponent(typeOrClass, params);
}
function getComponent(object, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchy(object, typeOrClass, index);
}
function getComponentSelf(object, typeOrClass, index = 0) {
  return object.getComponent(typeOrClass, index);
}
function getComponentHierarchy(object, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchyBreadth(object, typeOrClass, index);
}
function getComponentHierarchyBreadth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentHierarchyDepth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentDescendants(object, typeOrClass, index = 0) {
  return ObjectUtils.getComponentDescendantsBreadth(object, typeOrClass, index);
}
function getComponentDescendantsBreadth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentDescendantsDepth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentChildren(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponents(object, typeOrClass) {
  return ObjectUtils.getComponentsHierarchy(object, typeOrClass);
}
function getComponentsSelf(object, typeOrClass) {
  return object.getComponents(typeOrClass);
}
function getComponentsHierarchy(object, typeOrClass) {
  return ObjectUtils.getComponentsHierarchyBreadth(object, typeOrClass);
}
function getComponentsHierarchyBreadth(object, typeOrClass) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsHierarchyDepth(object, typeOrClass) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsDescendants(object, typeOrClass) {
  return ObjectUtils.getComponentsDescendantsBreadth(object, typeOrClass);
}
function getComponentsDescendantsBreadth(object, typeOrClass) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsDescendantsDepth(object, typeOrClass) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsChildren(object, typeOrClass) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function setActive(object, active) {
  ObjectUtils.setActiveHierarchy(object, active);
}
function setActiveSelf(object, active) {
  object.active = active;
}
function setActiveHierarchy(object, active) {
  ObjectUtils.setActiveHierarchyBreadth(object, active);
}
function setActiveHierarchyBreadth(object, active) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveHierarchyDepth(object, active) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveDescendants(object, active) {
  ObjectUtils.setActiveDescendantsBreadth(object, active);
}
function setActiveDescendantsBreadth(object, active) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveDescendantsDepth(object, active) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveChildren(object, active) {
  let objects = ObjectUtils.getChildren(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function hasUniformScale2(object) {
  return ObjectUtils.hasUniformScaleWorld(object);
}
var hasUniformScaleWorld = function() {
  let scale4 = Vec3Utils.create();
  return function hasUniformScaleWorld2(object) {
    ObjectUtils.getScaleWorld(object, scale4);
    return Math.abs(scale4[0] - scale4[1]) < MathUtils.EPSILON && Math.abs(scale4[1] - scale4[2]) < MathUtils.EPSILON && Math.abs(scale4[0] - scale4[2]) < MathUtils.EPSILON;
  };
}();
var hasUniformScaleLocal = function() {
  let scale4 = Vec3Utils.create();
  return function hasUniformScaleLocal2(object) {
    ObjectUtils.getScaleLocal(object, scale4);
    return Math.abs(scale4[0] - scale4[1]) < MathUtils.EPSILON && Math.abs(scale4[1] - scale4[2]) < MathUtils.EPSILON && Math.abs(scale4[0] - scale4[2]) < MathUtils.EPSILON;
  };
}();
var clone5 = function() {
  let scale4 = Vec3Utils.create();
  let transformQuat2 = Quat2Utils.create();
  return function clone10(object, cloneParams = new CloneParams()) {
    let clonedObject = null;
    let cloneParent = cloneParams.myCloneParent === void 0 ? ObjectUtils.getParent(object) : cloneParams.myCloneParent;
    if (cloneParams.myUseDefaultObjectClone) {
      clonedObject = object.clone(cloneParent);
      if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive) {
        let clonedComponents = clonedObject.pp_getComponents();
        for (let clonedComponent of clonedComponents) {
          if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive && !clonedComponent.active) {
            clonedComponent.active = true;
            clonedComponent.active = false;
          }
        }
      }
    } else if (ObjectUtils.isCloneable(object, cloneParams)) {
      let objectsToCloneData = [];
      objectsToCloneData.push([cloneParent, object]);
      let objectsToCloneComponentsData = [];
      while (objectsToCloneData.length > 0) {
        let cloneData = objectsToCloneData.shift();
        let parent = cloneData[0];
        let objectToClone = cloneData[1];
        let currentClonedObject = parent != null ? ObjectUtils.addObject(parent) : SceneUtils.addObject(Globals.getScene(ObjectUtils.getEngine(object)));
        ObjectUtils.setName(currentClonedObject, ObjectUtils.getName(objectToClone));
        ObjectUtils.setScaleLocal(currentClonedObject, ObjectUtils.getScaleLocal(objectToClone, scale4));
        ObjectUtils.setTransformLocalQuat(currentClonedObject, ObjectUtils.getTransformLocalQuat(objectToClone, transformQuat2));
        if (!cloneParams.myIgnoreComponents) {
          objectsToCloneComponentsData.push([objectToClone, currentClonedObject]);
        }
        if (!cloneParams.myIgnoreDescendants) {
          for (let child of ObjectUtils.getChildren(objectToClone)) {
            let cloneDescendant = false;
            if (cloneParams.myDescendantsToInclude.length > 0) {
              cloneDescendant = cloneParams.myDescendantsToInclude.find((descendantToInclude) => ObjectUtils.equals(descendantToInclude, child)) != null;
            } else {
              cloneDescendant = cloneParams.myDescendantsToIgnore.find((descendantToIgnore) => ObjectUtils.equals(descendantToIgnore, child)) == null;
            }
            if (cloneDescendant && cloneParams.myIgnoreDescendantCallback != null) {
              cloneDescendant = !cloneParams.myIgnoreDescendantCallback(child);
            }
            if (cloneDescendant) {
              objectsToCloneData.push([currentClonedObject, child]);
            }
          }
        }
        if (clonedObject == null) {
          clonedObject = currentClonedObject;
        }
      }
      let componentsToCloneData = [];
      while (objectsToCloneComponentsData.length > 0) {
        let cloneData = objectsToCloneComponentsData.shift();
        let objectToClone = cloneData[0];
        let currentClonedObject = cloneData[1];
        let components = ObjectUtils.getComponentsSelf(objectToClone);
        for (let component of components) {
          if (ComponentUtils.isCloneable(component.type, cloneParams.myUseDefaultComponentClone || cloneParams.myUseDefaultComponentCloneAsFallback, ObjectUtils.getEngine(object))) {
            let cloneComponent = false;
            if (cloneParams.myComponentsToInclude.length > 0) {
              cloneComponent = cloneParams.myComponentsToInclude.indexOf(component.type) != -1;
            } else {
              cloneComponent = cloneParams.myComponentsToIgnore.indexOf(component.type) == -1;
            }
            if (cloneComponent && cloneParams.myIgnoreComponentCallback != null) {
              cloneComponent = !cloneParams.myIgnoreComponentCallback(component);
            }
            if (cloneComponent) {
              componentsToCloneData.push([component, currentClonedObject]);
            }
          }
        }
      }
      let componentsToPostProcessData = [];
      while (componentsToCloneData.length > 0) {
        let cloneData = componentsToCloneData.shift();
        let componentToClone = cloneData[0];
        let currentClonedObject = cloneData[1];
        let clonedComponent = null;
        if (!cloneParams.myUseDefaultComponentClone) {
          clonedComponent = ComponentUtils.clone(componentToClone, currentClonedObject, cloneParams.myComponentDeepCloneParams, cloneParams.myComponentCustomCloneParams, cloneParams.myUseDefaultComponentCloneAsFallback, cloneParams.myDefaultComponentCloneAutoStartIfNotActive);
        } else {
          clonedComponent = ComponentUtils.cloneDefault(componentToClone, currentClonedObject, cloneParams.myDefaultComponentCloneAutoStartIfNotActive);
        }
        if (clonedComponent != null) {
          if (ComponentUtils.hasClonePostProcess(componentToClone.type, ObjectUtils.getEngine(object))) {
            componentsToPostProcessData.push([componentToClone, clonedComponent]);
          }
        }
      }
      while (componentsToPostProcessData.length > 0) {
        let cloneData = componentsToPostProcessData.shift();
        let componentToClone = cloneData[0];
        let currentClonedComponent = cloneData[1];
        ComponentUtils.clonePostProcess(componentToClone, currentClonedComponent, cloneParams.myComponentDeepCloneParams, cloneParams.myComponentCustomCloneParams);
      }
    } else if (cloneParams.myUseDefaultObjectCloneAsFallback) {
      clonedObject = object.clone(cloneParent);
      if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive) {
        let clonedComponents = clonedObject.pp_getComponents();
        for (let clonedComponent of clonedComponents) {
          if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive && !clonedComponent.active) {
            clonedComponent.active = true;
            clonedComponent.active = false;
          }
        }
      }
    }
    return clonedObject;
  };
}();
function isCloneable(object, cloneParams = new CloneParams()) {
  if (cloneParams.myIgnoreNonCloneable || cloneParams.myIgnoreComponents || cloneParams.myUseDefaultComponentClone || cloneParams.myUseDefaultComponentCloneAsFallback) {
    return true;
  }
  let cloneable = true;
  let objectsToClone = [];
  objectsToClone.push(object);
  while (cloneable && objectsToClone.length > 0) {
    let objectToClone = objectsToClone.shift();
    let components = ObjectUtils.getComponentsSelf(objectToClone);
    for (let component of components) {
      let cloneComponent = false;
      if (cloneParams.myComponentsToInclude.length > 0) {
        cloneComponent = cloneParams.myComponentsToInclude.indexOf(component.type) != -1;
      } else {
        cloneComponent = cloneParams.myComponentsToIgnore.indexOf(component.type) == -1;
      }
      if (cloneComponent && cloneParams.myIgnoreComponentCallback != null) {
        cloneComponent = !cloneParams.myIgnoreComponentCallback(component);
      }
      if (cloneComponent && !ComponentUtils.isCloneable(component.type, false, ObjectUtils.getEngine(object))) {
        cloneable = false;
        break;
      }
    }
    if (cloneable && !cloneParams.myIgnoreDescendants) {
      for (let child of ObjectUtils.getChildren(objectToClone)) {
        let cloneDescendant = false;
        if (cloneParams.myDescendantsToInclude.length > 0) {
          cloneDescendant = cloneParams.myDescendantsToInclude.find((descendantToInclude) => ObjectUtils.equals(descendantToInclude, child)) != null;
        } else {
          cloneDescendant = cloneParams.myDescendantsToIgnore.find((descendantToInclude) => ObjectUtils.equals(descendantToInclude, child)) == null;
        }
        if (cloneDescendant && cloneParams.myIgnoreDescendantCallback != null) {
          cloneDescendant = !cloneParams.myIgnoreDescendantCallback(child);
        }
        if (cloneDescendant) {
          objectsToClone.push(child);
        }
      }
    }
  }
  return cloneable;
}
function toString(object) {
  return ObjectUtils.toStringCompact(object);
}
var toStringExtended = function() {
  let tab = "    ";
  let newLine = "\n";
  let startObject = "{";
  let endObject = "}";
  let nameLabel = "name: ";
  let idLabel = "id: ";
  let componentsLabel = "components: ";
  let typeLabel = "type: ";
  let childrenLabel = "children: ";
  let startComponents = "[";
  let endComponents = "]";
  let startChildren = startComponents;
  let endChildren = endComponents;
  let separator = ",";
  let newLineTab = newLine.concat(tab, tab);
  return function toStringExtended3(object) {
    let objectString = "";
    objectString = objectString.concat(startObject, newLine);
    let components = ObjectUtils.getComponentsSelf(object);
    let children = ObjectUtils.getChildren(object);
    let name = ObjectUtils.getName(object);
    if (components.length > 0 || children.length > 0 || name.length > 0) {
      objectString = objectString.concat(tab, idLabel, ObjectUtils.getID(object), separator, newLine);
    } else {
      objectString = objectString.concat(tab, idLabel, ObjectUtils.getID(object), newLine);
    }
    if (name.length > 0) {
      if (components.length > 0 || children.length > 0) {
        objectString = objectString.concat(tab, nameLabel, ObjectUtils.getName(object), separator, newLine);
      } else {
        objectString = objectString.concat(tab, nameLabel, ObjectUtils.getName(object), newLine);
      }
    }
    if (components.length > 0) {
      objectString = objectString.concat(tab, componentsLabel, newLine, tab, startComponents, newLine);
      for (let i = 0; i < components.length; i++) {
        let component = components[i];
        objectString = objectString.concat(tab, tab, startObject, newLine);
        objectString = objectString.concat(tab, tab, tab, typeLabel, component.type, separator, newLine);
        objectString = objectString.concat(tab, tab, tab, idLabel, component._id, separator, newLine);
        objectString = objectString.concat(tab, tab, endObject);
        if (i != components.length - 1) {
          objectString = objectString.concat(separator, newLine);
        } else {
          objectString = objectString.concat(newLine);
        }
      }
      if (children.length > 0) {
        objectString = objectString.concat(tab, endComponents, separator, newLine);
      } else {
        objectString = objectString.concat(tab, endComponents, newLine);
      }
    }
    if (children.length > 0) {
      objectString = objectString.concat(tab, childrenLabel, newLine, tab, startChildren, newLine);
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        let childString = ObjectUtils.toStringExtended(child);
        childString = childString.replaceAll(newLine, newLineTab);
        childString = tab.concat(tab, childString);
        objectString = objectString.concat(childString);
        if (i != children.length - 1) {
          objectString = objectString.concat(separator, newLine);
        } else {
          objectString = objectString.concat(newLine);
        }
      }
      objectString = objectString.concat(tab, endChildren, newLine);
    }
    objectString = objectString.concat(endObject);
    return objectString;
  };
}();
var toStringCompact = function() {
  let tab = "    ";
  let newLine = "\n";
  let emptyName = "<none>";
  let nameLabel = "name: ";
  let componentsLabel = "components: ";
  let separator = ", ";
  let newLineTab = newLine.concat(tab);
  return function toStringCompact3(object) {
    let objectString = "";
    let name = ObjectUtils.getName(object);
    if (name.length > 0) {
      objectString = objectString.concat(nameLabel, name);
    } else {
      objectString = objectString.concat(nameLabel, emptyName);
    }
    let components = ObjectUtils.getComponentsSelf(object);
    if (components.length > 0) {
      objectString = objectString.concat(separator, componentsLabel);
      for (let i = 0; i < components.length; i++) {
        let component = components[i];
        objectString = objectString.concat(component.type);
        if (i != components.length - 1) {
          objectString = objectString.concat(separator);
        }
      }
    }
    let children = ObjectUtils.getChildren(object);
    if (children.length > 0) {
      objectString = objectString.concat(newLine);
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        let childString = ObjectUtils.toStringCompact(child);
        childString = childString.replaceAll(newLine, newLineTab);
        childString = tab.concat(childString);
        objectString = objectString.concat(childString);
        if (i != children.length - 1) {
          objectString = objectString.concat(newLine);
        }
      }
    }
    return objectString;
  };
}();
function getObjectByName(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchy(object, name, isRegex, index);
}
function getObjectByNameHierarchy(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyBreadth(object, name, isRegex, index);
}
function getObjectByNameHierarchyBreadth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameHierarchyDepth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameDescendants(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameDescendantsBreadth(object, name, isRegex, index);
}
function getObjectByNameDescendantsBreadth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameDescendantsDepth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameChildren(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectsByName(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchy(object, name, isRegex);
}
function getObjectsByNameHierarchy(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyBreadth(object, name, isRegex);
}
function getObjectsByNameHierarchyBreadth(object, name, isRegex = false) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameHierarchyDepth(object, name, isRegex = false) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameDescendants(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameDescendantsBreadth(object, name, isRegex);
}
function getObjectsByNameDescendantsBreadth(object, name, isRegex = false) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameDescendantsDepth(object, name, isRegex = false) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameChildren(object, name, isRegex = false) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectByID(object, id) {
  return ObjectUtils.getObjectByIDHierarchy(object, id);
}
function getObjectByIDHierarchy(object, id) {
  return ObjectUtils.getObjectByIDHierarchyBreadth(object, id);
}
function getObjectByIDHierarchyBreadth(object, id) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDHierarchyDepth(object, id) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDDescendants(object, id) {
  return ObjectUtils.getObjectByIDDescendantsBreadth(object, id);
}
function getObjectByIDDescendantsBreadth(object, id) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDDescendantsDepth(object, id) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDChildren(object, id) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getHierarchy(object) {
  return ObjectUtils.getHierarchyBreadth(object);
}
function getHierarchyBreadth(object) {
  let hierarchy = ObjectUtils.getDescendantsBreadth(object);
  hierarchy.unshift(object);
  return hierarchy;
}
function getHierarchyDepth(object) {
  let hierarchy = ObjectUtils.getDescendantsDepth(object);
  hierarchy.unshift(object);
  return hierarchy;
}
function getDescendants(object) {
  return ObjectUtils.getDescendantsBreadth(object);
}
function getDescendantsBreadth(object) {
  let descendants = [];
  let descendantsQueue = ObjectUtils.getChildren(object);
  while (descendantsQueue.length > 0) {
    let descendant = descendantsQueue.shift();
    descendants.push(descendant);
    for (let child of ObjectUtils.getChildren(descendant)) {
      descendantsQueue.push(child);
    }
  }
  return descendants;
}
function getDescendantsDepth(object) {
  let descendants = [];
  let children = ObjectUtils.getChildren(object);
  for (let child of children) {
    descendants.push(child);
    let childDescendants = ObjectUtils.getDescendantsDepth(child);
    for (let i = 0; i < childDescendants.length; i++) {
      descendants.push(childDescendants[i]);
    }
  }
  return descendants;
}
function getChildren(object) {
  return object.children;
}
function getSelf(object) {
  return object;
}
function addObject(object) {
  return Globals.getScene(ObjectUtils.getEngine(object)).addObject(object);
}
function getName(object) {
  return object.name;
}
function setName(object, name) {
  object.name = name;
}
function getEngine(object) {
  return object.engine;
}
function getID(object) {
  return object.objectId;
}
function markDirty(object) {
  return object.setDirty();
}
function isTransformChanged(object) {
  return object.changed;
}
function equals3(object, otherObject) {
  return object.equals(otherObject);
}
function destroy(object) {
  let destroyReturnValue = void 0;
  try {
    destroyReturnValue = object.destroy();
  } catch (error3) {
  }
  return destroyReturnValue;
}
function reserveObjects(object, count) {
  ObjectUtils.reserveObjectsHierarchy(object, count);
}
function reserveObjectsSelf(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapSelf(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function reserveObjectsHierarchy(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapHierarchy(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function reserveObjectsDescendants(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapDescendants(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function reserveObjectsChildren(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapChildren(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function getComponentsAmountMap(object, amountMap = /* @__PURE__ */ new Map()) {
  return ObjectUtils.getComponentsAmountMapHierarchy(object, amountMap);
}
function getComponentsAmountMapSelf(object, amountMap = /* @__PURE__ */ new Map()) {
  let objectsAmount = amountMap.get("object");
  if (objectsAmount == null) {
    objectsAmount = 0;
  }
  objectsAmount += 1;
  amountMap.set("object", objectsAmount);
  let components = ObjectUtils.getComponentsSelf(object);
  for (let component of components) {
    let type = component.type;
    let typeAmount = amountMap.get(type);
    if (typeAmount == null) {
      typeAmount = 0;
    }
    typeAmount += 1;
    amountMap.set(type, typeAmount);
  }
  return amountMap;
}
function getComponentsAmountMapHierarchy(object, amountMap = /* @__PURE__ */ new Map()) {
  let hierarchy = ObjectUtils.getHierarchy(object);
  for (let hierarchyObject of hierarchy) {
    ObjectUtils.getComponentsAmountMapSelf(hierarchyObject, amountMap);
  }
  return amountMap;
}
function getComponentsAmountMapDescendants(object, amountMap = /* @__PURE__ */ new Map()) {
  let descendants = ObjectUtils.getDescendants(object);
  for (let descendant of descendants) {
    ObjectUtils.getComponentsAmountMapSelf(descendant, amountMap);
  }
  return amountMap;
}
function getComponentsAmountMapChildren(object, amountMap = /* @__PURE__ */ new Map()) {
  let children = ObjectUtils.getChildren(object);
  for (let child of children) {
    ObjectUtils.getComponentsAmountMapSelf(child, amountMap);
  }
  return amountMap;
}
function getComponentObjects(objects, typeOrClass, index = 0) {
  let component = null;
  for (let object of objects) {
    component = object.getComponent(typeOrClass, index);
    if (component != null) {
      break;
    }
  }
  return component;
}
function getComponentsObjects(objects, typeOrClass) {
  let components = [];
  for (let currentObject of objects) {
    let currentObjectComponents = currentObject.getComponents(typeOrClass);
    for (let i = 0; i < currentObjectComponents.length; i++) {
      components.push(currentObjectComponents[i]);
    }
  }
  return components;
}
function setActiveObjects(objects, active) {
  for (let currentObject of objects) {
    currentObject.active = active;
  }
}
function getObjectByNameObjects(objects, name, isRegex = false, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (let currentObject of objects) {
    let objectName = ObjectUtils.getName(currentObject);
    if (!isRegex && objectName == name || isRegex && objectName.match(name) != null) {
      if (currentIndex == 0) {
        objectFound = currentObject;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByNameObjects(objects, name, isRegex = false) {
  let objectsFound = [];
  for (let currentObject of objects) {
    let objectName = ObjectUtils.getName(currentObject);
    if (!isRegex && objectName == name || isRegex && objectName.match(name) != null) {
      objectsFound.push(currentObject);
    }
  }
  return objectsFound;
}
function getObjectByIDObjects(objects, id, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (let currentObject of objects) {
    if (ObjectUtils.getID(currentObject) == id) {
      if (currentIndex == 0) {
        objectFound = currentObject;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByIDObjects(objects, id) {
  let objectsFound = [];
  for (let currentObject of objects) {
    if (ObjectUtils.getID(currentObject) == id) {
      objectsFound.push(currentObject);
    }
  }
  return objectsFound;
}
function wrapObject(id, engine = Globals.getMainEngine()) {
  return engine.wrapObject(id);
}
var ObjectUtils = {
  getPosition: getPosition3,
  getPositionWorld,
  getPositionLocal,
  getRotation: getRotation3,
  getRotationDegrees: getRotationDegrees3,
  getRotationRadians: getRotationRadians3,
  getRotationMatrix,
  getRotationQuat: getRotationQuat3,
  getRotationWorld,
  getRotationWorldDegrees,
  getRotationWorldRadians,
  getRotationWorldMatrix,
  getRotationWorldQuat,
  getRotationLocal,
  getRotationLocalDegrees,
  getRotationLocalRadians,
  getRotationLocalMatrix,
  getRotationLocalQuat,
  getScale: getScale2,
  getScaleWorld,
  getScaleLocal,
  getTransform,
  getTransformMatrix,
  getTransformQuat,
  getTransformWorld,
  getTransformWorldMatrix,
  getTransformWorldQuat,
  getTransformLocal,
  getTransformLocalMatrix,
  getTransformLocalQuat,
  getAxes: getAxes4,
  getAxesWorld,
  getAxesLocal,
  getForward: getForward4,
  getForwardWorld,
  getForwardLocal,
  getBackward: getBackward4,
  getBackwardWorld,
  getBackwardLocal,
  getUp: getUp4,
  getUpWorld,
  getUpLocal,
  getDown: getDown4,
  getDownWorld,
  getDownLocal,
  getLeft: getLeft4,
  getLeftWorld,
  getLeftLocal,
  getRight: getRight4,
  getRightWorld,
  getRightLocal,
  setPosition: setPosition3,
  setPositionWorld,
  setPositionLocal,
  setRotation: setRotation3,
  setRotationDegrees: setRotationDegrees3,
  setRotationRadians: setRotationRadians3,
  setRotationMatrix,
  setRotationQuat: setRotationQuat3,
  setRotationWorld,
  setRotationWorldDegrees,
  setRotationWorldRadians,
  setRotationWorldMatrix,
  setRotationWorldQuat,
  setRotationLocal,
  setRotationLocalDegrees,
  setRotationLocalRadians,
  setRotationLocalMatrix,
  setRotationLocalQuat,
  setScale: setScale2,
  setScaleWorld,
  setScaleLocal,
  setAxes: setAxes2,
  setAxesWorld,
  setAxesLocal,
  setForward: setForward2,
  setForwardWorld,
  setForwardLocal,
  setBackward: setBackward2,
  setBackwardWorld,
  setBackwardLocal,
  setUp: setUp2,
  setUpWorld,
  setUpLocal,
  setDown: setDown2,
  setDownWorld,
  setDownLocal,
  setLeft: setLeft2,
  setLeftWorld,
  setLeftLocal,
  setRight: setRight2,
  setRightWorld,
  setRightLocal,
  setTransform,
  setTransformMatrix,
  setTransformQuat,
  setTransformWorld,
  setTransformWorldMatrix,
  setTransformWorldQuat,
  setTransformLocal,
  setTransformLocalMatrix,
  setTransformLocalQuat,
  resetPosition,
  resetPositionWorld,
  resetPositionLocal,
  resetRotation,
  resetRotationWorld,
  resetRotationLocal,
  resetScale,
  resetScaleWorld,
  resetScaleLocal,
  resetTransform,
  resetTransformWorld,
  resetTransformLocal,
  translate,
  translateWorld,
  translateLocal,
  translateObject,
  translateAxis,
  translateAxisWorld,
  translateAxisLocal,
  translateAxisObject,
  rotate: rotate3,
  rotateDegrees: rotateDegrees3,
  rotateRadians: rotateRadians3,
  rotateMatrix,
  rotateQuat: rotateQuat3,
  rotateWorld,
  rotateWorldDegrees,
  rotateWorldRadians,
  rotateWorldMatrix,
  rotateWorldQuat,
  rotateLocal,
  rotateLocalDegrees,
  rotateLocalRadians,
  rotateLocalMatrix,
  rotateLocalQuat,
  rotateObject,
  rotateObjectDegrees,
  rotateObjectRadians,
  rotateObjectMatrix,
  rotateObjectQuat,
  rotateAxis: rotateAxis4,
  rotateAxisDegrees: rotateAxisDegrees4,
  rotateAxisRadians: rotateAxisRadians4,
  rotateAxisWorld,
  rotateAxisWorldDegrees,
  rotateAxisWorldRadians,
  rotateAxisLocal,
  rotateAxisLocalDegrees,
  rotateAxisLocalRadians,
  rotateAxisObject,
  rotateAxisObjectDegrees,
  rotateAxisObjectRadians,
  rotateAround: rotateAround2,
  rotateAroundDegrees: rotateAroundDegrees2,
  rotateAroundRadians: rotateAroundRadians2,
  rotateAroundMatrix,
  rotateAroundQuat: rotateAroundQuat2,
  rotateAroundWorld,
  rotateAroundWorldDegrees,
  rotateAroundWorldRadians,
  rotateAroundWorldMatrix,
  rotateAroundWorldQuat,
  rotateAroundLocal,
  rotateAroundLocalDegrees,
  rotateAroundLocalRadians,
  rotateAroundLocalMatrix,
  rotateAroundLocalQuat,
  rotateAroundObject,
  rotateAroundObjectDegrees,
  rotateAroundObjectRadians,
  rotateAroundObjectMatrix,
  rotateAroundObjectQuat,
  rotateAroundAxis: rotateAroundAxis2,
  rotateAroundAxisDegrees: rotateAroundAxisDegrees2,
  rotateAroundAxisRadians: rotateAroundAxisRadians2,
  rotateAroundAxisWorld,
  rotateAroundAxisWorldDegrees,
  rotateAroundAxisWorldRadians,
  rotateAroundAxisLocal,
  rotateAroundAxisLocalDegrees,
  rotateAroundAxisLocalRadians,
  rotateAroundAxisObject,
  rotateAroundAxisObjectDegrees,
  rotateAroundAxisObjectRadians,
  scaleObject,
  lookAt,
  lookAtWorld,
  lookAtLocal,
  lookTo,
  lookToWorld,
  lookToLocal,
  setParent,
  getParent,
  convertPositionObjectToWorld,
  convertDirectionObjectToWorld,
  convertPositionWorldToObject,
  convertDirectionWorldToObject,
  convertPositionLocalToWorld,
  convertDirectionLocalToWorld,
  convertPositionWorldToLocal,
  convertDirectionWorldToLocal,
  convertPositionObjectToLocal,
  convertDirectionObjectToLocal,
  convertPositionLocalToObject,
  convertDirectionLocalToObject,
  convertTransformObjectToWorld,
  convertTransformObjectToWorldMatrix,
  convertTransformObjectToWorldQuat,
  convertTransformWorldToObject,
  convertTransformWorldToObjectMatrix,
  convertTransformWorldToObjectQuat,
  convertTransformLocalToWorld,
  convertTransformLocalToWorldMatrix,
  convertTransformLocalToWorldQuat,
  convertTransformWorldToLocal,
  convertTransformWorldToLocalMatrix,
  convertTransformWorldToLocalQuat,
  convertTransformObjectToLocal,
  convertTransformObjectToLocalMatrix,
  convertTransformObjectToLocalQuat,
  convertTransformLocalToObject,
  convertTransformLocalToObjectMatrix,
  convertTransformLocalToObjectQuat,
  addComponent,
  getComponent,
  getComponentSelf,
  getComponentHierarchy,
  getComponentHierarchyBreadth,
  getComponentHierarchyDepth,
  getComponentDescendants,
  getComponentDescendantsBreadth,
  getComponentDescendantsDepth,
  getComponentChildren,
  getComponents,
  getComponentsSelf,
  getComponentsHierarchy,
  getComponentsHierarchyBreadth,
  getComponentsHierarchyDepth,
  getComponentsDescendants,
  getComponentsDescendantsBreadth,
  getComponentsDescendantsDepth,
  getComponentsChildren,
  setActive,
  setActiveSelf,
  setActiveHierarchy,
  setActiveHierarchyBreadth,
  setActiveHierarchyDepth,
  setActiveDescendants,
  setActiveDescendantsBreadth,
  setActiveDescendantsDepth,
  setActiveChildren,
  hasUniformScale: hasUniformScale2,
  hasUniformScaleWorld,
  hasUniformScaleLocal,
  clone: clone5,
  isCloneable,
  toString,
  toStringExtended,
  toStringCompact,
  getObjectByName,
  getObjectByNameHierarchy,
  getObjectByNameHierarchyBreadth,
  getObjectByNameHierarchyDepth,
  getObjectByNameDescendants,
  getObjectByNameDescendantsBreadth,
  getObjectByNameDescendantsDepth,
  getObjectByNameChildren,
  getObjectsByName,
  getObjectsByNameHierarchy,
  getObjectsByNameHierarchyBreadth,
  getObjectsByNameHierarchyDepth,
  getObjectsByNameDescendants,
  getObjectsByNameDescendantsBreadth,
  getObjectsByNameDescendantsDepth,
  getObjectsByNameChildren,
  getObjectByID,
  getObjectByIDHierarchy,
  getObjectByIDHierarchyBreadth,
  getObjectByIDHierarchyDepth,
  getObjectByIDDescendants,
  getObjectByIDDescendantsBreadth,
  getObjectByIDDescendantsDepth,
  getObjectByIDChildren,
  getHierarchy,
  getHierarchyBreadth,
  getHierarchyDepth,
  getDescendants,
  getDescendantsBreadth,
  getDescendantsDepth,
  getChildren,
  getSelf,
  addObject,
  getName,
  setName,
  getEngine,
  getID,
  markDirty,
  isTransformChanged,
  equals: equals3,
  destroy,
  reserveObjects,
  reserveObjectsSelf,
  reserveObjectsHierarchy,
  reserveObjectsDescendants,
  reserveObjectsChildren,
  getComponentsAmountMap,
  getComponentsAmountMapSelf,
  getComponentsAmountMapHierarchy,
  getComponentsAmountMapDescendants,
  getComponentsAmountMapChildren,
  getComponentObjects,
  getComponentsObjects,
  setActiveObjects,
  getObjectByNameObjects,
  getObjectsByNameObjects,
  getObjectByIDObjects,
  getObjectsByIDObjects,
  wrapObject
};
function _reserveObjects(count, componentsAmountMap, scene) {
  let objectsToReserve = componentsAmountMap.get("object") * count;
  componentsAmountMap.delete("object");
  let componentsToReserve = {};
  for (let [componentName, componentCount] of componentsAmountMap.entries()) {
    componentsToReserve[componentName] = componentCount * count;
  }
  scene.reserveObjects(objectsToReserve, componentsToReserve);
}

// dist/cauldron/wl/utils/scene_utils.js
function getRoot(scene) {
  return ObjectUtils.wrapObject(0, scene.engine);
}
function addObject2(scene) {
  return ObjectUtils.addObject(SceneUtils.getRoot(scene));
}
function getObjects(scene) {
  return SceneUtils.getObjectsBreadth(scene);
}
function getObjectsBreadth(scene) {
  return ObjectUtils.getHierarchyBreadth(SceneUtils.getRoot(scene));
}
function getObjectsDepth(scene) {
  return ObjectUtils.getHierarchyDepth(SceneUtils.getRoot(scene));
}
function getComponent2(scene, typeOrClass, index = 0) {
  return SceneUtils.getComponentBreadth(scene, typeOrClass, index);
}
function getComponentBreadth(scene, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchyBreadth(SceneUtils.getRoot(scene), typeOrClass, index);
}
function getComponentDepth(scene, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchyDepth(SceneUtils.getRoot(scene), typeOrClass, index);
}
function getComponents2(scene, typeOrClass) {
  return SceneUtils.getComponentsBreadth(scene, typeOrClass);
}
function getComponentsBreadth(scene, typeOrClass) {
  return ObjectUtils.getComponentsHierarchyBreadth(SceneUtils.getRoot(scene), typeOrClass);
}
function getComponentsDepth(scene, typeOrClass) {
  return ObjectUtils.getComponentsHierarchyDepth(SceneUtils.getRoot(scene), typeOrClass);
}
function getObjectByName2(scene, name, isRegex = false, index = 0) {
  return SceneUtils.getObjectByNameBreadth(scene, name, isRegex, index);
}
function getObjectByNameBreadth(scene, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyBreadth(SceneUtils.getRoot(scene), name, isRegex, index);
}
function getObjectByNameDepth(scene, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyDepth(SceneUtils.getRoot(scene), name, isRegex, index);
}
function getObjectsByName2(scene, name, isRegex = false) {
  return SceneUtils.getObjectsByNameBreadth(scene, name, isRegex);
}
function getObjectsByNameBreadth(scene, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyBreadth(SceneUtils.getRoot(scene), name, isRegex);
}
function getObjectsByNameDepth(scene, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyDepth(SceneUtils.getRoot(scene), name, isRegex);
}
function getObjectByID2(scene, id) {
  return SceneUtils.getObjectByIDBreadth(scene, id);
}
function getObjectByIDBreadth(scene, id) {
  return ObjectUtils.getObjectByIDHierarchyBreadth(SceneUtils.getRoot(scene), id);
}
function getObjectByIDDepth(scene, id) {
  return ObjectUtils.getObjectByIDHierarchyDepth(SceneUtils.getRoot(scene), id);
}
function toString2(scene) {
  return SceneUtils.toStringCompact(scene);
}
function toStringCompact2(scene) {
  return ObjectUtils.toStringCompact(SceneUtils.getRoot(scene));
}
function toStringExtended2(scene) {
  return ObjectUtils.toStringExtended(SceneUtils.getRoot(scene));
}
function getComponentsAmountMap2(scene, amountMap = /* @__PURE__ */ new Map()) {
  return ObjectUtils.getComponentsAmountMap(SceneUtils.getRoot(scene), amountMap);
}
var SceneUtils = {
  getRoot,
  addObject: addObject2,
  getObjects,
  getObjectsBreadth,
  getObjectsDepth,
  getComponent: getComponent2,
  getComponentBreadth,
  getComponentDepth,
  getComponents: getComponents2,
  getComponentsBreadth,
  getComponentsDepth,
  getObjectByName: getObjectByName2,
  getObjectByNameBreadth,
  getObjectByNameDepth,
  getObjectsByName: getObjectsByName2,
  getObjectsByNameBreadth,
  getObjectsByNameDepth,
  getObjectByID: getObjectByID2,
  getObjectByIDBreadth,
  getObjectByIDDepth,
  toString: toString2,
  toStringCompact: toStringCompact2,
  toStringExtended: toStringExtended2,
  getComponentsAmountMap: getComponentsAmountMap2
};

// dist/cauldron/wl/engine_globals.js
var _myMainEngine = null;
var _myEngines = [];
function initEngine(engine) {
  if (engine != null) {
    addEngine(engine);
    if (getMainEngine() == null) {
      setMainEngine(engine);
    }
  }
}
function getMainEngine() {
  return _myMainEngine;
}
function setMainEngine(engine) {
  if (hasEngine(engine)) {
    _myMainEngine = engine;
  }
}
function removeMainEngine() {
  _myMainEngine = null;
}
function getEngines() {
  return _myEngines;
}
function addEngine(engine) {
  removeEngine(engine);
  _myEngines.push(engine);
}
function removeEngine(engine) {
  let index = _myEngines.indexOf(engine);
  if (index >= 0) {
    _myEngines.splice(index, 1);
    if (getMainEngine() == engine) {
      removeMainEngine();
    }
  }
}
function hasEngine(engine) {
  return _myEngines.indexOf(engine) >= 0;
}
function getScene(engine = getMainEngine()) {
  let scene = null;
  if (engine != null) {
    scene = engine.scene;
  }
  return scene;
}
function getRoot2(engine = getMainEngine()) {
  let root = null;
  let scene = getScene(engine);
  if (scene != null) {
    root = SceneUtils.getRoot(scene);
  }
  return root;
}
function getPhysics(engine = getMainEngine()) {
  let physics = null;
  if (engine != null) {
    physics = engine.physics;
  }
  return physics;
}
function getCanvas(engine = getMainEngine()) {
  let canvas = null;
  if (engine != null) {
    canvas = engine.canvas;
  }
  return canvas;
}
function getWASM(engine = getMainEngine()) {
  let wasm = null;
  if (engine != null) {
    wasm = engine.wasm;
  }
  return wasm;
}
function getXR(engine = getMainEngine()) {
  let xr = null;
  if (engine != null) {
    xr = engine.xr;
  }
  return xr;
}

// dist/debug/debug_globals.js
var debug_globals_exports = {};
__export(debug_globals_exports, {
  getDebugManager: () => getDebugManager,
  getDebugVisualManager: () => getDebugVisualManager,
  hasDebugEnabled: () => hasDebugEnabled,
  hasDebugManager: () => hasDebugManager,
  isDebugEnabled: () => isDebugEnabled,
  removeDebugEnabled: () => removeDebugEnabled,
  removeDebugManager: () => removeDebugManager,
  setDebugEnabled: () => setDebugEnabled,
  setDebugManager: () => setDebugManager
});
var _myDebugManagers = /* @__PURE__ */ new WeakMap();
var _myDebugEnableds = /* @__PURE__ */ new WeakMap();
function getDebugManager(engine = Globals.getMainEngine()) {
  return _myDebugManagers.get(engine);
}
function setDebugManager(debugManager, engine = Globals.getMainEngine()) {
  _myDebugManagers.set(engine, debugManager);
}
function removeDebugManager(engine = Globals.getMainEngine()) {
  _myDebugManagers.delete(engine);
}
function hasDebugManager(engine = Globals.getMainEngine()) {
  return _myDebugManagers.has(engine);
}
function getDebugVisualManager(engine = Globals.getMainEngine()) {
  let debugManager = getDebugManager(engine);
  if (debugManager != null) {
    return debugManager.getDebugVisualManager();
  }
  return null;
}
function isDebugEnabled(engine = Globals.getMainEngine()) {
  return _myDebugEnableds.get(engine);
}
function setDebugEnabled(debugEnabled, engine = Globals.getMainEngine()) {
  _myDebugEnableds.set(engine, debugEnabled);
}
function removeDebugEnabled(engine = Globals.getMainEngine()) {
  _myDebugEnableds.delete(engine);
}
function hasDebugEnabled(engine = Globals.getMainEngine()) {
  return _myDebugEnableds.has(engine);
}

// dist/gameplay/experimental/character_controller/collision/character_collision_system_globals.js
var character_collision_system_globals_exports = {};
__export(character_collision_system_globals_exports, {
  getCharacterCollisionSystem: () => getCharacterCollisionSystem,
  hasCharacterCollisionSystem: () => hasCharacterCollisionSystem,
  removeCharacterCollisionSystem: () => removeCharacterCollisionSystem,
  setCharacterCollisionSystem: () => setCharacterCollisionSystem
});
var _myCharacterCollisionSystems = /* @__PURE__ */ new WeakMap();
function getCharacterCollisionSystem(engine = Globals.getMainEngine()) {
  return _myCharacterCollisionSystems.get(engine);
}
function setCharacterCollisionSystem(characterCollisionSystem, engine = Globals.getMainEngine()) {
  _myCharacterCollisionSystems.set(engine, characterCollisionSystem);
}
function removeCharacterCollisionSystem(engine = Globals.getMainEngine()) {
  _myCharacterCollisionSystems.delete(engine);
}
function hasCharacterCollisionSystem(engine = Globals.getMainEngine()) {
  return _myCharacterCollisionSystems.has(engine);
}

// dist/input/cauldron/input_globals.js
var input_globals_exports = {};
__export(input_globals_exports, {
  getGamepad: () => getGamepad,
  getGamepads: () => getGamepads,
  getGamepadsManager: () => getGamepadsManager,
  getHandPose: () => getHandPose,
  getHandPoses: () => getHandPoses,
  getHeadPose: () => getHeadPose,
  getInputManager: () => getInputManager,
  getKeyboard: () => getKeyboard,
  getLeftGamepad: () => getLeftGamepad,
  getLeftHandPose: () => getLeftHandPose,
  getLeftTrackedHandPose: () => getLeftTrackedHandPose,
  getMouse: () => getMouse,
  getRightGamepad: () => getRightGamepad,
  getRightHandPose: () => getRightHandPose,
  getRightTrackedHandPose: () => getRightTrackedHandPose,
  getTrackedHandPose: () => getTrackedHandPose,
  getTrackedHandPoses: () => getTrackedHandPoses,
  hasInputManager: () => hasInputManager,
  hasPoseForwardFixed: () => hasPoseForwardFixed,
  isPoseForwardFixed: () => isPoseForwardFixed,
  removeInputManager: () => removeInputManager,
  removePoseForwardFixed: () => removePoseForwardFixed,
  setInputManager: () => setInputManager,
  setPoseForwardFixed: () => setPoseForwardFixed
});
var _myInputManagers = /* @__PURE__ */ new WeakMap();
var _myPoseForwardFixeds = /* @__PURE__ */ new WeakMap();
function getInputManager(engine = Globals.getMainEngine()) {
  return _myInputManagers.get(engine);
}
function setInputManager(inputManager, engine = Globals.getMainEngine()) {
  _myInputManagers.set(engine, inputManager);
}
function removeInputManager(engine = Globals.getMainEngine()) {
  _myInputManagers.delete(engine);
}
function hasInputManager(engine = Globals.getMainEngine()) {
  return _myInputManagers.has(engine);
}
function getMouse(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getMouse();
  }
  return null;
}
function getKeyboard(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getKeyboard();
  }
  return null;
}
function getGamepadsManager(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager();
  }
  return null;
}
function getGamepad(handedness, engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepad(handedness);
  }
  return null;
}
function getGamepads(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepads();
  }
  return null;
}
function getLeftGamepad(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getLeftGamepad();
  }
  return null;
}
function getRightGamepad(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getRightGamepad();
  }
  return null;
}
function getHeadPose(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHeadPose();
  }
  return null;
}
function getHandPose(handedness, engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHandPose(handedness);
  }
  return null;
}
function getHandPoses(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHandPoses();
  }
  return null;
}
function getLeftHandPose(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getLeftHandPose();
  }
  return null;
}
function getRightHandPose(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getRightHandPose();
  }
  return null;
}
function getTrackedHandPose(handedness, engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getTrackedHandPose(handedness);
  }
  return null;
}
function getTrackedHandPoses(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getTrackedHandPoses();
  }
  return null;
}
function getLeftTrackedHandPose(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getLeftTrackedHandPose();
  }
  return null;
}
function getRightTrackedHandPose(engine = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getRightTrackedHandPose();
  }
  return null;
}
function isPoseForwardFixed(engine = Globals.getMainEngine()) {
  return _myPoseForwardFixeds.get(engine);
}
function setPoseForwardFixed(toolEnabled, engine = Globals.getMainEngine()) {
  _myPoseForwardFixeds.set(engine, toolEnabled);
}
function removePoseForwardFixed(engine = Globals.getMainEngine()) {
  _myPoseForwardFixeds.delete(engine);
}
function hasPoseForwardFixed(engine = Globals.getMainEngine()) {
  return _myPoseForwardFixeds.has(engine);
}

// dist/tool/cauldron/tool_globals.js
var tool_globals_exports = {};
__export(tool_globals_exports, {
  hasToolEnabled: () => hasToolEnabled,
  isToolEnabled: () => isToolEnabled,
  removeToolEnabled: () => removeToolEnabled,
  setToolEnabled: () => setToolEnabled
});
var _myToolEnableds = /* @__PURE__ */ new WeakMap();
function isToolEnabled(engine = Globals.getMainEngine()) {
  return _myToolEnableds.get(engine);
}
function setToolEnabled(toolEnabled, engine = Globals.getMainEngine()) {
  _myToolEnableds.set(engine, toolEnabled);
}
function removeToolEnabled(engine = Globals.getMainEngine()) {
  _myToolEnableds.delete(engine);
}
function hasToolEnabled(engine = Globals.getMainEngine()) {
  return _myToolEnableds.has(engine);
}

// dist/tool/console_vr/console_vr_globals.js
var console_vr_globals_exports = {};
__export(console_vr_globals_exports, {
  getConsoleVR: () => getConsoleVR,
  hasConsoleVR: () => hasConsoleVR,
  removeConsoleVR: () => removeConsoleVR,
  setConsoleVR: () => setConsoleVR
});
var _myConsoleVRs = /* @__PURE__ */ new WeakMap();
function getConsoleVR(engine = Globals.getMainEngine()) {
  return _myConsoleVRs.get(engine);
}
function setConsoleVR(consoleVR, engine = Globals.getMainEngine()) {
  _myConsoleVRs.set(engine, consoleVR);
}
function removeConsoleVR(engine = Globals.getMainEngine()) {
  _myConsoleVRs.delete(engine);
}
function hasConsoleVR(engine = Globals.getMainEngine()) {
  return _myConsoleVRs.has(engine);
}

// dist/tool/easy_tune/easy_tune_globals.js
var easy_tune_globals_exports = {};
__export(easy_tune_globals_exports, {
  getEasyTuneTarget: () => getEasyTuneTarget,
  getEasyTuneVariables: () => getEasyTuneVariables,
  hasEasyTuneTarget: () => hasEasyTuneTarget,
  hasEasyTuneVariables: () => hasEasyTuneVariables,
  removeEasyTuneTarget: () => removeEasyTuneTarget,
  removeEasyTuneVariables: () => removeEasyTuneVariables,
  setEasyTuneTarget: () => setEasyTuneTarget,
  setEasyTuneVariables: () => setEasyTuneVariables
});
var _myEasyTuneVariablesList = /* @__PURE__ */ new WeakMap();
var _myEasyTuneTargets = /* @__PURE__ */ new WeakMap();
function getEasyTuneVariables(engine = Globals.getMainEngine()) {
  return _myEasyTuneVariablesList.get(engine);
}
function setEasyTuneVariables(easyTuneVariables, engine = Globals.getMainEngine()) {
  _myEasyTuneVariablesList.set(engine, easyTuneVariables);
}
function removeEasyTuneVariables(engine = Globals.getMainEngine()) {
  _myEasyTuneVariablesList.delete(engine);
}
function hasEasyTuneVariables(engine = Globals.getMainEngine()) {
  return _myEasyTuneVariablesList.has(engine);
}
function getEasyTuneTarget(engine = Globals.getMainEngine()) {
  return _myEasyTuneTargets.get(engine);
}
function setEasyTuneTarget(easyTuneTarget, engine = Globals.getMainEngine()) {
  _myEasyTuneTargets.set(engine, easyTuneTarget);
}
function removeEasyTuneTarget(engine = Globals.getMainEngine()) {
  _myEasyTuneTargets.delete(engine);
}
function hasEasyTuneTarget(engine = Globals.getMainEngine()) {
  return _myEasyTuneTargets.has(engine);
}

// dist/pp/default_resources_globals.js
var default_resources_globals_exports = {};
__export(default_resources_globals_exports, {
  getDefaultMaterials: () => getDefaultMaterials,
  getDefaultMeshes: () => getDefaultMeshes,
  getDefaultResources: () => getDefaultResources,
  hasDefaultResources: () => hasDefaultResources,
  removeDefaultResources: () => removeDefaultResources,
  setDefaultResources: () => setDefaultResources
});
var _myDefaultResourcesContainer = /* @__PURE__ */ new WeakMap();
function getDefaultResources(engine = Globals.getMainEngine()) {
  return _myDefaultResourcesContainer.get(engine);
}
function setDefaultResources(defaultResources, engine = Globals.getMainEngine()) {
  _myDefaultResourcesContainer.set(engine, defaultResources);
}
function removeDefaultResources(engine = Globals.getMainEngine()) {
  _myDefaultResourcesContainer.delete(engine);
}
function hasDefaultResources(engine = Globals.getMainEngine()) {
  return _myDefaultResourcesContainer.has(engine);
}
function getDefaultMeshes(engine = Globals.getMainEngine()) {
  let defaultResources = getDefaultResources(engine);
  if (defaultResources != null) {
    return defaultResources.myMeshes;
  }
  return null;
}
function getDefaultMaterials(engine = Globals.getMainEngine()) {
  let defaultResources = getDefaultResources(engine);
  if (defaultResources != null) {
    return defaultResources.myMaterials;
  }
  return null;
}

// dist/pp/scene_objects_globals.js
var scene_objects_globals_exports = {};
__export(scene_objects_globals_exports, {
  getPlayerObjects: () => getPlayerObjects,
  getSceneObjects: () => getSceneObjects,
  hasSceneObjects: () => hasSceneObjects,
  removeSceneObjects: () => removeSceneObjects,
  setSceneObjects: () => setSceneObjects
});
var _mySceneObjectsContainer = /* @__PURE__ */ new WeakMap();
function getSceneObjects(engine = Globals.getMainEngine()) {
  return _mySceneObjectsContainer.get(engine);
}
function setSceneObjects(sceneObjects, engine = Globals.getMainEngine()) {
  _mySceneObjectsContainer.set(engine, sceneObjects);
}
function removeSceneObjects(engine = Globals.getMainEngine()) {
  _mySceneObjectsContainer.delete(engine);
}
function hasSceneObjects(engine = Globals.getMainEngine()) {
  return _mySceneObjectsContainer.has(engine);
}
function getPlayerObjects(engine = Globals.getMainEngine()) {
  let sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myPlayerObjects;
  }
  return null;
}

// dist/pp/globals.js
var Globals = {
  ...engine_globals_exports,
  ...scene_objects_globals_exports,
  ...default_resources_globals_exports,
  ...audio_globals_exports,
  ...visual_globals_exports,
  ...debug_globals_exports,
  ...window_globals_exports,
  ...object_pool_globals_exports,
  ...character_collision_system_globals_exports,
  ...input_globals_exports,
  ...save_globals_exports,
  ...analytics_globals_exports,
  ...tool_globals_exports,
  ...console_vr_globals_exports,
  ...easy_tune_globals_exports
};

// dist/cauldron/wl/utils/default_wl_component_clone_callbacks.js
import { MeshComponent, TextComponent } from "@wonderlandengine/api";

// dist/cauldron/utils/mesh_utils.js
import { Mesh, MeshAttribute, MeshIndexType } from "@wonderlandengine/api";

// dist/cauldron/js/utils/vec2_utils.js
import { vec2 as gl_vec2 } from "gl-matrix";
function create6(x, y) {
  let out = gl_vec2.create();
  if (x !== void 0) {
    set6(out, x, y);
  }
  return out;
}
function set6(vector, x, y) {
  if (y === void 0) {
    gl_vec2.set(vector, x, x);
  } else {
    gl_vec2.set(vector, x, y);
  }
  return vector;
}
function length4(vector) {
  return gl_vec2.length(vector);
}
function normalize4(vector, out = create6()) {
  gl_vec2.normalize(out, vector);
  return out;
}
function copy6(from, to) {
  gl_vec2.copy(to, from);
  return to;
}
function clone6(vector, out = create6()) {
  Vec2Utils.copy(vector, out);
  return out;
}
function zero2(vector) {
  gl_vec2.zero(vector);
  return vector;
}
function isZero2(vector, epsilon = 0) {
  return Vec2Utils.length(vector) <= epsilon;
}
var Vec2Utils = {
  create: create6,
  set: set6,
  length: length4,
  normalize: normalize4,
  copy: copy6,
  clone: clone6,
  zero: zero2,
  isZero: isZero2
};

// dist/cauldron/js/utils/vec4_utils.js
import { vec4 as gl_vec4 } from "gl-matrix";
function create7(x, y, z, w) {
  let out = gl_vec4.create();
  if (x !== void 0) {
    set7(out, x, y, z, w);
  }
  return out;
}
function set7(vector, x, y, z, w) {
  if (y === void 0) {
    gl_vec4.set(vector, x, x, x, x);
  } else {
    gl_vec4.set(vector, x, y, z, w);
  }
  return vector;
}
function copy7(from, to) {
  gl_vec4.copy(to, from);
  return to;
}
function clone7(vector, out = create7()) {
  Vec4Utils.copy(vector, out);
  return out;
}
var Vec4Utils = {
  create: create7,
  set: set7,
  copy: copy7,
  clone: clone7
};

// dist/cauldron/js/utils/vec_utils.js
function zero3(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = 0;
  }
  return out;
}
function isZero3(vector, epsilon = 0) {
  let zero4 = true;
  for (let i = 0; i < vector.length && zero4; i++) {
    zero4 = zero4 && Math.abs(vector[i]) <= epsilon;
  }
  return zero4;
}
function scale3(vector, value, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = out[i] * value;
  }
  return out;
}
function round(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.round(out[i]);
  }
  return out;
}
function floor(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.floor(out[i]);
  }
  return out;
}
function ceil(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.ceil(out[i]);
  }
  return out;
}
function clamp2(vector, start, end, out = null) {
  out = _prepareOut(vector, out);
  let fixedStart = start != null ? start : -Number.MAX_VALUE;
  let fixedEnd = end != null ? end : Number.MAX_VALUE;
  let min = Math.min(fixedStart, fixedEnd);
  let max = Math.max(fixedStart, fixedEnd);
  for (let i = 0; i < out.length; i++) {
    out[i] = MathUtils.clamp(out[i], min, max);
  }
  return out;
}
function equals4(vector, other, epsilon = 0) {
  let equals5 = vector.length == other.length;
  for (let i = 0; i < vector.length && equals5; i++) {
    equals5 = equals5 && Math.abs(vector[i] - other[i]) <= epsilon;
  }
  return equals5;
}
function toString3(vector, decimalPlaces = null) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  return message;
}
function log(vector, decimalPlaces = 4) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  console.log(message);
}
function error(vector, decimalPlaces = 4) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  console.error(message);
}
function warn(vector, decimalPlaces = 4) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  console.warn(message);
}
var VecUtils = {
  zero: zero3,
  isZero: isZero3,
  scale: scale3,
  round,
  floor,
  ceil,
  clamp: clamp2,
  equals: equals4,
  toString: toString3,
  log,
  error,
  warn
};
function _buildConsoleMessage(vector, decimalPlaces) {
  let message = "[";
  for (let i = 0; i < vector.length; i++) {
    if (i != 0) {
      message = message.concat(", ");
    }
    if (decimalPlaces != null) {
      message = message.concat(vector[i].toFixed(decimalPlaces));
    } else {
      message = message.concat(vector[i].toString());
    }
  }
  message = message.concat("]");
  return message;
}
function _prepareOut(vector, out) {
  if (out == null) {
    out = ArrayUtils.clone(vector);
  } else if (out != vector) {
    ArrayUtils.copy(vector, out);
  }
  return out;
}

// dist/cauldron/js/utils/js_utils.js
function getObjectPrototypes(object) {
  let prototypes = [];
  prototypes.push(object);
  let objectProto = Object.getPrototypeOf(object);
  while (objectProto != null) {
    ArrayUtils.pushUnique(prototypes, objectProto);
    objectProto = Object.getPrototypeOf(objectProto);
  }
  let prototypesToCheck = [object];
  while (prototypesToCheck.length > 0) {
    let prototypeToCheck = prototypesToCheck.shift();
    if (prototypeToCheck != null) {
      ArrayUtils.pushUnique(prototypes, prototypeToCheck);
      ArrayUtils.pushUnique(prototypesToCheck, Object.getPrototypeOf(prototypeToCheck));
      try {
        ArrayUtils.pushUnique(prototypesToCheck, prototypeToCheck.prototype);
      } catch (error3) {
      }
    }
  }
  return prototypes;
}
function getObjectPropertyNames(object) {
  let propertyNames = [];
  let prototypes = JSUtils.getObjectPrototypes(object);
  for (let prototype of prototypes) {
    if (prototype != null) {
      let ownPropertyNames = Object.getOwnPropertyNames(prototype);
      for (let ownPropertyName of ownPropertyNames) {
        ArrayUtils.pushUnique(propertyNames, ownPropertyName);
      }
    }
  }
  return propertyNames;
}
function getObjectPropertyDescriptor(object, propertyName) {
  let propertyDescriptor = null;
  let propertyParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
  if (propertyParent != null) {
    propertyDescriptor = Object.getOwnPropertyDescriptor(propertyParent, propertyName);
  }
  return propertyDescriptor;
}
function getObjectProperty(object, propertyName) {
  let property = void 0;
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null) {
    if (propertyDescriptor.get != null) {
      property = propertyDescriptor.get.bind(object)();
    } else {
      property = propertyDescriptor.value;
    }
  }
  return property;
}
function setObjectProperty(valueToSet, object, propertyName) {
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  let setUsed = false;
  if (propertyDescriptor != null) {
    if (propertyDescriptor.set != null) {
      setUsed = true;
      propertyDescriptor.set.bind(object)(valueToSet);
    }
  }
  if (!setUsed) {
    let propertyParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
    if (propertyParent == null) {
      propertyParent = object;
    }
    Object.defineProperty(propertyParent, propertyName, {
      value: valueToSet
    });
  }
}
function getObjectPropertyOwnParent(object, propertyName) {
  let parent = null;
  let parents = JSUtils.getObjectPropertyOwnParents(object, propertyName);
  if (parents.length > 0) {
    parent = parents[0];
  }
  return parent;
}
function getObjectPropertyOwnParents(object, propertyName) {
  let parents = [];
  let possibleParents = JSUtils.getObjectPrototypes(object);
  for (let possibleParent of possibleParents) {
    let propertyNames = Object.getOwnPropertyNames(possibleParent);
    if (ArrayUtils.hasEqual(propertyNames, propertyName)) {
      parents.push(possibleParent);
    }
  }
  return parents;
}
function getObjectFromPath(path, pathStartObject = Globals.getWindow()) {
  let object = null;
  let objectName = JSUtils.getObjectNameFromPath(path);
  if (objectName != null) {
    object = JSUtils.getObjectProperty(JSUtils.getObjectParentFromPath(path, pathStartObject), objectName);
  }
  return object;
}
function getObjectNameFromPath(path) {
  let objectName = null;
  if (path != null) {
    let pathSplit = path.split(".");
    if (pathSplit.length > 0) {
      objectName = pathSplit[pathSplit.length - 1];
    }
  }
  return objectName;
}
function getObjectParentFromPath(path, pathStartObject = Globals.getWindow()) {
  let pathSplit = path.split(".");
  let currentParent = pathStartObject;
  for (let i = 0; i < pathSplit.length - 1; i++) {
    currentParent = JSUtils.getObjectProperty(currentParent, pathSplit[i]);
  }
  return currentParent;
}
function overwriteObjectProperty(newProperty, object, propertyName, overwriteOnOwnParent = true, jsObjectFunctionsSpecialOverwrite = false, logEnabled = false) {
  let success = false;
  try {
    let propertyOwnParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
    if (propertyOwnParent != null) {
      let originalPropertyDescriptor = Object.getOwnPropertyDescriptor(propertyOwnParent, propertyName);
      if (originalPropertyDescriptor != null) {
        let originalProperty = JSUtils.getObjectProperty(propertyOwnParent, propertyName);
        JSUtils.copyObjectProperties(originalProperty, newProperty, true, jsObjectFunctionsSpecialOverwrite, logEnabled);
        let overwriteTarget = object;
        if (overwriteOnOwnParent) {
          overwriteTarget = propertyOwnParent;
        }
        Object.defineProperty(overwriteTarget, propertyName, {
          value: newProperty,
          enumerable: originalPropertyDescriptor.enumerable,
          writable: originalPropertyDescriptor.writable,
          configurable: originalPropertyDescriptor.configurable
        });
        success = true;
      } else {
        Object.defineProperty(object, propertyName, {
          value: newProperty
        });
        success = true;
      }
    } else {
      Object.defineProperty(object, propertyName, {
        value: newProperty
      });
      success = true;
    }
  } catch (error3) {
    if (logEnabled) {
      console.error("Property:", propertyName, "of:", object, "can't be overwritten.");
    }
  }
  return success;
}
function copyObjectProperties(fromObject, toObject, cleanCopy = false, jsObjectFunctionsSpecialCopy = false, logEnabled = false) {
  if (fromObject != null) {
    if (cleanCopy) {
      JSUtils.cleanObjectProperties(toObject);
    }
    Object.setPrototypeOf(toObject, Object.getPrototypeOf(fromObject));
    let fromObjectPropertyNames = Object.getOwnPropertyNames(fromObject);
    for (let fromObjectPropertyName of fromObjectPropertyNames) {
      try {
        let fromObjectPropertyDescriptor = Object.getOwnPropertyDescriptor(fromObject, fromObjectPropertyName);
        Object.defineProperty(toObject, fromObjectPropertyName, {
          value: fromObjectPropertyDescriptor.value,
          enumerable: fromObjectPropertyDescriptor.enumerable,
          writable: fromObjectPropertyDescriptor.writable,
          configurable: fromObjectPropertyDescriptor.configurable
        });
      } catch (error3) {
        if (logEnabled) {
          console.error("Property:", fromObjectPropertyName, "of:", fromObject.name, "can't be overwritten.");
        }
      }
    }
    if (jsObjectFunctionsSpecialCopy) {
      _jsObjectFunctionsSpecialCopy(fromObject, toObject);
    }
  }
}
function cleanObjectProperties(object) {
  let objectNames = Object.getOwnPropertyNames(object);
  ArrayUtils.pushUnique(objectNames, "__proto__");
  for (let objectName of objectNames) {
    try {
      Object.defineProperty(object, objectName, {
        value: void 0
      });
    } catch (error3) {
    }
    try {
      delete object[objectName];
    } catch (error3) {
    }
  }
  Object.setPrototypeOf(object, null);
}
function doesObjectPropertyUseAccessors(object, propertyName) {
  let propertyUseAccessors = false;
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null)) {
    propertyUseAccessors = true;
  }
  return propertyUseAccessors;
}
function isFunctionByName(functionParent, functionName) {
  let isFunctionResult = false;
  let functionProperty = JSUtils.getObjectProperty(functionParent, functionName);
  if (functionProperty != null) {
    isFunctionResult = JSUtils.isFunction(functionProperty);
  }
  return isFunctionResult;
}
function isClassByName(classParent, className) {
  let isClassResult = false;
  let classProperty = JSUtils.getObjectProperty(classParent, className);
  if (classProperty != null) {
    isClassResult = JSUtils.isClass(classProperty);
  }
  return isClassResult;
}
function isObjectByName(objectParent, objectName) {
  let isObjectResult = false;
  let objectProperty = JSUtils.getObjectProperty(objectParent, objectName);
  if (objectProperty != null) {
    isObjectResult = JSUtils.isObject(objectProperty);
  }
  return isObjectResult;
}
function isFunction(property) {
  return typeof property == "function" && !JSUtils.isClass(property);
}
var isClass = function() {
  let checkClassRegex = new RegExp("^class");
  return function isClass2(property) {
    return typeof property == "function" && property.prototype != null && typeof property.prototype.constructor == "function" && property.toString != null && typeof property.toString == "function" && property.toString()?.match(checkClassRegex) != null;
  };
}();
function isObject(property) {
  return typeof property == "object";
}
var JSUtils = {
  getObjectPrototypes,
  getObjectPropertyNames,
  getObjectPropertyDescriptor,
  getObjectProperty,
  setObjectProperty,
  getObjectPropertyOwnParent,
  getObjectPropertyOwnParents,
  getObjectFromPath,
  getObjectNameFromPath,
  getObjectParentFromPath,
  overwriteObjectProperty,
  copyObjectProperties,
  cleanObjectProperties,
  doesObjectPropertyUseAccessors,
  isFunctionByName,
  isClassByName,
  isObjectByName,
  isFunction,
  isClass,
  isObject
};
function _jsObjectFunctionsSpecialCopy(fromObject, toObject) {
  try {
    if (typeof toObject == "function" && typeof fromObject == "function") {
      let functionsToOverwrite = ["toString", "toLocaleString", "valueOf"];
      for (let functionToOverwrite of functionsToOverwrite) {
        let propertyDescriptorToOverwrite = JSUtils.getObjectPropertyDescriptor(fromObject, functionToOverwrite);
        if (propertyDescriptorToOverwrite != null && propertyDescriptorToOverwrite.value != null && propertyDescriptorToOverwrite.value == Object[functionToOverwrite]) {
          let valueToReturn = Object[functionToOverwrite].bind(fromObject)();
          let overwrittenFunction = function() {
            return valueToReturn;
          };
          JSUtils.overwriteObjectProperty(overwrittenFunction, toObject, functionToOverwrite, false, false);
        }
      }
    }
  } catch (error3) {
  }
}

// dist/plugin/utils/plugin_utils.js
function injectProperties(fromReference, toReference, enumerable = true, writable = true, configurable = true, keepOriginalDescriptorAttributes = true, bindThisAsFirstParam = false, prefix = null, functionNamesToExclude = []) {
  let ownPropertyNames = Object.getOwnPropertyNames(fromReference);
  for (let ownPropertyName of ownPropertyNames) {
    if (functionNamesToExclude.includes(ownPropertyName))
      continue;
    let enumerableToUse = enumerable;
    let writableToUse = writable;
    let configurableToUse = configurable;
    if (keepOriginalDescriptorAttributes) {
      let originalDescriptor = Object.getOwnPropertyDescriptor(toReference, ownPropertyName);
      if (originalDescriptor != null) {
        enumerableToUse = originalDescriptor.enumerable;
        writableToUse = originalDescriptor.writable;
        configurableToUse = originalDescriptor.configurable;
      }
    }
    let adjustedPropertyName = ownPropertyName;
    if (prefix != null) {
      if (adjustedPropertyName.length > 0 && adjustedPropertyName[0] == adjustedPropertyName[0].toUpperCase()) {
        adjustedPropertyName = prefix.toUpperCase() + adjustedPropertyName;
      } else {
        adjustedPropertyName = prefix + adjustedPropertyName;
      }
    }
    let propertyDescriptor = Object.getOwnPropertyDescriptor(fromReference, ownPropertyName);
    let useAccessors = propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null);
    if (!useAccessors) {
      let adjustedProperyValue = fromReference[ownPropertyName];
      if (bindThisAsFirstParam && JSUtils.isFunction(adjustedProperyValue)) {
        let originalFunction = fromReference[ownPropertyName];
        adjustedProperyValue = function() {
          return originalFunction(this, ...arguments);
        };
        Object.defineProperty(adjustedProperyValue, "name", {
          value: adjustedPropertyName
        });
      }
      Object.defineProperty(toReference, adjustedPropertyName, {
        value: adjustedProperyValue,
        enumerable: enumerableToUse,
        writable: writableToUse,
        configurable: configurableToUse
      });
    } else {
      Object.defineProperty(toReference, adjustedPropertyName, {
        get: propertyDescriptor.get,
        set: propertyDescriptor.set,
        enumerable: enumerableToUse,
        configurable: configurableToUse
      });
    }
  }
}
var PluginUtils = {
  injectProperties
};

// dist/plugin/js/extensions/array_extension.js
function initArrayExtension() {
  initArrayExtensionProtoype();
}
function vec2_create(x, y) {
  return Vec2Utils.create(x, y);
}
function vec3_create(x, y, z) {
  return Vec3Utils.create(x, y, z);
}
function vec4_create(x, y, z, w) {
  return Vec4Utils.create(x, y, z, w);
}
function quat_create(x, y, z, w) {
  return QuatUtils.create(x, y, z, w);
}
function quat2_create(x1, y1, z1, w1, x2, y2, z2, w2) {
  return Quat2Utils.create(x1, y1, z1, w1, x2, y2, z2, w2);
}
function mat3_create(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  return Mat3Utils.create(m00, m01, m02, m10, m11, m12, m20, m21, m22);
}
function mat4_create(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  return Mat4Utils.create(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
}
function initArrayExtensionProtoype() {
  let arrayExtension = {};
  arrayExtension.pp_first = function pp_first() {
    return ArrayUtils.first(this);
  };
  arrayExtension.pp_last = function pp_last() {
    return ArrayUtils.last(this);
  };
  arrayExtension.pp_has = function pp_has(callback) {
    return ArrayUtils.has(this, callback);
  };
  arrayExtension.pp_hasEqual = function pp_hasEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.hasEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_find = function pp_find(callback) {
    return ArrayUtils.find(this, callback);
  };
  arrayExtension.pp_findIndex = function pp_findIndex(callback) {
    return ArrayUtils.findIndex(this, callback);
  };
  arrayExtension.pp_findAll = function pp_findAll(callback) {
    return ArrayUtils.findAll(this, callback);
  };
  arrayExtension.pp_findAllIndexes = function pp_findAllIndexes(callback) {
    return ArrayUtils.findAllIndexes(this, callback);
  };
  arrayExtension.pp_findEqual = function pp_findEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_findAllEqual = function pp_findAllEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findAllEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_findIndexEqual = function pp_findIndexEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findIndexEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_findAllIndexesEqual = function pp_findAllIndexesEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findAllIndexesEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_removeIndex = function pp_removeIndex(index) {
    return ArrayUtils.removeIndex(this, index);
  };
  arrayExtension.pp_removeAllIndexes = function pp_removeAllIndexes(indexes) {
    return ArrayUtils.removeAllIndexes(this, indexes);
  };
  arrayExtension.pp_remove = function pp_remove(callback) {
    return ArrayUtils.remove(this, callback);
  };
  arrayExtension.pp_removeAll = function pp_removeAll(callback) {
    return ArrayUtils.removeAll(this, callback);
  };
  arrayExtension.pp_removeEqual = function pp_removeEqual(elementToRemove, elementsEqualCallback = null) {
    return ArrayUtils.removeEqual(this, elementToRemove, elementsEqualCallback);
  };
  arrayExtension.pp_removeAllEqual = function pp_removeAllEqual(elementToRemove, elementsEqualCallback = null) {
    return ArrayUtils.removeAllEqual(this, elementToRemove, elementsEqualCallback);
  };
  arrayExtension.pp_pushUnique = function pp_pushUnique(element, elementsEqualCallback = null) {
    return ArrayUtils.pushUnique(this, element, elementsEqualCallback);
  };
  arrayExtension.pp_unshiftUnique = function pp_unshiftUnique(element, elementsEqualCallback = null) {
    return ArrayUtils.unshiftUnique(this, element, elementsEqualCallback);
  };
  arrayExtension.pp_copy = function pp_copy(array, copyCallback = null) {
    return ArrayUtils.copy(array, this, copyCallback);
  };
  arrayExtension.pp_clone = function pp_clone(cloneCallback = null) {
    return ArrayUtils.clone(this, cloneCallback);
  };
  arrayExtension.pp_equals = function pp_equals(array, elementsEqualCallback = null) {
    return ArrayUtils.equals(this, array, elementsEqualCallback);
  };
  arrayExtension.pp_clear = function pp_clear() {
    return ArrayUtils.clear(this);
  };
  let vecExtension = {};
  vecExtension.vec_zero = function vec_zero(out = null) {
    return VecUtils.zero(this, out);
  };
  vecExtension.vec_isZero = function vec_isZero(epsilon = 0) {
    return VecUtils.isZero(this, epsilon);
  };
  vecExtension.vec_scale = function vec_scale(value, out = null) {
    return VecUtils.scale(this, value, out);
  };
  vecExtension.vec_round = function vec_round(out = null) {
    return VecUtils.round(this, out);
  };
  vecExtension.vec_floor = function vec_floor(out = null) {
    return VecUtils.floor(this, out);
  };
  vecExtension.vec_ceil = function vec_ceil(out = null) {
    return VecUtils.ceil(this, out);
  };
  vecExtension.vec_clamp = function vec_clamp(start, end, out = null) {
    return VecUtils.clamp(this, start, end, out);
  };
  vecExtension.vec_equals = function vec_equals(vector, epsilon = 0) {
    return VecUtils.equals(this, vector, epsilon);
  };
  vecExtension.vec_toString = function vec_toString(decimalPlaces = null) {
    return VecUtils.toString(this, decimalPlaces);
  };
  vecExtension.vec_log = function vec_log(decimalPlaces = 4) {
    return VecUtils.log(this, decimalPlaces);
  };
  vecExtension.vec_error = function vec_error(decimalPlaces = 4) {
    return VecUtils.error(this, decimalPlaces);
  };
  vecExtension.vec_warn = function vec_warn(decimalPlaces = 4) {
    return VecUtils.warn(this, decimalPlaces);
  };
  let vec2Extension = {};
  vec2Extension.vec2_set = function vec2_set(x, y) {
    return Vec2Utils.set(this, x, y);
  };
  vec2Extension.vec2_length = function vec2_length() {
    return Vec2Utils.length(this);
  };
  vec2Extension.vec2_normalize = function vec2_normalize(out = Vec2Utils.create()) {
    return Vec2Utils.normalize(this, out);
  };
  vec2Extension.vec2_copy = function vec2_copy(vector) {
    return Vec2Utils.copy(vector, this);
  };
  vec2Extension.vec2_clone = function vec2_clone(out = Vec2Utils.create()) {
    return Vec2Utils.clone(this, out);
  };
  vec2Extension.vec2_zero = function vec2_zero() {
    return Vec2Utils.zero(this);
  };
  vec2Extension.vec2_isZero = function vec2_isZero(epsilon = 0) {
    return Vec2Utils.isZero(this, epsilon);
  };
  let vec3Extension = {};
  vec3Extension.vec3_set = function vec3_set(x, y, z) {
    return Vec3Utils.set(this, x, y, z);
  };
  vec3Extension.vec3_normalize = function vec3_normalize(out = Vec3Utils.create()) {
    return Vec3Utils.normalize(this, out);
  };
  vec3Extension.vec3_copy = function vec3_copy(vector) {
    return Vec3Utils.copy(vector, this);
  };
  vec3Extension.vec3_clone = function vec3_clone(out = Vec3Utils.create()) {
    return Vec3Utils.clone(this, out);
  };
  vec3Extension.vec3_zero = function vec3_zero() {
    return Vec3Utils.zero(this);
  };
  vec3Extension.vec3_angle = function vec3_angle(vector) {
    return Vec3Utils.angle(this, vector);
  };
  vec3Extension.vec3_angleDegrees = function vec3_angleDegrees(vector) {
    return Vec3Utils.angleDegrees(this, vector);
  };
  vec3Extension.vec3_angleRadians = function vec3_angleRadians(vector) {
    return Vec3Utils.angleRadians(this, vector);
  };
  vec3Extension.vec3_equals = function vec3_equals(vector, epsilon = 0) {
    return Vec3Utils.equals(this, vector, epsilon);
  };
  vec3Extension.vec3_length = function vec3_length() {
    return Vec3Utils.length(this);
  };
  vec3Extension.vec3_lengthSquared = function vec3_lengthSquared() {
    return Vec3Utils.lengthSquared(this);
  };
  vec3Extension.vec3_distance = function vec3_distance(vector) {
    return Vec3Utils.distance(this, vector);
  };
  vec3Extension.vec3_distanceSquared = function vec3_distanceSquared(vector) {
    return Vec3Utils.distanceSquared(this, vector);
  };
  vec3Extension.vec3_add = function vec3_add(vector, out = Vec3Utils.create()) {
    return Vec3Utils.add(this, vector, out);
  };
  vec3Extension.vec3_sub = function vec3_sub(vector, out = Vec3Utils.create()) {
    return Vec3Utils.sub(this, vector, out);
  };
  vec3Extension.vec3_mul = function vec3_mul(vector, out = Vec3Utils.create()) {
    return Vec3Utils.mul(this, vector, out);
  };
  vec3Extension.vec3_div = function vec3_div(vector, out = Vec3Utils.create()) {
    return Vec3Utils.div(this, vector, out);
  };
  vec3Extension.vec3_scale = function vec3_scale(value, out = Vec3Utils.create()) {
    return Vec3Utils.scale(this, value, out);
  };
  vec3Extension.vec3_dot = function vec3_dot(vector) {
    return Vec3Utils.dot(this, vector);
  };
  vec3Extension.vec3_negate = function vec3_negate(out = Vec3Utils.create()) {
    return Vec3Utils.negate(this, out);
  };
  vec3Extension.vec3_cross = function vec3_cross(vector, out = Vec3Utils.create()) {
    return Vec3Utils.cross(this, vector, out);
  };
  vec3Extension.vec3_transformQuat = function vec3_transformQuat(quat, out = Vec3Utils.create()) {
    return Vec3Utils.transformQuat(this, quat, out);
  };
  vec3Extension.vec3_transformMat3 = function vec3_transformMat3(matrix, out = Vec3Utils.create()) {
    return Vec3Utils.transformMat3(this, matrix, out);
  };
  vec3Extension.vec3_transformMat4 = function vec3_transformMat4(matrix, out = Vec3Utils.create()) {
    return Vec3Utils.transformMat4(this, matrix, out);
  };
  vec3Extension.vec3_lengthSigned = function vec3_lengthSigned(positiveDirection) {
    return Vec3Utils.lengthSigned(this, positiveDirection);
  };
  vec3Extension.vec3_angleSigned = function vec3_angleSigned(vector, referenceAxis) {
    return Vec3Utils.angleSigned(this, vector, referenceAxis);
  };
  vec3Extension.vec3_angleSignedDegrees = function vec3_angleSignedDegrees(vector, referenceAxis) {
    return Vec3Utils.angleSignedDegrees(this, vector, referenceAxis);
  };
  vec3Extension.vec3_angleSignedRadians = function vec3_angleSignedRadians(vector, referenceAxis) {
    return Vec3Utils.angleSignedRadians(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivoted = function vec3_anglePivoted(vector, referenceAxis) {
    return Vec3Utils.anglePivoted(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedDegrees = function vec3_anglePivotedDegrees(vector, referenceAxis) {
    return Vec3Utils.anglePivotedDegrees(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedRadians = function vec3_anglePivotedRadians(vector, referenceAxis) {
    return Vec3Utils.anglePivotedRadians(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedSigned = function vec3_anglePivotedSigned(vector, referenceAxis) {
    return Vec3Utils.anglePivotedSigned(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedSignedDegrees = function vec3_anglePivotedSignedDegrees(vector, referenceAxis) {
    return Vec3Utils.anglePivotedSignedDegrees(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedSignedRadians = function vec3_anglePivotedSignedRadians(vector, referenceAxis) {
    return Vec3Utils.anglePivotedSignedRadians(this, vector, referenceAxis);
  };
  vec3Extension.vec3_toRadians = function vec3_toRadians(out = Vec3Utils.create()) {
    return Vec3Utils.toRadians(this, out);
  };
  vec3Extension.vec3_toDegrees = function vec3_toDegrees(out = Vec3Utils.create()) {
    return Vec3Utils.toDegrees(this, out);
  };
  vec3Extension.vec3_toQuat = function vec3_toQuat(out) {
    return Vec3Utils.toQuat(this, out);
  };
  vec3Extension.vec3_radiansToQuat = function vec3_radiansToQuat(out = QuatUtils.create()) {
    return Vec3Utils.radiansToQuat(this, out);
  };
  vec3Extension.vec3_degreesToQuat = function vec3_degreesToQuat(out = QuatUtils.create()) {
    return Vec3Utils.degreesToQuat(this, out);
  };
  vec3Extension.vec3_isNormalized = function vec3_isNormalized(epsilon = MathUtils.EPSILON) {
    return Vec3Utils.isNormalized(this, epsilon);
  };
  vec3Extension.vec3_isZero = function vec3_isZero(epsilon = 0) {
    return Vec3Utils.isZero(this, epsilon);
  };
  vec3Extension.vec3_valueAlongAxis = function vec3_valueAlongAxis(axis) {
    return Vec3Utils.valueAlongAxis(this, axis);
  };
  vec3Extension.vec3_valueAlongPlane = function vec3_valueAlongPlane(planeNormal) {
    return Vec3Utils.valueAlongPlane(this, planeNormal);
  };
  vec3Extension.vec3_componentAlongAxis = function vec3_componentAlongAxis(axis, out = Vec3Utils.create()) {
    return Vec3Utils.componentAlongAxis(this, axis, out);
  };
  vec3Extension.vec3_removeComponentAlongAxis = function vec3_removeComponentAlongAxis(axis, out = Vec3Utils.create()) {
    return Vec3Utils.removeComponentAlongAxis(this, axis, out);
  };
  vec3Extension.vec3_copyComponentAlongAxis = function vec3_copyComponentAlongAxis(vector, axis, out = Vec3Utils.create()) {
    return Vec3Utils.copyComponentAlongAxis(vector, this, axis, out);
  };
  vec3Extension.vec3_isConcordant = function vec3_isConcordant(vector) {
    return Vec3Utils.isConcordant(this, vector);
  };
  vec3Extension.vec3_isFartherAlongAxis = function vec3_isFartherAlongAxis(vector, axis) {
    return Vec3Utils.isFartherAlongAxis(this, vector, axis);
  };
  vec3Extension.vec3_isToTheRight = function vec3_isToTheRight(vector, referenceAxis) {
    return Vec3Utils.isToTheRight(this, vector, referenceAxis);
  };
  vec3Extension.vec3_signTo = function vec3_signTo(vector, referenceAxis, zeroSign = 1) {
    return Vec3Utils.signTo(this, vector, referenceAxis, zeroSign);
  };
  vec3Extension.vec3_projectOnAxis = function vec3_projectOnAxis(axis, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnAxis(this, axis, out);
  };
  vec3Extension.vec3_projectOnAxisAlongAxis = function vec3_projectOnAxisAlongAxis(axis, projectAlongAxis, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnAxisAlongAxis(this, axis, projectAlongAxis, out);
  };
  vec3Extension.vec3_projectOnPlane = function vec3_projectOnPlane(planeNormal, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnPlane(this, planeNormal, out);
  };
  vec3Extension.vec3_projectOnPlaneAlongAxis = function vec3_projectOnPlaneAlongAxis(planeNormal, projectAlongAxis, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnPlaneAlongAxis(this, planeNormal, projectAlongAxis, out);
  };
  vec3Extension.vec3_isOnAxis = function vec3_isOnAxis(axis) {
    return Vec3Utils.isOnAxis(this, axis);
  };
  vec3Extension.vec3_isOnPlane = function vec3_isOnPlane(planeNormal) {
    return Vec3Utils.isOnPlane(this, planeNormal);
  };
  vec3Extension.vec3_rotate = function vec3_rotate(rotation, out) {
    return Vec3Utils.rotate(this, rotation, out);
  };
  vec3Extension.vec3_rotateDegrees = function vec3_rotateDegrees(rotation, out) {
    return Vec3Utils.rotateDegrees(this, rotation, out);
  };
  vec3Extension.vec3_rotateRadians = function vec3_rotateRadians(rotation, out) {
    return Vec3Utils.rotateRadians(this, rotation, out);
  };
  vec3Extension.vec3_rotateQuat = function vec3_rotateQuat(rotation, out) {
    return Vec3Utils.rotateQuat(this, rotation, out);
  };
  vec3Extension.vec3_rotateAxis = function vec3_rotateAxis(angle2, axis, out) {
    return Vec3Utils.rotateAxis(this, angle2, axis, out);
  };
  vec3Extension.vec3_rotateAxisDegrees = function vec3_rotateAxisDegrees(angle2, axis, out) {
    return Vec3Utils.rotateAxisDegrees(this, angle2, axis, out);
  };
  vec3Extension.vec3_rotateAxisRadians = function vec3_rotateAxisRadians(angle2, axis, out) {
    return Vec3Utils.rotateAxisRadians(this, angle2, axis, out);
  };
  vec3Extension.vec3_rotateAround = function vec3_rotateAround(rotation, origin, out) {
    return Vec3Utils.rotateAround(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundDegrees = function vec3_rotateAroundDegrees(rotation, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundDegrees(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundRadians = function vec3_rotateAroundRadians(rotation, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundRadians(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundQuat = function vec3_rotateAroundQuat(rotation, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundQuat(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundAxis = function vec3_rotateAroundAxis(angle2, axis, origin, out) {
    return Vec3Utils.rotateAroundAxis(this, angle2, axis, origin, out);
  };
  vec3Extension.vec3_rotateAroundAxisDegrees = function vec3_rotateAroundAxisDegrees(angle2, axis, origin, out) {
    return Vec3Utils.rotateAroundAxisDegrees(this, angle2, axis, origin, out);
  };
  vec3Extension.vec3_rotateAroundAxisRadians = function vec3_rotateAroundAxisRadians(angle2, axis, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundAxisRadians(this, angle2, axis, origin, out);
  };
  vec3Extension.vec3_convertPositionToWorld = function vec3_convertPositionToWorld(parentTransform, out) {
    return Vec3Utils.convertPositionToWorld(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToLocal = function vec3_convertPositionToLocal(parentTransform, out) {
    return Vec3Utils.convertPositionToLocal(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToWorldMatrix = function vec3_convertPositionToWorldMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToWorldMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToLocalMatrix = function vec3_convertPositionToLocalMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToLocalMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToWorldQuat = function vec3_convertPositionToWorldQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToWorldQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToLocalQuat = function vec3_convertPositionToLocalQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToLocalQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToWorld = function vec3_convertDirectionToWorld(parentTransform, out) {
    return Vec3Utils.convertDirectionToWorld(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToLocal = function vec3_convertDirectionToLocal(parentTransform, out) {
    return Vec3Utils.convertDirectionToLocal(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToWorldMatrix = function vec3_convertDirectionToWorldMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToWorldMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToLocalMatrix = function vec3_convertDirectionToLocalMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToLocalMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToWorldQuat = function vec3_convertDirectionToWorldQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToWorldQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToLocalQuat = function vec3_convertDirectionToLocalQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToLocalQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_addRotation = function vec3_addRotation(rotation, out) {
    return Vec3Utils.addRotation(this, rotation, out);
  };
  vec3Extension.vec3_addRotationDegrees = function vec3_addRotationDegrees(rotation, out) {
    return Vec3Utils.addRotationDegrees(this, rotation, out);
  };
  vec3Extension.vec3_addRotationRadians = function vec3_addRotationRadians(rotation, out) {
    return Vec3Utils.addRotationRadians(this, rotation, out);
  };
  vec3Extension.vec3_addRotationQuat = function vec3_addRotationQuat(rotation, out) {
    return Vec3Utils.addRotationQuat(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotation = function vec3_degreesAddRotation(rotation, out) {
    return Vec3Utils.degreesAddRotation(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotationDegrees = function vec3_degreesAddRotationDegrees(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.degreesAddRotationDegrees(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotationRadians = function vec3_degreesAddRotationRadians(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.degreesAddRotationRadians(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotationQuat = function vec3_degreesAddRotationQuat(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.degreesAddRotationQuat(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotation = function vec3_radiansAddRotation(rotation, out) {
    return Vec3Utils.radiansAddRotation(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotationDegrees = function vec3_radiansAddRotationDegrees(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.radiansAddRotationDegrees(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotationRadians = function vec3_radiansAddRotationRadians(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.radiansAddRotationRadians(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotationQuat = function vec3_radiansAddRotationQuat(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.radiansAddRotationQuat(this, rotation, out);
  };
  vec3Extension.vec3_toMatrix = function vec3_toMatrix(out = Mat3Utils.create()) {
    return Vec3Utils.toMatrix(this, out);
  };
  vec3Extension.vec3_degreesToMatrix = function vec3_degreesToMatrix(out = Mat3Utils.create()) {
    return Vec3Utils.degreesToMatrix(this, out);
  };
  vec3Extension.vec3_radiansToMatrix = function vec3_radiansToMatrix(out = Mat3Utils.create()) {
    return Vec3Utils.radiansToMatrix(this, out);
  };
  vec3Extension.vec3_rotationTo = function vec3_rotationTo(to, out) {
    return Vec3Utils.rotationTo(this, to, out);
  };
  vec3Extension.vec3_rotationToDegrees = function vec3_rotationToDegrees(to, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToDegrees(this, to, out);
  };
  vec3Extension.vec3_rotationToRadians = function vec3_rotationToRadians(to, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToRadians(this, to, out);
  };
  vec3Extension.vec3_rotationToQuat = function vec3_rotationToQuat(to, out = QuatUtils.create()) {
    return Vec3Utils.rotationToQuat(this, to, out);
  };
  vec3Extension.vec3_rotationToPivoted = function vec3_rotationToPivoted(to, pivotAxis, out) {
    return Vec3Utils.rotationToPivoted(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_rotationToPivotedDegrees = function vec3_rotationToPivotedDegrees(to, pivotAxis, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToPivotedDegrees(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_rotationToPivotedRadians = function vec3_rotationToPivotedRadians(to, pivotAxis, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToPivotedRadians(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_rotationToPivotedQuat = function vec3_rotationToPivotedQuat(to, pivotAxis, out = QuatUtils.create()) {
    return Vec3Utils.rotationToPivotedQuat(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_lerp = function vec3_lerp(to, interpolationFactor, out = Vec3Utils.create()) {
    return Vec3Utils.lerp(this, to, interpolationFactor, out);
  };
  vec3Extension.vec3_interpolate = function vec3_interpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec3Utils.create()) {
    return Vec3Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
  };
  vec3Extension.vec3_perpendicularRandom = function vec3_perpendicularRandom(out = Vec3Utils.create()) {
    return Vec3Utils.perpendicularRandom(this, out);
  };
  let vec4Extension = {};
  vec4Extension.vec4_set = function vec4_set(x, y, z, w) {
    return Vec4Utils.set(this, x, y, z, w);
  };
  vec4Extension.vec4_copy = function vec4_copy(vector) {
    return Vec4Utils.copy(vector, this);
  };
  vec4Extension.vec4_clone = function vec4_clone(out = Vec4Utils.create()) {
    return Vec4Utils.clone(this, out);
  };
  let quatExtension = {};
  quatExtension.quat_set = function quat_set(x, y, z, w) {
    return QuatUtils.set(this, x, y, z, w);
  };
  quatExtension.quat_normalize = function quat_normalize(out = QuatUtils.create()) {
    return QuatUtils.normalize(this, out);
  };
  quatExtension.quat_copy = function quat_copy(quat) {
    return QuatUtils.copy(quat, this);
  };
  quatExtension.quat_clone = function quat_clone(out = QuatUtils.create()) {
    return QuatUtils.clone(this, out);
  };
  quatExtension.quat_identity = function quat_identity() {
    return QuatUtils.identity(this);
  };
  quatExtension.quat_length = function quat_length() {
    return QuatUtils.length(this);
  };
  quatExtension.quat_lengthSquared = function quat_lengthSquared() {
    return QuatUtils.lengthSquared(this);
  };
  quatExtension.quat_invert = function quat_invert(out = QuatUtils.create()) {
    return QuatUtils.invert(this, out);
  };
  quatExtension.quat_conjugate = function quat_conjugate(out = QuatUtils.create()) {
    return QuatUtils.conjugate(this, out);
  };
  quatExtension.quat_mul = function quat_mul(rotation, out = QuatUtils.create()) {
    return QuatUtils.mul(this, rotation, out);
  };
  quatExtension.quat_getAxis = function quat_getAxis(out = Vec3Utils.create()) {
    return QuatUtils.getAxis(this, out);
  };
  quatExtension.quat_getAngle = function quat_getAngle() {
    return QuatUtils.getAngle(this);
  };
  quatExtension.quat_getAngleDegrees = function quat_getAngleDegrees() {
    return QuatUtils.getAngleDegrees(this);
  };
  quatExtension.quat_getAngleRadians = function quat_getAngleRadians() {
    return QuatUtils.getAngleRadians(this);
  };
  quatExtension.quat_getAxisScaled = function quat_getAxisScaled(out = Vec3Utils.create()) {
    return QuatUtils.getAxisScaled(this, out);
  };
  quatExtension.quat_getAxisScaledDegrees = function quat_getAxisScaledDegrees(out = Vec3Utils.create()) {
    return QuatUtils.getAxisScaledDegrees(this, out);
  };
  quatExtension.quat_getAxisScaledRadians = function quat_getAxisScaledRadians(out = Vec3Utils.create()) {
    return QuatUtils.getAxisScaledRadians(this, out);
  };
  quatExtension.quat_getAxes = function quat_getAxes(out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return QuatUtils.getAxes(this, out);
  };
  quatExtension.quat_getForward = function quat_getForward(out = Vec3Utils.create()) {
    return QuatUtils.getForward(this, out);
  };
  quatExtension.quat_getBackward = function quat_getBackward(out) {
    return QuatUtils.getBackward(this, out);
  };
  quatExtension.quat_getLeft = function quat_getLeft(out = Vec3Utils.create()) {
    return QuatUtils.getLeft(this, out);
  };
  quatExtension.quat_getRight = function quat_getRight(out) {
    return QuatUtils.getRight(this, out);
  };
  quatExtension.quat_getUp = function quat_getUp(out = Vec3Utils.create()) {
    return QuatUtils.getUp(this, out);
  };
  quatExtension.quat_getDown = function quat_getDown(out) {
    return QuatUtils.getDown(this, out);
  };
  quatExtension.quat_setAxes = function quat_setAxes(left, up, forward) {
    return QuatUtils.setAxes(this, left, up, forward);
  };
  quatExtension.quat_setForward = function quat_setForward(forward, up = null, left = null) {
    return QuatUtils.setForward(this, forward, up, left);
  };
  quatExtension.quat_setBackward = function quat_setBackward(backward, up = null, left = null) {
    return QuatUtils.setBackward(this, backward, up, left);
  };
  quatExtension.quat_setUp = function quat_setUp(up, forward = null, left = null) {
    return QuatUtils.setUp(this, up, forward, left);
  };
  quatExtension.quat_setDown = function quat_setDown(down, forward = null, left = null) {
    return QuatUtils.setDown(this, down, forward, left);
  };
  quatExtension.quat_setLeft = function quat_setLeft(left, up = null, forward = null) {
    return QuatUtils.setLeft(this, left, up, forward);
  };
  quatExtension.quat_setRight = function quat_setRight(right, up = null, forward = null) {
    return QuatUtils.setRight(this, right, up, forward);
  };
  quatExtension.quat_toWorld = function quat_toWorld(parentQuat, out = QuatUtils.create()) {
    return QuatUtils.toWorld(this, parentQuat, out);
  };
  quatExtension.quat_toLocal = function quat_toLocal(parentQuat, out = QuatUtils.create()) {
    return QuatUtils.toLocal(this, parentQuat, out);
  };
  quatExtension.quat_fromAxis = function quat_fromAxis(angle2, axis) {
    return QuatUtils.fromAxis(angle2, axis, this);
  };
  quatExtension.quat_fromAxisDegrees = function quat_fromAxisDegrees(angle2, axis) {
    return QuatUtils.fromAxisDegrees(angle2, axis, this);
  };
  quatExtension.quat_fromAxisRadians = function quat_fromAxisRadians(angle2, axis) {
    return QuatUtils.fromAxisRadians(angle2, axis, this);
  };
  quatExtension.quat_fromAxes = function quat_fromAxes(leftAxis, upAxis, forwardAxis) {
    return QuatUtils.fromAxes(leftAxis, upAxis, forwardAxis, this);
  };
  quatExtension.quat_fromRadians = function quat_fromRadians(radiansRotation) {
    return QuatUtils.fromRadians(radiansRotation, this);
  };
  quatExtension.quat_fromDegrees = function quat_fromDegrees(degreesRotation) {
    return QuatUtils.fromDegrees(degreesRotation, this);
  };
  quatExtension.quat_toRadians = function quat_toRadians(out = Vec3Utils.create()) {
    return QuatUtils.toRadians(this, out);
  };
  quatExtension.quat_toDegrees = function quat_toDegrees(out = Vec3Utils.create()) {
    return QuatUtils.toDegrees(this, out);
  };
  quatExtension.quat_isNormalized = function quat_isNormalized(epsilon = MathUtils.EPSILON) {
    return QuatUtils.isNormalized(this, epsilon);
  };
  quatExtension.quat_addRotation = function quat_addRotation(rotation, out) {
    return QuatUtils.addRotation(this, rotation, out);
  };
  quatExtension.quat_addRotationDegrees = function quat_addRotationDegrees(rotation, out) {
    return QuatUtils.addRotationDegrees(this, rotation, out);
  };
  quatExtension.quat_addRotationRadians = function quat_addRotationRadians(rotation, out) {
    return QuatUtils.addRotationRadians(this, rotation, out);
  };
  quatExtension.quat_addRotationQuat = function quat_addRotationQuat(rotation, out = QuatUtils.create()) {
    return QuatUtils.addRotationQuat(this, rotation, out);
  };
  quatExtension.quat_subRotation = function quat_subRotation(rotation, out) {
    return QuatUtils.subRotation(this, rotation, out);
  };
  quatExtension.quat_subRotationDegrees = function quat_subRotationDegrees(rotation, out) {
    return QuatUtils.subRotationDegrees(this, rotation, out);
  };
  quatExtension.quat_subRotationRadians = function quat_subRotationRadians(rotation, out) {
    return QuatUtils.subRotationRadians(this, rotation, out);
  };
  quatExtension.quat_subRotationQuat = function quat_subRotationQuat(rotation, out = QuatUtils.create()) {
    return QuatUtils.subRotationQuat(this, rotation, out);
  };
  quatExtension.quat_rotationTo = function quat_rotationTo(to, out) {
    return QuatUtils.rotationTo(this, to, out);
  };
  quatExtension.quat_rotationToDegrees = function quat_rotationToDegrees(to, out) {
    return QuatUtils.rotationToDegrees(this, to, out);
  };
  quatExtension.quat_rotationToRadians = function quat_rotationToRadians(to, out) {
    return QuatUtils.rotationToRadians(this, to, out);
  };
  quatExtension.quat_rotationToQuat = function quat_rotationToQuat(to, out) {
    return QuatUtils.rotationToQuat(this, to, out);
  };
  quatExtension.quat_rotationAroundAxis = function quat_rotationAroundAxis(axis, out) {
    return QuatUtils.rotationAroundAxis(this, axis, out);
  };
  quatExtension.quat_rotationAroundAxisDegrees = function quat_rotationAroundAxisDegrees(axis, out = Vec3Utils.create()) {
    return QuatUtils.rotationAroundAxisDegrees(this, axis, out);
  };
  quatExtension.quat_rotationAroundAxisRadians = function quat_rotationAroundAxisRadians(axis, out = Vec3Utils.create()) {
    return QuatUtils.rotationAroundAxisRadians(this, axis, out);
  };
  quatExtension.quat_rotationAroundAxisQuat = function quat_rotationAroundAxisQuat(axis, out = QuatUtils.create()) {
    return QuatUtils.rotationAroundAxisQuat(this, axis, out);
  };
  quatExtension.quat_getTwist = function quat_getTwist(axis, out = QuatUtils.create()) {
    return QuatUtils.getTwist(this, axis, out);
  };
  quatExtension.quat_getSwing = function quat_getSwing(axis, out = QuatUtils.create()) {
    return QuatUtils.getSwing(this, axis, out);
  };
  quatExtension.quat_getSwingFromTwist = function quat_getSwingFromTwist(twist, out = QuatUtils.create()) {
    return QuatUtils.getSwingFromTwist(this, twist, out);
  };
  quatExtension.quat_getTwistFromSwing = function quat_getTwistFromSwing(swing, out = QuatUtils.create()) {
    return QuatUtils.getTwistFromSwing(this, swing, out);
  };
  quatExtension.quat_fromTwistSwing = function quat_fromTwistSwing(twist, swing) {
    return QuatUtils.fromTwistSwing(twist, swing, this);
  };
  quatExtension.quat_toMatrix = function quat_toMatrix(out = Mat3Utils.create()) {
    return QuatUtils.toMatrix(this, out);
  };
  quatExtension.quat_rotate = function quat_rotate(rotation, out) {
    return QuatUtils.rotate(this, rotation, out);
  };
  quatExtension.quat_rotateDegrees = function quat_rotateDegrees(rotation, out) {
    return QuatUtils.rotateDegrees(this, rotation, out);
  };
  quatExtension.quat_rotateRadians = function quat_rotateRadians(rotation, out) {
    return QuatUtils.rotateRadians(this, rotation, out);
  };
  quatExtension.quat_rotateQuat = function quat_rotateQuat(rotation, out) {
    return QuatUtils.rotateQuat(this, rotation, out);
  };
  quatExtension.quat_rotateAxis = function quat_rotateAxis(angle2, axis, out) {
    return QuatUtils.rotateAxis(this, angle2, axis, out);
  };
  quatExtension.quat_rotateAxisDegrees = function quat_rotateAxisDegrees(angle2, axis, out) {
    return QuatUtils.rotateAxisDegrees(this, angle2, axis, out);
  };
  quatExtension.quat_rotateAxisRadians = function quat_rotateAxisRadians(angle2, axis, out) {
    return QuatUtils.rotateAxisRadians(this, angle2, axis, out);
  };
  quatExtension.quat_lerp = function quat_lerp(to, interpolationFactor, out = QuatUtils.create()) {
    return QuatUtils.lerp(this, to, interpolationFactor, out);
  };
  quatExtension.quat_interpolate = function quat_interpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
    return QuatUtils.interpolate(this, to, interpolationFactor, easingFunction, out);
  };
  quatExtension.quat_slerp = function quat_slerp(to, interpolationFactor, out = QuatUtils.create()) {
    return QuatUtils.slerp(this, to, interpolationFactor, out);
  };
  quatExtension.quat_sinterpolate = function quat_sinterpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
    return QuatUtils.sinterpolate(this, to, interpolationFactor, easingFunction, out);
  };
  let quat2Extension = {};
  quat2Extension.quat2_set = function quat2_set(x1, y1, z1, w1, x2, y2, z2, w2) {
    return Quat2Utils.set(this, x1, y1, z1, w1, x2, y2, z2, w2);
  };
  quat2Extension.quat2_normalize = function quat2_normalize(out = Quat2Utils.create()) {
    return Quat2Utils.normalize(this, out);
  };
  quat2Extension.quat2_invert = function quat2_invert(out = Quat2Utils.create()) {
    return Quat2Utils.invert(this, out);
  };
  quat2Extension.quat2_conjugate = function quat2_conjugate(out = Quat2Utils.create()) {
    return Quat2Utils.conjugate(this, out);
  };
  quat2Extension.quat2_copy = function quat2_copy(quat) {
    return Quat2Utils.copy(quat, this);
  };
  quat2Extension.quat2_identity = function quat2_identity() {
    return Quat2Utils.identity(this);
  };
  quat2Extension.quat2_getPosition = function quat2_getPosition(out = Vec3Utils.create()) {
    return Quat2Utils.getPosition(this, out);
  };
  quat2Extension.quat2_getRotation = function quat2_getRotation(out) {
    return Quat2Utils.getRotation(this, out);
  };
  quat2Extension.quat2_getRotationDegrees = function quat2_getRotationDegrees(out = Vec3Utils.create()) {
    return Quat2Utils.getRotationDegrees(this, out);
  };
  quat2Extension.quat2_getRotationRadians = function quat2_getRotationRadians(out = Vec3Utils.create()) {
    return Quat2Utils.getRotationRadians(this, out);
  };
  quat2Extension.quat2_getRotationQuat = function quat2_getRotationQuat(out = QuatUtils.create()) {
    return Quat2Utils.getRotationQuat(this, out);
  };
  quat2Extension.quat2_setPosition = function quat2_setPosition(position) {
    return Quat2Utils.setPosition(this, position);
  };
  quat2Extension.quat2_setRotation = function quat2_setRotation(rotation) {
    return Quat2Utils.setRotation(this, rotation);
  };
  quat2Extension.quat2_setRotationDegrees = function quat2_setRotationDegrees(rotation) {
    return Quat2Utils.setRotationDegrees(this, rotation);
  };
  quat2Extension.quat2_setRotationRadians = function quat2_setRotationRadians(rotation) {
    return Quat2Utils.setRotationRadians(this, rotation);
  };
  quat2Extension.quat2_setRotationQuat = function quat2_setRotationQuat(rotation) {
    return Quat2Utils.setRotationQuat(this, rotation);
  };
  quat2Extension.quat2_setPositionRotation = function quat2_setPositionRotation(position, rotation) {
    return Quat2Utils.setPositionRotation(this, position, rotation);
  };
  quat2Extension.quat2_setPositionRotationDegrees = function quat2_setPositionRotationDegrees(position, rotation) {
    return Quat2Utils.setPositionRotationDegrees(this, position, rotation);
  };
  quat2Extension.quat2_setPositionRotationRadians = function quat2_setPositionRotationRadians(position, rotation) {
    return Quat2Utils.setPositionRotationRadians(this, position, rotation);
  };
  quat2Extension.quat2_setPositionRotationQuat = function quat2_setPositionRotationQuat(position, rotation) {
    return Quat2Utils.setPositionRotationQuat(this, position, rotation);
  };
  quat2Extension.quat2_isNormalized = function quat2_isNormalized(epsilon = MathUtils.EPSILON) {
    return Quat2Utils.isNormalized(this, epsilon);
  };
  quat2Extension.quat2_length = function quat2_length() {
    return Quat2Utils.length(this);
  };
  quat2Extension.quat2_lengthSquared = function quat2_lengthSquared() {
    return Quat2Utils.lengthSquared(this);
  };
  quat2Extension.quat2_mul = function quat2_mul(quat, out = Quat2Utils.create()) {
    return Quat2Utils.mul(this, quat, out);
  };
  quat2Extension.quat2_getAxes = function quat2_getAxes(out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return Quat2Utils.getAxes(this, out);
  };
  quat2Extension.quat2_getForward = function quat2_getForward(out = Vec3Utils.create()) {
    return Quat2Utils.getForward(this, out);
  };
  quat2Extension.quat2_getBackward = function quat2_getBackward(out) {
    return Quat2Utils.getBackward(this, out);
  };
  quat2Extension.quat2_getLeft = function quat2_getLeft(out = Vec3Utils.create()) {
    return Quat2Utils.getLeft(this, out);
  };
  quat2Extension.quat2_getRight = function quat2_getRight(out) {
    return Quat2Utils.getRight(this, out);
  };
  quat2Extension.quat2_getUp = function quat2_getUp(out = Vec3Utils.create()) {
    return Quat2Utils.getUp(this, out);
  };
  quat2Extension.quat2_getDown = function quat2_getDown(out) {
    return Quat2Utils.getDown(this, out);
  };
  quat2Extension.quat2_toWorld = function quat2_toWorld(parentTransformQuat, out = Quat2Utils.create()) {
    return Quat2Utils.toWorld(this, parentTransformQuat, out);
  };
  quat2Extension.quat2_toLocal = function quat2_toLocal(parentTransformQuat, out = Quat2Utils.create()) {
    return Quat2Utils.toLocal(this, parentTransformQuat, out);
  };
  quat2Extension.quat2_rotateAxis = function quat2_rotateAxis(angle2, axis, out) {
    return Quat2Utils.rotateAxis(this, angle2, axis, out);
  };
  quat2Extension.quat2_rotateAxisDegrees = function quat2_rotateAxisDegrees(angle2, axis, out) {
    return Quat2Utils.rotateAxisDegrees(this, angle2, axis, out);
  };
  quat2Extension.quat2_rotateAxisRadians = function quat2_rotateAxisRadians(angle2, axis, out = Quat2Utils.create()) {
    return Quat2Utils.rotateAxisRadians(this, angle2, axis, out);
  };
  quat2Extension.quat2_toMatrix = function quat2_toMatrix(out = Mat4Utils.create()) {
    return Quat2Utils.toMatrix(this, out);
  };
  quat2Extension.quat2_fromMatrix = function quat2_fromMatrix(matrix) {
    return Quat2Utils.fromMatrix(matrix, this);
  };
  quat2Extension.quat2_lerp = function quat2_lerp(to, interpolationFactor, out = Quat2Utils.create()) {
    return Quat2Utils.lerp(this, to, interpolationFactor, out);
  };
  quat2Extension.quat2_interpolate = function quat2_interpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
    return Quat2Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
  };
  quat2Extension.quat2_slerp = function quat2_slerp(to, interpolationFactor, out = Quat2Utils.create()) {
    return Quat2Utils.slerp(this, to, interpolationFactor, out);
  };
  quat2Extension.quat2_sinterpolate = function quat2_sinterpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
    return Quat2Utils.sinterpolate(this, to, interpolationFactor, easingFunction, out);
  };
  let mat3Extension = {};
  mat3Extension.mat3_set = function mat3_set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    return Mat3Utils.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);
  };
  mat3Extension.mat3_toDegrees = function mat3_toDegrees(out = Vec3Utils.create()) {
    return Mat3Utils.toDegrees(this, out);
  };
  mat3Extension.mat3_toRadians = function mat3_toRadians(out = Vec3Utils.create()) {
    return Mat3Utils.toRadians(this, out);
  };
  mat3Extension.mat3_toQuat = function mat3_toQuat(out = QuatUtils.create()) {
    return Mat3Utils.toQuat(this, out);
  };
  mat3Extension.mat3_fromAxes = function mat3_fromAxes(leftAxis, upAxis, forwardAxis) {
    return Mat3Utils.fromAxes(leftAxis, upAxis, forwardAxis, this);
  };
  let mat4Extension = {};
  mat4Extension.mat4_set = function mat4_set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    return Mat4Utils.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
  };
  mat4Extension.mat4_copy = function mat4_copy(matrix) {
    return Mat4Utils.copy(matrix, this);
  };
  mat4Extension.mat4_identity = function mat4_identity() {
    return Mat4Utils.identity(this);
  };
  mat4Extension.mat4_invert = function mat4_invert(out = Mat4Utils.create()) {
    return Mat4Utils.invert(this, out);
  };
  mat4Extension.mat4_mul = function mat4_mul(matrix, out = Mat4Utils.create()) {
    return Mat4Utils.mul(this, matrix, out);
  };
  mat4Extension.mat4_scale = function mat4_scale(vector, out = Mat4Utils.create()) {
    return Mat4Utils.scale(this, vector, out);
  };
  mat4Extension.mat4_clone = function mat4_clone(out = Mat4Utils.create()) {
    return Mat4Utils.clone(this, out);
  };
  mat4Extension.mat4_getPosition = function mat4_getPosition(out = Vec3Utils.create()) {
    return Mat4Utils.getPosition(this, out);
  };
  mat4Extension.mat4_getRotation = function mat4_getRotation(out = Vec3Utils.create()) {
    return Mat4Utils.getRotation(this, out);
  };
  mat4Extension.mat4_getRotationDegrees = function mat4_getRotationDegrees(out = Vec3Utils.create()) {
    return Mat4Utils.getRotationDegrees(this, out);
  };
  mat4Extension.mat4_getRotationRadians = function mat4_getRotationRadians(out = Vec3Utils.create()) {
    return Mat4Utils.getRotationRadians(this, out);
  };
  mat4Extension.mat4_getRotationQuat = function mat4_getRotationQuat(out = QuatUtils.create()) {
    return Mat4Utils.getRotationQuat(this, out);
  };
  mat4Extension.mat4_getScale = function mat4_getScale(out = Vec3Utils.create()) {
    return Mat4Utils.getScale(this, out);
  };
  mat4Extension.mat4_setPosition = function mat4_setPosition(position) {
    return Mat4Utils.setPosition(this, position);
  };
  mat4Extension.mat4_setRotation = function mat4_setRotation(rotation) {
    return Mat4Utils.setRotation(this, rotation);
  };
  mat4Extension.mat4_setRotationDegrees = function mat4_setRotationDegrees(rotation) {
    return Mat4Utils.setRotationDegrees(this, rotation);
  };
  mat4Extension.mat4_setRotationRadians = function mat4_setRotationRadians(rotation) {
    return Mat4Utils.setRotationRadians(this, rotation);
  };
  mat4Extension.mat4_setRotationQuat = function mat4_setRotationQuat(rotation) {
    return Mat4Utils.setRotationQuat(this, rotation);
  };
  mat4Extension.mat4_setScale = function mat4_setScale(scale4) {
    return Mat4Utils.setScale(this, scale4);
  };
  mat4Extension.mat4_setPositionRotationScale = function mat4_setPositionRotationScale(position, rotation, scale4) {
    return Mat4Utils.setPositionRotationScale(this, position, rotation, scale4);
  };
  mat4Extension.mat4_setPositionRotationDegreesScale = function mat4_setPositionRotationDegreesScale(position, rotation, scale4) {
    return Mat4Utils.setPositionRotationDegreesScale(this, position, rotation, scale4);
  };
  mat4Extension.mat4_setPositionRotationRadiansScale = function mat4_setPositionRotationRadiansScale(position, rotation, scale4) {
    return Mat4Utils.setPositionRotationRadiansScale(this, position, rotation, scale4);
  };
  mat4Extension.mat4_setPositionRotationQuatScale = function mat4_setPositionRotationQuatScale(position, rotation, scale4) {
    return Mat4Utils.setPositionRotationQuatScale(this, position, rotation, scale4);
  };
  mat4Extension.mat4_setPositionRotation = function mat4_setPositionRotation(position, rotation) {
    return Mat4Utils.setPositionRotation(this, position, rotation);
  };
  mat4Extension.mat4_setPositionRotationDegrees = function mat4_setPositionRotationDegrees(position, rotation) {
    return Mat4Utils.setPositionRotationDegrees(this, position, rotation);
  };
  mat4Extension.mat4_setPositionRotationRadians = function mat4_setPositionRotationRadians(position, rotation) {
    return Mat4Utils.setPositionRotationRadians(this, position, rotation);
  };
  mat4Extension.mat4_setPositionRotationQuat = function mat4_setPositionRotationQuat(position, rotation) {
    return Mat4Utils.setPositionRotationQuat(this, position, rotation);
  };
  mat4Extension.mat4_getAxes = function mat4_getAxes(out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return Mat4Utils.getAxes(this, out);
  };
  mat4Extension.mat4_getForward = function mat4_getForward(out = Vec3Utils.create()) {
    return Mat4Utils.getForward(this, out);
  };
  mat4Extension.mat4_getBackward = function mat4_getBackward(out) {
    return Mat4Utils.getBackward(this, out);
  };
  mat4Extension.mat4_getLeft = function mat4_getLeft(out = Vec3Utils.create()) {
    return Mat4Utils.getLeft(this, out);
  };
  mat4Extension.mat4_getRight = function mat4_getRight(out) {
    return Mat4Utils.getRight(this, out);
  };
  mat4Extension.mat4_getUp = function mat4_getUp(out = Vec3Utils.create()) {
    return Mat4Utils.getUp(this, out);
  };
  mat4Extension.mat4_getDown = function mat4_getDown(out) {
    return Mat4Utils.getDown(this, out);
  };
  mat4Extension.mat4_toWorld = function mat4_toWorld(parentTransformMatrix, out = Mat4Utils.create()) {
    return Mat4Utils.toWorld(this, parentTransformMatrix, out);
  };
  mat4Extension.mat4_toLocal = function mat4_toLocal(parentTransformMatrix, out = Mat4Utils.create()) {
    return Mat4Utils.toLocal(this, parentTransformMatrix, out);
  };
  mat4Extension.mat4_hasUniformScale = function mat4_hasUniformScale() {
    return Mat4Utils.hasUniformScale(this);
  };
  mat4Extension.mat4_toQuat = function mat4_toQuat(out = Quat2Utils.create()) {
    return Mat4Utils.toQuat(this, out);
  };
  mat4Extension.mat4_fromQuat = function mat4_fromQuat(quat) {
    return Mat4Utils.fromQuat(quat, this);
  };
  let arrayPrototypesToExtend = [
    Array.prototype,
    Uint8ClampedArray.prototype,
    Uint8Array.prototype,
    Uint16Array.prototype,
    Uint32Array.prototype,
    Int8Array.prototype,
    Int16Array.prototype,
    Int32Array.prototype,
    Float32Array.prototype,
    Float64Array.prototype
  ];
  for (let arrayPrototypeToExtend of arrayPrototypesToExtend) {
    PluginUtils.injectProperties(arrayExtension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vecExtension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vec2Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vec3Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vec4Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(quatExtension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(quat2Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(mat3Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(mat4Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(arrayExtension, arrayPrototypeToExtend, false, true, true);
  }
}

// dist/cauldron/utils/mesh_utils.js
var MeshCreationVertexParams = class {
  constructor() {
    this.myPosition = null;
    this.myTextureCoordinates = null;
    this.myNormal = null;
    this.myColor = null;
  }
};
var MeshCreationTriangleParams = class {
  constructor() {
    this.myIndexes = new Uint32Array(3);
  }
};
var MeshCreationParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myVertexes = [];
    this.myTriangles = [];
    this.myEngine = engine;
  }
};
function create8(meshCreationParams) {
  let indexData = [];
  for (let triangle of meshCreationParams.myTriangles) {
    indexData.push(triangle.myIndexes[0]);
    indexData.push(triangle.myIndexes[1]);
    indexData.push(triangle.myIndexes[2]);
  }
  let indexDataUnsignedInt = new Uint32Array(indexData.length);
  indexDataUnsignedInt.pp_copy(indexData);
  let vertexCount = meshCreationParams.myVertexes.length;
  let mesh = new Mesh(meshCreationParams.myEngine, {
    vertexCount,
    indexData: indexDataUnsignedInt,
    indexType: MeshIndexType.UnsignedInt
  });
  let positionAttribute = null;
  let textureCoordinatesAttribute = null;
  let normalAttribute = null;
  let colorAttribute = null;
  try {
    positionAttribute = mesh.attribute(MeshAttribute.Position);
  } catch (error3) {
    positionAttribute = null;
  }
  try {
    textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
  } catch (error3) {
    textureCoordinatesAttribute = null;
  }
  try {
    normalAttribute = mesh.attribute(MeshAttribute.Normal);
  } catch (error3) {
    normalAttribute = null;
  }
  try {
    colorAttribute = mesh.attribute(MeshAttribute.Color);
  } catch (error3) {
    colorAttribute = null;
  }
  for (let i = 0; i < meshCreationParams.myVertexes.length; i++) {
    let vertex = meshCreationParams.myVertexes[i];
    if (positionAttribute != null && vertex.myPosition) {
      positionAttribute.set(i, vertex.myPosition);
    }
    if (textureCoordinatesAttribute != null && vertex.myTextureCoordinates) {
      textureCoordinatesAttribute.set(i, vertex.myTextureCoordinates);
    }
    if (normalAttribute != null && vertex.myNormal) {
      normalAttribute.set(i, vertex.myNormal);
    }
    if (colorAttribute != null && vertex.myColor) {
      colorAttribute.set(i, vertex.myColor);
    }
  }
  return mesh;
}
var clone8 = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal = vec3_create();
  let color = vec4_create();
  return function clone10(mesh) {
    if (mesh == null) {
      return null;
    }
    let clonedIndexData = mesh.indexData.pp_clone();
    let clonedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount,
      indexData: clonedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let clonedPositionAttribute = null;
    let clonedTextureCoordinatesAttribute = null;
    let clonedNormalAttribute = null;
    let clonedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      clonedPositionAttribute = clonedMesh.attribute(MeshAttribute.Position);
    } catch (error3) {
      positionAttribute = null;
      clonedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      clonedTextureCoordinatesAttribute = clonedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error3) {
      textureCoordinatesAttribute = null;
      clonedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      clonedNormalAttribute = clonedMesh.attribute(MeshAttribute.Normal);
    } catch (error3) {
      normalAttribute = null;
      clonedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      clonedColorAttribute = clonedMesh.attribute(MeshAttribute.Color);
    } catch (error3) {
      colorAttribute = null;
      clonedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && clonedPositionAttribute != null) {
        clonedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && clonedTextureCoordinatesAttribute != null) {
        clonedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && clonedNormalAttribute != null) {
        clonedNormalAttribute.set(i, normalAttribute.get(i, normal));
      }
      if (colorAttribute != null && clonedColorAttribute != null) {
        clonedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return clonedMesh;
  };
}();
var invert4 = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal = vec3_create();
  let color = vec4_create();
  return function invert5(mesh) {
    if (mesh == null) {
      return null;
    }
    let invertedIndexData = new Uint32Array(mesh.indexData.length);
    for (let i = 0; i < mesh.indexData.length / 3; i++) {
      invertedIndexData[i * 3 + 0] = mesh.indexData[i * 3 + 2];
      invertedIndexData[i * 3 + 1] = mesh.indexData[i * 3 + 1];
      invertedIndexData[i * 3 + 2] = mesh.indexData[i * 3 + 0];
    }
    let invertedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount,
      indexData: invertedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let invertedPositionAttribute = null;
    let invertedTextureCoordinatesAttribute = null;
    let invertedNormalAttribute = null;
    let invertedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      invertedPositionAttribute = invertedMesh.attribute(MeshAttribute.Position);
    } catch (error3) {
      positionAttribute = null;
      invertedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      invertedTextureCoordinatesAttribute = invertedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error3) {
      textureCoordinatesAttribute = null;
      invertedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      invertedNormalAttribute = invertedMesh.attribute(MeshAttribute.Normal);
    } catch (error3) {
      normalAttribute = null;
      invertedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      invertedColorAttribute = invertedMesh.attribute(MeshAttribute.Color);
    } catch (error3) {
      colorAttribute = null;
      invertedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && invertedPositionAttribute != null) {
        invertedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && invertedTextureCoordinatesAttribute != null) {
        invertedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && invertedNormalAttribute != null) {
        normalAttribute.get(i, normal);
        normal.vec3_negate(normal);
        invertedNormalAttribute.set(i, normal);
      }
      if (colorAttribute != null && invertedColorAttribute != null) {
        invertedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return invertedMesh;
  };
}();
var makeDoubleSided = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal = vec3_create();
  let color = vec4_create();
  return function makeDoubleSided2(mesh) {
    if (mesh == null) {
      return null;
    }
    let doubleSidedIndexData = new Uint32Array(mesh.indexData.length * 2);
    for (let i = 0; i < doubleSidedIndexData.length / 3; i++) {
      doubleSidedIndexData[i * 3 * 2 + 0] = mesh.indexData[i * 3 + 0] * 2;
      doubleSidedIndexData[i * 3 * 2 + 1] = mesh.indexData[i * 3 + 1] * 2;
      doubleSidedIndexData[i * 3 * 2 + 2] = mesh.indexData[i * 3 + 2] * 2;
      doubleSidedIndexData[i * 3 * 2 + 3] = mesh.indexData[i * 3 + 2] * 2 + 1;
      doubleSidedIndexData[i * 3 * 2 + 4] = mesh.indexData[i * 3 + 1] * 2 + 1;
      doubleSidedIndexData[i * 3 * 2 + 5] = mesh.indexData[i * 3 + 0] * 2 + 1;
    }
    let doubleSidedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount * 2,
      indexData: doubleSidedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let doubleSidedPositionAttribute = null;
    let doubleSidedTextureCoordinatesAttribute = null;
    let doubleSidedNormalAttribute = null;
    let doubleSidedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      doubleSidedPositionAttribute = doubleSidedMesh.attribute(MeshAttribute.Position);
    } catch (error3) {
      positionAttribute = null;
      doubleSidedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      doubleSidedTextureCoordinatesAttribute = doubleSidedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error3) {
      textureCoordinatesAttribute = null;
      doubleSidedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      doubleSidedNormalAttribute = doubleSidedMesh.attribute(MeshAttribute.Normal);
    } catch (error3) {
      normalAttribute = null;
      doubleSidedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      doubleSidedColorAttribute = doubleSidedMesh.attribute(MeshAttribute.Color);
    } catch (error3) {
      colorAttribute = null;
      doubleSidedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && doubleSidedPositionAttribute != null) {
        doubleSidedPositionAttribute.set(i * 2, positionAttribute.get(i, position));
        doubleSidedPositionAttribute.set(i * 2 + 1, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && doubleSidedTextureCoordinatesAttribute != null) {
        doubleSidedTextureCoordinatesAttribute.set(i * 2, textureCoordinatesAttribute.get(i, textureCoordinates));
        doubleSidedTextureCoordinatesAttribute.set(i * 2 + 1, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && doubleSidedNormalAttribute != null) {
        normalAttribute.get(i, normal);
        doubleSidedNormalAttribute.set(i * 2, normal);
        let invertedNormal = normal.vec3_negate();
        doubleSidedNormalAttribute.set(i * 2 + 1, invertedNormal);
      }
      if (colorAttribute != null && doubleSidedColorAttribute != null) {
        doubleSidedColorAttribute.set(i * 2, colorAttribute.get(i, color));
        doubleSidedColorAttribute.set(i * 2 + 1, colorAttribute.get(i, color));
      }
    }
    return doubleSidedMesh;
  };
}();
function createPlane(engine = Globals.getMainEngine()) {
  let vertexCount = 4;
  let meshCreationParams = new MeshCreationParams(engine);
  for (let i = 0; i < vertexCount; ++i) {
    let vertexCreationParams = new MeshCreationVertexParams();
    vertexCreationParams.myPosition = new vec3_create();
    vertexCreationParams.myPosition[0] = -1 + (i & 1) * 2;
    vertexCreationParams.myPosition[1] = -1 + ((i & 2) >> 1) * 2;
    vertexCreationParams.myPosition[2] = 0;
    vertexCreationParams.myTextureCoordinates = new vec2_create();
    vertexCreationParams.myTextureCoordinates[0] = i & 1;
    vertexCreationParams.myTextureCoordinates[1] = (i & 2) >> 1;
    vertexCreationParams.myNormal = new vec3_create();
    vertexCreationParams.myNormal[0] = 0;
    vertexCreationParams.myNormal[1] = 0;
    vertexCreationParams.myNormal[2] = 1;
    meshCreationParams.myVertexes.push(vertexCreationParams);
  }
  let firstTriangle = new MeshCreationTriangleParams();
  firstTriangle.myIndexes[0] = 0;
  firstTriangle.myIndexes[1] = 1;
  firstTriangle.myIndexes[2] = 2;
  let secondTriangle = new MeshCreationTriangleParams();
  secondTriangle.myIndexes[0] = 2;
  secondTriangle.myIndexes[1] = 1;
  secondTriangle.myIndexes[2] = 3;
  meshCreationParams.myTriangles.push(firstTriangle);
  meshCreationParams.myTriangles.push(secondTriangle);
  let mesh = MeshUtils.create(meshCreationParams);
  return mesh;
}
var MeshUtils = {
  create: create8,
  clone: clone8,
  invert: invert4,
  makeDoubleSided,
  createPlane
};

// dist/cauldron/wl/utils/default_wl_component_clone_callbacks.js
function cloneMesh(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject, true);
  if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent.TypeName, "material")) {
    if (componentToClone.material != null) {
      clonedComponent.material = componentToClone.material.clone();
    }
  }
  if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent.TypeName, "mesh")) {
    clonedComponent.mesh = MeshUtils.clone(componentToClone.mesh);
  }
  return clonedComponent;
}
function cloneCollision(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  return clonedComponent;
}
function cloneText(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  if (deepCloneParams.isDeepCloneComponentVariable(TextComponent.TypeName, "material")) {
    if (componentToClone.material != null) {
      clonedComponent.material = componentToClone.material.clone();
    }
  }
  return clonedComponent;
}
function clonePhysX(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  return clonedComponent;
}
var DefaultWLComponentCloneCallbacks = {
  cloneMesh,
  cloneCollision,
  cloneText,
  clonePhysX
};

// dist/cauldron/wl/utils/component_utils.js
var _myCloneCallbacks = /* @__PURE__ */ new WeakMap();
var _myClonePostProcessCallbacks = /* @__PURE__ */ new WeakMap();
var DeepCloneParams = class {
  constructor() {
    this._myDeepCloneComponents = false;
    this._myDeepCloneOverrideComponentsMap = /* @__PURE__ */ new Map();
    this._myDeepCloneOverrideComponentsVariablesMap = /* @__PURE__ */ new Map();
  }
  // The implementation is component dependant, not every component implements the deep clone
  setDeepCloneComponents(deepClone) {
    this._myDeepCloneComponents = deepClone;
  }
  // This value override the deep clone components value
  // The implementation is component dependant, not every component implements the deep clone
  setDeepCloneComponent(componentName, deepClone) {
    this._myDeepCloneOverrideComponentsMap.set(componentName, deepClone);
  }
  // This value override both the deep clone components value and the deep clone component override one
  // The implementation is component dependant, not every component variable override is taken into consideration
  setDeepCloneComponentVariable(componentName, variableName, deepClone) {
    let componentsVariablesMap = null;
    if (!this._myDeepCloneOverrideComponentsVariablesMap.has(componentName)) {
      this._myDeepCloneOverrideComponentsVariablesMap.set(componentName, /* @__PURE__ */ new Map());
    }
    componentsVariablesMap = this._myDeepCloneOverrideComponentsVariablesMap.get(componentName);
    componentsVariablesMap.set(variableName, deepClone);
  }
  isDeepCloneComponent(componentName) {
    let deepCloneOverride = this._myDeepCloneOverrideComponentsMap.get(componentName);
    if (deepCloneOverride != null) {
      return deepCloneOverride;
    }
    return this._myDeepCloneComponents;
  }
  isDeepCloneComponentVariable(componentName, variableName) {
    let componentsVariablesMap = this._myDeepCloneOverrideComponentsVariablesMap.get(componentName);
    if (componentsVariablesMap != null) {
      let deepCloneOverride = componentsVariablesMap.get(variableName);
      if (deepCloneOverride != null) {
        return deepCloneOverride;
      }
    }
    return this.isDeepCloneComponent(componentName);
  }
};
var CustomCloneParams = class {
  constructor() {
    this._myParams = /* @__PURE__ */ new Map();
  }
  addParam(name, value) {
    this._myParams.set(name, value);
  }
  removeParam(name) {
    this._myParams.delete(name);
  }
  getParam(name) {
    this._myParams.get(name);
  }
  hasParam(name) {
    this._myParams.has(name);
  }
};
function isWLComponent(typeOrClass) {
  return ComponentUtils.isWLNativeComponent(typeOrClass) || ComponentUtils.isWLJavascriptComponent(typeOrClass);
}
function isWLNativeComponent(typeOrClass) {
  let wlNative = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (ComponentUtils.getWLNativeComponentTypes().includes(type)) {
    wlNative = true;
  }
  return wlNative;
}
function isWLJavascriptComponent(typeOrClass) {
  let wlJavascript = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (ComponentUtils.getWLJavascriptComponentTypes().includes(type)) {
    wlJavascript = true;
  }
  return wlJavascript;
}
function getWLNativeComponentTypes() {
  return _myWLNativeComponentTypes;
}
function getWLJavascriptComponentTypes() {
  return _myWLJavascriptComponentTypes;
}
function getTypeFromTypeOrClass(typeOrClass) {
  if (typeOrClass == null)
    return;
  let type = typeOrClass;
  if (typeOrClass.TypeName != null) {
    type = typeOrClass.TypeName;
  }
  return type;
}
function getClassFromType(type, engine = Globals.getMainEngine()) {
  let classToReturn = null;
  if (ComponentUtils.isWLNativeComponent(type)) {
    if (ComponentUtils.isWLNativeComponentRegistered(type, engine)) {
      switch (type) {
        case AnimationComponent.TypeName:
          classToReturn = AnimationComponent;
          break;
        case CollisionComponent.TypeName:
          classToReturn = CollisionComponent;
          break;
        case InputComponent.TypeName:
          classToReturn = InputComponent;
          break;
        case LightComponent.TypeName:
          classToReturn = LightComponent;
          break;
        case MeshComponent2.TypeName:
          classToReturn = MeshComponent2;
          break;
        case PhysXComponent.TypeName:
          classToReturn = PhysXComponent;
          break;
        case TextComponent2.TypeName:
          classToReturn = TextComponent2;
          break;
        case ViewComponent.TypeName:
          classToReturn = ViewComponent;
          break;
        default:
          classToReturn = null;
      }
    }
  } else {
    classToReturn = ComponentUtils.getJavascriptComponentClass(type, engine);
  }
  return classToReturn;
}
function isRegistered(typeOrClass, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return ComponentUtils.getClassFromType(type, engine) != null;
}
function getJavascriptComponentInstances(engine = Globals.getMainEngine()) {
  return Globals.getWASM(engine)._components;
}
function getJavascriptComponentClass(type, engine = Globals.getMainEngine()) {
  return ComponentUtils.getJavascriptComponentClassesByIndex(engine)[ComponentUtils.getJavascriptComponentTypeIndex(type, engine)];
}
function getJavascriptComponentClassesByIndex(engine = Globals.getMainEngine()) {
  return Globals.getWASM(engine)._componentTypes;
}
function getJavascriptComponentTypeIndex(typeOrClass, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return ComponentUtils.getJavascriptComponentTypeIndexes(engine)[type];
}
function getJavascriptComponentTypeIndexes(engine = Globals.getMainEngine()) {
  return Globals.getWASM(engine)._componentTypeIndices;
}
function getJavascriptComponentTypeFromIndex(typeIndex, engine = Globals.getMainEngine()) {
  let type = null;
  let componentClass = ComponentUtils.getJavascriptComponentClassesByIndex(engine)[typeIndex];
  if (componentClass != null) {
    type = componentClass.TypeName;
  }
  return type;
}
function isWLNativeComponentRegistered(typeOrClass, engine = Globals.getMainEngine()) {
  let wasm = Globals.getWASM(engine);
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return wasm._wl_get_component_manager_index(wasm.tempUTF8(type)) >= 0;
}
function isCloneable2(typeOrClass, defaultCloneValid = false, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return defaultCloneValid || ComponentUtils.hasCloneCallback(type, engine) || ComponentUtils.getClassFromType(type, engine)?.prototype.pp_clone != null;
}
function hasClonePostProcess(typeOrClass, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return ComponentUtils.hasClonePostProcessCallback(type, engine) || ComponentUtils.getClassFromType(type, engine)?.prototype.pp_clonePostProcess != null;
}
function clone9(componentToClone, targetObject, deeCloneParams, customCloneParams, useDefaultCloneAsFallback = false, defaultCloneAutoStartIfNotActive = true) {
  let clonedComponent = null;
  let cloneCallback = ComponentUtils.getCloneCallback(componentToClone.type, ObjectUtils.getEngine(componentToClone.object));
  if (cloneCallback != null) {
    clonedComponent = cloneCallback(componentToClone, targetObject, deeCloneParams, customCloneParams);
  } else if (componentToClone.pp_clone != null) {
    clonedComponent = componentToClone.pp_clone(targetObject, deeCloneParams, customCloneParams);
  } else if (useDefaultCloneAsFallback) {
    clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject, defaultCloneAutoStartIfNotActive);
  }
  return clonedComponent;
}
function clonePostProcess(componentToClone, clonedComponent, deeCloneParams, customCloneParams) {
  let clonePostProcessCallback = ComponentUtils.getClonePostProcessCallback(componentToClone.type, ObjectUtils.getEngine(componentToClone.object));
  if (clonePostProcessCallback != null) {
    clonePostProcessCallback(componentToClone, clonedComponent, deeCloneParams, customCloneParams);
  } else if (componentToClone.pp_clonePostProcess != null) {
    componentToClone.pp_clonePostProcess(clonedComponent, deeCloneParams, customCloneParams);
  }
  return clonedComponent;
}
function cloneDefault(componentToClone, targetObject, autoStartIfNotActive = true) {
  let clonedComponent = ObjectUtils.addComponent(targetObject, componentToClone.type, componentToClone);
  if (autoStartIfNotActive && !clonedComponent.active) {
    clonedComponent.active = true;
    clonedComponent.active = false;
  }
  return clonedComponent;
}
function setCloneCallback(typeOrClass, callback, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (!_myCloneCallbacks.has(engine)) {
    _myCloneCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _myCloneCallbacks.get(engine).set(type, callback);
}
function removeCloneCallback(typeOrClass, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myCloneCallbacks.has(engine)) {
    _myCloneCallbacks.get(engine).delete(type);
  }
}
function getCloneCallback(typeOrClass, engine = Globals.getMainEngine()) {
  let callback = null;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myCloneCallbacks.has(engine)) {
    callback = _myCloneCallbacks.get(engine).get(type);
  }
  return callback;
}
function hasCloneCallback(typeOrClass, engine = Globals.getMainEngine()) {
  let hasCallback = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myCloneCallbacks.has(engine)) {
    hasCallback = _myCloneCallbacks.get(engine).has(type);
  }
  return hasCallback;
}
function setClonePostProcessCallback(typeOrClass, callback, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (!_myClonePostProcessCallbacks.has(engine)) {
    _myClonePostProcessCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _myClonePostProcessCallbacks.get(engine).set(type, callback);
}
function removeClonePostProcessCallback(typeOrClass, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myClonePostProcessCallbacks.has(engine)) {
    _myClonePostProcessCallbacks.get(engine).delete(type);
  }
}
function getClonePostProcessCallback(typeOrClass, engine = Globals.getMainEngine()) {
  let callback = null;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myClonePostProcessCallbacks.has(engine)) {
    callback = _myClonePostProcessCallbacks.get(engine).get(type);
  }
  return callback;
}
function hasClonePostProcessCallback(typeOrClass, engine = Globals.getMainEngine()) {
  let hasCallback = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myClonePostProcessCallbacks.has(engine)) {
    hasCallback = _myClonePostProcessCallbacks.get(engine).has(type);
  }
  return hasCallback;
}
function getDefaultWLComponentCloneCallback(typeOrClass) {
  let callback = null;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  switch (type) {
    case MeshComponent2.TypeName:
      callback = DefaultWLComponentCloneCallbacks.cloneMesh;
      break;
    case CollisionComponent.TypeName:
      callback = DefaultWLComponentCloneCallbacks.cloneCollision;
      break;
    case TextComponent2.TypeName:
      callback = DefaultWLComponentCloneCallbacks.cloneText;
      break;
    case PhysXComponent.TypeName:
      callback = DefaultWLComponentCloneCallbacks.clonePhysX;
      break;
    default:
      callback = null;
  }
  return callback;
}
function hasDefaultWLComponentCloneCallback(typeOrClass) {
  return ComponentUtils.getDefaultWLComponentCloneCallback(typeOrClass) != null;
}
function setDefaultWLComponentCloneCallbacks(engine = Globals.getMainEngine()) {
  for (let nativeType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(nativeType);
    if (cloneCallback != null) {
      ComponentUtils.setCloneCallback(nativeType, cloneCallback, engine);
    }
  }
  for (let javascriptType of ComponentUtils.getWLJavascriptComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(javascriptType);
    if (cloneCallback != null) {
      ComponentUtils.setCloneCallback(javascriptType, cloneCallback, engine);
    }
  }
}
function removeDefaultWLComponentCloneCallbacks(engine = Globals.getMainEngine()) {
  for (let nativeType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(nativeType);
    if (cloneCallback != null) {
      if (ComponentUtils.getCloneCallback(nativeType, engine) == cloneCallback) {
        ComponentUtils.removeCloneCallback(nativeType, engine);
      }
    }
  }
  for (let javascriptType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(javascriptType);
    if (cloneCallback != null) {
      if (ComponentUtils.getCloneCallback(javascriptType, engine) == cloneCallback) {
        ComponentUtils.removeCloneCallback(javascriptType, engine);
      }
    }
  }
}
var ComponentUtils = {
  isWLComponent,
  isWLNativeComponent,
  isWLJavascriptComponent,
  getWLNativeComponentTypes,
  getWLJavascriptComponentTypes,
  getTypeFromTypeOrClass,
  getClassFromType,
  isRegistered,
  getJavascriptComponentInstances,
  getJavascriptComponentClass,
  getJavascriptComponentClassesByIndex,
  getJavascriptComponentTypeIndex,
  getJavascriptComponentTypeIndexes,
  getJavascriptComponentTypeFromIndex,
  isWLNativeComponentRegistered,
  isCloneable: isCloneable2,
  hasClonePostProcess,
  clone: clone9,
  clonePostProcess,
  cloneDefault,
  setCloneCallback,
  removeCloneCallback,
  getCloneCallback,
  hasCloneCallback,
  setClonePostProcessCallback,
  removeClonePostProcessCallback,
  getClonePostProcessCallback,
  hasClonePostProcessCallback,
  setDefaultWLComponentCloneCallbacks,
  removeDefaultWLComponentCloneCallbacks,
  getDefaultWLComponentCloneCallback,
  hasDefaultWLComponentCloneCallback
};
var _myWLNativeComponentTypes = [
  AnimationComponent.TypeName,
  CollisionComponent.TypeName,
  InputComponent.TypeName,
  LightComponent.TypeName,
  MeshComponent2.TypeName,
  PhysXComponent.TypeName,
  TextComponent2.TypeName,
  ViewComponent.TypeName
];
var _myWLJavascriptComponentTypes = [
  ARCamera8thwall2.TypeName,
  Anchor.TypeName,
  Cursor2.TypeName,
  CursorTarget2.TypeName,
  DebugObject2.TypeName,
  DeviceOrientationLook2.TypeName,
  FingerCursor2.TypeName,
  FixedFoveation2.TypeName,
  HandTracking2.TypeName,
  HitTestLocation2.TypeName,
  HowlerAudioListener2.TypeName,
  HowlerAudioSource2.TypeName,
  ImageTexture2.TypeName,
  MouseLookComponent2.TypeName,
  PlaneDetection.TypeName,
  PlayerHeight2.TypeName,
  TargetFramerate2.TypeName,
  TeleportComponent2.TypeName,
  Trail2.TypeName,
  TwoJointIkSolver2.TypeName,
  VideoTexture2.TypeName,
  VrModeActiveSwitch2.TypeName,
  Vrm2.TypeName,
  WasdControlsComponent2.TypeName
];

// dist/plugin/js/extensions/math_extension.js
function initMathExtension() {
  initMathExtensionStatic();
}
function initMathExtensionStatic() {
  let mathExtension = {};
  Object.defineProperty(mathExtension, "PP_EPSILON", {
    get() {
      return MathUtils.EPSILON;
    },
    set(value) {
      MathUtils.EPSILON = value;
    }
  });
  Object.defineProperty(mathExtension, "PP_EPSILON_SQUARED", {
    get() {
      return MathUtils.EPSILON_SQUARED;
    },
    set(value) {
      MathUtils.EPSILON = value;
    }
  });
  Object.defineProperty(mathExtension, "PP_EPSILON_DEGREES", {
    get() {
      return MathUtils.EPSILON_DEGREES;
    },
    set(value) {
      MathUtils.EPSILON = value;
    }
  });
  mathExtension.pp_clamp = function pp_clamp(value, start, end) {
    return MathUtils.clamp(value, start, end);
  };
  mathExtension.pp_sign = function pp_sign(value, zeroSign = 1) {
    return MathUtils.sign(value, zeroSign);
  };
  mathExtension.pp_toDegrees = function pp_toDegrees(angle2) {
    return MathUtils.toDegrees(angle2);
  };
  mathExtension.pp_toRadians = function pp_toRadians(angle2) {
    return MathUtils.toRadians(angle2);
  };
  mathExtension.pp_roundDecimal = function pp_roundDecimal(number, decimalPlaces) {
    return MathUtils.roundDecimal(number, decimalPlaces);
  };
  mathExtension.pp_mapToRange = function pp_mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
    return MathUtils.mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd);
  };
  mathExtension.pp_random = function pp_random(start = 0, end = 1) {
    return MathUtils.random(start, end);
  };
  mathExtension.pp_randomInt = function pp_randomInt(start, end) {
    return MathUtils.randomInt(start, end);
  };
  mathExtension.pp_randomBool = function pp_randomBool() {
    return MathUtils.randomBool();
  };
  mathExtension.pp_randomSign = function pp_randomSign() {
    return MathUtils.randomSign();
  };
  mathExtension.pp_randomPick = function pp_randomPick(...args) {
    return MathUtils.randomPick(...args);
  };
  mathExtension.pp_randomUUID = function pp_randomUUID() {
    return MathUtils.randomUUID();
  };
  mathExtension.pp_lerp = function pp_lerp(from, to, interpolationFactor) {
    return MathUtils.lerp(from, to, interpolationFactor);
  };
  mathExtension.pp_interpolate = function pp_interpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
    return MathUtils.interpolate(from, to, interpolationFactor, easingFunction);
  };
  mathExtension.pp_interpolatePeriodic = function pp_interpolatePeriodic(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
    return MathUtils.interpolatePeriodic(from, to, interpolationFactor, easingFunction);
  };
  mathExtension.pp_angleDistance = function pp_angleDistance(from, to) {
    return MathUtils.angleDistance(from, to);
  };
  mathExtension.pp_angleDistanceDegrees = function pp_angleDistanceDegrees(from, to) {
    return MathUtils.angleDistanceDegrees(from, to);
  };
  mathExtension.pp_angleDistanceRadians = function pp_angleDistanceRadians(from, to) {
    return MathUtils.angleDistanceRadians(from, to);
  };
  mathExtension.pp_angleDistanceSigned = function pp_angleDistanceSigned(from, to) {
    return MathUtils.angleDistanceSigned(from, to);
  };
  mathExtension.pp_angleDistanceSignedDegrees = function pp_angleDistanceSignedDegrees(from, to) {
    return MathUtils.angleDistanceSignedDegrees(from, to);
  };
  mathExtension.pp_angleDistanceSignedRadians = function pp_angleDistanceSignedRadians(from, to) {
    return MathUtils.angleDistanceSignedRadians(from, to);
  };
  mathExtension.pp_angleClamp = function pp_angleClamp(angle2, usePositiveRange = false) {
    return MathUtils.angleClamp(angle2, usePositiveRange);
  };
  mathExtension.pp_angleClampDegrees = function pp_angleClampDegrees(angle2, usePositiveRange = false) {
    return MathUtils.angleClampDegrees(angle2, usePositiveRange);
  };
  mathExtension.pp_angleClampRadians = function pp_angleClampRadians(angle2, usePositiveRange = false) {
    return MathUtils.angleClampRadians(angle2, usePositiveRange);
  };
  mathExtension.pp_isInsideAngleRange = function pp_isInsideAngleRange(angle2, start, end, useShortestAngle = false) {
    return MathUtils.isInsideAngleRange(angle2, start, end, useShortestAngle);
  };
  mathExtension.pp_isInsideAngleRangeDegrees = function pp_isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle = false) {
    return MathUtils.isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle);
  };
  mathExtension.pp_isInsideAngleRangeRadians = function pp_isInsideAngleRangeRadians(angle2, start, end, useShortestAngle = false) {
    return MathUtils.isInsideAngleRangeRadians(angle2, start, end, useShortestAngle);
  };
  PluginUtils.injectProperties(mathExtension, Math, false, true, true);
}

// dist/plugin/js/extensions/number_extension.js
function initNumberExtension(engine) {
  initNumberExtensionPrototype();
}
function initNumberExtensionPrototype() {
  let numberExtension = {};
  numberExtension.get = function get() {
    return this.valueOf();
  };
  PluginUtils.injectProperties(numberExtension, Number.prototype, false, true, true);
}

// dist/plugin/js/extensions/init_js_extentions.js
function initJSExtensions() {
  initMathExtension();
  initArrayExtension();
  initNumberExtension();
}

// dist/plugin/js/init_js_plugins.js
function initJSPlugins(engine) {
  initJSExtensions(engine);
}

// dist/plugin/wl/extensions/getter_extensions.js
import { Physics, RayHit } from "@wonderlandengine/api";
function initGetterExtensions() {
  initPhysicsGetterExtensionPrototype();
  initRayHitGetterExtensionPrototype();
}
function initPhysicsGetterExtensionPrototype() {
  let extension = {};
  extension.pp_getEngine = function pp_getEngine() {
    return this._engine;
  };
  PluginUtils.injectProperties(extension, Physics.prototype, false, true, true);
}
function initRayHitGetterExtensionPrototype() {
  let extension = {};
  extension.pp_getLocations = function pp_getLocations(out) {
    if (!out)
      out = Array.from({ length: this.hitCount }, () => new Float32Array(3));
    const wasm = this._engine.wasm;
    const alignedPtr = this._ptr / 4;
    for (let i = 0; i < this.hitCount; ++i) {
      const locationPtr = alignedPtr + 3 * i;
      out[i][0] = wasm.HEAPF32[locationPtr];
      out[i][1] = wasm.HEAPF32[locationPtr + 1];
      out[i][2] = wasm.HEAPF32[locationPtr + 2];
    }
    return out;
  };
  extension.pp_getNormals = function pp_getNormals(out) {
    if (!out)
      out = Array.from({ length: this.hitCount }, () => new Float32Array(3));
    const wasm = this._engine.wasm;
    const alignedPtr = (this._ptr + 48) / 4;
    for (let i = 0; i < this.hitCount; ++i) {
      const normalPtr = alignedPtr + 3 * i;
      out[i][0] = wasm.HEAPF32[normalPtr];
      out[i][1] = wasm.HEAPF32[normalPtr + 1];
      out[i][2] = wasm.HEAPF32[normalPtr + 2];
    }
    return out;
  };
  extension.pp_getDistances = function pp_getDistances(out = new Float32Array(this.hitCount)) {
    const wasm = this._engine.wasm;
    const alignedPtr = (this._ptr + 48 * 2) / 4;
    for (let i = 0; i < this.hitCount; ++i) {
      const distancePtr = alignedPtr + i;
      out[i] = wasm.HEAPF32[distancePtr];
    }
    return out;
  };
  extension.pp_getObjects = function pp_getObjects(out = new Array(this.hitCount)) {
    const HEAPU16 = this._engine.wasm.HEAPU16;
    const alignedPtr = this._ptr + (48 * 2 + 16) >> 1;
    for (let i = 0; i < this.hitCount; ++i) {
      const objectPtr = alignedPtr + i;
      out[i] = this._engine.wrapObject(HEAPU16[objectPtr + i]);
    }
    return out;
  };
  PluginUtils.injectProperties(extension, RayHit.prototype, false, true, true);
}

// dist/plugin/wl/extensions/object_extension.js
import { Object3D } from "@wonderlandengine/api";
function initObjectExtension() {
  initObjectExtensionProtoype();
}
function initObjectExtensionProtoype() {
  let objectExtension = {};
  objectExtension.pp_getPosition = function pp_getPosition(position) {
    return ObjectUtils.getPosition(this, position);
  };
  objectExtension.pp_getPositionWorld = function pp_getPositionWorld(position = Vec3Utils.create()) {
    return ObjectUtils.getPositionWorld(this, position);
  };
  objectExtension.pp_getPositionLocal = function pp_getPositionLocal(position = Vec3Utils.create()) {
    return ObjectUtils.getPositionLocal(this, position);
  };
  objectExtension.pp_getRotation = function pp_getRotation(rotation) {
    return ObjectUtils.getRotation(this, rotation);
  };
  objectExtension.pp_getRotationDegrees = function pp_getRotationDegrees(rotation) {
    return ObjectUtils.getRotationDegrees(this, rotation);
  };
  objectExtension.pp_getRotationRadians = function pp_getRotationRadians(rotation) {
    return ObjectUtils.getRotationRadians(this, rotation);
  };
  objectExtension.pp_getRotationMatrix = function pp_getRotationMatrix(rotation) {
    return ObjectUtils.getRotationMatrix(this, rotation);
  };
  objectExtension.pp_getRotationQuat = function pp_getRotationQuat(rotation) {
    return ObjectUtils.getRotationQuat(this, rotation);
  };
  objectExtension.pp_getRotationWorld = function pp_getRotationWorld(rotation) {
    return ObjectUtils.getRotationWorld(this, rotation);
  };
  objectExtension.pp_getRotationWorldDegrees = function pp_getRotationWorldDegrees(rotation) {
    return ObjectUtils.getRotationWorldDegrees(this, rotation);
  };
  objectExtension.pp_getRotationWorldRadians = function pp_getRotationWorldRadians(rotation = Vec3Utils.create()) {
    return ObjectUtils.getRotationWorldRadians(this, rotation);
  };
  objectExtension.pp_getRotationWorldMatrix = function pp_getRotationWorldMatrix(rotation = Mat3Utils.create()) {
    return ObjectUtils.getRotationWorldMatrix(this, rotation);
  };
  objectExtension.pp_getRotationWorldQuat = function pp_getRotationWorldQuat(rotation = QuatUtils.create()) {
    return ObjectUtils.getRotationWorldQuat(this, rotation);
  };
  objectExtension.pp_getRotationLocal = function pp_getRotationLocal(rotation) {
    return ObjectUtils.getRotationLocal(this, rotation);
  };
  objectExtension.pp_getRotationLocalDegrees = function pp_getRotationLocalDegrees(rotation) {
    return ObjectUtils.getRotationLocalDegrees(this, rotation);
  };
  objectExtension.pp_getRotationLocalRadians = function pp_getRotationLocalRadians(rotation = Vec3Utils.create()) {
    return ObjectUtils.getRotationLocalRadians(this, rotation);
  };
  objectExtension.pp_getRotationLocalMatrix = function pp_getRotationLocalMatrix(rotation = Mat3Utils.create()) {
    return ObjectUtils.getRotationLocalMatrix(this, rotation);
  };
  objectExtension.pp_getRotationLocalQuat = function pp_getRotationLocalQuat(rotation = QuatUtils.create()) {
    return ObjectUtils.getRotationLocalQuat(this, rotation);
  };
  objectExtension.pp_getScale = function pp_getScale(scale4) {
    return ObjectUtils.getScale(this, scale4);
  };
  objectExtension.pp_getScaleWorld = function pp_getScaleWorld(scale4 = Vec3Utils.create()) {
    return ObjectUtils.getScaleWorld(this, scale4);
  };
  objectExtension.pp_getScaleLocal = function pp_getScaleLocal(scale4 = Vec3Utils.create()) {
    return ObjectUtils.getScaleLocal(this, scale4);
  };
  objectExtension.pp_getTransform = function pp_getTransform(transform) {
    return ObjectUtils.getTransform(this, transform);
  };
  objectExtension.pp_getTransformMatrix = function pp_getTransformMatrix(transform) {
    return ObjectUtils.getTransformMatrix(this, transform);
  };
  objectExtension.pp_getTransformQuat = function pp_getTransformQuat(transform) {
    return ObjectUtils.getTransformQuat(this, transform);
  };
  objectExtension.pp_getTransformWorld = function pp_getTransformWorld(transform) {
    return ObjectUtils.getTransformWorld(this, transform);
  };
  objectExtension.pp_getTransformWorldMatrix = function pp_getTransformWorldMatrix(transform = Mat4Utils.create()) {
    return ObjectUtils.getTransformWorldMatrix(this, transform);
  };
  objectExtension.pp_getTransformWorldQuat = function pp_getTransformWorldQuat(transform = Quat2Utils.create()) {
    return ObjectUtils.getTransformWorldQuat(this, transform);
  };
  objectExtension.pp_getTransformLocal = function pp_getTransformLocal(transform) {
    return ObjectUtils.getTransformLocal(this, transform);
  };
  objectExtension.pp_getTransformLocalMatrix = function pp_getTransformLocalMatrix(transform = Mat4Utils.create()) {
    return ObjectUtils.getTransformLocalMatrix(this, transform);
  };
  objectExtension.pp_getTransformLocalQuat = function pp_getTransformLocalQuat(transform = Quat2Utils.create()) {
    return ObjectUtils.getTransformLocalQuat(this, transform);
  };
  objectExtension.pp_getAxes = function pp_getAxes(axes) {
    return ObjectUtils.getAxes(this, axes);
  };
  objectExtension.pp_getAxesWorld = function pp_getAxesWorld(axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return ObjectUtils.getAxesWorld(this, axes);
  };
  objectExtension.pp_getAxesLocal = function pp_getAxesLocal(axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return ObjectUtils.getAxesLocal(this, axes);
  };
  objectExtension.pp_getForward = function pp_getForward(forward) {
    return ObjectUtils.getForward(this, forward);
  };
  objectExtension.pp_getForwardWorld = function pp_getForwardWorld(forward = Vec3Utils.create()) {
    return ObjectUtils.getForwardWorld(this, forward);
  };
  objectExtension.pp_getForwardLocal = function pp_getForwardLocal(forward = Vec3Utils.create()) {
    return ObjectUtils.getForwardLocal(this, forward);
  };
  objectExtension.pp_getBackward = function pp_getBackward(backward) {
    return ObjectUtils.getBackward(this, backward);
  };
  objectExtension.pp_getBackwardWorld = function pp_getBackwardWorld(backward = Vec3Utils.create()) {
    return ObjectUtils.getBackwardWorld(this, backward);
  };
  objectExtension.pp_getBackwardLocal = function pp_getBackwardLocal(backward = Vec3Utils.create()) {
    return ObjectUtils.getBackwardLocal(this, backward);
  };
  objectExtension.pp_getUp = function pp_getUp(up) {
    return ObjectUtils.getUp(this, up);
  };
  objectExtension.pp_getUpWorld = function pp_getUpWorld(up = Vec3Utils.create()) {
    return ObjectUtils.getUpWorld(this, up);
  };
  objectExtension.pp_getUpLocal = function pp_getUpLocal(up = Vec3Utils.create()) {
    return ObjectUtils.getUpLocal(this, up);
  };
  objectExtension.pp_getDown = function pp_getDown(down) {
    return ObjectUtils.getDown(this, down);
  };
  objectExtension.pp_getDownWorld = function pp_getDownWorld(down = Vec3Utils.create()) {
    return ObjectUtils.getDownWorld(this, down);
  };
  objectExtension.pp_getDownLocal = function pp_getDownLocal(down = Vec3Utils.create()) {
    return ObjectUtils.getDownLocal(this, down);
  };
  objectExtension.pp_getLeft = function pp_getLeft(left) {
    return ObjectUtils.getLeft(this, left);
  };
  objectExtension.pp_getLeftWorld = function pp_getLeftWorld(left = Vec3Utils.create()) {
    return ObjectUtils.getLeftWorld(this, left);
  };
  objectExtension.pp_getLeftLocal = function pp_getLeftLocal(left = Vec3Utils.create()) {
    return ObjectUtils.getLeftLocal(this, left);
  };
  objectExtension.pp_getRight = function pp_getRight(right) {
    return ObjectUtils.getRight(this, right);
  };
  objectExtension.pp_getRightWorld = function pp_getRightWorld(right = Vec3Utils.create()) {
    return ObjectUtils.getRightWorld(this, right);
  };
  objectExtension.pp_getRightLocal = function pp_getRightLocal(right = Vec3Utils.create()) {
    return ObjectUtils.getRightLocal(this, right);
  };
  objectExtension.pp_setPosition = function pp_setPosition(position) {
    return ObjectUtils.setPosition(this, position);
  };
  objectExtension.pp_setPositionWorld = function pp_setPositionWorld(position) {
    return ObjectUtils.setPositionWorld(this, position);
  };
  objectExtension.pp_setPositionLocal = function pp_setPositionLocal(position) {
    return ObjectUtils.setPositionLocal(this, position);
  };
  objectExtension.pp_setRotation = function pp_setRotation(rotation) {
    return ObjectUtils.setRotation(this, rotation);
  };
  objectExtension.pp_setRotationDegrees = function pp_setRotationDegrees(rotation) {
    return ObjectUtils.setRotationDegrees(this, rotation);
  };
  objectExtension.pp_setRotationRadians = function pp_setRotationRadians(rotation) {
    return ObjectUtils.setRotationRadians(this, rotation);
  };
  objectExtension.pp_setRotationMatrix = function pp_setRotationMatrix(rotation) {
    return ObjectUtils.setRotationMatrix(this, rotation);
  };
  objectExtension.pp_setRotationQuat = function pp_setRotationQuat(rotation) {
    return ObjectUtils.setRotationQuat(this, rotation);
  };
  objectExtension.pp_setRotationWorld = function pp_setRotationWorld(rotation) {
    return ObjectUtils.setRotationWorld(this, rotation);
  };
  objectExtension.pp_setRotationWorldDegrees = function pp_setRotationWorldDegrees(rotation) {
    return ObjectUtils.setRotationWorldDegrees(this, rotation);
  };
  objectExtension.pp_setRotationWorldRadians = function pp_setRotationWorldRadians(rotation) {
    return ObjectUtils.setRotationWorldRadians(this, rotation);
  };
  objectExtension.pp_setRotationWorldMatrix = function pp_setRotationWorldMatrix(rotation) {
    return ObjectUtils.setRotationWorldMatrix(this, rotation);
  };
  objectExtension.pp_setRotationWorldQuat = function pp_setRotationWorldQuat(rotation) {
    return ObjectUtils.setRotationWorldQuat(this, rotation);
  };
  objectExtension.pp_setRotationLocal = function pp_setRotationLocal(rotation) {
    return ObjectUtils.setRotationLocal(this, rotation);
  };
  objectExtension.pp_setRotationLocalDegrees = function pp_setRotationLocalDegrees(rotation) {
    return ObjectUtils.setRotationLocalDegrees(this, rotation);
  };
  objectExtension.pp_setRotationLocalRadians = function pp_setRotationLocalRadians(rotation) {
    return ObjectUtils.setRotationLocalRadians(this, rotation);
  };
  objectExtension.pp_setRotationLocalMatrix = function pp_setRotationLocalMatrix(rotation) {
    return ObjectUtils.setRotationLocalMatrix(this, rotation);
  };
  objectExtension.pp_setRotationLocalQuat = function pp_setRotationLocalQuat(rotation) {
    return ObjectUtils.setRotationLocalQuat(this, rotation);
  };
  objectExtension.pp_setScale = function pp_setScale(scale4) {
    return ObjectUtils.setScale(this, scale4);
  };
  objectExtension.pp_setScaleWorld = function pp_setScaleWorld(scale4) {
    return ObjectUtils.setScaleWorld(this, scale4);
  };
  objectExtension.pp_setScaleLocal = function pp_setScaleLocal(scale4) {
    return ObjectUtils.setScaleLocal(this, scale4);
  };
  objectExtension.pp_setAxes = function pp_setAxes(left, up, forward) {
    return ObjectUtils.setAxes(this, left, up, forward);
  };
  objectExtension.pp_setAxesWorld = function pp_setAxesWorld(left, up, forward) {
    return ObjectUtils.setAxesWorld(this, left, up, forward);
  };
  objectExtension.pp_setAxesLocal = function pp_setAxesLocal(left, up, forward) {
    return ObjectUtils.setAxesLocal(this, left, up, forward);
  };
  objectExtension.pp_setForward = function pp_setForward(forward, up, left) {
    return ObjectUtils.setForward(this, forward, up, left);
  };
  objectExtension.pp_setForwardWorld = function pp_setForwardWorld(forward, up = null, left = null) {
    return ObjectUtils.setForwardWorld(this, forward, up, left);
  };
  objectExtension.pp_setForwardLocal = function pp_setForwardLocal(forward, up = null, left = null) {
    return ObjectUtils.setForwardLocal(this, forward, up, left);
  };
  objectExtension.pp_setBackward = function pp_setBackward(backward, up, left) {
    return ObjectUtils.setBackward(this, backward, up, left);
  };
  objectExtension.pp_setBackwardWorld = function pp_setBackwardWorld(backward, up = null, left = null) {
    return ObjectUtils.setBackwardWorld(this, backward, up, left);
  };
  objectExtension.pp_setBackwardLocal = function pp_setBackwardLocal(backward, up = null, left = null) {
    return ObjectUtils.setBackwardLocal(this, backward, up, left);
  };
  objectExtension.pp_setUp = function pp_setUp(up, forward, left) {
    return ObjectUtils.setUp(this, up, forward, left);
  };
  objectExtension.pp_setUpWorld = function pp_setUpWorld(up, forward = null, left = null) {
    return ObjectUtils.setUpWorld(this, up, forward, left);
  };
  objectExtension.pp_setUpLocal = function pp_setUpLocal(up, forward = null, left = null) {
    return ObjectUtils.setUpLocal(this, up, forward, left);
  };
  objectExtension.pp_setDown = function pp_setDown(down, forward, left) {
    return ObjectUtils.setDown(this, down, forward, left);
  };
  objectExtension.pp_setDownWorld = function pp_setDownWorld(down, forward = null, left = null) {
    return ObjectUtils.setDownWorld(this, down, forward, left);
  };
  objectExtension.pp_setDownLocal = function pp_setDownLocal(down, forward = null, left = null) {
    return ObjectUtils.setDownLocal(this, down, forward, left);
  };
  objectExtension.pp_setLeft = function pp_setLeft(left, up, forward) {
    return ObjectUtils.setLeft(this, left, up, forward);
  };
  objectExtension.pp_setLeftWorld = function pp_setLeftWorld(left, up = null, forward = null) {
    return ObjectUtils.setLeftWorld(this, left, up, forward);
  };
  objectExtension.pp_setLeftLocal = function pp_setLeftLocal(left, up = null, forward = null) {
    return ObjectUtils.setLeftLocal(this, left, up, forward);
  };
  objectExtension.pp_setRight = function pp_setRight(right, up, forward) {
    return ObjectUtils.setRight(this, right, up, forward);
  };
  objectExtension.pp_setRightWorld = function pp_setRightWorld(right, up = null, forward = null) {
    return ObjectUtils.setRightWorld(this, right, up, forward);
  };
  objectExtension.pp_setRightLocal = function pp_setRightLocal(right, up = null, forward = null) {
    return ObjectUtils.setRightLocal(this, right, up, forward);
  };
  objectExtension.pp_setTransform = function pp_setTransform(transform) {
    return ObjectUtils.setTransform(this, transform);
  };
  objectExtension.pp_setTransformMatrix = function pp_setTransformMatrix(transform) {
    return ObjectUtils.setTransformMatrix(this, transform);
  };
  objectExtension.pp_setTransformQuat = function pp_setTransformQuat(transform) {
    return ObjectUtils.setTransformQuat(this, transform);
  };
  objectExtension.pp_setTransformWorld = function pp_setTransformWorld(transform) {
    return ObjectUtils.setTransformWorld(this, transform);
  };
  objectExtension.pp_setTransformWorldMatrix = function pp_setTransformWorldMatrix(transform) {
    return ObjectUtils.setTransformWorldMatrix(this, transform);
  };
  objectExtension.pp_setTransformWorldQuat = function pp_setTransformWorldQuat(transform) {
    return ObjectUtils.setTransformWorldQuat(this, transform);
  };
  objectExtension.pp_setTransformLocal = function pp_setTransformLocal(transform) {
    return ObjectUtils.setTransformLocal(this, transform);
  };
  objectExtension.pp_setTransformLocalMatrix = function pp_setTransformLocalMatrix(transform) {
    return ObjectUtils.setTransformLocalMatrix(this, transform);
  };
  objectExtension.pp_setTransformLocalQuat = function pp_setTransformLocalQuat(transform) {
    return ObjectUtils.setTransformLocalQuat(this, transform);
  };
  objectExtension.pp_resetPosition = function pp_resetPosition() {
    return ObjectUtils.resetPosition(this);
  };
  objectExtension.pp_resetPositionWorld = function pp_resetPositionWorld() {
    return ObjectUtils.resetPositionWorld(this);
  };
  objectExtension.pp_resetPositionLocal = function pp_resetPositionLocal() {
    return ObjectUtils.resetPositionLocal(this);
  };
  objectExtension.pp_resetRotation = function pp_resetRotation() {
    return ObjectUtils.resetRotation(this);
  };
  objectExtension.pp_resetRotationWorld = function pp_resetRotationWorld() {
    return ObjectUtils.resetRotationWorld(this);
  };
  objectExtension.pp_resetRotationLocal = function pp_resetRotationLocal() {
    return ObjectUtils.resetRotationLocal(this);
  };
  objectExtension.pp_resetScale = function pp_resetScale() {
    return ObjectUtils.resetScale(this);
  };
  objectExtension.pp_resetScaleWorld = function pp_resetScaleWorld() {
    return ObjectUtils.resetScaleWorld(this);
  };
  objectExtension.pp_resetScaleLocal = function pp_resetScaleLocal() {
    return ObjectUtils.resetScaleLocal(this);
  };
  objectExtension.pp_resetTransform = function pp_resetTransform() {
    return ObjectUtils.resetTransform(this);
  };
  objectExtension.pp_resetTransformWorld = function pp_resetTransformWorld() {
    return ObjectUtils.resetTransformWorld(this);
  };
  objectExtension.pp_resetTransformLocal = function pp_resetTransformLocal() {
    return ObjectUtils.resetTransformLocal(this);
  };
  objectExtension.pp_translate = function pp_translate(translation) {
    return ObjectUtils.translate(this, translation);
  };
  objectExtension.pp_translateWorld = function pp_translateWorld(translation) {
    return ObjectUtils.translateWorld(this, translation);
  };
  objectExtension.pp_translateLocal = function pp_translateLocal(translation) {
    return ObjectUtils.translateLocal(this, translation);
  };
  objectExtension.pp_translateObject = function pp_translateObject(translation) {
    return ObjectUtils.translateObject(this, translation);
  };
  objectExtension.pp_translateAxis = function pp_translateAxis(amount, direction) {
    return ObjectUtils.translateAxis(this, amount, direction);
  };
  objectExtension.pp_translateAxisWorld = function pp_translateAxisWorld(amount, direction) {
    return ObjectUtils.translateAxisWorld(this, amount, direction);
  };
  objectExtension.pp_translateAxisLocal = function pp_translateAxisLocal(amount, direction) {
    return ObjectUtils.translateAxisLocal(this, amount, direction);
  };
  objectExtension.pp_translateAxisObject = function pp_translateAxisObject(amount, direction) {
    return ObjectUtils.translateAxisObject(this, amount, direction);
  };
  objectExtension.pp_rotate = function pp_rotate(rotation) {
    return ObjectUtils.rotate(this, rotation);
  };
  objectExtension.pp_rotateDegrees = function pp_rotateDegrees(rotation) {
    return ObjectUtils.rotateDegrees(this, rotation);
  };
  objectExtension.pp_rotateRadians = function pp_rotateRadians(rotation) {
    return ObjectUtils.rotateRadians(this, rotation);
  };
  objectExtension.pp_rotateMatrix = function pp_rotateMatrix(rotation) {
    return ObjectUtils.rotateMatrix(this, rotation);
  };
  objectExtension.pp_rotateQuat = function pp_rotateQuat(rotation) {
    return ObjectUtils.rotateQuat(this, rotation);
  };
  objectExtension.pp_rotateWorld = function pp_rotateWorld(rotation) {
    return ObjectUtils.rotateWorld(this, rotation);
  };
  objectExtension.pp_rotateWorldDegrees = function pp_rotateWorldDegrees(rotation) {
    return ObjectUtils.rotateWorldDegrees(this, rotation);
  };
  objectExtension.pp_rotateWorldRadians = function pp_rotateWorldRadians(rotation) {
    return ObjectUtils.rotateWorldRadians(this, rotation);
  };
  objectExtension.pp_rotateWorldMatrix = function pp_rotateWorldMatrix(rotation) {
    return ObjectUtils.rotateWorldMatrix(this, rotation);
  };
  objectExtension.pp_rotateWorldQuat = function pp_rotateWorldQuat(rotation) {
    return ObjectUtils.rotateWorldQuat(this, rotation);
  };
  objectExtension.pp_rotateLocal = function pp_rotateLocal(rotation) {
    return ObjectUtils.rotateLocal(this, rotation);
  };
  objectExtension.pp_rotateLocalDegrees = function pp_rotateLocalDegrees(rotation) {
    return ObjectUtils.rotateLocalDegrees(this, rotation);
  };
  objectExtension.pp_rotateLocalRadians = function pp_rotateLocalRadians(rotation) {
    return ObjectUtils.rotateLocalRadians(this, rotation);
  };
  objectExtension.pp_rotateLocalMatrix = function pp_rotateLocalMatrix(rotation) {
    return ObjectUtils.rotateLocalMatrix(this, rotation);
  };
  objectExtension.pp_rotateLocalQuat = function pp_rotateLocalQuat(rotation) {
    return ObjectUtils.rotateLocalQuat(this, rotation);
  };
  objectExtension.pp_rotateObject = function pp_rotateObject(rotation) {
    return ObjectUtils.rotateObject(this, rotation);
  };
  objectExtension.pp_rotateObjectDegrees = function pp_rotateObjectDegrees(rotation) {
    return ObjectUtils.rotateObjectDegrees(this, rotation);
  };
  objectExtension.pp_rotateObjectRadians = function pp_rotateObjectRadians(rotation) {
    return ObjectUtils.rotateObjectRadians(this, rotation);
  };
  objectExtension.pp_rotateObjectMatrix = function pp_rotateObjectMatrix(rotation) {
    return ObjectUtils.rotateObjectMatrix(this, rotation);
  };
  objectExtension.pp_rotateObjectQuat = function pp_rotateObjectQuat(rotation) {
    return ObjectUtils.rotateObjectQuat(this, rotation);
  };
  objectExtension.pp_rotateAxis = function pp_rotateAxis(angle2, axis) {
    return ObjectUtils.rotateAxis(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisDegrees = function pp_rotateAxisDegrees(angle2, axis) {
    return ObjectUtils.rotateAxisDegrees(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisRadians = function pp_rotateAxisRadians(angle2, axis) {
    return ObjectUtils.rotateAxisRadians(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisWorld = function pp_rotateAxisWorld(angle2, axis) {
    return ObjectUtils.rotateAxisWorld(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisWorldDegrees = function pp_rotateAxisWorldDegrees(angle2, axis) {
    return ObjectUtils.rotateAxisWorldDegrees(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisWorldRadians = function pp_rotateAxisWorldRadians(angle2, axis) {
    return ObjectUtils.rotateAxisWorldRadians(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisLocal = function pp_rotateAxisLocal(angle2, axis) {
    return ObjectUtils.rotateAxisLocal(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisLocalDegrees = function pp_rotateAxisLocalDegrees(angle2, axis) {
    return ObjectUtils.rotateAxisLocalDegrees(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisLocalRadians = function pp_rotateAxisLocalRadians(angle2, axis) {
    return ObjectUtils.rotateAxisLocalRadians(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisObject = function pp_rotateAxisObject(angle2, axis) {
    return ObjectUtils.rotateAxisObject(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisObjectDegrees = function pp_rotateAxisObjectDegrees(angle2, axis) {
    return ObjectUtils.rotateAxisObjectDegrees(this, angle2, axis);
  };
  objectExtension.pp_rotateAxisObjectRadians = function pp_rotateAxisObjectRadians(angle2, axis) {
    return ObjectUtils.rotateAxisObjectRadians(this, angle2, axis);
  };
  objectExtension.pp_rotateAround = function pp_rotateAround(rotation, origin) {
    return ObjectUtils.rotateAround(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundDegrees = function pp_rotateAroundDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundRadians = function pp_rotateAroundRadians(rotation, origin) {
    return ObjectUtils.rotateAroundRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundMatrix = function pp_rotateAroundMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundQuat = function pp_rotateAroundQuat(rotation, origin) {
    return ObjectUtils.rotateAroundQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorld = function pp_rotateAroundWorld(rotation, origin) {
    return ObjectUtils.rotateAroundWorld(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldDegrees = function pp_rotateAroundWorldDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundWorldDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldRadians = function pp_rotateAroundWorldRadians(rotation, origin) {
    return ObjectUtils.rotateAroundWorldRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldMatrix = function pp_rotateAroundWorldMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundWorldMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldQuat = function pp_rotateAroundWorldQuat(rotation, origin) {
    return ObjectUtils.rotateAroundWorldQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocal = function pp_rotateAroundLocal(rotation, origin) {
    return ObjectUtils.rotateAroundLocal(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalDegrees = function pp_rotateAroundLocalDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundLocalDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalRadians = function pp_rotateAroundLocalRadians(rotation, origin) {
    return ObjectUtils.rotateAroundLocalRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalMatrix = function pp_rotateAroundLocalMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundLocalMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalQuat = function pp_rotateAroundLocalQuat(rotation, origin) {
    return ObjectUtils.rotateAroundLocalQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObject = function pp_rotateAroundObject(rotation, origin) {
    return ObjectUtils.rotateAroundObject(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectDegrees = function pp_rotateAroundObjectDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundObjectDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectRadians = function pp_rotateAroundObjectRadians(rotation, origin) {
    return ObjectUtils.rotateAroundObjectRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectMatrix = function pp_rotateAroundObjectMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundObjectMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectQuat = function pp_rotateAroundObjectQuat(rotation, origin) {
    return ObjectUtils.rotateAroundObjectQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundAxis = function pp_rotateAroundAxis(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxis(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisDegrees = function pp_rotateAroundAxisDegrees(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisDegrees(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisRadians = function pp_rotateAroundAxisRadians(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisRadians(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorld = function pp_rotateAroundAxisWorld(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisWorld(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorldDegrees = function pp_rotateAroundAxisWorldDegrees(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisWorldDegrees(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorldRadians = function pp_rotateAroundAxisWorldRadians(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisWorldRadians(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocal = function pp_rotateAroundAxisLocal(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisLocal(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocalDegrees = function pp_rotateAroundAxisLocalDegrees(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisLocalDegrees(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocalRadians = function pp_rotateAroundAxisLocalRadians(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisLocalRadians(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObject = function pp_rotateAroundAxisObject(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisObject(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObjectDegrees = function pp_rotateAroundAxisObjectDegrees(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisObjectDegrees(this, angle2, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObjectRadians = function pp_rotateAroundAxisObjectRadians(angle2, axis, origin) {
    return ObjectUtils.rotateAroundAxisObjectRadians(this, angle2, axis, origin);
  };
  objectExtension.pp_scaleObject = function pp_scaleObject(scale4) {
    return ObjectUtils.scaleObject(this, scale4);
  };
  objectExtension.pp_lookAt = function pp_lookAt(position, up) {
    return ObjectUtils.lookAt(this, position, up);
  };
  objectExtension.pp_lookAtWorld = function pp_lookAtWorld(position, up) {
    return ObjectUtils.lookAtWorld(this, position, up);
  };
  objectExtension.pp_lookAtLocal = function pp_lookAtLocal(position, up) {
    return ObjectUtils.lookAtLocal(this, position, up);
  };
  objectExtension.pp_lookTo = function pp_lookTo(direction, up) {
    return ObjectUtils.lookTo(this, direction, up);
  };
  objectExtension.pp_lookToWorld = function pp_lookToWorld(direction, up) {
    return ObjectUtils.lookToWorld(this, direction, up);
  };
  objectExtension.pp_lookToLocal = function pp_lookToLocal(direction, up) {
    return ObjectUtils.lookToLocal(this, direction, up);
  };
  objectExtension.pp_setParent = function pp_setParent(newParent, keepTransformWorld = true) {
    return ObjectUtils.setParent(this, newParent, keepTransformWorld);
  };
  objectExtension.pp_getParent = function pp_getParent() {
    return ObjectUtils.getParent(this);
  };
  objectExtension.pp_convertPositionObjectToWorld = function pp_convertPositionObjectToWorld(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionObjectToWorld(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionObjectToWorld = function pp_convertDirectionObjectToWorld(direction, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionObjectToWorld(this, direction, resultDirection);
  };
  objectExtension.pp_convertPositionWorldToObject = function pp_convertPositionWorldToObject(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionWorldToObject(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionWorldToObject = function pp_convertDirectionWorldToObject(direction, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionWorldToObject(this, direction, resultDirection);
  };
  objectExtension.pp_convertPositionLocalToWorld = function pp_convertPositionLocalToWorld(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionLocalToWorld(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionLocalToWorld = function pp_convertDirectionLocalToWorld(direction, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionLocalToWorld(this, direction, resultDirection);
  };
  objectExtension.pp_convertPositionWorldToLocal = function pp_convertPositionWorldToLocal(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionWorldToLocal(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionWorldToLocal = function pp_convertDirectionWorldToLocal(direction, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionWorldToLocal(this, direction, resultDirection);
  };
  objectExtension.pp_convertPositionObjectToLocal = function pp_convertPositionObjectToLocal(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionObjectToLocal(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionObjectToLocal = function pp_convertDirectionObjectToLocal(direction, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionObjectToLocal(this, direction, resultDirection);
  };
  objectExtension.pp_convertPositionLocalToObject = function pp_convertPositionLocalToObject(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionLocalToObject(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionLocalToObject = function pp_convertDirectionLocalToObject(direction, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionLocalToObject(this, direction, resultDirection);
  };
  objectExtension.pp_convertTransformObjectToWorld = function pp_convertTransformObjectToWorld(transform, resultTransform) {
    return ObjectUtils.convertTransformObjectToWorld(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToWorldMatrix = function pp_convertTransformObjectToWorldMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformObjectToWorldMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToWorldQuat = function pp_convertTransformObjectToWorldQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformObjectToWorldQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObject = function pp_convertTransformWorldToObject(transform, resultTransform) {
    return ObjectUtils.convertTransformWorldToObject(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObjectMatrix = function pp_convertTransformWorldToObjectMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformWorldToObjectMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObjectQuat = function pp_convertTransformWorldToObjectQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformWorldToObjectQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorld = function pp_convertTransformLocalToWorld(transform, resultTransform) {
    return ObjectUtils.convertTransformLocalToWorld(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorldMatrix = function pp_convertTransformLocalToWorldMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformLocalToWorldMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorldQuat = function pp_convertTransformLocalToWorldQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformLocalToWorldQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocal = function pp_convertTransformWorldToLocal(transform, resultTransform) {
    return ObjectUtils.convertTransformWorldToLocal(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocalMatrix = function pp_convertTransformWorldToLocalMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformWorldToLocalMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocalQuat = function pp_convertTransformWorldToLocalQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformWorldToLocalQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocal = function pp_convertTransformObjectToLocal(transform, resultTransform) {
    return ObjectUtils.convertTransformObjectToLocal(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocalMatrix = function pp_convertTransformObjectToLocalMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformObjectToLocalMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocalQuat = function pp_convertTransformObjectToLocalQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformObjectToLocalQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObject = function pp_convertTransformLocalToObject(transform, resultTransform) {
    return ObjectUtils.convertTransformLocalToObject(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObjectMatrix = function pp_convertTransformLocalToObjectMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformLocalToObjectMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObjectQuat = function pp_convertTransformLocalToObjectQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformLocalToObjectQuat(this, transform, resultTransform);
  };
  objectExtension.pp_addComponent = function pp_addComponent(typeOrClass, paramsOrActive, active = null) {
    return ObjectUtils.addComponent(this, typeOrClass, paramsOrActive, active);
  };
  objectExtension.pp_getComponent = function pp_getComponent(typeOrClass, index = 0) {
    return ObjectUtils.getComponent(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentSelf = function pp_getComponentSelf(typeOrClass, index = 0) {
    return ObjectUtils.getComponentSelf(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentHierarchy = function pp_getComponentHierarchy(typeOrClass, index = 0) {
    return ObjectUtils.getComponentHierarchy(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentHierarchyBreadth = function pp_getComponentHierarchyBreadth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentHierarchyBreadth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentHierarchyDepth = function pp_getComponentHierarchyDepth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentHierarchyDepth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentDescendants = function pp_getComponentDescendants(typeOrClass, index = 0) {
    return ObjectUtils.getComponentDescendants(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentDescendantsBreadth = function pp_getComponentDescendantsBreadth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentDescendantsBreadth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentDescendantsDepth = function pp_getComponentDescendantsDepth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentDescendantsDepth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentChildren = function pp_getComponentChildren(typeOrClass, index = 0) {
    return ObjectUtils.getComponentChildren(this, typeOrClass, index);
  };
  objectExtension.pp_getComponents = function pp_getComponents(typeOrClass) {
    return ObjectUtils.getComponents(this, typeOrClass);
  };
  objectExtension.pp_getComponentsSelf = function pp_getComponentsSelf(typeOrClass) {
    return ObjectUtils.getComponentsSelf(this, typeOrClass);
  };
  objectExtension.pp_getComponentsHierarchy = function pp_getComponentsHierarchy(typeOrClass) {
    return ObjectUtils.getComponentsHierarchy(this, typeOrClass);
  };
  objectExtension.pp_getComponentsHierarchyBreadth = function pp_getComponentsHierarchyBreadth(typeOrClass) {
    return ObjectUtils.getComponentsHierarchyBreadth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsHierarchyDepth = function pp_getComponentsHierarchyDepth(typeOrClass) {
    return ObjectUtils.getComponentsHierarchyDepth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsDescendants = function pp_getComponentsDescendants(typeOrClass) {
    return ObjectUtils.getComponentsDescendants(this, typeOrClass);
  };
  objectExtension.pp_getComponentsDescendantsBreadth = function pp_getComponentsDescendantsBreadth(typeOrClass) {
    return ObjectUtils.getComponentsDescendantsBreadth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsDescendantsDepth = function pp_getComponentsDescendantsDepth(typeOrClass) {
    return ObjectUtils.getComponentsDescendantsDepth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsChildren = function pp_getComponentsChildren(typeOrClass) {
    return ObjectUtils.getComponentsChildren(this, typeOrClass);
  };
  objectExtension.pp_setActive = function pp_setActive(active) {
    return ObjectUtils.setActive(this, active);
  };
  objectExtension.pp_setActiveSelf = function pp_setActiveSelf(active) {
    return ObjectUtils.setActiveSelf(this, active);
  };
  objectExtension.pp_setActiveHierarchy = function pp_setActiveHierarchy(active) {
    return ObjectUtils.setActiveHierarchy(this, active);
  };
  objectExtension.pp_setActiveHierarchyBreadth = function pp_setActiveHierarchyBreadth(active) {
    return ObjectUtils.setActiveHierarchyBreadth(this, active);
  };
  objectExtension.pp_setActiveHierarchyDepth = function pp_setActiveHierarchyDepth(active) {
    return ObjectUtils.setActiveHierarchyDepth(this, active);
  };
  objectExtension.pp_setActiveDescendants = function pp_setActiveDescendants(active) {
    return ObjectUtils.setActiveDescendants(this, active);
  };
  objectExtension.pp_setActiveDescendantsBreadth = function pp_setActiveDescendantsBreadth(active) {
    return ObjectUtils.setActiveDescendantsBreadth(this, active);
  };
  objectExtension.pp_setActiveDescendantsDepth = function pp_setActiveDescendantsDepth(active) {
    return ObjectUtils.setActiveDescendantsDepth(this, active);
  };
  objectExtension.pp_setActiveChildren = function pp_setActiveChildren(active) {
    return ObjectUtils.setActiveChildren(this, active);
  };
  objectExtension.pp_hasUniformScale = function pp_hasUniformScale() {
    return ObjectUtils.hasUniformScale(this);
  };
  objectExtension.pp_hasUniformScaleWorld = function pp_hasUniformScaleWorld() {
    return ObjectUtils.hasUniformScaleWorld(this);
  };
  objectExtension.pp_hasUniformScaleLocal = function pp_hasUniformScaleLocal() {
    return ObjectUtils.hasUniformScaleLocal(this);
  };
  objectExtension.pp_clone = function pp_clone(cloneParams = new CloneParams()) {
    return ObjectUtils.clone(this, cloneParams);
  };
  objectExtension.pp_isCloneable = function pp_isCloneable(cloneParams = new CloneParams()) {
    return ObjectUtils.isCloneable(this, cloneParams);
  };
  objectExtension.pp_toString = function pp_toString() {
    return ObjectUtils.toString(this);
  };
  objectExtension.pp_toStringExtended = function pp_toStringExtended() {
    return ObjectUtils.toStringExtended(this);
  };
  objectExtension.pp_toStringCompact = function pp_toStringCompact() {
    return ObjectUtils.toStringCompact(this);
  };
  objectExtension.pp_getObjectByName = function pp_getObjectByName(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByName(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameHierarchy = function pp_getObjectByNameHierarchy(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameHierarchy(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameHierarchyBreadth = function pp_getObjectByNameHierarchyBreadth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameHierarchyBreadth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameHierarchyDepth = function pp_getObjectByNameHierarchyDepth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameHierarchyDepth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameDescendants = function pp_getObjectByNameDescendants(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameDescendants(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameDescendantsBreadth = function pp_getObjectByNameDescendantsBreadth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameDescendantsBreadth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameDescendantsDepth = function pp_getObjectByNameDescendantsDepth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameDescendantsDepth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameChildren = function pp_getObjectByNameChildren(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameChildren(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectsByName = function pp_getObjectsByName(name, isRegex = false) {
    return ObjectUtils.getObjectsByName(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameHierarchy = function pp_getObjectsByNameHierarchy(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameHierarchy(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameHierarchyBreadth = function pp_getObjectsByNameHierarchyBreadth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameHierarchyBreadth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameHierarchyDepth = function pp_getObjectsByNameHierarchyDepth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameHierarchyDepth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameDescendants = function pp_getObjectsByNameDescendants(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameDescendants(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameDescendantsBreadth = function pp_getObjectsByNameDescendantsBreadth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameDescendantsBreadth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameDescendantsDepth = function pp_getObjectsByNameDescendantsDepth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameDescendantsDepth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameChildren = function pp_getObjectsByNameChildren(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameChildren(this, name, isRegex);
  };
  objectExtension.pp_getObjectByID = function pp_getObjectByID(id) {
    return ObjectUtils.getObjectByID(this, id);
  };
  objectExtension.pp_getObjectByIDHierarchy = function pp_getObjectByIDHierarchy(id) {
    return ObjectUtils.getObjectByIDHierarchy(this, id);
  };
  objectExtension.pp_getObjectByIDHierarchyBreadth = function pp_getObjectByIDHierarchyBreadth(id) {
    return ObjectUtils.getObjectByIDHierarchyBreadth(this, id);
  };
  objectExtension.pp_getObjectByIDHierarchyDepth = function pp_getObjectByIDHierarchyDepth(id) {
    return ObjectUtils.getObjectByIDHierarchyDepth(this, id);
  };
  objectExtension.pp_getObjectByIDDescendants = function pp_getObjectByIDDescendants(id) {
    return ObjectUtils.getObjectByIDDescendants(this, id);
  };
  objectExtension.pp_getObjectByIDDescendantsBreadth = function pp_getObjectByIDDescendantsBreadth(id) {
    return ObjectUtils.getObjectByIDDescendantsBreadth(this, id);
  };
  objectExtension.pp_getObjectByIDDescendantsDepth = function pp_getObjectByIDDescendantsDepth(id) {
    return ObjectUtils.getObjectByIDDescendantsDepth(this, id);
  };
  objectExtension.pp_getObjectByIDChildren = function pp_getObjectByIDChildren(id) {
    return ObjectUtils.getObjectByIDChildren(this, id);
  };
  objectExtension.pp_getHierarchyBreadth = function pp_getHierarchyBreadth() {
    return ObjectUtils.getHierarchyBreadth(this);
  };
  objectExtension.pp_getHierarchyDepth = function pp_getHierarchyDepth() {
    return ObjectUtils.getHierarchyDepth(this);
  };
  objectExtension.pp_getDescendants = function pp_getDescendants() {
    return ObjectUtils.getDescendants(this);
  };
  objectExtension.pp_getDescendantsBreadth = function pp_getDescendantsBreadth() {
    return ObjectUtils.getDescendantsBreadth(this);
  };
  objectExtension.pp_getDescendantsDepth = function pp_getDescendantsDepth() {
    return ObjectUtils.getDescendantsDepth(this);
  };
  objectExtension.pp_getChildren = function pp_getChildren() {
    return ObjectUtils.getChildren(this);
  };
  objectExtension.pp_getSelf = function pp_getSelf() {
    return ObjectUtils.getSelf(this);
  };
  objectExtension.pp_addObject = function pp_addObject() {
    return ObjectUtils.addObject(this);
  };
  objectExtension.pp_getName = function pp_getName() {
    return ObjectUtils.getName(this);
  };
  objectExtension.pp_setName = function pp_setName(name) {
    return ObjectUtils.setName(this, name);
  };
  objectExtension.pp_getEngine = function pp_getEngine() {
    return ObjectUtils.getEngine(this);
  };
  objectExtension.pp_getID = function pp_getID() {
    return ObjectUtils.getID(this);
  };
  objectExtension.pp_markDirty = function pp_markDirty() {
    return ObjectUtils.markDirty(this);
  };
  objectExtension.pp_isTransformChanged = function pp_isTransformChanged() {
    return ObjectUtils.isTransformChanged(this);
  };
  objectExtension.pp_equals = function pp_equals(otherObject) {
    return ObjectUtils.equals(this, otherObject);
  };
  objectExtension.pp_destroy = function pp_destroy() {
    return ObjectUtils.destroy(this);
  };
  objectExtension.pp_reserveObjects = function pp_reserveObjects(count) {
    return ObjectUtils.reserveObjects(this, count);
  };
  objectExtension.pp_reserveObjectsSelf = function pp_reserveObjectsSelf(count) {
    return ObjectUtils.reserveObjectsSelf(this, count);
  };
  objectExtension.pp_reserveObjectsHierarchy = function pp_reserveObjectsHierarchy(count) {
    return ObjectUtils.reserveObjectsHierarchy(this, count);
  };
  objectExtension.pp_reserveObjectsDescendants = function pp_reserveObjectsDescendants(count) {
    return ObjectUtils.reserveObjectsDescendants(this, count);
  };
  objectExtension.pp_reserveObjectsChildren = function pp_reserveObjectsChildren(count) {
    return ObjectUtils.reserveObjectsChildren(this, count);
  };
  objectExtension.pp_getComponentsAmountMap = function pp_getComponentsAmountMap(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMap(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapSelf = function pp_getComponentsAmountMapSelf(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapSelf(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapHierarchy = function pp_getComponentsAmountMapHierarchy(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapHierarchy(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapDescendants = function pp_getComponentsAmountMapDescendants(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapDescendants(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapChildren = function pp_getComponentsAmountMapChildren(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapChildren(this, amountMap);
  };
  PluginUtils.injectProperties(objectExtension, Object3D.prototype, false, true, true);
}

// dist/plugin/wl/extensions/scene_extension.js
import { Scene } from "@wonderlandengine/api";
function initSceneExtension() {
  initSceneExtensionPrototype();
}
function initSceneExtensionPrototype() {
  let sceneExtension = {};
  sceneExtension.pp_getRoot = function pp_getRoot() {
    return SceneUtils.getRoot(this);
  };
  sceneExtension.pp_addObject = function pp_addObject() {
    return SceneUtils.addObject(this);
  };
  sceneExtension.pp_getObjects = function pp_getObjects() {
    return SceneUtils.getObjects(this);
  };
  sceneExtension.pp_getObjectsBreadth = function pp_getObjectsBreadth() {
    return SceneUtils.getObjectsBreadth(this);
  };
  sceneExtension.pp_getObjectsDepth = function pp_getObjectsDepth() {
    return SceneUtils.getObjectsDepth(this);
  };
  sceneExtension.pp_getComponent = function pp_getComponent(typeOrClass, index = 0) {
    return SceneUtils.getComponent(this, typeOrClass, index);
  };
  sceneExtension.pp_getComponentBreadth = function pp_getComponentBreadth(typeOrClass, index = 0) {
    return SceneUtils.getComponentBreadth(this, typeOrClass, index);
  };
  sceneExtension.pp_getComponentDepth = function pp_getComponentDepth(typeOrClass, index = 0) {
    return SceneUtils.getComponentDepth(this, typeOrClass, index);
  };
  sceneExtension.pp_getComponents = function pp_getComponents(typeOrClass) {
    return SceneUtils.getComponents(this, typeOrClass);
  };
  sceneExtension.pp_getComponentsBreadth = function pp_getComponentsBreadth(typeOrClass) {
    return SceneUtils.getComponentsBreadth(this, typeOrClass);
  };
  sceneExtension.pp_getComponentsDepth = function pp_getComponentsDepth(typeOrClass) {
    return SceneUtils.getComponentsDepth(this, typeOrClass);
  };
  sceneExtension.pp_getObjectByName = function pp_getObjectByName(name, isRegex = false, index = 0) {
    return SceneUtils.getObjectByName(this, name, isRegex, index);
  };
  sceneExtension.pp_getObjectByNameBreadth = function pp_getObjectByNameBreadth(name, isRegex = false, index = 0) {
    return SceneUtils.getObjectByNameBreadth(this, name, isRegex, index);
  };
  sceneExtension.pp_getObjectByNameDepth = function pp_getObjectByNameDepth(name, isRegex = false, index = 0) {
    return SceneUtils.getObjectByNameDepth(this, name, isRegex, index);
  };
  sceneExtension.pp_getObjectsByName = function pp_getObjectsByName(name, isRegex = false) {
    return SceneUtils.getObjectsByName(this, name, isRegex);
  };
  sceneExtension.pp_getObjectsByNameBreadth = function pp_getObjectsByNameBreadth(name, isRegex = false) {
    return SceneUtils.getObjectsByNameBreadth(this, name, isRegex);
  };
  sceneExtension.pp_getObjectsByNameDepth = function pp_getObjectsByNameDepth(name, isRegex = false) {
    return SceneUtils.getObjectsByNameDepth(this, name, isRegex);
  };
  sceneExtension.pp_getObjectByID = function pp_getObjectByID(id) {
    return SceneUtils.getObjectByID(this, id);
  };
  sceneExtension.pp_getObjectByIDBreadth = function pp_getObjectByIDBreadth(id) {
    return SceneUtils.getObjectByIDBreadth(this, id);
  };
  sceneExtension.pp_getObjectByIDDepth = function pp_getObjectByIDDepth(id) {
    return SceneUtils.getObjectByIDDepth(this, id);
  };
  sceneExtension.pp_toString = function pp_toString() {
    return SceneUtils.toString(this);
  };
  sceneExtension.pp_toStringCompact = function pp_toStringCompact() {
    return SceneUtils.toStringCompact(this);
  };
  sceneExtension.pp_toStringExtended = function pp_toStringExtended() {
    return SceneUtils.toStringExtended(this);
  };
  sceneExtension.pp_getComponentsAmountMap = function pp_getComponentsAmountMap(amountMap = /* @__PURE__ */ new Map()) {
    return SceneUtils.getComponentsAmountMap(this, amountMap);
  };
  PluginUtils.injectProperties(sceneExtension, Scene.prototype, false, true, true);
}

// dist/plugin/wl/extensions/init_wl_extentions.js
function initWLExtensions(engine) {
  initObjectExtension();
  initSceneExtension();
  initGetterExtensions();
}

// dist/plugin/wl/mods/components/cauldron_mods.js
import { Emitter } from "@wonderlandengine/api";
function initCauldronMods() {
  initEmitterModPrototype();
}
function initEmitterModPrototype() {
  let mod = {};
  mod._flushTransactions = function _flushTransactions() {
    let listeners = this._listeners;
    for (let i = 0; i < this._transactions.length; i++) {
      let transaction = this._transactions[i];
      if (transaction.type === 1) {
        listeners.push(transaction.data);
      } else {
        this.remove(transaction.data);
      }
    }
    this._transactions.length = 0;
  };
  PluginUtils.injectProperties(mod, Emitter.prototype, false, true, true);
}

// dist/plugin/wl/mods/components/cursor_component_mod.js
import { InputComponent as InputComponent2, ViewComponent as ViewComponent2 } from "@wonderlandengine/api";
import { Cursor as Cursor3, CursorTarget as CursorTarget3, HitTestLocation as HitTestLocation3 } from "@wonderlandengine/components";

// dist/cauldron/utils/browser_utils.js
var isMobile = function() {
  let checkMobileRegex = new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini", "i");
  return function isMobile2() {
    let userAgent = window.navigator.userAgent;
    return userAgent != null && userAgent.match(checkMobileRegex) != null;
  };
}();
function isDesktop() {
  return !BrowserUtils.isMobile();
}
var isLocalhost = function() {
  let localhostRegex = new RegExp("(localhost|127\\.0\\.0\\.1)(:(\\d{4}))?");
  return function isLocalhost2(port = null, isRegex = false) {
    let isLocalhost3 = false;
    let localhostMatch = window.location.origin.match(localhostRegex);
    if (localhostMatch != null) {
      if (port == null) {
        isLocalhost3 = true;
      } else if (localhostMatch.length >= 4 && localhostMatch[3] != null) {
        let portMatch = localhostMatch[3];
        if (isRegex) {
          isLocalhost3 = portMatch.match(port) != null;
        } else {
          isLocalhost3 = portMatch == port;
        }
      }
    }
    return isLocalhost3;
  };
}();
function openLink(url, newTab = true, exitXRSessionBeforeOpen = true, exitXRSessionOnSuccess = true, tryOpenLinkOnClickOnFailure = false, onSuccessCallback = null, onFailureCallback = null, engine = Globals.getMainEngine()) {
  let element = document.createElement("a");
  element.style.display = "none";
  document.body.appendChild(element);
  element.addEventListener("click", function() {
    let targetPage = void 0;
    if (newTab) {
      targetPage = "_blank";
    } else {
      targetPage = "_top";
    }
    let result = window.open(url, targetPage);
    if (result != null) {
      if (!exitXRSessionBeforeOpen && exitXRSessionOnSuccess) {
        XRUtils.exitSession(engine);
      }
      if (onSuccessCallback != null) {
        onSuccessCallback();
      }
    } else {
      if (tryOpenLinkOnClickOnFailure) {
        setTimeout(function() {
          BrowserUtils.openLinkOnClick(url, newTab, exitXRSessionOnSuccess, onSuccessCallback, onFailureCallback);
        }, 100);
      } else if (onFailureCallback != null) {
        onFailureCallback();
      }
    }
  });
  if (exitXRSessionBeforeOpen) {
    XRUtils.exitSession(engine);
  }
  element.click();
  document.body.removeChild(element);
}
function openLinkOnClick(url, newTab = true, exitXRSessionOnSuccess = true, onSuccessCallback = null, onFailureCallback = null, engine = Globals.getMainEngine()) {
  document.addEventListener("click", function() {
    let targetPage = void 0;
    if (newTab) {
      targetPage = "_blank";
    } else {
      targetPage = "_top";
    }
    let result = window.open(url, targetPage);
    if (result != null) {
      if (exitXRSessionOnSuccess) {
        XRUtils.exitSession(engine);
      }
      if (onSuccessCallback != null) {
        onSuccessCallback();
      }
    } else {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
    }
  }, { once: true });
}
var BrowserUtils = {
  isMobile,
  isDesktop,
  isLocalhost,
  openLink,
  openLinkOnClick
};

// dist/cauldron/utils/xr_utils.js
function getSession(engine = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine);
  return xr != null ? xr.session : null;
}
function getSessionMode(engine = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine);
  return xr != null ? xr.sessionMode : null;
}
function getReferenceSpace(engine = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine);
  return xr != null ? xr.currentReferenceSpace : null;
}
function getReferenceSpaceType(engine = Globals.getMainEngine()) {
  let type = "local";
  try {
    let xr = Globals.getXR(engine);
    type = xr != null ? xr.currentReferenceSpaceType : null;
  } catch (error3) {
  }
  return type;
}
function getFrame(engine = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine);
  return xr != null ? xr.frame : null;
}
function isSessionActive(engine = Globals.getMainEngine()) {
  return XRUtils.getSession(engine) != null;
}
function isReferenceSpaceFloorBased(engine = Globals.getMainEngine()) {
  return XRUtils.getReferenceSpaceType(engine).includes("floor");
}
function exitSession(engine = Globals.getMainEngine()) {
  let xrSession = XRUtils.getSession(engine);
  if (xrSession != null) {
    xrSession.end();
  }
}
function registerSessionStartEventListener(id, listener, manuallyCallSessionStartIfSessionAlreadyActive = true, addManualCallFlagToStartListener = false, engine = Globals.getMainEngine()) {
  if (listener != null) {
    if (addManualCallFlagToStartListener) {
      engine.onXRSessionStart.add(listener.bind(void 0, false), { id, immediate: false });
    } else {
      engine.onXRSessionStart.add(listener, { id, immediate: false });
    }
    if (manuallyCallSessionStartIfSessionAlreadyActive && XRUtils.isSessionActive(engine)) {
      if (addManualCallFlagToStartListener) {
        listener(true, XRUtils.getSession(engine), XRUtils.getSessionMode(engine));
      } else {
        listener(XRUtils.getSession(engine), XRUtils.getSessionMode(engine));
      }
    }
  }
}
function unregisterSessionStartEventListener(id, engine = Globals.getMainEngine()) {
  engine.onXRSessionStart.remove(id);
}
function registerSessionEndEventListener(id, listener, engine = Globals.getMainEngine()) {
  if (listener != null) {
    engine.onXRSessionEnd.add(listener, { id });
  }
}
function unregisterSessionEndEventListener(id, engine = Globals.getMainEngine()) {
  return engine.onXRSessionEnd.remove(id);
}
function registerSessionStartEndEventListeners(id, startListener, endListener, manuallyCallSessionStartIfSessionAlreadyActive = true, addManualCallFlagToStartListener = false, engine = Globals.getMainEngine()) {
  XRUtils.registerSessionEndEventListener(id, endListener, engine);
  XRUtils.registerSessionStartEventListener(id, startListener, manuallyCallSessionStartIfSessionAlreadyActive, addManualCallFlagToStartListener, engine);
}
function unregisterSessionStartEndEventListeners(id, engine = Globals.getMainEngine()) {
  XRUtils.unregisterSessionEndEventListener(id, engine);
  XRUtils.unregisterSessionStartEventListener(id, engine);
}
function isXRSupported(engine = Globals.getMainEngine()) {
  return XRUtils.isVRSupported(engine) || XRUtils.isARSupported(engine);
}
function isVRSupported(engine = Globals.getMainEngine()) {
  return engine.vrSupported;
}
function isARSupported(engine = Globals.getMainEngine()) {
  return engine.arSupported;
}
function isDeviceEmulated(onlyOnLocalhost = true) {
  let emulated = window.CustomWebXRPolyfill != null && (!onlyOnLocalhost || BrowserUtils.isLocalhost());
  return emulated;
}
var XRUtils = {
  getSession,
  getSessionMode,
  getReferenceSpace,
  getReferenceSpaceType,
  getFrame,
  isSessionActive,
  exitSession,
  registerSessionStartEventListener,
  unregisterSessionStartEventListener,
  registerSessionEndEventListener,
  unregisterSessionEndEventListener,
  registerSessionStartEndEventListeners,
  unregisterSessionStartEndEventListeners,
  isReferenceSpaceFloorBased,
  isXRSupported,
  isVRSupported,
  isARSupported,
  isDeviceEmulated
};

// dist/input/cauldron/input_types.js
var Handedness = {
  LEFT: "left",
  RIGHT: "right"
};
var HandednessIndex = {
  LEFT: 0,
  RIGHT: 1
};
var InputSourceType = {
  GAMEPAD: 0,
  TRACKED_HAND: 1
};
var TrackedHandJointID = {
  WRIST: "wrist",
  THUMB_METACARPAL: "thumb-metacarpal",
  THUMB_PHALANX_PROXIMAL: "thumb-phalanx-proximal",
  THUMB_PHALANX_DISTAL: "thumb-phalanx-distal",
  THUMB_TIP: "thumb-tip",
  INDEX_FINGER_METACARPAL: "index-finger-metacarpal",
  INDEX_FINGER_PHALANX_PROXIMAL: "index-finger-phalanx-proximal",
  INDEX_FINGER_PHALANX_INTERMEDIATE: "index-finger-phalanx-intermediate",
  INDEX_FINGER_PHALANX_DISTAL: "index-finger-phalanx-distal",
  INDEX_FINGER_TIP: "index-finger-tip",
  MIDDLE_FINGER_METACARPAL: "middle-finger-metacarpal",
  MIDDLE_FINGER_PHALANX_PROXIMAL: "middle-finger-phalanx-proximal",
  MIDDLE_FINGER_PHALANX_INTERMEDIATE: "middle-finger-phalanx-intermediate",
  MIDDLE_FINGER_PHALANX_DISTAL: "middle-finger-phalanx-distal",
  MIDDLE_FINGER_TIP: "middle-finger-tip",
  RING_FINGER_METACARPAL: "ring-finger-metacarpal",
  RING_FINGER_PHALANX_PROXIMAL: "ring-finger-phalanx-proximal",
  RING_FINGER_PHALANX_INTERMEDIATE: "ring-finger-phalanx-intermediate",
  RING_FINGER_PHALANX_DISTAL: "ring-finger-phalanx-distal",
  RING_FINGER_TIP: "ring-finger-tip",
  PINKY_FINGER_METACARPAL: "pinky-finger-metacarpal",
  PINKY_FINGER_PHALANX_PROXIMAL: "pinky-finger-phalanx-proximal",
  PINKY_FINGER_PHALANX_INTERMEDIATE: "pinky-finger-phalanx-intermediate",
  PINKY_FINGER_PHALANX_DISTAL: "pinky-finger-phalanx-distal",
  PINKY_FINGER_TIP: "pinky-finger-tip"
};
var TrackedHandJointIDIndex = {
  WRIST: 0,
  THUMB_METACARPAL: 1,
  THUMB_PHALANX_PROXIMAL: 2,
  THUMB_PHALANX_DISTAL: 3,
  THUMB_TIP: 4,
  INDEX_FINGER_METACARPAL: 5,
  INDEX_FINGER_PHALANX_PROXIMAL: 6,
  INDEX_FINGER_PHALANX_INTERMEDIATE: 7,
  INDEX_FINGER_PHALANX_DISTAL: 8,
  INDEX_FINGER_TIP: 9,
  MIDDLE_FINGER_METACARPAL: 10,
  MIDDLE_FINGER_PHALANX_PROXIMAL: 11,
  MIDDLE_FINGER_PHALANX_INTERMEDIATE: 12,
  MIDDLE_FINGER_PHALANX_DISTAL: 13,
  MIDDLE_FINGER_TIP: 14,
  RING_FINGER_METACARPAL: 15,
  RING_FINGER_PHALANX_PROXIMAL: 16,
  RING_FINGER_PHALANX_INTERMEDIATE: 17,
  RING_FINGER_PHALANX_DISTAL: 18,
  RING_FINGER_TIP: 19,
  PINKY_FINGER_METACARPAL: 20,
  PINKY_FINGER_PHALANX_PROXIMAL: 21,
  PINKY_FINGER_PHALANX_INTERMEDIATE: 22,
  PINKY_FINGER_PHALANX_DISTAL: 23,
  PINKY_FINGER_TIP: 24
};

// dist/input/cauldron/input_utils.js
function getHandednessByIndex(index) {
  let handedness = null;
  switch (index) {
    case HandednessIndex.LEFT:
      handedness = Handedness.LEFT;
      break;
    case HandednessIndex.RIGHT:
      handedness = Handedness.RIGHT;
      break;
  }
  return handedness;
}
function getInputSource(handedness, inputSourceType = null, engine = Globals.getMainEngine()) {
  let inputSource = null;
  let xrSession = XRUtils.getSession(engine);
  if (xrSession != null && xrSession.inputSources != null) {
    for (let i = 0; i < xrSession.inputSources.length; i++) {
      let input = xrSession.inputSources[i];
      let correctType = !inputSourceType || inputSourceType == InputSourceType.GAMEPAD && !input.hand || inputSourceType == InputSourceType.TRACKED_HAND && input.hand;
      if (correctType && input.handedness == handedness) {
        inputSource = input;
        break;
      }
    }
  }
  return inputSource;
}
function getInputSourceTypeByHandedness(handedness, engine) {
  let inputSource = InputUtils.getInputSource(handedness, void 0, engine);
  return InputUtils.getInputSourceType(inputSource);
}
function getInputSourceType(inputSource) {
  let inputSourceType = null;
  if (inputSource) {
    if (inputSource.hand) {
      inputSourceType = InputSourceType.TRACKED_HAND;
    } else {
      inputSourceType = InputSourceType.GAMEPAD;
    }
  }
  return inputSourceType;
}
function getOppositeHandedness(handedness) {
  let oppositeHandedness = null;
  switch (handedness) {
    case Handedness.LEFT:
      oppositeHandedness = Handedness.RIGHT;
      break;
    case Handedness.RIGHT:
      oppositeHandedness = Handedness.LEFT;
      break;
  }
  return oppositeHandedness;
}
function getJointIDByIndex(index) {
  let jointID = null;
  let jointIDKey = null;
  for (let jointIDIndexKey in TrackedHandJointIDIndex) {
    if (TrackedHandJointIDIndex[jointIDIndexKey] == index) {
      jointIDKey = jointIDIndexKey;
      break;
    }
  }
  if (jointIDKey != null) {
    jointID = TrackedHandJointID[jointIDKey];
  }
  return jointID;
}
var InputUtils = {
  getHandednessByIndex,
  getInputSource,
  getInputSourceTypeByHandedness,
  getInputSourceType,
  getOppositeHandedness,
  getJointIDByIndex
};

// dist/plugin/wl/mods/components/cursor_component_mod.js
function initCursorComponentMod() {
  initCursorComponentModPrototype();
}
function initCursorComponentModPrototype() {
  let cursorComponentMod = {};
  cursorComponentMod.init = function init() {
    this.maxDistance = 100;
    this.visible = false;
    this.globalTarget = this.object.pp_addComponent(CursorTarget3);
    this.hitTestTarget = this.object.pp_addComponent(CursorTarget3);
    this.hoveringObject = null;
    this.hoveringObjectTarget = null;
    this.cursorPos = vec3_create();
    this._collisionMask = 1 << this.collisionGroup;
    this._doubleClickTimer = 0;
    this._tripleClickTimer = 0;
    this._multipleClickObject = null;
    this._multipleClickDelay = 0.3;
    this._onDestroyCallbacks = [];
    this._prevHitLocationLocalToTarget = vec3_create();
    this._pointerID = null;
    this._updatePointerStyle = false;
    this._lastClientX = null;
    this._lastClientY = null;
    this._lastWidth = null;
    this._lastHeight = null;
    this._lastPointerID = null;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
    this._pointerLeaveToProcess = false;
    this._pointerLeaveMouseEvent = null;
    this._transformQuat = quat2_create();
    this._origin = vec3_create();
    this._direction = vec3_create();
    this._isHovering = false;
    this._isDown = false;
    this._lastIsDown = false;
    this._isRealDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    this._tempVec = vec3_create();
    this._viewComponent = null;
    this._cursorRayOrigin = vec3_create();
    this._cursorRayScale = vec3_create();
    this._projectionMatrix = mat4_create();
    this._hitTestLocation = null;
    this._hitTestObject = null;
    this._rayHitLocation = vec3_create();
    this._hitObjectData = [null, null, null];
    this._myViewEventListenersRegistered = false;
  };
  cursorComponentMod.start = function start() {
    if (this.handedness == 0) {
      let inputComp = this.object.pp_getComponent(InputComponent2);
      if (!inputComp) {
        console.warn("cursor component on object " + this.object.pp_getName() + ' was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness;
        this.input = inputComp;
      }
    } else {
      this.handedness = InputUtils.getHandednessByIndex(this.handedness - 1);
    }
    this.pp_setViewComponent(this.object.pp_getComponent(ViewComponent2));
    XRUtils.registerSessionStartEventListener(this, this.setupVREvents.bind(this), true, false, this.engine);
    this._onDestroyCallbacks.push(() => {
      XRUtils.unregisterSessionStartEventListener(this, this.engine);
    });
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
      this._cursorRayScale.set(this.cursorRayObject.pp_getScaleLocal());
      this._setCursorRayTransform(null);
    }
    this._setCursorVisibility(false);
    if (this.useWebXRHitTest) {
      this._hitTestObject = this.object.pp_addObject();
      this._hitTestLocation = this.hitTestObject.pp_addComponent(HitTestLocation3, { scaleObject: false });
    }
  };
  cursorComponentMod.update = function update(dt) {
    if (this._doubleClickTimer > 0) {
      this._doubleClickTimer -= dt;
    }
    if (this._tripleClickTimer > 0) {
      this._tripleClickTimer -= dt;
    }
    if (XRUtils.isSessionActive(this.engine) && this._viewComponent == null) {
      if (this.arTouchDown && this._pp_isAR()) {
        let axes = XRUtils.getSession(this.engine).inputSources[0].gamepad.axes;
        this._direction.vec3_set(axes[0], -axes[1], -1);
        this.updateDirection();
      } else {
        this.object.pp_getPosition(this._origin);
        this.object.pp_getForward(this._direction);
      }
      let hitObjectData = this._pp_rayCast();
      this._pp_hoverBehaviour(hitObjectData[0], hitObjectData[1], hitObjectData[2], this._lastOriginalGamepadEvent);
    } else if (!XRUtils.isSessionActive(this.engine) && this._viewComponent != null) {
      if (this._lastPointerID != null) {
        this._pp_updateMousePos(this._lastClientX, this._lastClientY, this._lastWidth, this._lastHeight);
        let hitObjectData = this._pp_rayCast();
        this._pp_hoverBehaviour(hitObjectData[0], hitObjectData[1], hitObjectData[2], this._lastOriginalMouseEvent);
        if (this.hoveringObject != null) {
          this._pointerID = this._lastPointerID;
        } else {
          this._pointerID = null;
        }
      } else if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalMouseEvent, true);
      }
    } else if (this.hoveringObject != null) {
      this._pp_hoverBehaviour(null, null, null, null, true);
    }
    this._pp_processPointerLeave();
    if (this.hoveringObject != null && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
      if (this.cursorObject) {
        this._setCursorVisibility(true);
        this.cursorObject.pp_setPosition(this.cursorPos);
        this.cursorObject.pp_setTransformLocalQuat(this.cursorObject.pp_getTransformLocalQuat(this._transformQuat).quat2_normalize(this._transformQuat));
      }
      if (this.cursorRayObject) {
        this._setCursorRayTransform(this.cursorPos);
      }
    } else {
      if (this.cursorObject) {
        this._setCursorVisibility(false);
      }
      if (this.cursorRayObject) {
        this._setCursorRayTransform(null);
      }
    }
    if (this.cursorRayObject) {
      if (XRUtils.isSessionActive(this.engine) && this._viewComponent == null || !XRUtils.isSessionActive(this.engine) && this._viewComponent != null && this.handedness != Handedness.LEFT && this.handedness != Handedness.RIGHT) {
        this.cursorRayObject.pp_setActive(true);
      } else {
        this.cursorRayObject.pp_setActive(false);
      }
    }
    if (this.hoveringObject == null) {
      this._pointerID = null;
    }
    this._updatePointerStyle = false;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
  };
  cursorComponentMod.onActivate = function onActivate() {
    this._isDown = false;
    this._lastIsDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
  };
  cursorComponentMod.onDeactivate = function onDeactivate() {
    if (this.hoveringObject != null) {
      this._pp_hoverBehaviour(null, null, null, null, true);
    }
    this.hoveringObject = null;
    this.hoveringObjectTarget = null;
    this._pp_updateCursorStyle();
    this._setCursorVisibility(false);
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
    }
    this._isDown = false;
    this._lastIsDown = false;
    this._isRealDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    this._pointerID = null;
    this._lastPointerID = null;
    this._lastClientX = null;
    this._lastClientY = null;
    this._lastWidth = null;
    this._lastHeight = null;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
    this._pointerLeaveToProcess = false;
    this._pointerLeaveMouseEvent = null;
  };
  cursorComponentMod.onDestroy = function onDestroy() {
    if (this._hitTestObject != null) {
      this._hitTestObject.pp_destroy();
    }
    for (let callback of this._onDestroyCallbacks) {
      callback();
    }
  };
  cursorComponentMod.updateDirection = function() {
    let transformWorld = quat2_create();
    return function updateDirection() {
      this.object.pp_getPosition(this._origin);
      this._direction.vec3_transformMat4(this._projectionMatrix, this._direction);
      this._direction.vec3_normalize(this._direction);
      this._direction.vec3_transformQuat(this.object.pp_getTransformQuat(transformWorld), this._direction);
    };
  }();
  cursorComponentMod.setupVREvents = function setupVREvents(session) {
    let onSelect = this.onSelect.bind(this);
    session.addEventListener("select", onSelect);
    let onSelectStart = this.onSelectStart.bind(this);
    session.addEventListener("selectstart", onSelectStart);
    let onSelectEnd = this.onSelectEnd.bind(this);
    session.addEventListener("selectend", onSelectEnd);
    this._onDestroyCallbacks.push(() => {
      if (!XRUtils.isSessionActive(this.engine))
        return;
      let session2 = XRUtils.getSession(this.engine);
      session2.removeEventListener("select", onSelect);
      session2.removeEventListener("selectstart", onSelectStart);
      session2.removeEventListener("selectend", onSelectEnd);
    });
    this._onViewportResize();
  };
  cursorComponentMod.onSelect = function onSelect(e) {
  };
  cursorComponentMod.onSelectStart = function onSelectStart(e) {
    if (this.active) {
      if (this._pp_isAR()) {
        this.arTouchDown = true;
        this._lastOriginalGamepadEvent = e;
      } else if (e.inputSource.handedness == this.handedness) {
        this._isDown = true;
        this._isRealDown = true;
        if (!this._lastIsDown) {
          this._isDownForUpWithDown = true;
        }
        this._lastOriginalGamepadEvent = e;
      }
    }
  };
  cursorComponentMod.onSelectEnd = function onSelectEnd(e) {
    if (this.active) {
      if (this._pp_isAR()) {
        this.arTouchDown = false;
        this._lastOriginalGamepadEvent = e;
      } else if (e.inputSource.handedness == this.handedness) {
        if (!this._isDownForUpWithDown) {
          this._isUpWithNoDown = true;
        }
        this._isDown = false;
        this._isRealDown = false;
        this._isDownForUpWithDown = false;
        this._lastOriginalGamepadEvent = e;
      }
    }
  };
  cursorComponentMod.onPointerMove = function onPointerMove(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId)
        return;
      let bounds = Globals.getBody(this.engine).getBoundingClientRect();
      this._pp_updateMouseData(e, e.clientX, e.clientY, bounds.width, bounds.height, e.pointerId);
    }
  };
  cursorComponentMod.onClick = function onClick(e) {
  };
  cursorComponentMod.onPointerDown = function onPointerDown(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId || e.button !== 0)
        return;
      let bounds = Globals.getBody(this.engine).getBoundingClientRect();
      this._pp_updateMouseData(e, e.clientX, e.clientY, bounds.width, bounds.height, e.pointerId);
      this._isDown = true;
      this._isRealDown = true;
      if (!this._lastIsDown) {
        this._isDownForUpWithDown = true;
      }
    }
  };
  cursorComponentMod.onPointerUp = function onPointerUp(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId || e.button !== 0)
        return;
      let bounds = Globals.getBody(this.engine).getBoundingClientRect();
      this._pp_updateMouseData(e, e.clientX, e.clientY, bounds.width, bounds.height, e.pointerId);
      if (!this._isDownForUpWithDown) {
        this._isUpWithNoDown = true;
      }
      this._isDown = false;
      this._isRealDown = false;
      this._isDownForUpWithDown = false;
      this._updatePointerStyle = true;
    }
  };
  cursorComponentMod._onViewportResize = function _onViewportResize() {
    if (!this._viewComponent)
      return;
    this._viewComponent.projectionMatrix.mat4_invert(this._projectionMatrix);
  };
  cursorComponentMod._setCursorRayTransform = function _setCursorRayTransform(hitPosition) {
    if (!this.cursorRayObject)
      return;
    if (this.cursorRayScalingAxis != 4) {
      this.cursorRayObject.pp_resetScaleLocal();
      if (hitPosition != null) {
        this.cursorRayObject.pp_getPosition(this._cursorRayOrigin);
        let dist = this._cursorRayOrigin.vec3_distance(hitPosition);
        this._cursorRayScale[this.cursorRayScalingAxis] = dist;
        this.cursorRayObject.pp_scaleObject(this._cursorRayScale);
      }
    }
  };
  cursorComponentMod._setCursorVisibility = function _setCursorVisibility(visible) {
    this.visible = visible;
    if (!this.cursorObject)
      return;
    this.cursorObject.pp_setActive(visible);
  };
  cursorComponentMod._pp_hoverBehaviour = function _pp_hoverBehaviour(hitObject, hitLocation, hitTestResults, originalEvent = null, forceUnhover = false) {
    if (!forceUnhover && hitObject != null) {
      let hoveringObjectChanged = false;
      if (this.hoveringObject == null || !this.hoveringObject.pp_equals(hitObject)) {
        if (this.hoveringObject != null) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUnhover.notify(null, this, originalEvent);
          }
        }
        hoveringObjectChanged = true;
        this.hoveringObject = hitObject;
        this.hoveringObjectTarget = this.hoveringObject.pp_getComponent(CursorTarget3);
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onHover.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onHover.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onHover.notify(hitTestResults, this, originalEvent);
        }
        this._pp_updateCursorStyle();
        if (!this._pp_isDownToProcess() && this._isRealDown) {
          this._isDown = true;
          this._lastIsDown = true;
          this._isDownForUpWithDown = false;
          this._isUpWithNoDown = false;
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onDownOnHover.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onDownOnHover.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onDownOnHover.notify(hitTestResults, this, originalEvent);
          }
        }
      }
      if (this._updatePointerStyle) {
        this._pp_updateCursorStyle();
      }
      if (!hoveringObjectChanged && this._pp_isMoving(hitLocation)) {
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onMove.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onMove.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onMove.notify(hitTestResults, this, originalEvent);
        }
      }
      if (this._pp_isDownToProcess()) {
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onDown.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onDown.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onDown.notify(hitTestResults, this, originalEvent);
        }
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onClick.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onClick.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onClick.notify(hitTestResults, this, originalEvent);
        }
        if (this._tripleClickTimer > 0 && this._multipleClickObject && this._multipleClickObject.pp_equals(this.hoveringObject)) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onTripleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onTripleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onTripleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = 0;
        } else if (this._doubleClickTimer > 0 && this._multipleClickObject && this._multipleClickObject.pp_equals(this.hoveringObject)) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onDoubleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onDoubleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onDoubleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = this._multipleClickDelay;
          this._doubleClickTimer = 0;
        } else {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onSingleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onSingleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onSingleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = 0;
          this._doubleClickTimer = this._multipleClickDelay;
          this._multipleClickObject = this.hoveringObject;
        }
      } else {
        if (!this._isUpWithNoDown && !hoveringObjectChanged && this._pp_isUpToProcess()) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUpWithDown.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUpWithDown.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUp.notify(hitTestResults, this, originalEvent);
            this.hitTestTarget.onUpWithDown.notify(hitTestResults, this, originalEvent);
          }
        } else if (this._isUpWithNoDown || hoveringObjectChanged && this._pp_isUpToProcess()) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUpWithNoDown.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUpWithNoDown.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUp.notify(hitTestResults, this, originalEvent);
            this.hitTestTarget.onUpWithNoDown.notify(hitTestResults, this, originalEvent);
          }
        }
      }
      this._prevHitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, this._prevHitLocationLocalToTarget);
    } else if (this.hoveringObject != null && (forceUnhover || hitObject == null)) {
      if (!this.hoveringReality) {
        if (this.hoveringObjectTarget)
          this.hoveringObjectTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
        this.globalTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
      } else {
        this.hitTestTarget.onUnhover.notify(null, this, originalEvent);
      }
      this.hoveringObject = null;
      this.hoveringObjectTarget = null;
      this._pp_updateCursorStyle();
    }
    if (this.hoveringObject != null) {
      this._lastIsDown = this._isDown;
    } else {
      this._isDown = false;
      this._lastIsDown = false;
      this._isDownForUpWithDown = false;
    }
    this._isUpWithNoDown = false;
  };
  cursorComponentMod._pp_rayCast = function _pp_rayCast() {
    let rayHit = this.rayCastMode == 0 ? Globals.getScene(this.engine).rayCast(this._origin, this._direction, this._collisionMask) : Globals.getPhysics(this.engine).rayCast(this._origin, this._direction, this._collisionMask, this.maxDistance);
    let rayHitCollisionDistanceValid = true;
    if (this.rayCastMode == 0 && rayHit.hitCount > 0 && rayHit.distances[0] > this.maxDistance) {
      rayHitCollisionDistanceValid = false;
    }
    this._hitObjectData[0] = null;
    this._hitObjectData[1] = null;
    this._hitObjectData[2] = null;
    let hitTestResultDistance = Infinity;
    if (this._hitTestLocation != null && this._hitTestLocation.visible) {
      this._hitTestObject.pp_getPositionWorld(this.cursorPos);
      this._rayHitLocation.vec3_copy(this.cursorPos);
      hitTestResultDistance = this.cursorPos.vec3_distance(this.object.pp_getPositionWorld(this._tempVec));
      this._hitObjectData[0] = this._hitTestObject;
      this._hitObjectData[1] = this._rayHitLocation;
    }
    this.hoveringReality = false;
    if (rayHit.hitCount > 0 && rayHitCollisionDistanceValid) {
      let rayHitDistance = rayHit.distances[0];
      if (rayHitDistance <= hitTestResultDistance) {
        this.cursorPos.vec3_copy(rayHit.locations[0]);
        this._rayHitLocation.vec3_copy(this.cursorPos);
        this._hitObjectData[0] = rayHit.objects[0];
        this._hitObjectData[1] = this._rayHitLocation;
      } else {
        this.hoveringReality = true;
      }
    } else if (hitTestResultDistance == Infinity) {
      this.cursorPos.vec3_zero();
      this._hitObjectData[0] = null;
      this._hitObjectData[1] = null;
    }
    let xrFrame = XRUtils.getFrame(this.engine);
    if (this.hoveringReality && xrFrame != null) {
      this._hitObjectData[2] = this._hitTestLocation.getHitTestResults(xrFrame)[0];
    }
    return this._hitObjectData;
  };
  cursorComponentMod._pp_updateMouseData = function _pp_updateMouseData(e, clientX, clientY, w, h, pointerID) {
    this._lastClientX = clientX;
    this._lastClientY = clientY;
    this._lastWidth = w;
    this._lastHeight = h;
    this._lastPointerID = pointerID;
    this._lastOriginalMouseEvent = e;
  };
  cursorComponentMod._pp_updateMousePos = function _pp_updateMousePos(clientX, clientY, w, h) {
    let left = clientX / w;
    let top = clientY / h;
    this._direction.vec3_set(left * 2 - 1, -top * 2 + 1, -1);
    this.updateDirection();
  };
  cursorComponentMod.pp_setViewComponent = function pp_setViewComponent(viewComponent) {
    this._viewComponent = viewComponent;
    if (this._viewComponent != null) {
      this._viewComponent.projectionMatrix.mat4_invert(this._projectionMatrix);
      if (!this._myViewEventListenersRegistered) {
        this._myViewEventListenersRegistered = true;
        let onClick = this.onClick.bind(this);
        Globals.getCanvas(this.engine).addEventListener("click", onClick);
        let onPointerDown = this.onPointerDown.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerdown", onPointerDown);
        let onPointerMove = this.onPointerMove.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointermove", onPointerMove);
        let onPointerUp = this.onPointerUp.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerup", onPointerUp);
        let onPointerLeave = this._pp_onPointerLeave.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerleave", onPointerLeave);
        let onViewportResize = this._onViewportResize.bind(this);
        this.engine.onResize.add(onViewportResize);
        this._onDestroyCallbacks.push(() => {
          Globals.getCanvas(this.engine).removeEventListener("click", onClick);
          Globals.getCanvas(this.engine).removeEventListener("pointerdown", onPointerDown);
          Globals.getCanvas(this.engine).removeEventListener("pointermove", onPointerMove);
          Globals.getCanvas(this.engine).removeEventListener("pointerup", onPointerUp);
          Globals.getCanvas(this.engine).removeEventListener("pointerleave", onPointerLeave);
          this.engine.onResize.remove(onViewportResize);
          this._myViewEventListenersRegistered = false;
        });
      }
    }
  };
  cursorComponentMod._pp_onPointerLeave = function _pp_onPointerLeave(e) {
    if (this._pointerID == null || this._pointerID == e.pointerId) {
      this._pointerLeaveToProcess = true;
      this._pointerLeaveMouseEvent = e;
    }
  };
  cursorComponentMod._pp_processPointerLeave = function _pp_processPointerLeave() {
    if (this._pointerLeaveToProcess) {
      this._pointerID = null;
      this._lastPointerID = null;
      this._lastClientX = null;
      this._lastClientY = null;
      this._lastWidth = null;
      this._lastHeight = null;
      this._lastOriginalMouseEvent = this._pointerLeaveMouseEvent;
      this._pointerLeaveToProcess = false;
      this._pointerLeaveMouseEvent = null;
      if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalMouseEvent, true);
      }
      this._isDown = false;
      this._lastIsDown = false;
      this._isRealDown = false;
      this._isDownForUpWithDown = false;
      this._isUpWithNoDown = false;
    }
  };
  cursorComponentMod._pp_isDownToProcess = function _pp_isDownToProcess() {
    return this._isDown !== this._lastIsDown && this._isDown;
  };
  cursorComponentMod._pp_isUpToProcess = function _pp_isUpToProcess() {
    return this._isDown !== this._lastIsDown && !this._isDown;
  };
  cursorComponentMod._pp_isMoving = function() {
    let hitLocationLocalToTarget = vec3_create();
    return function _pp_isMoving(hitLocation) {
      let moving = false;
      hitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, hitLocationLocalToTarget);
      if (!hitLocationLocalToTarget.vec_equals(this._prevHitLocationLocalToTarget, 1e-4)) {
        moving = true;
      }
      return moving;
    };
  }();
  cursorComponentMod._pp_isAR = function _pp_isAR() {
    let firstInputSource = XRUtils.getSession(this.engine).inputSources[0];
    return this.input != null && firstInputSource.handedness === "none" && firstInputSource.gamepad != null;
  };
  cursorComponentMod._pp_updateCursorStyle = function _pp_updateCursorStyle() {
    if (this.styleCursor) {
      if (this.hoveringObjectTarget != null && !this.hoveringObjectTarget.isSurface) {
        Globals.getBody(this.engine).style.cursor = "pointer";
      } else if (Globals.getBody(this.engine).style.cursor == "pointer") {
        Globals.getBody(this.engine).style.cursor = "default";
      }
    }
  };
  PluginUtils.injectProperties(cursorComponentMod, Cursor3.prototype, false, true, true);
}

// dist/plugin/wl/mods/components/cursor_target_component_mod.js
import { Emitter as Emitter2 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget4 } from "@wonderlandengine/components";
function initCursorTargetComponentMod() {
  initCursorTargetComponentModPrototype();
}
function initCursorTargetComponentModPrototype() {
  let cursorTargetComponentMod = {};
  cursorTargetComponentMod.init = function init() {
    this.onSingleClick = new Emitter2();
    this.onDoubleClick = new Emitter2();
    this.onTripleClick = new Emitter2();
    this.onDownOnHover = new Emitter2();
    this.onUpWithDown = new Emitter2();
    this.onUpWithNoDown = new Emitter2();
    this.isSurface = false;
  };
  cursorTargetComponentMod.start = function start() {
  };
  cursorTargetComponentMod.update = function update(dt) {
  };
  cursorTargetComponentMod.onActivate = function onActivate() {
  };
  cursorTargetComponentMod.onDeactivate = function onDeactivate() {
  };
  cursorTargetComponentMod.onDestroy = function onDestroy() {
  };
  PluginUtils.injectProperties(cursorTargetComponentMod, CursorTarget4.prototype, false, true, true);
}

// dist/plugin/wl/mods/components/mouse_look_component_mod.js
import { MouseLookComponent as MouseLookComponent3 } from "@wonderlandengine/components";

// dist/cauldron/cauldron/timer.js
import { Emitter as Emitter3 } from "@wonderlandengine/api";
var Timer = class {
  constructor(duration, autoStart = true) {
    this._myDuration = duration;
    this._myOnEndEmitter = new Emitter3();
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
    if (autoStart) {
      this.start();
    } else {
      this.reset();
    }
  }
  start(duration = null) {
    this.reset(duration);
    this._myStarted = true;
  }
  end() {
    this._done();
  }
  reset(duration = null) {
    if (duration != null) {
      this._myDuration = Math.max(0, duration);
    }
    this._myTimeLeft = this._myDuration;
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
  }
  update(dt) {
    this._myJustDone = false;
    if (this.isRunning()) {
      this._myTimeLeft = Math.max(0, this._myTimeLeft - dt);
      if (this._myTimeLeft == 0) {
        this._done();
      }
    }
  }
  isDone() {
    return this._myDone;
  }
  isJustDone() {
    return this._myJustDone;
  }
  isStarted() {
    return this._myStarted;
  }
  isRunning() {
    return this.isStarted() && !this.isDone();
  }
  getDuration() {
    return this._myDuration;
  }
  setDuration(duration) {
    this._myDuration = Math.max(0, duration);
  }
  getTimeLeft() {
    return this._myTimeLeft;
  }
  getPercentage() {
    let percentage = 1;
    if (this._myTimeLeft > 0 && this._myDuration > 0) {
      percentage = (this._myDuration - this._myTimeLeft) / this._myDuration;
    }
    return Math.pp_clamp(percentage, 0, 1);
  }
  setPercentage(percentage) {
    if (this.isRunning()) {
      let durationPercentage = Math.pp_clamp(1 - percentage, 0, 1);
      this._myTimeLeft = this._myDuration * durationPercentage;
    }
  }
  onEnd(listener, id = null) {
    this._myOnEndEmitter.add(listener, { id });
  }
  unregisterOnEnd(id = null) {
    this._myOnEndEmitter.remove(id);
  }
  _done() {
    this._myTimeLeft = 0;
    this._myDone = true;
    this._myJustDone = true;
    this._myOnEndEmitter.notify();
  }
};

// dist/plugin/wl/mods/components/mouse_look_component_mod.js
function initMouseLookComponentMod() {
  initMouseLookComponentModPrototype();
}
function initMouseLookComponentModPrototype() {
  let mouseLookComponentMod = {};
  mouseLookComponentMod.init = function init() {
    this.pointerId = null;
    this.prevMoveEvent = null;
    this.resetMovingDelay = 0.15;
    this.resetMovingTimer = new Timer(this.resetMovingDelay, false);
    this.isMoving = false;
    this.mouseDown = false;
    this.pointerMoveListener = this._onMove.bind(this);
    this.contextMenuListener = function(event) {
      if (this.active) {
        event.preventDefault();
      }
    }.bind(this);
    this.pointerDown = function(event) {
      if (this.active) {
        if (this.pointerId != null)
          return;
        if (!this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.pointerId = event.pointerId;
            this.mouseDown = true;
            if (event.button == 1) {
              event.preventDefault();
              return false;
            }
          }
        }
      }
    }.bind(this);
    this.pointerUp = function(event) {
      if (this.active) {
        if (event.pointerId != this.pointerId)
          return;
        if (this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.mouseDown = false;
          }
        }
      }
    }.bind(this);
    this.pointerLeave = function(event) {
      if (this.active) {
        if (event.pointerId != this.pointerId)
          return;
        this.pointerId = null;
        this.prevMoveEvent = null;
        if (this.mouseDown) {
          this.mouseDown = false;
        }
      }
    }.bind(this);
    Globals.getBody(this.engine).addEventListener("pointermove", this.pointerMoveListener);
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex == 2) {
        Globals.getCanvas(this.engine).addEventListener("contextmenu", this.contextMenuListener, false);
      }
      Globals.getCanvas(this.engine).addEventListener("pointerdown", this.pointerDown);
      Globals.getBody(this.engine).addEventListener("pointerup", this.pointerUp);
    }
    Globals.getBody(this.engine).addEventListener("pointerleave", this.pointerLeave);
  };
  mouseLookComponentMod.start = function start() {
  };
  mouseLookComponentMod.onActivate = function onActivate() {
  };
  mouseLookComponentMod.onDeactivate = function onDeactivate() {
    if (this.mouseDown) {
    }
    this.isMoving = false;
    this.mouseDown = false;
    this.pointerId = null;
    this.prevMoveEvent = null;
  };
  mouseLookComponentMod.onDestroy = function onDestroy() {
    Globals.getBody(this.engine).removeEventListener("pointermove", this.pointerMoveListener);
    Globals.getCanvas(this.engine).removeEventListener("contextmenu", this.contextMenuListener);
    Globals.getCanvas(this.engine).removeEventListener("pointerdown", this.pointerDown);
    Globals.getBody(this.engine).removeEventListener("pointerup", this.pointerUp);
    Globals.getBody(this.engine).removeEventListener("pointerleave", this.pointerLeave);
  };
  mouseLookComponentMod.update = function update(dt) {
    if (this.resetMovingTimer.isRunning()) {
      this.resetMovingTimer.update(dt);
      if (this.resetMovingTimer.isDone()) {
        this.resetMovingTimer.reset();
        this.isMoving = false;
      }
    }
    if (!this.isMoving) {
      if (!this.requireMouseDown || !this.mouseDown) {
        this.pointerId = null;
      }
      this.prevMoveEvent = null;
    }
  };
  mouseLookComponentMod._onMove = function() {
    let viewForward = vec3_create();
    let viewUp = vec3_create();
    let referenceUp = vec3_create();
    let referenceUpNegate = vec3_create();
    let referenceRight = vec3_create();
    let newUp = vec3_create();
    return function _onMove(event) {
      if (this.active) {
        if (this.pointerId != null && event.pointerId != this.pointerId)
          return;
        if (this.mouseDown || !this.requireMouseDown) {
          viewForward = this.object.pp_getBackward(viewForward);
          viewUp = this.object.pp_getUp(viewUp);
          referenceUp.vec3_set(0, 1, 0);
          if (this.object.pp_getParent() != null) {
            referenceUp = this.object.pp_getParent().pp_getUp(referenceUp);
          }
          referenceRight = viewForward.vec3_cross(referenceUp, referenceRight);
          let minAngle = 1;
          if (viewForward.vec3_angle(referenceUp) < minAngle) {
            referenceRight = viewUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
          } else if (viewForward.vec3_angle(referenceUp.vec3_negate(referenceUpNegate)) < minAngle) {
            referenceRight = viewUp.vec3_cross(referenceUp, referenceRight);
          } else if (!viewUp.vec3_isConcordant(referenceUp)) {
            referenceRight.vec3_negate(referenceRight);
          }
          referenceRight.vec3_normalize(referenceRight);
          let movementX = event.movementX;
          let movementY = event.movementY;
          if (movementX == null || movementY == null) {
            if (this.prevMoveEvent != null) {
              movementX = event.pageX - this.prevMoveEvent.pageX;
              movementY = event.pageY - this.prevMoveEvent.pageY;
            } else {
              movementX = 0;
              movementY = 0;
            }
          }
          this.rotationX = -this.sensitity * movementX;
          this.rotationY = -this.sensitity * movementY;
          this.object.pp_rotateAxis(this.rotationY, referenceRight);
          let maxVerticalAngle = 89 - 1e-3;
          newUp = this.object.pp_getUp(newUp);
          let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            this.object.pp_rotateAxis(fixAngle, referenceRight);
          }
          this.object.pp_rotateAxis(this.rotationX, referenceUp);
          this.prevMoveEvent = event;
          this.pointerId = event.pointerId;
          this.resetMovingTimer.start(this.resetMovingDelay);
          this.isMoving = true;
        }
      }
    };
  }();
  PluginUtils.injectProperties(mouseLookComponentMod, MouseLookComponent3.prototype, false, true, true);
}

// dist/plugin/wl/mods/components/init_component_mods.js
function initComponentMods() {
  initCursorComponentMod();
  initCursorTargetComponentMod();
  initMouseLookComponentMod();
  initCauldronMods();
}

// dist/plugin/wl/mods/init_wl_mods.js
function initWLMods() {
  initComponentMods();
}

// dist/plugin/wl/init_wl_plugins.js
function initWLPlugins(engine) {
  initWLExtensions(engine);
  initWLMods();
}

// dist/plugin/init_plugins.js
function initPlugins(engine) {
  initJSPlugins();
  initWLPlugins(engine);
}

// dist/pp/register_pp_components.js
function registerPPComponents(engine) {
  engine.registerComponent(AddPPToWindowComponent, AddWLToWindowComponent, AdjustHierarchyPhysXScaleComponent, AnalyticsManagerComponent, AudioManagerComponent, BenchmarkMaxPhysXComponent, BenchmarkMaxVisibleTrianglesComponent, CADisplayLeaderboardComponent, CharacterCollisionSystemComponent, ClearConsoleOnXRSessionStartComponent, ConsoleVRToolComponent, CopyHandTransformComponent, CopyHeadTransformComponent, CopyReferenceSpaceTransformComponent, CopyPlayerTransformComponent, DebugPPArrayCreationPerformanceAnalyzerComponent, DebugArrayFunctionsPerformanceAnalyzerComponent, DebugFunctionsPerformanceAnalyzerComponent, DebugManagerComponent, DebugPPFunctionsPerformanceAnalyzerComponent, DebugTransformComponent, DebugWLComponentsFunctionsPerformanceAnalyzerComponent, DebugWLFunctionsPerformanceAnalyzerComponent, EasyLightAttenuationComponent, EasyLightColorComponent, EasyMeshAmbientFactorComponent, EasyMeshColorComponent, EasyScaleComponent, EasySetTuneTargeetGrabComponent, EasySetTuneTargetChildNumberComponent, EasyTextColorComponent, EasyTransformComponent, EasyTuneImportVariablesComponent, EasyTuneToolComponent, EnableDebugComponent, EnableToolComponent, FingerCursorComponent, GamepadControlSchemeComponent, GamepadMeshAnimatorComponent, GetDefaultResourcesComponent, GetSceneObjectsComponent, GrabbableComponent, GrabberHandComponent, InitConsoleVRComponent, InitEasyTuneVariablesComponent, InputManagerComponent, MuteEverythingComponent, ObjectPoolManagerComponent, PPGatewayComponent, PlayerLocomotionComponent, SaveManagerComponent, SetActiveComponent, SetHandLocalTransformComponent, SetHeadLocalTransformComponent, SetPlayerHeightComponent, SetTrackedHandJointLocalTransformComponent, ShowFPSComponent, SpatialAudioListenerComponent, SwitchHandObjectComponent, ToolCursorComponent, TrackedHandDrawAllJointsComponent, TrackedHandDrawJointComponent, TrackedHandDrawSkinComponent, VirtualGamepadComponent, VisualManagerComponent);
}

// dist/pp/init_pp.js
function initPP(engine) {
  Globals.initEngine(engine);
  ComponentUtils.setDefaultWLComponentCloneCallbacks(engine);
  registerWLComponents(engine);
  registerPPComponents(engine);
  initPlugins(engine);
}

// dist/pp/scene_objects.js
var SceneObjects = class {
  constructor() {
    this.myScene = null;
    this.myCauldron = null;
    this.myDynamics = null;
    this.myParticles = null;
    this.myVisualElements = null;
    this.myTools = null;
    this.myPlayerObjects = new PlayerObjects();
  }
};
var PlayerObjects = class {
  constructor() {
    this.myPlayer = null;
    this.myCauldron = null;
    this.myReferenceSpace = null;
    this.myCameraNonXR = null;
    this.myEyes = [];
    this.myEyeLeft = null;
    this.myEyeRight = null;
    this.myHands = [];
    this.myHandLeft = null;
    this.myHandRight = null;
    this.myHead = null;
    this.myHeadDebugs = null;
  }
};

// dist/pp/default_resources.js
var DefaultResources = class {
  constructor() {
    this.myMeshes = new DefaultResourcesMeshes();
    this.myMaterials = new DefaultResourcesMaterials();
  }
};
var DefaultResourcesMeshes = class {
  constructor() {
    this.myPlane = null;
    this.myCube = null;
    this.mySphere = null;
    this.myCone = null;
    this.myCylinder = null;
    this.myCircle = null;
    this.myInvertedCube = null;
    this.myInvertedSphere = null;
    this.myInvertedCone = null;
    this.myInvertedCylinder = null;
    this.myDoubleSidedPlane = null;
    this.myDoubleSidedCube = null;
    this.myDoubleSidedSphere = null;
    this.myDoubleSidedCone = null;
    this.myDoubleSidedCylinder = null;
    this.myDoubleSidedCircle = null;
  }
};
var DefaultResourcesMaterials = class {
  constructor() {
    this.myFlatOpaque = null;
    this.myFlatTransparentNoDepth = null;
    this.myPhongOpaque = null;
    this.myText = null;
  }
};

// dist/pp/components/pp_gateway_component.js
import { Component as Component17, Property as Property13 } from "@wonderlandengine/api";

// dist/audio/components/audio_manager_component.js
import { Component, Property } from "@wonderlandengine/api";

// dist/audio/audio_manager.js
import { Howler as Howler2 } from "howler";

// dist/audio/audio_player.js
import { RetainEmitter } from "@wonderlandengine/api";
import { Howl, Howler } from "howler";

// dist/audio/audio_setup.js
var AudioSetup = class _AudioSetup {
  constructor(audioFilePath = null) {
    this.myAudioFilePath = audioFilePath;
    this.myLoop = false;
    this.myAutoPlay = false;
    this.myVolume = 1;
    this._myRate = 1;
    this.myPool = 5;
    this.myPreload = true;
    this.myPreventPlayWhenAudioContextNotRunning = false;
    this.myPosition = null;
    this.mySpatial = true;
    this.myReferenceDistance = Number.MAX_VALUE;
  }
  clone() {
    let audioSetup = new _AudioSetup();
    audioSetup.myAudioFilePath = this.myAudioFilePath;
    audioSetup.myLoop = this.myLoop;
    audioSetup.myAutoPlay = this.myAutoPlay;
    audioSetup.myVolume = this.myVolume;
    audioSetup.myPitch = this.myPitch;
    audioSetup.myRate = this.myRate;
    audioSetup.myPool = this.myPool;
    audioSetup.myPreload = this.myPreload;
    audioSetup.myPreventPlayWhenAudioContextNotRunning = this.myPreventPlayWhenAudioContextNotRunning;
    if (this.myPosition != null) {
      audioSetup.myPosition = this.myPosition.vec3_clone();
    } else {
      audioSetup.myPosition = null;
    }
    audioSetup.mySpatial = this.mySpatial;
    audioSetup.myReferenceDistance = this.myReferenceDistance;
    return audioSetup;
  }
  get myPitch() {
    return this._myRate;
  }
  get myRate() {
    return this._myRate;
  }
  set myPitch(pitch) {
    this._myRate = pitch;
  }
  set myRate(rate) {
    this._myRate = rate;
  }
};

// dist/audio/audio_player.js
var AudioEvent = {
  END: "end",
  STOP: "stop",
  LOAD: "load",
  LOAD_ERROR: "loaderror",
  PLAY: "play",
  PLAY_ERROR: "playerror",
  PAUSE: "pause",
  MUTE: "mute",
  VOLUME: "volume",
  RATE: "rate",
  SEEK: "seek",
  FADE: "fade",
  UNLOCK: "unlock"
};
var AudioPlayer = class {
  /**
   * TS type inference helper
   *
   * @param {any} audioInstance
   */
  constructor(audioSetupOrAudioFilePath, audioInstance = null) {
    if (audioSetupOrAudioFilePath == null) {
      this._myAudioSetup = new AudioSetup();
    } else if (typeof audioSetupOrAudioFilePath === "string") {
      this._myAudioSetup = new AudioSetup(audioSetupOrAudioFilePath);
    } else {
      this._myAudioSetup = audioSetupOrAudioFilePath.clone();
    }
    this._myAudio = null;
    if (audioInstance == null) {
      this._myAudio = new Howl({
        src: [this._myAudioSetup.myAudioFilePath],
        loop: this._myAudioSetup.myLoop,
        volume: this._myAudioSetup.myVolume,
        autoplay: false,
        rate: this._myAudioSetup.myRate,
        pool: this._myAudioSetup.myPool,
        pos: this._myAudioSetup.mySpatial ? this._myAudioSetup.myPosition : null,
        refDistance: this._myAudioSetup.myReferenceDistance,
        preload: this._myAudioSetup.myPreload
      });
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
    } else {
      this._myAudio = audioInstance;
    }
    this._myLastAudioID = null;
    this._myAudioEventEmitters = /* @__PURE__ */ new Map();
    for (let eventKey in AudioEvent) {
      this._myAudioEventEmitters.set(AudioEvent[eventKey], new RetainEmitter());
    }
    this._addListeners();
    if (this._myAudioSetup.myAutoPlay) {
      this.play();
    }
    this._myDestroyed = false;
  }
  isValid() {
    return this._myAudio != null;
  }
  play() {
    if (Howler.state != "running" && this._myAudioSetup.myPreventPlayWhenAudioContextNotRunning) {
      return false;
    }
    let audioID = this._myAudio.play();
    if (audioID != null) {
      this._myLastAudioID = audioID;
      this.updatePosition(this._myAudioSetup.myPosition, true);
      this.updatePitch(this._myAudioSetup.myPitch, true);
      this.updateVolume(this._myAudioSetup.myVolume, true);
    }
    return audioID != null;
  }
  stop() {
    this._myAudio.stop();
  }
  pause() {
    this._myAudio.pause();
  }
  resume() {
    this._myAudio.play();
  }
  isPlaying(checkOnlyLast = false) {
    let playing = false;
    if (checkOnlyLast) {
      playing = this._myAudio.playing(this._myLastAudioID);
    } else {
      playing = this._myAudio.playing();
    }
    return playing;
  }
  isLoaded() {
    return this._myAudio.state() == "loaded";
  }
  fade(fromVolume, toVolume, duration, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setVolume(toVolume);
    }
    if (updateOnlyLast) {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3, this._myLastAudioID);
    } else {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3);
    }
  }
  isFading(checkOnlyLast = true) {
    let fading = false;
    if (checkOnlyLast) {
      let lastSound = this._myAudio._soundById(this._myLastAudioID);
      if (lastSound != null) {
        fading = lastSound._fadeTo != null;
      }
    } else {
      for (let sound of this._myAudio._sounds) {
        if (sound._fadeTo != null) {
          fading = true;
          break;
        }
      }
    }
    return fading;
  }
  updatePosition(position, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setPosition(position);
    }
    if (this._myAudioSetup.mySpatial && position) {
      if (updateOnlyLast) {
        this._myAudio.pos(position[0], position[1], position[2], this._myLastAudioID);
      } else {
        this._myAudio.pos(position[0], position[1], position[2]);
      }
    }
  }
  updatePitch(pitch, updateOnlyLast = true, setValueOnPlayer = true) {
    this.updateRate(pitch, updateOnlyLast, setValueOnPlayer);
  }
  updateRate(rate, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setRate(rate);
    }
    if (rate != null) {
      if (updateOnlyLast) {
        this._myAudio.rate(rate, this._myLastAudioID);
      } else {
        this._myAudio.rate(rate);
      }
    }
  }
  updateVolume(volume, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setVolume(volume);
    }
    if (volume != null) {
      if (updateOnlyLast) {
        this._myAudio.volume(volume, this._myLastAudioID);
      } else {
        this._myAudio.volume(volume);
      }
    }
  }
  setSpatial(spatial) {
    this._myAudioSetup.mySpatial = spatial;
  }
  setPosition(position) {
    this._myAudioSetup.myPosition = position;
  }
  setPitch(pitch) {
    this._myAudioSetup.myPitch = pitch;
  }
  setRate(rate) {
    this._myAudioSetup.myRate = rate;
  }
  setVolume(volume) {
    this._myAudioSetup.myVolume = volume;
  }
  getDuration() {
    return this._myAudio.duration();
  }
  getVolume() {
    return this._myAudioSetup.myVolume;
  }
  getPitch() {
    return this._myAudioSetup.myPitch;
  }
  getRate() {
    return this._myAudioSetup.myRate;
  }
  registerAudioEventListener(audioEvent, id, listener, notifyOnce = false, notifyIfAlreadyHappened = false) {
    this._myAudioEventEmitters.get(audioEvent).add(listener, { id, once: notifyOnce, immediate: notifyIfAlreadyHappened });
  }
  unregisterAudioEventListener(audioEvent, id) {
    this._myAudioEventEmitters.get(audioEvent).remove(id);
  }
  _addListeners() {
    if (this._myAudio != null) {
      for (let eventKey in AudioEvent) {
        let event = AudioEvent[eventKey];
        this._myAudio.on(event, function(audioID) {
          let emitter = this._myAudioEventEmitters.get(event);
          emitter.notify(audioID);
        }.bind(this));
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myAudio.unload();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/audio/audio_manager.js
var AudioManager = class {
  constructor(preloadAudio = true, engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myPreloadAudio = preloadAudio;
    this._myAudioSetups = /* @__PURE__ */ new Map();
    this._myAudioPlayersCreatedForPreload = [];
  }
  createAudioPlayer(audioSetupID) {
    let audioSetup = this.getAudioSetup(audioSetupID);
    if (audioSetup != null) {
      return new AudioPlayer(this.getAudioSetup(audioSetupID));
    }
    return null;
  }
  getAudioSetup(id) {
    return this._myAudioSetups.get(id);
  }
  addAudioSetup(id, audioSetup, preloadAudioOverride = null) {
    this._myAudioSetups.set(id, audioSetup);
    if (this._myPreloadAudio && preloadAudioOverride == null || preloadAudioOverride != null && preloadAudioOverride) {
      this._myAudioPlayersCreatedForPreload.push(this.createAudioPlayer(id));
    }
  }
  removeAudioSetup(id) {
    this._myAudioSetups.delete(id);
  }
  setVolume(volume) {
    Howler2.volume(volume);
  }
  setMute(mute) {
    Howler2.mute(mute);
  }
  stop() {
    Howler2.stop();
  }
  unloadAllAudioSources() {
    Howler2.unload();
  }
};

// dist/audio/components/audio_manager_component.js
var AudioManagerComponent = class extends Component {
  static TypeName = "pp-audio-manager";
  static Properties = {
    _myPreloadAudio: Property.bool(false),
    _myCleanUpAudioSourcesOnInit: Property.bool(false)
  };
  init() {
    this._myAudioManager = null;
    if (!Globals.hasAudioManager(this.engine)) {
      this._myAudioManager = new AudioManager(this._myPreloadAudio, this.engine);
      if (this._myCleanUpAudioSourcesOnInit) {
        this._myAudioManager.unloadAllAudioSources();
      }
      Globals.setAudioManager(this._myAudioManager, this.engine);
    }
  }
  onDestroy() {
    if (this._myAudioManager != null && Globals.getAudioManager(this.engine) == this._myAudioManager) {
      Globals.removeAudioManager(this.engine);
    }
  }
};

// dist/cauldron/cauldron/components/analytics_manager_component.js
import { Component as Component2, Property as Property2 } from "@wonderlandengine/api";

// dist/cauldron/cauldron/analytics_manager.js
var AnalyticsManager = class {
  constructor() {
    this._myAnalyticsEnabled = true;
    this._mySendDataCallback = null;
    this._myDefaultEventCooldown = 0;
    this._myEventCooldowns = /* @__PURE__ */ new Map();
    this._myDataLogEnabled = false;
    this._myEventsLogEnabled = false;
    this._myErrorsLogEnabled = false;
  }
  update(dt) {
    if (this._myEventCooldowns.size > 0) {
      let eventNamesToUpdateCooldown = this._myEventCooldowns.keys();
      for (let eventName of eventNamesToUpdateCooldown) {
        let newCooldown = this._myEventCooldowns.get(eventName) - dt;
        if (newCooldown <= 0) {
          this._myEventCooldowns.delete(eventName);
        } else {
          this._myEventCooldowns.set(eventName, newCooldown);
        }
      }
    }
  }
  setAnalyticsEnabled(enabled) {
    this._myAnalyticsEnabled = enabled;
  }
  isAnalyticsEnabled() {
    return this._myAnalyticsEnabled;
  }
  setSendDataCallback(callback) {
    this._mySendDataCallback = callback;
  }
  sendData(...args) {
    let dataSent = false;
    try {
      if (this._myAnalyticsEnabled) {
        if (this._myDataLogEnabled) {
          console.log("Analytics Data: " + args);
        }
        if (this._mySendDataCallback != null) {
          this._mySendDataCallback(...args);
          dataSent = true;
        } else if (this._myErrorsLogEnabled) {
          console.error("Analytics Error: You need to set the send data callback");
        } else {
          console.warn("Analytics Error: You need to set the send data callback");
        }
      }
    } catch (error3) {
      if (this._myErrorsLogEnabled) {
        console.error(error3);
      }
      dataSent = false;
    }
    return dataSent;
  }
  sendEvent(eventName, value = null) {
    let eventSent = false;
    try {
      if (this._myAnalyticsEnabled) {
        if (this._myEventsLogEnabled) {
          if (value != null) {
            console.log("Analytics Event: " + eventName + " - Value: " + value);
          } else {
            console.log("Analytics Event: " + eventName);
          }
        }
        if (this._mySendDataCallback != null) {
          if (value != null) {
            this._mySendDataCallback("event", eventName, { "value": value });
          } else {
            this._mySendDataCallback("event", eventName);
          }
          eventSent = true;
        } else if (this._myErrorsLogEnabled) {
          console.error("Analytics Error: You need to set the send data callback");
        } else {
          console.warn("Analytics Error: You need to set the send data callback");
        }
      }
    } catch (error3) {
      if (this._myErrorsLogEnabled) {
        console.error(error3);
      }
      eventSent = false;
    }
    return eventSent;
  }
  sendEventOnce(eventName, value = null) {
    if (this._myAnalyticsEnabled) {
      if (!this.hasEventAlreadyBeenSent(eventName)) {
        let eventSent = this.sendEvent(eventName, value, true);
        if (eventSent) {
          this._myEventsSentOnce.pp_pushUnique(eventName);
        }
      }
    }
  }
  clearEventSentOnceState(eventName) {
    this._myEventsSentOnce.pp_removeEqual(eventName);
  }
  clearAllEventsSentOnceState() {
    this._myEventsSentOnce.pp_clear();
  }
  hasEventAlreadyBeenSent(eventName) {
    return this._myEventsSentOnce.pp_hasEqual(eventName);
  }
  getEventsAlreadyBeenSent() {
    return this._myEventsSentOnce;
  }
  sendEventWithCooldown(eventName, value = null, cooldownSeconds = this._myDefaultEventCooldown) {
    if (this._myAnalyticsEnabled) {
      if (this.getEventCooldown(eventName) <= 0) {
        let eventSent = this.sendEvent(eventName, value, true);
        if (eventSent) {
          this._myEventCooldowns.set(eventName, cooldownSeconds);
        }
      }
    }
  }
  getDefaultEventCooldown() {
    return this._myDefaultEventCooldown;
  }
  setDefaultEventCooldown(cooldownSeconds) {
    this._myDefaultEventCooldown = cooldownSeconds;
  }
  clearEventCooldown(eventName) {
    this._myEventCooldowns.delete(eventName);
  }
  clearAllEventCooldowns() {
    this._myEventCooldowns.clear();
  }
  getEventCooldown(eventName) {
    let eventCooldown = this._myEventCooldowns.get(eventName);
    if (eventCooldown != null) {
      return eventCooldown;
    }
    return 0;
  }
  getEventCooldowns() {
    return this._myEventCooldowns;
  }
  setDataLogEnabled(enabled) {
    this._myDataLogEnabled = enabled;
  }
  isDataLogEnabled() {
    return this._myDataLogEnabled;
  }
  setEventsLogEnabled(enabled) {
    this._myEventsLogEnabled = enabled;
  }
  isEventsLogEnabled() {
    return this._myEventsLogEnabled;
  }
  setErrorsLogEnabled(enabled) {
    this._myErrorsLogEnabled = enabled;
  }
  isErrorsLogEnabled() {
    return this._myErrorsLogEnabled;
  }
};

// dist/cauldron/cauldron/components/analytics_manager_component.js
var AnalyticsManagerComponent = class extends Component2 {
  static TypeName = "pp-analytics-manager";
  static Properties = {
    _myDisableAnalyticsOnLocalhost: Property2.bool(true)
  };
  init() {
    this._myAnalyticsManager = null;
    if (!Globals.hasAnalyticsManager(this.engine)) {
      this._myAnalyticsManager = new AnalyticsManager();
      if (BrowserUtils.isLocalhost() && this._myDisableAnalyticsOnLocalhost) {
        this._myAnalyticsManager.setAnalyticsEnabled(false);
      }
      Globals.setAnalyticsManager(this._myAnalyticsManager, this.engine);
    }
  }
  update(dt) {
    if (this._myAnalyticsManager != null) {
      this._myAnalyticsManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myAnalyticsManager != null && Globals.getAnalyticsManager(this.engine) == this._myAnalyticsManager) {
      Globals.removeAnalyticsManager(this.engine);
    }
  }
};

// dist/cauldron/cauldron/components/save_manager_component.js
import { Component as Component3, Property as Property3 } from "@wonderlandengine/api";

// dist/cauldron/cauldron/save_manager.js
import { Emitter as Emitter4 } from "@wonderlandengine/api";

// dist/cauldron/utils/save_utils.js
function save(id, value) {
  if (value != null) {
    localStorage.setItem(id, value);
  }
}
function has2(id) {
  return SaveUtils.loadString(id, null) != null;
}
function remove2(id) {
  return localStorage.removeItem(id);
}
function clear2() {
  return localStorage.clear();
}
function load(id, defaultValue = null) {
  return SaveUtils.loadString(id, defaultValue);
}
function loadString(id, defaultValue = null) {
  const item = localStorage.getItem(id);
  if (item != null) {
    return item;
  }
  return defaultValue;
}
function loadNumber(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item != null) {
    return Number(item);
  }
  return defaultValue;
}
function loadBool(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item == "true") {
    return true;
  } else if (item == "false") {
    return false;
  }
  return defaultValue;
}
function loadObject(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item != null) {
    try {
      return JSON.parse(item);
    } catch (error3) {
    }
  }
  return defaultValue;
}
var SaveUtils = {
  save,
  has: has2,
  remove: remove2,
  clear: clear2,
  load,
  loadString,
  loadNumber,
  loadBool,
  loadObject
};

// dist/cauldron/cauldron/save_manager.js
var SaveManager = class {
  constructor(saveID, autoLoadSaves = true, engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._mySaveID = saveID;
    this._myCommitSavesDelayTimer = new Timer(0, false);
    this._myDelaySavesCommit = true;
    this._myCommitSavesDirty = false;
    this._myCommitSavesDirtyClearOnFail = true;
    this._myCommitSavesOnInterrupt = true;
    this._myCommitSavesWhenLoadSavesFailed = false;
    this._myResetSaveObjectOnLoadSavesFail = false;
    this._mySaveObject = {};
    this._myLoadSavesSucceded = false;
    this._mySaveObjectLoadedOnce = false;
    this._myAtLeastOneValueSavedOnce = false;
    this._myClearEmitter = new Emitter4();
    this._myDeleteEmitter = new Emitter4();
    this._myDeleteIDEmitters = /* @__PURE__ */ new Map();
    this._mySaveEmitter = new Emitter4();
    this._mySaveValueChangedEmitter = new Emitter4();
    this._mySaveIDEmitters = /* @__PURE__ */ new Map();
    this._mySaveValueChangedIDEmitters = /* @__PURE__ */ new Map();
    this._myCommitSavesEmitter = new Emitter4();
    this._myLoadEmitter = new Emitter4();
    this._myLoadIDEmitters = /* @__PURE__ */ new Map();
    this._myLoadSavesEmitter = new Emitter4();
    if (autoLoadSaves) {
      this.loadSaves();
    }
    this._myXRVisibilityChangeEventListener = null;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
    this._myWindowVisibilityChangeEventListener = function() {
      if (document.visibilityState != "visible") {
        this._onInterrupt();
      }
    }.bind(this);
    window.addEventListener("visibilitychange", this._myWindowVisibilityChangeEventListener);
    this._myDestroyed = false;
  }
  setCommitSavesDelay(delay) {
    this._myCommitSavesDelayTimer.start(delay);
  }
  setDelaySavesCommit(delayed) {
    this._myDelaySavesCommit = delayed;
  }
  setCommitSavesDirty(dirty, startDelayTimer = true) {
    this._myCommitSavesDirty = dirty;
    if (dirty && startDelayTimer) {
      if (!this.startDelayTimer.isRunning()) {
        this._myCommitSavesDelayTimer.start();
      }
    } else {
      this._myCommitSavesDelayTimer.reset();
    }
  }
  setCommitSavesDirtyClearOnFail(clearOnFail) {
    this._myCommitSavesDirtyClearOnFail = clearOnFail;
  }
  setCommitSavesOnInterrupt(commitSavesOnInterrupt) {
    this._myCommitSavesOnInterrupt = commitSavesOnInterrupt;
  }
  setCommitSavesWhenLoadSavesFailed(commitSavesWhenLoadSavesFailed) {
    this._myCommitSavesWhenLoadSavesFailed = commitSavesWhenLoadSavesFailed;
  }
  setResetSaveObjectOnLoadSavesFail(resetSaveObjectOnLoadSavesFail) {
    this._myResetSaveObjectOnLoadSavesFail = resetSaveObjectOnLoadSavesFail;
  }
  getCommitSavesDelay() {
    return this._myCommitSavesDelayTimer.getDuration();
  }
  isDelaySavesCommit() {
    return this._myDelaySavesCommit;
  }
  isCommitSavesDirty() {
    return this._myCommitSavesDirty;
  }
  isCommitSavesDirtyClearOnFail() {
    return this._myCommitSavesDirtyClearOnFail;
  }
  isCommitSavesOnInterrupt() {
    return this._myCommitSavesOnInterrupt;
  }
  isCommitSavesWhenLoadSavesFailed() {
    return this._myCommitSavesWhenLoadSavesFailed;
  }
  isResetSaveObjectOnLoadSavesFail() {
    return this._myResetSaveObjectOnLoadSavesFail;
  }
  hasLoadSavesSucceded() {
    return this._myLoadSavesSucceded;
  }
  update(dt) {
    if (this._myCommitSavesDelayTimer.isRunning()) {
      this._myCommitSavesDelayTimer.update(dt);
      if (this._myCommitSavesDelayTimer.isDone()) {
        if (this._myCommitSavesDirty) {
          this._commitSaves();
        }
      }
    } else {
      if (this._myCommitSavesDirty) {
        this._commitSaves();
      }
    }
  }
  has(id) {
    return id in this._mySaveObject;
  }
  save(id, value, overrideDelaySavesCommit = null) {
    let sameValue = false;
    if (this.has(id)) {
      sameValue = this._mySaveObject[id] === value;
    }
    if (!sameValue) {
      this._mySaveObject[id] = value;
      if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
        this._myCommitSavesDirty = true;
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        this._commitSaves();
      }
    }
    this._myAtLeastOneValueSavedOnce = true;
    this._mySaveEmitter.notify(id, value);
    if (this._mySaveIDEmitters.size > 0) {
      let emitter = this._mySaveIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value);
      }
    }
    if (!sameValue) {
      this._mySaveValueChangedEmitter.notify(id, value);
      if (this._mySaveValueChangedIDEmitters.size > 0) {
        let emitter = this._mySaveValueChangedIDEmitters.get(id);
        if (emitter != null) {
          emitter.notify(id, value);
        }
      }
    }
  }
  delete(id, overrideDelaySavesCommit = null) {
    if (this.has(id)) {
      delete this._mySaveObject[id];
      if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
        this._myCommitSavesDirty = true;
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        this._commitSaves();
      }
    }
    this._myAtLeastOneValueSavedOnce = true;
    this._myDeleteEmitter.notify(id);
    if (this._myDeleteIDEmitters.size > 0) {
      let emitter = this._myDeleteIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id);
      }
    }
  }
  clear(overrideDelaySavesCommit = null) {
    if (Object.keys(this._mySaveObject).length > 0) {
      this._mySaveObject = {};
      if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
        this._myCommitSavesDirty = true;
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        this._commitSaves();
      }
    }
    this._myAtLeastOneValueSavedOnce = true;
    this._myClearEmitter.notify();
  }
  load(id, defaultValue) {
    let value = this._mySaveObject[id];
    if (value == null && defaultValue != null) {
      value = defaultValue;
    }
    this._myLoadEmitter.notify(id, value);
    if (this._myLoadIDEmitters.size > 0) {
      let emitter = this._myLoadIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value);
      }
    }
    return value;
  }
  commitSaves(commitSavesOnlyIfDirty = true) {
    if (this._myCommitSavesDirty || !commitSavesOnlyIfDirty) {
      this._commitSaves();
    }
  }
  _commitSaves() {
    let succeded = true;
    if (this._myLoadSavesSucceded || this._myCommitSavesWhenLoadSavesFailed) {
      try {
        let saveObjectStringified = JSON.stringify(this._mySaveObject);
        SaveUtils.save(this._mySaveID, saveObjectStringified);
      } catch (error3) {
        succeded = false;
      }
    }
    if (succeded || this._myCommitSavesDirtyClearOnFail) {
      this._myCommitSavesDirty = false;
      this._myCommitSavesDelayTimer.reset();
    }
    this._myCommitSavesEmitter.notify(succeded);
    return succeded;
  }
  loadSaves() {
    let saveObject = {};
    let loadSavesSucceded = false;
    let saveObjectReset = false;
    let maxLoadObjectAttempts = 3;
    do {
      try {
        saveObject = SaveUtils.loadObject(this._mySaveID, {});
        loadSavesSucceded = true;
      } catch (error3) {
        maxLoadObjectAttempts--;
      }
    } while (maxLoadObjectAttempts > 0 && !loadSavesSucceded);
    if (loadSavesSucceded) {
      this._mySaveObject = saveObject;
      this._myLoadSavesSucceded = true;
    } else if (this._myResetSaveObjectOnLoadSavesFail) {
      this._mySaveObject = {};
      this._myLoadSavesSucceded = false;
      saveObjectReset = true;
    }
    this._mySaveObjectLoadedOnce = true;
    this._myLoadSavesEmitter.notify(loadSavesSucceded, saveObjectReset);
    return loadSavesSucceded;
  }
  _onXRSessionStart(session) {
    this._myXRVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState != "visible") {
        this._onInterrupt();
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myXRVisibilityChangeEventListener);
  }
  _onXRSessionEnd() {
    this._myXRVisibilityChangeEventListener = null;
    this._onInterrupt();
  }
  _onInterrupt() {
    if (this._myCommitSavesOnInterrupt && this._myCommitSavesDirty && (this._mySaveObjectLoadedOnce || this._myAtLeastOneValueSavedOnce)) {
      this.commitSaves();
    }
  }
  registerClearEventListener(listenerID, listener) {
    this._myClearEmitter.add(listener, { id: listenerID });
  }
  unregisterClearEventListener(listenerID) {
    this._myClearEmitter.remove(listenerID);
  }
  registerDeleteEventListener(listenerID, listener) {
    this._myDeleteEmitter.add(listener, { id: listenerID });
  }
  unregisterDeleteEventListener(listenerID) {
    this._myDeleteEmitter.remove(listenerID);
  }
  registerDeleteIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myDeleteIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterDeleteIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myDeleteIDEmitters.delete(valueID);
      }
    }
  }
  registerSaveEventListener(listenerID, listener) {
    this._mySaveEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveEventListener(listenerID) {
    this._mySaveEmitter.remove(listenerID);
  }
  registerSaveIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._mySaveIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._mySaveIDEmitters.delete(valueID);
      }
    }
  }
  registerSaveValueChangedEventListener(listenerID, listener) {
    this._mySaveValueChangedEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveValueChangedEventListener(listenerID) {
    this._mySaveValueChangedEmitter.remove(listenerID);
  }
  registerSaveValueChangedIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._mySaveValueChangedIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveValueChangedIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._mySaveValueChangedIDEmitters.delete(valueID);
      }
    }
  }
  registerCommitSavesEventListener(listenerID, listener) {
    this._myCommitSavesEmitter.add(listener, { id: listenerID });
  }
  unregisterCommitSavesEventListener(listenerID) {
    this._myCommitSavesEmitter.remove(listenerID);
  }
  registerLoadEventListener(listenerID, listener) {
    this._myLoadEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadEventListener(listenerID) {
    this._myLoadEmitter.remove(listenerID);
  }
  registerLoadIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myLoadIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myLoadIDEmitters.delete(valueID);
      }
    }
  }
  registerLoadSavesEventListener(listenerID, listener) {
    this._myLoadSavesEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadSavesEventListener(listenerID) {
    this._myLoadSavesEmitter.remove(listenerID);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.getSession(this._myEngine)?.removeEventListener("visibilitychange", this._myXRVisibilityChangeEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
    window.removeEventListener("visibilitychange", this._myWindowVisibilityChangeEventListener);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/cauldron/cauldron/components/save_manager_component.js
var SaveManagerComponent = class extends Component3 {
  static TypeName = "pp-save-manager";
  static Properties = {
    _mySaveID: Property3.string(""),
    _myAutoLoadSaves: Property3.bool(true)
  };
  init() {
    this._mySaveManager = null;
    if (this._mySaveID.length > 0 && !Globals.hasSaveManager(this.engine)) {
      this._mySaveManager = new SaveManager(this._mySaveID, this._myAutoLoadSaves, this.engine);
      Globals.setSaveManager(this._mySaveManager, this.engine);
    }
  }
  update(dt) {
    if (this._mySaveManager != null) {
      this._mySaveManager.update(dt);
    }
  }
  onDestroy() {
    if (this._mySaveManager != null && Globals.getSaveManager(this.engine) == this._mySaveManager) {
      Globals.removeSaveManager(this.engine);
    }
  }
};

// dist/cauldron/object_pool/components/object_pool_manager_component.js
import { Component as Component4 } from "@wonderlandengine/api";

// dist/cauldron/object_pool/object_pool_manager.js
var ObjectPoolManager = class {
  constructor() {
    this._myPools = /* @__PURE__ */ new Map();
    this._myDestroyed = false;
  }
  addPool(poolID, pool) {
    if (!this._myPools.has(poolID)) {
      this._myPools.set(poolID, pool);
    } else {
      console.warn("Trying to add a Pool with an ID that has been already used:", poolID);
    }
  }
  destroyPool(poolID) {
    let poolToRemove = this._myPools.get(poolID);
    if (poolToRemove != null) {
      this._myPools.delete(poolID);
      poolToRemove.destroy();
    }
  }
  getPool(poolID) {
    return this._myPools.get(poolID);
  }
  hasPool(poolID) {
    return this._myPools.has(poolID);
  }
  get(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).get();
    }
    return null;
  }
  has(poolIDOrObject, object) {
    let hasObject = false;
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        if (pool.has(poolIDOrObject)) {
          hasObject = true;
          break;
        }
      }
    } else {
      hasObject = this._myPools.get(poolIDOrObject).has(object);
    }
    return hasObject;
  }
  isBusy(poolIDOrObject, object) {
    let busy = false;
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        if (pool.isBusy(poolIDOrObject)) {
          busy = true;
          break;
        }
      }
    } else {
      busy = this._myPools.get(poolIDOrObject).isBusy(object);
    }
    return busy;
  }
  isAvailable(poolIDOrObject, object) {
    let available = false;
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        if (pool.isAvailable(poolIDOrObject)) {
          available = true;
          break;
        }
      }
    } else {
      available = this._myPools.get(poolIDOrObject).isAvailable(object);
    }
    return available;
  }
  release(poolIDOrObject, object) {
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        pool.release(poolIDOrObject);
      }
    } else {
      this._myPools.get(poolIDOrObject).release(object);
    }
  }
  releaseAll(poolID = void 0) {
    if (poolID === void 0) {
      for (let pool of this._myPools.values()) {
        pool.releaseAll();
      }
    } else {
      this._myPools.get(poolID).releaseAll();
    }
  }
  increase(poolID, amount) {
    let pool = this._myPools.get(poolID);
    if (pool) {
      pool.increase(amount);
    }
  }
  increasePercentage(poolID, percentage) {
    let pool = this._myPools.get(poolID);
    if (pool) {
      pool.increasePercentage(percentage);
    }
  }
  getSize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getSize();
    }
    return null;
  }
  getAvailableSize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getAvailableSize();
    }
    return null;
  }
  getBusySize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getBusySize();
    }
    return null;
  }
  destroy() {
    this._myDestroyed = true;
    for (let pool of this._myPools.values()) {
      pool.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/cauldron/object_pool/components/object_pool_manager_component.js
var ObjectPoolManagerComponent = class extends Component4 {
  static TypeName = "pp-object-pools-manager";
  static Properties = {};
  init() {
    this._myObjectPoolManager = null;
    if (!Globals.hasObjectPoolManager(this.engine)) {
      this._myObjectPoolManager = new ObjectPoolManager();
      Globals.setObjectPoolManager(this._myObjectPoolManager, this.engine);
    }
  }
  onDestroy() {
    if (this._myObjectPoolManager != null && Globals.getObjectPoolManager(this.engine) == this._myObjectPoolManager) {
      Globals.removeObjectPoolManager(this.engine);
    }
  }
};

// dist/cauldron/visual/components/visual_manager_component.js
import { Component as Component5 } from "@wonderlandengine/api";

// dist/cauldron/object_pool/object_pool.js
var ObjectPoolParams = class {
  constructor() {
    this.myInitialPoolSize = 0;
    this.myAmountToAddWhenEmpty = 0;
    this.myPercentageToAddWhenEmpty = 0;
    this.myCloneParams = void 0;
    this.myOptimizeObjectsAllocation = true;
    this.myCloneCallback = null;
    this.mySetActiveCallback = null;
    this.myEqualCallback = null;
    this.myDestroyCallback = null;
    this.myOptimizeObjectsAllocationCallback = null;
    this.myLogEnabled = false;
  }
};
var ObjectPool = class {
  constructor(objectPrototype, objectPoolParams) {
    this._myObjectPoolParams = objectPoolParams;
    this._myObjectPrototype = objectPrototype;
    this._myAvailableObjects = [];
    this._myBusyObjects = [];
    this._addToPool(objectPoolParams.myInitialPoolSize, false);
    this._myDestroyed = false;
  }
  get() {
    let object = this._myAvailableObjects.shift();
    if (object == null) {
      let amountToAdd = Math.ceil(this._myBusyObjects.length * this._myObjectPoolParams.myPercentageToAddWhenEmpty);
      amountToAdd += this._myObjectPoolParams.myAmountToAddWhenEmpty;
      this._addToPool(amountToAdd, this._myObjectPoolParams.myLogEnabled);
      object = this._myAvailableObjects.shift();
    }
    if (object != null) {
      this._myBusyObjects.push(object);
    }
    return object;
  }
  has(object) {
    let hasObject = false;
    if (this.isBusy(object) || this.isAvailable(object)) {
      hasObject = true;
    }
    return hasObject;
  }
  isBusy(object) {
    return this._myBusyObjects.pp_has(this._equals.bind(this, object));
  }
  isAvailable(object) {
    return this._myAvailableObjects.pp_has(this._equals.bind(this, object));
  }
  release(object) {
    let released = this._myBusyObjects.pp_remove(this._equals.bind(this, object));
    if (released != null) {
      this._setActive(released, false);
      this._myAvailableObjects.push(released);
    }
  }
  releaseAll() {
    for (let busyObject of this._myBusyObjects) {
      this._setActive(busyObject, false);
      this._myAvailableObjects.push(busyObject);
    }
  }
  increase(amount) {
    this._addToPool(amount, false);
  }
  increasePercentage(percentage) {
    let amount = Math.ceil(this.getSize() * percentage);
    this._addToPool(amount, false);
  }
  getObjects() {
    let objects = [];
    objects.push(...this._myAvailableObjects);
    objects.push(...this._myBusyObjects);
    return objects;
  }
  getSize() {
    return this._myBusyObjects.length + this._myAvailableObjects.length;
  }
  getAvailableObjects() {
    return this._myAvailableObjects;
  }
  getAvailableSize() {
    return this._myAvailableObjects.length;
  }
  getBusyObjects() {
    return this._myBusyObjects;
  }
  getBusySize() {
    return this._myBusyObjects.length;
  }
  _addToPool(size, logEnabled) {
    if (size <= 0) {
      return;
    }
    if (this._myObjectPoolParams.myOptimizeObjectsAllocation) {
      if (this._myObjectPoolParams.myOptimizeObjectsAllocationCallback != null) {
        this._myObjectPoolParams.myOptimizeObjectsAllocationCallback(this._myObjectPrototype, size);
      } else if (this._myObjectPrototype.pp_reserveObjects != null) {
        this._myObjectPrototype.pp_reserveObjects(size);
      }
    }
    for (let i = 0; i < size; i++) {
      this._myAvailableObjects.push(this._clone(this._myObjectPrototype));
    }
    if (logEnabled) {
      console.warn("Added new elements to the pool:", size);
    }
  }
  _clone(object) {
    let clone10 = null;
    if (this._myObjectPoolParams.myCloneCallback != null) {
      clone10 = this._myObjectPoolParams.myCloneCallback(object, this._myObjectPoolParams.myCloneParams);
    } else if (object.pp_clone != null) {
      clone10 = object.pp_clone(this._myObjectPoolParams.myCloneParams);
    } else if (object.clone != null) {
      clone10 = object.clone(this._myObjectPoolParams.myCloneParams);
    }
    if (clone10 == null) {
      console.error("Object not cloneable, pool will return null");
    } else {
      this._setActive(clone10, false);
    }
    return clone10;
  }
  _setActive(object, active) {
    if (this._myObjectPoolParams.mySetActiveCallback != null) {
      this._myObjectPoolParams.mySetActiveCallback(object, active);
    } else if (object.pp_setActive != null) {
      object.pp_setActive(active);
    } else if (object.setActive != null) {
      object.setActive(active);
    }
  }
  _equals(first2, second) {
    let equals5 = false;
    if (this._myObjectPoolParams.myEqualCallback != null) {
      equals5 = this._myObjectPoolParams.myEqualCallback(first2, second);
    } else if (first2.pp_equals != null) {
      equals5 = first2.pp_equals(second);
    } else if (first2.equals != null) {
      equals5 = first2.equals(second);
    } else {
      equals5 = first2 == second;
    }
    return equals5;
  }
  destroy() {
    this._myDestroyed = true;
    for (let object of this._myAvailableObjects) {
      this._destroyObject(object);
    }
    for (let object of this._myBusyObjects) {
      this._destroyObject(object);
    }
    this._destroyObject(this._myObjectPrototype);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
  _destroyObject(object) {
    if (this._myObjectPoolParams.myDestroyCallback != null) {
      this._myObjectPoolParams.myDestroyCallback(object);
    } else if (object.pp_destroy != null) {
      object.pp_destroy();
    } else if (object.destroy != null) {
      object.destroy();
    }
  }
};

// dist/cauldron/visual/elements/visual_arrow.js
import { MeshComponent as MeshComponent4 } from "@wonderlandengine/api";

// dist/cauldron/visual/elements/visual_element_types.js
var VisualElementType = {
  MESH: 0,
  LINE: 1,
  POINT: 2,
  TEXT: 3,
  ARROW: 4,
  TRANSFORM: 5,
  RAYCAST: 6,
  TORUS: 7
};

// dist/cauldron/visual/elements/visual_line.js
import { MeshComponent as MeshComponent3 } from "@wonderlandengine/api";
var VisualLineParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myStart = vec3_create();
    this.myDirection = vec3_create(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.LINE;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  copy(other) {
  }
};
var VisualLine = class _VisualLine {
  constructor(params = new VisualLineParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myLineParentObject = null;
    this._myLineObject = null;
    this._myLineMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myLineParentObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _build() {
    this._myLineParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myLineObject = this._myLineParentObject.pp_addObject();
    this._myLineMeshComponent = this._myLineObject.pp_addComponent(MeshComponent3);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualLineParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualLine(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myLineParentObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualLine.prototype._refresh = function() {
  let scaleLine = vec3_create();
  let translateLine = vec3_create();
  let forward = vec3_create(0, 1, 0);
  return function _refresh() {
    this._myLineParentObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myLineParentObject.pp_setPositionLocal(this._myParams.myStart);
    } else {
      this._myLineParentObject.pp_setPosition(this._myParams.myStart);
    }
    scaleLine.vec3_set(this._myParams.myThickness / 2, this._myParams.myLength / 2, this._myParams.myThickness / 2);
    if (this._myParams.myLocal) {
      this._myLineObject.pp_setScaleLocal(scaleLine);
    } else {
      this._myLineObject.pp_setScale(scaleLine);
    }
    if (this._myParams.myLocal) {
      this._myLineObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myLineObject.pp_setUp(this._myParams.myDirection, forward);
    }
    this._myLineObject.pp_resetPositionLocal();
    translateLine.vec3_set(0, this._myParams.myLength / 2, 0);
    this._myLineObject.pp_translateObject(translateLine);
    if (this._myParams.myMesh != null) {
      this._myLineMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myLineMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).myCylinder;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myLineMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myLineMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myLineMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualLineParams.prototype.copy = function copy8(other) {
  this.myStart.vec3_copy(other.myStart);
  this.myDirection.vec3_copy(other.myDirection);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  this.myMesh = other.myMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/visual/elements/visual_arrow.js
var VisualArrowParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myStart = vec3_create();
    this.myDirection = vec3_create(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myArrowThickness = null;
    this.myArrowLength = null;
    this.myShareArrowLengthWithLineWhenArrowLongerThanLength = true;
    this.myLineMesh = null;
    this.myArrowMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.ARROW;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  copy(other) {
  }
};
var VisualArrow = class _VisualArrow {
  constructor(params = new VisualArrowParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualLine = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualLine.setAutoRefresh(false);
    this._myArrowParentObject = null;
    this._myArrowObject = null;
    this._myArrowMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myVisualLine.setVisible(visible);
      this._myArrowParentObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualLine.forceRefresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualLine.update(dt);
  }
  _build() {
    this._myArrowParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myArrowObject = this._myArrowParentObject.pp_addObject();
    this._myArrowMeshComponent = this._myArrowObject.pp_addComponent(MeshComponent4);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualArrowParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualArrow(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualLine.destroy();
    this._myArrowParentObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualArrow.prototype._refresh = function() {
  let arrowPosition = vec3_create();
  let parentTranslate = vec3_create();
  let arrowScale = vec3_create();
  let forward = vec3_create(0, 1, 0);
  return function _refresh() {
    this._myArrowParentObject.pp_setParent(this._myParams.myParent, false);
    let arrowThickness = this._myParams.myArrowThickness != null ? this._myParams.myArrowThickness : this._myParams.myThickness * 1.5;
    let arrowLength = this._myParams.myArrowLength != null ? this._myParams.myArrowLength : this._myParams.myThickness * 3.5;
    if (this._myParams.myShareArrowLengthWithLineWhenArrowLongerThanLength && arrowLength > this._myParams.myLength / 2) {
      arrowLength = this._myParams.myLength / 2;
    }
    arrowLength = Math.min(arrowLength, this._myParams.myLength);
    arrowScale.vec3_set(arrowThickness, arrowLength / 2, arrowThickness);
    let lineLength = this._myParams.myLength - arrowLength;
    this._myParams.myDirection.vec3_scale(lineLength, arrowPosition);
    arrowPosition.vec3_add(this._myParams.myStart, arrowPosition);
    if (this._myParams.myLocal) {
      this._myArrowParentObject.pp_setPositionLocal(arrowPosition);
      this._myArrowParentObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myArrowParentObject.pp_setPosition(arrowPosition);
      this._myArrowParentObject.pp_setUp(this._myParams.myDirection, forward);
    }
    parentTranslate.vec3_set(0, arrowLength / 2 - 1e-5, 0);
    this._myArrowParentObject.pp_translateObject(parentTranslate);
    if (this._myParams.myLocal) {
      this._myArrowObject.pp_setScaleLocal(arrowScale);
    } else {
      this._myArrowObject.pp_setScale(arrowScale);
    }
    if (this._myParams.myArrowMesh != null) {
      this._myArrowMeshComponent.mesh = this._myParams.myArrowMesh;
    } else {
      this._myArrowMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).myCone;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myArrowMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myArrowMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myArrowMeshComponent.material = this._myParams.myMaterial;
    }
    let visualLineParams = this._myVisualLine.getParams();
    visualLineParams.myStart.vec3_copy(this._myParams.myStart);
    visualLineParams.myDirection.vec3_copy(this._myParams.myDirection);
    visualLineParams.myLength = lineLength;
    visualLineParams.myThickness = this._myParams.myThickness;
    visualLineParams.myMesh = this._myParams.myLineMesh;
    visualLineParams.myMaterial = this._myArrowMeshComponent.material;
    visualLineParams.myParent = this._myParams.myParent;
    visualLineParams.myLocal = this._myParams.myLocal;
    this._myVisualLine.paramsUpdated();
  };
}();
VisualArrowParams.prototype.copy = function copy9(other) {
  this.myStart.vec3_copy(other.myStart);
  this.myDirection.vec3_copy(other.myDirection);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  this.myArrowThickness = other.myArrowThickness;
  this.myArrowLength = other.myArrowLength;
  this.myShareArrowLengthWithLineWhenArrowLongerThanLength = other.myShareArrowLengthWithLineWhenArrowLongerThanLength;
  this.myArrowMesh = other.myArrowMesh;
  this.myLineMesh = other.myLineMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/visual/elements/visual_mesh.js
import { MeshComponent as MeshComponent5 } from "@wonderlandengine/api";
var VisualMeshParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myTransform = mat4_create();
    this.myMesh = null;
    this.myMaterial = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.MESH;
  }
  copy(other) {
  }
};
var VisualMesh = class _VisualMesh {
  constructor(params = new VisualMeshParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myMeshObject = null;
    this._myMeshComponent = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myMeshObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _refresh() {
    this._myMeshObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myMeshObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myMeshObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myMesh == null) {
      this._myMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).mySphere;
    } else {
      this._myMeshComponent.mesh = this._myParams.myMesh;
    }
    if (this._myParams.myMaterial == null) {
      this._myMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
    } else {
      this._myMeshComponent.material = this._myParams.myMaterial;
    }
  }
  _build() {
    this._myMeshObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myMeshComponent = this._myMeshObject.pp_addComponent(MeshComponent5);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualMeshParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualMesh(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  destroy() {
    this._myDestroyed = true;
    this._myMeshObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualMeshParams.prototype.copy = function copy10(other) {
  this.myTransform.pp_copy(other.myTransform);
  if (other.myMesh != null) {
    this.myMesh = other.myMesh;
  } else {
    this.myMesh = null;
  }
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/visual/elements/visual_point.js
import { MeshComponent as MeshComponent6 } from "@wonderlandengine/api";
var VisualPointParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPosition = vec3_create();
    this.myRadius = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.POINT;
  }
  copy(other) {
  }
};
var VisualPoint = class _VisualPoint {
  constructor(params = new VisualPointParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myPointObject = null;
    this._myPointMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myPointObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _build() {
    this._myPointObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myPointMeshComponent = this._myPointObject.pp_addComponent(MeshComponent6);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualPointParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualPoint(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myPointObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualPoint.prototype._refresh = function() {
  let rotation = vec3_create(0, 0, 0);
  return function _refresh() {
    this._myPointObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myPointObject.pp_setPositionLocal(this._myParams.myPosition);
      this._myPointObject.pp_setRotationLocal(rotation);
      this._myPointObject.pp_setScaleLocal(this._myParams.myRadius);
    } else {
      this._myPointObject.pp_setPosition(this._myParams.myPosition);
      this._myPointObject.pp_setRotation(rotation);
      this._myPointObject.pp_setScale(this._myParams.myRadius);
    }
    if (this._myParams.myMesh != null) {
      this._myPointMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myPointMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).mySphere;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myPointMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myPointMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myPointMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualPointParams.prototype.copy = function copy11(other) {
  this.myPosition.vec3_copy(other.myPosition);
  this.myRadius = other.myRadius;
  this.myMesh = other.myMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/physics/physics_utils.js
var _myLayerFlagsNames = ["0", "1", "2", "3", "4", "5", "6", "7"];
var _myRaycastCount = /* @__PURE__ */ new WeakMap();
var _myRaycastVisualDebugEnabled = /* @__PURE__ */ new WeakMap();
function setLayerFlagsNames(layerFlagsNames) {
  _myLayerFlagsNames = layerFlagsNames;
}
function getLayerFlagsNames() {
  return _myLayerFlagsNames;
}
function getRaycastCount(physics = Globals.getPhysics()) {
  let raycastCount = _myRaycastCount.get(physics);
  return raycastCount != null ? raycastCount : 0;
}
function resetRaycastCount(physics = Globals.getPhysics()) {
  _myRaycastCount.set(physics, 0);
}
function isRaycastVisualDebugEnabled(physics = Globals.getPhysics()) {
  return _myRaycastVisualDebugEnabled.get(physics);
}
function setRaycastVisualDebugEnabled(visualDebugEnabled, physics = Globals.getPhysics()) {
  _myRaycastVisualDebugEnabled.set(physics, visualDebugEnabled);
}
var raycast = function() {
  let maxHitCount = 20;
  let objects = new Array(maxHitCount);
  let distances = new Float32Array(maxHitCount);
  let locations = Array.from({ length: maxHitCount }, () => new Float32Array(3));
  let normals = Array.from({ length: maxHitCount }, () => new Float32Array(3));
  let insideCheckSubVector = vec3_create();
  let invertedRaycastDirection = vec3_create();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function raycast2(raycastParams, raycastResults = new RaycastResults()) {
    let internalRaycastResults = raycastParams.myPhysics.rayCast(raycastParams.myOrigin, raycastParams.myDirection, raycastParams.myBlockLayerFlags.getMask(), raycastParams.myDistance);
    if (raycastResults.myRaycastParams == null) {
      raycastResults.myRaycastParams = new RaycastParams(raycastParams.myPhysics);
    }
    raycastResults.myRaycastParams.copy(raycastParams);
    let currentValidHitIndex = 0;
    let validHitsCount = 0;
    let hitCount = internalRaycastResults.hitCount;
    if (hitCount != 0) {
      if (hitCount > maxHitCount) {
        console.warn("Raycast hitcount is more than the expected one: " + hitCount + " - Allocation of needed resources performed");
        maxHitCount = Math.ceil(hitCount + hitCount * 0.5);
        objects = new Array(maxHitCount);
        distances = new Float32Array(maxHitCount);
        locations = Array.from({ length: maxHitCount }, () => new Float32Array(3));
        normals = Array.from({ length: maxHitCount }, () => new Float32Array(3));
      }
      let objectsAlreadyGet = false;
      let distancesAlreadyGet = false;
      let locationsAlreadyGet = false;
      let normalsAlreadyGet = false;
      invertedRaycastDirection = raycastParams.myDirection.vec3_negate(invertedRaycastDirection);
      for (let i = 0; i < hitCount; i++) {
        if (raycastParams.myObjectsToIgnore.length != 0) {
          if (!objectsAlreadyGet) {
            objectsAlreadyGet = true;
            internalRaycastResults.pp_getObjects(objects);
          }
          if (raycastParams.myObjectsToIgnore.pp_hasEqual(objects[i], objectsEqualCallback)) {
            continue;
          }
        }
        if (!distancesAlreadyGet) {
          distancesAlreadyGet = true;
          internalRaycastResults.pp_getDistances(distances);
        }
        let hitInsideCollision = distances[i] == 0;
        if (hitInsideCollision) {
          if (!locationsAlreadyGet) {
            locationsAlreadyGet = true;
            internalRaycastResults.pp_getLocations(locations);
          }
          hitInsideCollision &&= raycastParams.myOrigin.vec3_sub(locations[i], insideCheckSubVector).vec3_isZero(Math.PP_EPSILON);
          if (hitInsideCollision) {
            if (!normalsAlreadyGet) {
              normalsAlreadyGet = true;
              internalRaycastResults.pp_getNormals(normals);
            }
            hitInsideCollision &&= invertedRaycastDirection.vec3_equals(normals[i], Math.PP_EPSILON_DEGREES);
          }
        }
        if (!raycastParams.myIgnoreHitsInsideCollision || !hitInsideCollision) {
          let hit = null;
          if (currentValidHitIndex < raycastResults.myHits.length) {
            hit = raycastResults.myHits[currentValidHitIndex];
          } else if (raycastResults._myUnusedHits != null && raycastResults._myUnusedHits.length > 0) {
            hit = raycastResults._myUnusedHits.pop();
            raycastResults.myHits.push(hit);
          } else {
            hit = new RaycastHit();
            raycastResults.myHits.push(hit);
          }
          if (!objectsAlreadyGet) {
            objectsAlreadyGet = true;
            internalRaycastResults.pp_getObjects(objects);
          }
          if (!locationsAlreadyGet) {
            locationsAlreadyGet = true;
            internalRaycastResults.pp_getLocations(locations);
          }
          if (!normalsAlreadyGet) {
            normalsAlreadyGet = true;
            internalRaycastResults.pp_getNormals(normals);
          }
          hit.myPosition.vec3_copy(locations[i]);
          hit.myNormal.vec3_copy(normals[i]);
          hit.myDistance = distances[i];
          hit.myObject = objects[i];
          hit.myInsideCollision = hitInsideCollision;
          validHitsCount++;
          currentValidHitIndex++;
        }
      }
    }
    if (raycastResults.myHits.length > validHitsCount) {
      if (raycastResults._myUnusedHits == null) {
        raycastResults._myUnusedHits = [];
      }
      let hitsToRemove = raycastResults.myHits.length - validHitsCount;
      for (let i = 0; i < hitsToRemove; i++) {
        raycastResults._myUnusedHits.push(raycastResults.myHits.pop());
      }
    }
    if (Globals.isDebugEnabled(raycastParams.myPhysics.pp_getEngine())) {
      if (PhysicsUtils.isRaycastVisualDebugEnabled(raycastParams.myPhysics)) {
        Globals.getDebugVisualManager(raycastParams.myPhysics.pp_getEngine()).drawRaycast(0, raycastResults);
      }
      _increaseRaycastCount(raycastParams.myPhysics);
    }
    return raycastResults;
  };
}();
var PhysicsUtils = {
  setLayerFlagsNames,
  getLayerFlagsNames,
  getRaycastCount,
  resetRaycastCount,
  isRaycastVisualDebugEnabled,
  setRaycastVisualDebugEnabled,
  raycast
};
function _increaseRaycastCount(physics = Globals.getPhysics()) {
  let raycastCount = _myRaycastCount.get(physics);
  if (raycastCount == null) {
    _myRaycastCount.set(physics, 1);
  } else {
    _myRaycastCount.set(physics, raycastCount + 1);
  }
}

// dist/cauldron/physics/physics_layer_flags.js
var PhysicsLayerFlags = class {
  constructor() {
    this._myLayerMask = 0;
  }
  setFlagActive(indexOrName, active) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      if (active) {
        this._myLayerMask = this._myLayerMask | mask;
      } else {
        this._myLayerMask = this._myLayerMask & ~mask;
      }
    }
  }
  isFlagActive(indexOrName) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    let active = false;
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      active = !!(this._myLayerMask & mask);
    }
    return active;
  }
  setAllFlagsActive(active) {
    if (!active) {
      this._myLayerMask = 0;
    } else {
      this._myLayerMask = Math.pow(2, PhysicsUtils.getLayerFlagsNames().length) - 1;
    }
  }
  add(layerFlags) {
    this._myLayerMask = this._myLayerMask | layerFlags.getMask();
  }
  remove(layerFlags) {
    this._myLayerMask = this._myLayerMask & ~layerFlags.getMask();
  }
  intersect(layerFlags) {
    this._myLayerMask = this._myLayerMask & layerFlags.getMask();
  }
  copy(layerFlags) {
    this._myLayerMask = layerFlags._myLayerMask;
  }
  getMask() {
    return this._myLayerMask;
  }
  setMask(layerMask) {
    this._myLayerMask = layerMask;
  }
};

// dist/cauldron/physics/physics_raycast_params.js
var RaycastParams = class {
  constructor(physics = Globals.getPhysics()) {
    this.myOrigin = vec3_create();
    this.myDirection = vec3_create();
    this.myDistance = 0;
    this.myBlockLayerFlags = new PhysicsLayerFlags();
    this.myObjectsToIgnore = [];
    this.myIgnoreHitsInsideCollision = false;
    this.myPhysics = physics;
  }
  copy(other) {
    this.myOrigin.vec3_copy(other.myOrigin);
    this.myDirection.vec3_copy(other.myDirection);
    this.myDistance = other.myDistance;
    this.myBlockLayerFlags.copy(other.myBlockLayerFlags);
    this.myObjectsToIgnore.pp_copy(other.myObjectsToIgnore);
    this.myIgnoreHitsInsideCollision = other.myIgnoreHitsInsideCollision;
    this.myPhysics = other.myPhysics;
  }
  reset() {
    this.myOrigin.vec3_zero();
    this.myDirection.vec3_zero();
    this.myDistance = 0;
    this.myBlockLayerFlags.setAllFlagsActive(false);
    this.myObjectsToIgnore.pp_clear();
    this.myIgnoreHitsInsideCollision = false;
  }
};
var RaycastResults = class {
  constructor() {
    this.myRaycastParams = null;
    this.myHits = [];
    this._myUnusedHits = null;
  }
  isColliding(ignoreHitsInsideCollision = false) {
    return ignoreHitsInsideCollision ? this.getFirstHitOutsideCollision() != null : this.myHits.length > 0;
  }
  getFirstHitInsideCollision() {
    let firstHit = null;
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (hit.myInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getFirstHitOutsideCollision() {
    let firstHit = null;
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (!hit.myInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getHitsInsideCollision() {
    let hits = [];
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (hit.myInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  getHitsOutsideCollision() {
    let hits = [];
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (!hit.myInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  removeHit(hitIndex) {
    let removedHit = this.myHits.pp_removeIndex(hitIndex);
    if (removedHit != null) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      this._myUnusedHits.push(removedHit);
    }
    return removedHit;
  }
  removeAllHits() {
    if (this._myUnusedHits == null) {
      this._myUnusedHits = [];
    }
    for (let i = 0; i < this.myHits.length; i++) {
      this._myUnusedHits.push(this.myHits[i]);
    }
    this.myHits.pp_clear();
  }
  copy(other) {
  }
  reset() {
    if (this.myRaycastParams != null) {
      this.myRaycastParams.reset();
    }
    this.removeAllHits();
  }
};
var RaycastHit = class {
  constructor() {
    this.myPosition = vec3_create();
    this.myNormal = vec3_create();
    this.myDistance = 0;
    this.myObject = null;
    this.myInsideCollision = false;
  }
  isValid() {
    return this.myObject != null;
  }
  copy(other) {
    this.myPosition.vec3_copy(other.myPosition);
    this.myNormal.vec3_copy(other.myNormal);
    this.myDistance = other.myDistance;
    this.myObject = other.myObject;
    this.myInsideCollision = other.myInsideCollision;
  }
  reset() {
    this.myPosition.vec3_zero();
    this.myNormal.vec3_zero();
    this.myDistance = 0;
    this.myObject = null;
    this.myInsideCollision = false;
  }
};
RaycastResults.prototype.copy = function() {
  let copyHitCallback = function(currentElement, elementToCopy) {
    if (currentElement == null) {
      currentElement = new RaycastHit();
    }
    currentElement.copy(elementToCopy);
    return currentElement;
  };
  return function copy35(other) {
    if (other.myRaycastParams == null) {
      this.myRaycastParams = null;
    } else {
      if (this.myRaycastParams == null) {
        this.myRaycastParams = new RaycastParams(other.myRaycastParams.myPhysics);
      }
      this.myRaycastParams.copy(other.myRaycastParams);
    }
    if (this.myHits.length > other.myHits.length) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      for (let i = 0; i < this.myHits.length - other.myHits.length; i++) {
        this._myUnusedHits.push(this.myHits.pop());
      }
    } else if (this.myHits.length < other.myHits.length) {
      if (this._myUnusedHits != null) {
        let length5 = Math.min(this._myUnusedHits.length, other.myHits.length - this.myHits.length);
        for (let i = 0; i < length5; i++) {
          this.myHits.push(this._myUnusedHits.pop());
        }
      }
    }
    this.myHits.pp_copy(other.myHits, copyHitCallback);
  };
}();

// dist/cauldron/visual/elements/visual_raycast.js
var VisualRaycastParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myRaycastResults = new RaycastResults();
    this.myHitNormalLength = 0.2;
    this.myThickness = 5e-3;
    this.myShowOnlyFirstHit = true;
    this.myRayMaterial = null;
    this.myHitNormalMaterial = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.RAYCAST;
  }
  get myRaycastResults() {
    return this._myRaycastResults;
  }
  set myRaycastResults(result) {
    this._myRaycastResults.copy(result);
  }
  copy(other) {
  }
};
var VisualRaycast = class _VisualRaycast {
  constructor(params = new VisualRaycastParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualRaycast = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRaycast.setAutoRefresh(false);
    this._myVisualRaycastHitList = [];
    this._myDestroyed = false;
    this._addVisualRaycastHit();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVisible) {
        if (this._myParams.myRaycastResults.myRaycastParams != null) {
          this._myVisualRaycast.setVisible(true);
        }
        if (this._myParams.myRaycastResults.myHits.length > 0) {
          let hitsToShow = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
          for (let i = 0; i < hitsToShow; i++) {
            let visualRaycastHit = this._myVisualRaycastHitList[i];
            visualRaycastHit.setVisible(true);
          }
        }
      } else {
        this._myVisualRaycast.setVisible(false);
        for (let visualRaycastHit of this._myVisualRaycastHitList) {
          visualRaycastHit.setVisible(false);
        }
      }
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualRaycast.forceRefresh();
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let hitsToRefresh = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
      for (let i = 0; i < hitsToRefresh; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        visualRaycastHit.forceRefresh();
      }
    }
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualRaycast.update(dt);
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.update(dt);
    }
  }
  _refresh() {
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.setVisible(false);
    }
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let raycastDistance = this._myParams.myShowOnlyFirstHit ? this._myParams.myRaycastResults.myHits.pp_first().myDistance : this._myParams.myRaycastResults.myHits.pp_last().myDistance;
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myDirection);
        visualRaycastParams.myLength = raycastDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myLocal = this._myParams.myLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
      let hitsToShow = this._myParams.myShowOnlyFirstHit ? 1 : this._myParams.myRaycastResults.myHits.length;
      while (hitsToShow > this._myVisualRaycastHitList.length) {
        this._addVisualRaycastHit();
      }
      for (let i = 0; i < hitsToShow; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        {
          let visualRaycastHitParams = visualRaycastHit.getParams();
          visualRaycastHitParams.myStart.vec3_copy(this._myParams.myRaycastResults.myHits[i].myPosition);
          visualRaycastHitParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myHits[i].myNormal);
          visualRaycastHitParams.myLength = this._myParams.myHitNormalLength;
          visualRaycastHitParams.myThickness = this._myParams.myThickness;
          if (this._myParams.myHitNormalMaterial == null) {
            visualRaycastHitParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myHitNormal;
          } else {
            visualRaycastHitParams.myMaterial = this._myParams.myHitNormalMaterial;
          }
          visualRaycastHitParams.myParent = this._myParams.myParent;
          visualRaycastHitParams.myLocal = this._myParams.myLocal;
          visualRaycastHit.paramsUpdated();
          visualRaycastHit.setVisible(this._myVisible);
        }
      }
    } else if (this._myParams.myRaycastResults.myRaycastParams != null) {
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myDirection);
        visualRaycastParams.myLength = this._myParams.myRaycastResults.myRaycastParams.myDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myLocal = this._myParams.myLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
    } else {
      this._myVisualRaycast.setVisible(false);
    }
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualRaycastParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualRaycast(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  _addVisualRaycastHit() {
    let visualRaycastHit = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    visualRaycastHit.setAutoRefresh(false);
    visualRaycastHit.setVisible(false);
    this._myVisualRaycastHitList.push(visualRaycastHit);
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualRaycast.destroy();
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualRaycastParams.prototype.copy = function copy12(other) {
  this.myRaycastResults = other.myRaycastResults;
  this.myHitNormalLength = other.myHitNormalLength;
  this.myThickness = other.myThickness;
  this.myShowOnlyFirstHit = other.myShowOnlyFirstHit;
  if (other.myRayMaterial != null) {
    this.myRayMaterial = other.myRayMaterial.clone();
  } else {
    this.myRayMaterial = null;
  }
  if (other.myHitNormalMaterial != null) {
    this.myHitNormalMaterial = other.myHitNormalMaterial.clone();
  } else {
    this.myHitNormalMaterial = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/visual/elements/visual_text.js
import { Alignment, Justification, TextComponent as TextComponent3 } from "@wonderlandengine/api";
var VisualTextParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myText = "";
    this.myAlignment = Alignment.Center;
    this.myJustification = Justification.Middle;
    this.myTransform = mat4_create();
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myLookAtObject = null;
    this.myType = VisualElementType.TEXT;
  }
  copy(other) {
  }
};
var VisualText = class _VisualText {
  constructor(params = new VisualTextParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myTextObject = null;
    this._myTextComponent = null;
    this._myTextMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myTextObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty || this._myParams.myLookAtObject != null) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _refresh() {
  }
  _build() {
    this._myTextObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myTextComponent = this._myTextObject.pp_addComponent(TextComponent3);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualTextParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualText(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  destroy() {
    this._myDestroyed = true;
    this._myTextObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualTextParams.prototype.copy = function copy13(other) {
  this.myText = other.myText;
  this.myAlignment = other.myAlignment;
  this.myJustification = other.myJustification;
  this.myTransform.mat4_copy(other.myTransform);
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myLookAtObject = other.myLookAtObject;
  this.myType = other.myType;
};
VisualText.prototype._refresh = function() {
  let lookAtPosition = vec3_create();
  return function _refresh() {
    this._myTextObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myTextObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTextObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myLookAtObject != null) {
      this._myParams.myLookAtObject.pp_getPosition(lookAtPosition);
      this._myTextObject.pp_lookAt(lookAtPosition);
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myTextComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myText;
      } else {
        if (this._myTextMaterial == null) {
          this._myTextMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myText.clone();
        }
        this._myTextComponent.material = this._myTextMaterial;
        this._myTextMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myTextComponent.material = this._myParams.myMaterial;
    }
    this._myTextComponent.text = this._myParams.myText;
    this._myTextComponent.alignment = this._myParams.myAlignment;
    this._myTextComponent.justification = this._myParams.myJustification;
    this._myDirty = false;
  };
}();

// dist/cauldron/visual/elements/visual_torus.js
var VisualTorusParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myTransform = mat4_create();
    this.myRadius = 0;
    this.mySegmentsAmount = 12;
    this.mySegmentThickness = 0.05;
    this.mySegmentMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.TORUS;
  }
  copy(other) {
  }
};
var VisualTorus = class _VisualTorus {
  constructor(params = new VisualTorusParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myTorusParentObject = null;
    this._myVisualSegmentList = [];
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVisible) {
        let segmentToShow = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
        for (let i = 0; i < segmentToShow; i++) {
          let visualSegment = this._myVisualSegmentList[i];
          visualSegment.setVisible(true);
        }
      } else {
        for (let visualSegment of this._myVisualSegmentList) {
          visualSegment.setVisible(false);
        }
      }
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    let segmentToRefresh = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
    for (let i = 0; i < segmentToRefresh; i++) {
      let visualSegment = this._myVisualSegmentList[i];
      visualSegment.forceRefresh();
    }
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.update(dt);
    }
  }
  _build() {
    this._myTorusParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._fillSegmentList();
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  _fillSegmentList() {
    while (this._myVisualSegmentList.length < this._myParams.mySegmentsAmount) {
      let visualSegment = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
      visualSegment.setAutoRefresh(false);
      visualSegment.setVisible(false);
      visualSegment.getParams().myParent = this._myTorusParentObject;
      visualSegment.getParams().myLocal = true;
      this._myVisualSegmentList.push(visualSegment);
    }
  }
  clone() {
    let clonedParams = new VisualTorusParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualTorus(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.destroy();
    }
    this._myTorusParentObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualTorus.prototype._refresh = function() {
  let segmentStart = vec3_create();
  let segmentEnd = vec3_create();
  let segmentDirection = vec3_create();
  let fixedSegmentStart = vec3_create();
  let fixedSegmentEnd = vec3_create();
  let up = vec3_create(0, 1, 0);
  return function _refresh() {
    this._fillSegmentList();
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.setVisible(false);
    }
    this._myTorusParentObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myTorusParentObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTorusParentObject.pp_setTransform(this._myParams.myTransform);
    }
    let sliceAngle = 2 * Math.PI / this._myParams.mySegmentsAmount;
    segmentStart.vec3_set(this._myParams.myRadius, 0, 0);
    for (let i = 0; i < this._myParams.mySegmentsAmount; i++) {
      segmentEnd = segmentStart.vec3_rotateAxisRadians(sliceAngle, up, segmentEnd);
      segmentDirection = segmentEnd.vec3_sub(segmentStart, segmentDirection).vec3_normalize(segmentDirection);
      let extraLength = Math.tan(sliceAngle / 2) * this._myParams.mySegmentThickness / 2;
      fixedSegmentStart = segmentStart.vec3_sub(segmentDirection.vec3_scale(extraLength, fixedSegmentStart), fixedSegmentStart);
      fixedSegmentEnd = segmentEnd.vec3_add(segmentDirection.vec3_scale(extraLength, fixedSegmentEnd), fixedSegmentEnd);
      let visualSegment = this._myVisualSegmentList[i];
      let visualSegmentParams = visualSegment.getParams();
      visualSegmentParams.setStartEnd(fixedSegmentStart, fixedSegmentEnd);
      visualSegmentParams.myThickness = this._myParams.mySegmentThickness;
      visualSegmentParams.myMesh = this._myParams.mySegmentMesh;
      if (this._myParams.myMaterial == null) {
        if (this._myParams.myColor == null) {
          visualSegmentParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
        } else {
          if (this._myFlatOpaqueMaterial == null) {
            this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
          }
          visualSegmentParams.myMaterial = this._myFlatOpaqueMaterial;
          this._myFlatOpaqueMaterial.color = this._myParams.myColor;
        }
      } else {
        visualSegmentParams.myMaterial = this._myParams.myMaterial;
      }
      visualSegment.paramsUpdated();
      visualSegment.setVisible(this._myVisible);
      segmentStart.vec3_copy(segmentEnd);
    }
  };
}();
VisualTorusParams.prototype.copy = function copy14(other) {
  this.myRadius = other.myRadius;
  this.mySegmentsAmount = other.mySegmentsAmount;
  this.mySegmentThickness = other.mySegmentThickness;
  this.myTransform.mat4_copy(other.myTransform);
  this.mySegmentMesh = other.mySegmentMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/visual/elements/visual_transform.js
var VisualTransformParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myTransform = mat4_create();
    this.myLength = 0.2;
    this.myThickness = 5e-3;
    this.myForwardMaterial = null;
    this.myUpMaterial = null;
    this.myRightMaterial = null;
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.TRANSFORM;
  }
  copy(other) {
  }
};
var VisualTransform = class _VisualTransform {
  constructor(params = new VisualTransformParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualRight = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualUp = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualForward = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRight.setAutoRefresh(false);
    this._myVisualUp.setAutoRefresh(false);
    this._myVisualForward.setAutoRefresh(false);
    this._myDestroyed = false;
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myVisualRight.setVisible(visible);
      this._myVisualUp.setVisible(visible);
      this._myVisualForward.setVisible(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualRight.forceRefresh();
    this._myVisualUp.forceRefresh();
    this._myVisualForward.forceRefresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualRight.update(dt);
    this._myVisualUp.update(dt);
    this._myVisualForward.update(dt);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualTransformParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone10 = new _VisualTransform(clonedParams);
    clone10.setAutoRefresh(this._myAutoRefresh);
    clone10.setVisible(this._myVisible);
    clone10._myDirty = this._myDirty;
    return clone10;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualRight.destroy();
    this._myVisualUp.destroy();
    this._myVisualForward.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualTransform.prototype._refresh = function() {
  let axes = [vec3_create(), vec3_create(), vec3_create()];
  let scale4 = vec3_create();
  let position = vec3_create();
  return function _refresh() {
    axes = this._myParams.myTransform.mat4_getAxes(axes);
    scale4 = this._myParams.myTransform.mat4_getScale(scale4);
    let maxValue = 0;
    for (let value of scale4) {
      maxValue = Math.max(value, maxValue);
    }
    if (maxValue == 0) {
      scale4[0] = 1;
      scale4[1] = 1;
      scale4[2] = 1;
    } else {
      scale4[0] = scale4[0] / maxValue;
      scale4[1] = scale4[1] / maxValue;
      scale4[2] = scale4[2] / maxValue;
    }
    position = this._myParams.myTransform.mat4_getPosition(position);
    {
      let visualArrowParams = this._myVisualRight.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[0].vec3_negate(visualArrowParams.myDirection).vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale4[0], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myRightMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRight;
      } else {
        visualArrowParams.myMaterial = this._myParams.myRightMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualRight.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualUp.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[1].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale4[1], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myUpMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myUp;
      } else {
        visualArrowParams.myMaterial = this._myParams.myUpMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualUp.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualForward.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[2].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale4[2], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myForwardMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myForward;
      } else {
        visualArrowParams.myMaterial = this._myParams.myForwardMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualForward.paramsUpdated();
    }
  };
}();
VisualTransformParams.prototype.copy = function copy15(other) {
  this.myTransform.mat4_copy(other.myTransform);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  if (other.myRightMaterial != null) {
    this.myRightMaterial = other.myRightMaterial.clone();
  } else {
    this.myRightMaterial = null;
  }
  if (other.myUpMaterial != null) {
    this.myUpMaterial = other.myUpMaterial.clone();
  } else {
    this.myUpMaterial = null;
  }
  if (other.myForwardMaterial != null) {
    this.myForwardMaterial = other.myForwardMaterial.clone();
  } else {
    this.myForwardMaterial = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/cauldron/visual/visual_manager.js
var VisualManager = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myVisualElementPrototypeCreationCallbacks = /* @__PURE__ */ new Map();
    this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
    this._myVisualElementLastID = 0;
    this._myVisualElementsToShow = [];
    this._myActive = true;
    this._myDestroyed = false;
    this._myObjectPoolManagerPrefix = this._getClassName() + "_" + Math.pp_randomUUID() + "_visual_element_type_";
    this._myTypePoolIDs = /* @__PURE__ */ new Map();
    this._addStandardVisualElementTypes();
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
  }
  update(dt) {
    if (this._myActive) {
      this._updateDraw(dt);
    }
  }
  // lifetimeSeconds can be null, in that case the element will be drawn until cleared
  draw(visualElementParams, lifetimeSeconds = 0, idToReuse = null) {
    if (!this._myActive) {
      return null;
    }
    let visualElement = null;
    let idReused = false;
    if (idToReuse != null) {
      if (this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
        let visualElements2 = this._myVisualElementsTypeMap.get(visualElementParams.myType);
        if (visualElements2.has(idToReuse)) {
          visualElement = visualElements2.get(idToReuse)[0];
          visualElement.copyParams(visualElementParams);
          visualElement.setVisible(false);
          idReused = true;
        }
      }
    }
    if (visualElement == null) {
      visualElement = this._getVisualElementFromPool(visualElementParams);
    }
    if (visualElement == null) {
      console.error("Couldn't create the requested visual element");
      return null;
    }
    if (!this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
      this._myVisualElementsTypeMap.set(visualElementParams.myType, /* @__PURE__ */ new Map());
    }
    let visualElements = this._myVisualElementsTypeMap.get(visualElementParams.myType);
    let elementID = null;
    if (!idReused) {
      elementID = this._myVisualElementLastID + 1;
      this._myVisualElementLastID = elementID;
      visualElements.set(elementID, [visualElement, new Timer(lifetimeSeconds, lifetimeSeconds != null)]);
    } else {
      elementID = idToReuse;
      let visualElementPair = visualElements.get(elementID);
      visualElementPair[0] = visualElement;
      visualElementPair[1].reset(lifetimeSeconds);
      if (lifetimeSeconds != null) {
        visualElementPair[1].start();
      }
    }
    this._myVisualElementsToShow.push(visualElement);
    return elementID;
  }
  getVisualElement(elementID) {
    let visualElement = null;
    for (let visualElements of this._myVisualElementsTypeMap.values()) {
      if (visualElements.has(elementID)) {
        let visualElementPair = visualElements.get(elementID);
        visualElement = visualElementPair[0];
        break;
      }
    }
    return visualElement;
  }
  getVisualElementParams(elementID) {
    return this.getVisualElement(elementID).getParams();
  }
  getVisualElementID(visualElement) {
    let elementID = null;
    for (let currentVisualElements of this._myVisualElementsTypeMap.values()) {
      for (let [currentElementID, currentVisualElement] of currentVisualElements.entries()) {
        if (currentVisualElement[0] == visualElement) {
          elementID = currentElementID;
          break;
        }
      }
      if (elementID != null) {
        break;
      }
    }
    return elementID;
  }
  clearVisualElement(elementID = null) {
    if (elementID == null) {
      for (let visualElements of this._myVisualElementsTypeMap.values()) {
        for (let visualElement of visualElements.values()) {
          this._releaseElement(visualElement[0]);
        }
      }
      this._myVisualElementsToShow = [];
      this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
      this._myVisualElementLastID = 0;
    } else {
      for (let visualElements of this._myVisualElementsTypeMap.values()) {
        if (visualElements.has(elementID)) {
          let visualElementPair = visualElements.get(elementID);
          this._releaseElement(visualElementPair[0]);
          visualElements.delete(elementID);
          this._myVisualElementsToShow.pp_removeEqual(visualElementPair[0]);
          break;
        }
      }
    }
  }
  allocateVisualElementType(visualElementType, amount) {
    if (!Globals.getObjectPoolManager(this._myEngine).hasPool(this._getTypePoolID(visualElementType))) {
      this._addVisualElementTypeToPool(visualElementType);
    }
    let pool = Globals.getObjectPoolManager(this._myEngine).getPool(this._getTypePoolID(visualElementType));
    let difference = pool.getAvailableSize() - amount;
    if (difference < 0) {
      pool.increase(-difference);
    }
  }
  addVisualElementType(visualElementType, visuaElementPrototypeCreationCallback) {
    this._myVisualElementPrototypeCreationCallbacks.set(visualElementType, visuaElementPrototypeCreationCallback);
  }
  removeVisualElementType(visualElementType) {
    this._myVisualElementPrototypeCreationCallbacks.delete(visualElementType);
  }
  _updateDraw(dt) {
    for (let visualElement of this._myVisualElementsToShow) {
      visualElement.setVisible(true);
    }
    this._myVisualElementsToShow.pp_clear();
    for (let visualElements of this._myVisualElementsTypeMap.values()) {
      let idsToRemove = [];
      for (let visualElementsEntry of visualElements.entries()) {
        let visualElement = visualElementsEntry[1];
        if (visualElement[1].isDone()) {
          this._releaseElement(visualElement[0]);
          idsToRemove.push(visualElementsEntry[0]);
        } else {
          visualElement[0].update(dt);
          visualElement[1].update(dt);
        }
      }
      for (let id of idsToRemove) {
        visualElements.delete(id);
      }
    }
  }
  _getVisualElementFromPool(params) {
    let element = null;
    if (!Globals.getObjectPoolManager(this._myEngine).hasPool(this._getTypePoolID(params.myType))) {
      this._addVisualElementTypeToPool(params.myType);
    }
    element = Globals.getObjectPoolManager(this._myEngine).get(this._getTypePoolID(params.myType));
    if (element != null) {
      element.copyParams(params);
    }
    return element;
  }
  _addVisualElementTypeToPool(type) {
    let objectPoolParams = new ObjectPoolParams();
    objectPoolParams.myInitialPoolSize = 10;
    objectPoolParams.myAmountToAddWhenEmpty = 0;
    objectPoolParams.myPercentageToAddWhenEmpty = 0.5;
    objectPoolParams.mySetActiveCallback = function(object, active) {
      object.setVisible(active);
    };
    let visualElementPrototype = null;
    if (this._myVisualElementPrototypeCreationCallbacks.has(type)) {
      visualElementPrototype = this._myVisualElementPrototypeCreationCallbacks.get(type)();
    }
    if (visualElementPrototype != null) {
      visualElementPrototype.setVisible(false);
      visualElementPrototype.setAutoRefresh(true);
      Globals.getObjectPoolManager(this._myEngine).addPool(this._getTypePoolID(type), new ObjectPool(visualElementPrototype, objectPoolParams));
    } else {
      console.error("Visual element type not supported");
    }
  }
  _addStandardVisualElementTypes() {
    this.addVisualElementType(VisualElementType.LINE, () => new VisualLine(new VisualLineParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.MESH, () => new VisualMesh(new VisualMeshParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.POINT, () => new VisualPoint(new VisualPointParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.ARROW, () => new VisualArrow(new VisualArrowParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TEXT, () => new VisualText(new VisualTextParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TRANSFORM, () => new VisualTransform(new VisualTransformParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.RAYCAST, () => new VisualRaycast(new VisualRaycastParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TORUS, () => new VisualTorus(new VisualTorusParams(this._myEngine)));
  }
  _getTypePoolID(type) {
    let typePoolID = this._myTypePoolIDs.get(type);
    if (typePoolID == null) {
      typePoolID = this._myObjectPoolManagerPrefix + type;
      this._myTypePoolIDs.set(type, typePoolID);
    }
    return typePoolID;
  }
  _releaseElement(visualElement) {
    let defaultElementsParent = Globals.getSceneObjects(this._myEngine).myVisualElements;
    if (visualElement.getParams().myParent != defaultElementsParent) {
      visualElement.getParams().myParent = defaultElementsParent;
      visualElement.forceRefresh();
    }
    Globals.getObjectPoolManager(this._myEngine).release(this._getTypePoolID(visualElement.getParams().myType), visualElement);
  }
  _getClassName() {
    return "visual_manager";
  }
  destroy() {
    this._myDestroyed = true;
    for (let poolID of this._myTypePoolIDs.values()) {
      Globals.getObjectPoolManager(this._myEngine)?.destroyPool(poolID);
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/cauldron/visual/visual_resources.js
var VisualResources = class {
  constructor() {
    this.myDefaultMaterials = new VisualResourcesMaterials();
  }
};
var VisualResourcesMaterials = class {
  constructor() {
    this.myMesh = null;
    this.myText = null;
    this.myRight = null;
    this.myUp = null;
    this.myForward = null;
    this.myRay = null;
    this.myHitNormal = null;
  }
};

// dist/cauldron/visual/components/visual_manager_component.js
var VisualManagerComponent = class extends Component5 {
  static TypeName = "pp-visual-manager";
  static Properties = {};
  init() {
    this._myVisualManager = null;
    if (!Globals.hasVisualManager(this.engine)) {
      this._myVisualManager = new VisualManager(this.engine);
      Globals.setVisualManager(this._myVisualManager, this.engine);
    }
    if (!Globals.hasVisualResources(this.engine)) {
      this._myVisualResources = new VisualResources();
      Globals.setVisualResources(this._myVisualResources, this.engine);
    }
  }
  start() {
    if (this._myVisualResources != null) {
      this._myVisualResources.myDefaultMaterials.myMesh = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myText = Globals.getDefaultMaterials(this.engine).myText.clone();
      this._myVisualResources.myDefaultMaterials.myRight = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myRight.color = vec4_create(1, 0, 0, 1);
      this._myVisualResources.myDefaultMaterials.myUp = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myUp.color = vec4_create(0, 1, 0, 1);
      this._myVisualResources.myDefaultMaterials.myForward = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myForward.color = vec4_create(0, 0, 1, 1);
      this._myVisualResources.myDefaultMaterials.myRay = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myRay.color = vec4_create(0, 1, 0, 1);
      this._myVisualResources.myDefaultMaterials.myHitNormal = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myHitNormal.color = vec4_create(1, 0, 0, 1);
    }
    if (this.myVisualManager != null) {
      this.myVisualManager.start();
    }
  }
  update(dt) {
    if (this.myVisualManager != null) {
      this.myVisualManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myVisualManager != null && Globals.getVisualManager(this.engine) == this._myVisualManager) {
      Globals.removeVisualManager(this.engine);
      this._myVisualManager.destroy();
    }
    if (this._myVisualResources != null && Globals.getVisualResources(this.engine) == this._myVisualResources) {
      Globals.removeVisualResources(this.engine);
    }
  }
};

// dist/cauldron/wl/components/add_wl_to_window_component.js
import * as WLAPI from "@wonderlandengine/api";
import { Component as Component6, Property as Property4 } from "@wonderlandengine/api";
import * as WLComponents from "@wonderlandengine/components";
var AddWLToWindowComponent = class extends Component6 {
  static TypeName = "pp-add-wl-to-window";
  static Properties = {
    _myAdd: Property4.bool(true)
  };
  init() {
    if (this._myAdd) {
      Globals.getWindow(this.engine).WL = {};
      this._addProperties(WLAPI);
      this._addProperties(WLComponents);
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        Globals.getWindow(this.engine).WL[propertyName] = object[propertyName];
      }
    }
  }
  onDestroy() {
    Globals.getWindow(this.engine).WL = void 0;
  }
};

// dist/debug/components/debug_manager_component.js
import { Component as Component7 } from "@wonderlandengine/api";

// dist/debug/debug_visual_manager.js
import { Alignment as Alignment2, Justification as Justification2 } from "@wonderlandengine/api";
var DebugVisualManager = class extends VisualManager {
  constructor(engine) {
    super(engine);
    this._myDefaultColor = vec4_create(1, 0, 1, 1);
    this._myDefaultLineThickness = 5e-3;
    this._myDefaultPointRadius = 0.01;
    this._myDefaultAxisLength = 0.2;
    this._myDefaultTextLookAtPlayer = true;
    this._myDefaultTextAlignment = Alignment2.Center;
    this._myDefaultTextJustification = Justification2.Middle;
    this._myDefaultUITextAlignment = Alignment2.Center;
    this._myDefaultUITextJustification = Justification2.Middle;
    this._myDefaultUITextScale = 1;
    this._myDefaultUITextScreenPosition = vec3_create(1, 1, 1);
  }
  drawLine(lifetimeSeconds, start, direction, length5, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualLineParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction);
      visualParams.myLength = length5;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawLineEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
  }
  drawArrow(lifetimeSeconds, start, direction, length5, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualArrowParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction);
      visualParams.myLength = length5;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawArrowEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
  }
  drawPoint(lifetimeSeconds, position, color = this._myDefaultColor, radius = this._myDefaultPointRadius) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualPointParams(this._myEngine);
      visualParams.myPosition.vec3_copy(position);
      visualParams.myRadius = radius;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawText(lifetimeSeconds, text, transform, color = this._myDefaultColor, lookAtPlayer = this._myDefaultTextLookAtPlayer, alignment = this._myDefaultTextAlignment, justification = this._myDefaultTextJustification) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myJustification = justification;
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      if (lookAtPlayer) {
        visualParams.myLookAtObject = Globals.getPlayerObjects(this._myEngine).myHead;
      }
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawRaycast(lifetimeSeconds, raycastResult, showOnlyFirstHit = true, hitNormalLength = this._myDefaultAxisLength, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualRaycastParams(this._myEngine);
      visualParams.myRaycastResults = raycastResult;
      visualParams.myShowOnlyFirstHit = showOnlyFirstHit;
      visualParams.myHitNormalLength = hitNormalLength;
      visualParams.myThickness = thickness;
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawTransform(lifetimeSeconds, transform, length5 = this._myDefaultAxisLength, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualTransformParams(this._myEngine);
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myLength = length5;
      visualParams.myThickness = thickness;
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawUIText(lifetimeSeconds, text, screenPosition, scale4 = this._myDefaultUITextScale, color = this._myDefaultColor, alignment = this._myDefaultUITextAlignment, justification = this._myDefaultUITextJustification) {
  }
  _getClassName() {
    return "debug_visual_manager";
  }
};
DebugVisualManager.prototype.drawLineEnd = function() {
  let direction = vec3_create();
  return function drawLineEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      direction = end.vec3_sub(start, direction);
      let length5 = direction.vec3_length();
      direction.vec3_normalize(direction);
      elementID = this.drawLine(lifetimeSeconds, start, direction, length5, color, thickness);
    }
    return elementID;
  };
}();
DebugVisualManager.prototype.drawArrowEnd = function() {
  let direction = vec3_create();
  return function drawArrowEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      direction = end.vec3_sub(start, direction);
      let length5 = direction.vec3_length();
      direction.vec3_normalize(direction);
      elementID = this.drawArrow(lifetimeSeconds, start, direction, length5, color, thickness);
    }
    return elementID;
  };
}();
DebugVisualManager.prototype.drawUIText = function() {
  let textRotationQuat = quat_create();
  let up = vec3_create(0, 1, 0);
  let lookToForward = vec3_create();
  let screenPositionNormalizedXR = vec3_create(-0.12 * 1, 0.12 * 1, 0.35);
  let screenPositionNormalizedNonXR = vec3_create(-0.27 * 1.15, 0.13 * 1.05, 0.35);
  let textPosition = vec3_create();
  let textRotation = vec3_create();
  let textScale = vec3_create();
  return function drawUIText(lifetimeSeconds, text, screenPosition = this._myDefaultUITextScreenPosition, scale4 = this._myDefaultUITextScale, color = this._myDefaultColor, alignment = this._myDefaultUITextAlignment, justification = this._myDefaultUITextJustification) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myJustification = justification;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      let scaleNormalized = 0.2;
      if (XRUtils.isSessionActive(this._myEngine)) {
        visualParams.myTransform.mat4_setPositionRotationScale(screenPositionNormalizedXR.vec3_mul(screenPosition, textPosition), textRotation.vec3_set(0, 180, 0), textScale.vec3_set(scaleNormalized * scale4, scaleNormalized * scale4, scaleNormalized * scale4));
        lookToForward = visualParams.myTransform.mat4_getPosition(lookToForward).vec3_negate(lookToForward).vec3_normalize(lookToForward);
        textRotationQuat = visualParams.myTransform.mat4_getRotationQuat(textRotationQuat);
        textRotationQuat.quat_setForward(lookToForward, up, textRotationQuat);
        visualParams.myTransform.mat4_setRotationQuat(textRotationQuat);
      } else {
        visualParams.myTransform.mat4_setPositionRotationScale(screenPositionNormalizedNonXR.vec3_mul(screenPosition, textPosition), textRotation.vec3_set(0, 180, 0), textScale.vec3_set(scaleNormalized * scale4, scaleNormalized * scale4, scaleNormalized * scale4));
      }
      visualParams.myParent = Globals.getPlayerObjects(this._myEngine).myHeadDebugs;
      visualParams.myLocal = true;
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  };
}();

// dist/debug/debug_manager.js
var DebugManager = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myDebugVisualManager = new DebugVisualManager(this._myEngine);
    this._myDestroyed = false;
  }
  getDebugVisualManager() {
    return this._myDebugVisualManager;
  }
  start() {
    this._myDebugVisualManager.start();
  }
  update(dt) {
    this._myDebugVisualManager.setActive(Globals.isDebugEnabled(this._myEngine));
    this._myDebugVisualManager.update(dt);
  }
  destroy() {
    this._myDestroyed = true;
    this._myDebugVisualManager.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/debug/components/debug_manager_component.js
var DebugManagerComponent = class extends Component7 {
  static TypeName = "pp-debug-manager";
  static Properties = {};
  init() {
    this._myDebugManager = null;
    if (!Globals.hasDebugManager(this.engine)) {
      this._myDebugManager = new DebugManager(this.engine);
      Globals.setDebugManager(this._myDebugManager, this.engine);
    }
  }
  start() {
    if (this._myDebugManager != null) {
      this._myDebugManager.start();
    }
  }
  update(dt) {
    if (this._myDebugManager != null) {
      this._myDebugManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myDebugManager != null && Globals.getDebugManager(this.engine) == this._myDebugManager) {
      Globals.removeDebugManager(this.engine);
      this._myDebugManager.destroy();
    }
  }
};

// dist/debug/components/enable_debug_component.js
import { Component as Component8, Property as Property5 } from "@wonderlandengine/api";
var EnableDebugComponent = class extends Component8 {
  static TypeName = "pp-enable-debug";
  static Properties = {
    _myEnable: Property5.bool(true)
  };
  init() {
    this._myDebugEnabled = null;
    if (!Globals.hasDebugEnabled(this.engine)) {
      this._myDebugEnabled = this._myEnable;
      Globals.setDebugEnabled(this._myDebugEnabled, this.engine);
    }
  }
  onDestroy() {
    if (this._myDebugEnabled != null && Globals.isDebugEnabled(this.engine) == this._myDebugEnabled) {
      Globals.removeDebugEnabled(this.engine);
    }
  }
};

// dist/gameplay/experimental/character_controller/collision/components/character_collision_system_component.js
import { Component as Component9 } from "@wonderlandengine/api";

// dist/gameplay/experimental/character_controller/collision/character_collision_results.js
var CharacterCollisionResults = class {
  constructor() {
    this.myCheckType = null;
    this.myTransformResults = new CharacterCollisionTransformResults();
    this.myMovementResults = new CharacterCollisionMovementResults();
    this.myHorizontalMovementResults = new CharacterCollisionMovementResults();
    this.myVerticalMovementResults = new CharacterCollisionMovementResults();
    this.myTeleportResults = new CharacterCollisionTeleportResults();
    this.myCheckTransformResults = new CharacterCollisionCheckTransformResults();
    this.myWallSlideResults = new CharacterCollisionWallSlideResults();
    this.myGroundInfo = new CharacterCollisionSurfaceInfo();
    this.myCeilingInfo = new CharacterCollisionSurfaceInfo();
    this.myGroundResults = new CharacterCollisionSurfaceResults();
    this.myCeilingResults = new CharacterCollisionSurfaceResults();
    this.mySplitMovementResults = new CharacterCollisionSplitMovementResults();
    this.myDebugResults = new CharacterCollisionDebugResults();
    this.myInternalResults = new CharacterCollisionInternalResults();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionCheckType = {
  CHECK_MOVEMENT: 0,
  CHECK_TELEPORT: 1,
  CHECK_TRANSFORM: 2,
  UPDATE_SURFACE_INFO: 3,
  UPDATE_GROUND_INFO: 4,
  UPDATE_CEILING_INFO: 5
};
var CharacterCollisionSurfaceInfo = class {
  constructor() {
    this.myOnSurface = false;
    this.mySurfaceAngle = 0;
    this.mySurfacePerceivedAngle = 0;
    this.mySurfaceNormal = vec3_create();
    this.mySurfaceHitMaxAngle = 0;
    this.mySurfaceHitMaxNormal = vec3_create();
    this.mySurfaceDistance = null;
    this.myBaseInsideCollision = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionWallSlideResults = class {
  constructor() {
    this.myHasSlid = false;
    this.mySlideMovementAngle = 0;
    this.mySlideMovementWallAngle = 0;
    this.myWallNormal = vec3_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionTransformResults = class {
  constructor() {
    this.myInitialTransformQuat = quat2_create();
    this.myFinalTransformQuat = quat2_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionMovementResults = class {
  constructor() {
    this.myInitialMovement = vec3_create();
    this.myFinalMovement = vec3_create();
    this.myMovementFailed = false;
    this.myMovementCollided = false;
    this.myReferenceCollisionHit = new RaycastHit();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionTeleportResults = class {
  constructor() {
    this.myInitialTeleportTransformQuat = quat2_create();
    this.myFinalTeleportTransformQuat = quat2_create();
    this.myTeleportFailed = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionCheckTransformResults = class {
  constructor() {
    this.myInitialCheckTransformQuat = quat2_create();
    this.myFinalCheckTransformQuat = quat2_create();
    this.myCheckTransformFailed = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionSurfaceResults = class {
  constructor() {
    this.myHasSnappedOnSurface = false;
    this.myHasPoppedOutSurface = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = false;
    this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionSplitMovementResults = class {
  constructor() {
    this.myStepsToPerform = 0;
    this.myStepsPerformed = 0;
    this.myMovementInterrupted = false;
    this.myMovementChecked = vec3_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionDebugResults = class {
  constructor() {
    this._myRaycastsPerformed = 0;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionInternalResults = class {
  constructor() {
    this.myLastRelevantInitialHorizontalMovement = vec3_create();
    this.myLastRelevantAdjustedInitialHorizontalMovement = vec3_create();
    this.myLastRelevantFinalHorizontalMovement = vec3_create();
    this.myLastRelevantInitialVerticalMovement = vec3_create();
    this.myLastRelevantAdjustedInitialVerticalMovement = vec3_create();
    this.myLastRelevantFinalVerticalMovement = vec3_create();
    this.myLastRelevantHasWallSlid = false;
    this.myHasWallSlidTowardOppositeDirection = false;
    this.myLastRelevantWallSlideFlickerPrevented = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.myWallSlide90DegreesDirectionSign = 0;
    this.myWallSlide90DegreesRecomputeDirectionSign = true;
  }
  reset() {
  }
  copy(other) {
  }
};
CharacterCollisionResults.prototype.reset = function reset() {
  this.myCheckType = null;
  this.myTransformResults.reset();
  this.myMovementResults.reset();
  this.myHorizontalMovementResults.reset();
  this.myVerticalMovementResults.reset();
  this.myTeleportResults.reset();
  this.myCheckTransformResults.reset();
  this.myWallSlideResults.reset();
  this.myGroundInfo.reset();
  this.myCeilingInfo.reset();
  this.myGroundResults.reset();
  this.myCeilingResults.reset();
  this.mySplitMovementResults.reset();
  this.myInternalResults.reset();
};
CharacterCollisionResults.prototype.copy = function copy16(other) {
  this.myCheckType = other.myCheckType;
  this.myTransformResults.copy(other.myTransformResults);
  this.myMovementResults.copy(other.myMovementResults);
  this.myHorizontalMovementResults.copy(other.myHorizontalMovementResults);
  this.myVerticalMovementResults.copy(other.myVerticalMovementResults);
  this.myTeleportResults.copy(other.myTeleportResults);
  this.myCheckTransformResults.copy(other.myCheckTransformResults);
  this.myWallSlideResults.copy(other.myWallSlideResults);
  this.myGroundInfo.copy(other.myGroundInfo);
  this.myCeilingInfo.copy(other.myCeilingInfo);
  this.myGroundResults.copy(other.myGroundResults);
  this.myCeilingResults.copy(other.myCeilingResults);
  this.mySplitMovementResults.copy(other.mySplitMovementResults);
  this.myInternalResults.copy(other.myInternalResults);
};
CharacterCollisionSurfaceInfo.prototype.reset = function reset2() {
  this.myOnSurface = false;
  this.mySurfaceAngle = 0;
  this.mySurfacePerceivedAngle = 0;
  this.mySurfaceNormal.vec3_zero();
  this.mySurfaceHitMaxAngle = 0;
  this.mySurfaceHitMaxNormal.vec3_zero();
  this.mySurfaceDistance = null;
  this.myBaseInsideCollision = false;
};
CharacterCollisionSurfaceInfo.prototype.copy = function copy17(other) {
  this.myOnSurface = other.myOnSurface;
  this.mySurfaceAngle = other.mySurfaceAngle;
  this.mySurfacePerceivedAngle = other.mySurfacePerceivedAngle;
  this.mySurfaceNormal.vec3_copy(other.mySurfaceNormal);
  this.mySurfaceHitMaxAngle = other.mySurfaceHitMaxAngle;
  this.mySurfaceHitMaxNormal.vec3_copy(other.mySurfaceHitMaxNormal);
  this.mySurfaceDistance = other.mySurfaceDistance;
  this.myBaseInsideCollision = other.myBaseInsideCollision;
};
CharacterCollisionWallSlideResults.prototype.reset = function reset3() {
  this.myHasSlid = false;
  this.mySlideMovementAngle = 0;
  this.mySlideMovementWallAngle = 0;
  this.myWallNormal.vec3_zero();
};
CharacterCollisionWallSlideResults.prototype.copy = function copy18(other) {
  this.myHasSlid = other.myHasSlid;
  this.mySlideMovementAngle = other.mySlideMovementAngle;
  this.mySlideMovementWallAngle = other.mySlideMovementWallAngle;
  this.myWallNormal.vec3_copy(other.myWallNormal);
};
CharacterCollisionTransformResults.prototype.reset = function reset4() {
  this.myInitialTransformQuat.quat2_identity();
  this.myFinalTransformQuat.quat2_identity();
};
CharacterCollisionTransformResults.prototype.copy = function copy19(other) {
  this.myInitialTransformQuat.quat2_copy(other.myInitialTransformQuat);
  this.myFinalTransformQuat.quat2_copy(other.myFinalTransformQuat);
};
CharacterCollisionMovementResults.prototype.reset = function reset5() {
  this.myInitialMovement.vec3_zero();
  this.myFinalMovement.vec3_zero();
  this.myMovementFailed = false;
  this.myMovementCollided = false;
  this.myReferenceCollisionHit.reset();
};
CharacterCollisionMovementResults.prototype.copy = function copy20(other) {
  this.myInitialMovement.vec3_copy(other.myInitialMovement);
  this.myFinalMovement.vec3_copy(other.myFinalMovement);
  this.myMovementFailed = other.myMovementFailed;
  this.myMovementCollided = other.myMovementCollided;
  this.myReferenceCollisionHit.copy(other.myReferenceCollisionHit);
};
CharacterCollisionTeleportResults.prototype.reset = function reset6() {
  this.myInitialTeleportTransformQuat.quat2_identity();
  this.myFinalTeleportTransformQuat.quat2_identity();
  this.myTeleportFailed = false;
};
CharacterCollisionTeleportResults.prototype.copy = function copy21(other) {
  this.myInitialTeleportTransformQuat.quat2_copy(other.myInitialTeleportTransformQuat);
  this.myFinalTeleportTransformQuat.quat2_copy(other.myFinalTeleportTransformQuat);
  this.myTeleportFailed = other.myTeleportFailed;
};
CharacterCollisionCheckTransformResults.prototype.reset = function reset7() {
  this.myInitialCheckTransformQuat.quat2_identity();
  this.myFinalCheckTransformQuat.quat2_identity();
  this.myCheckTransformFailed = false;
};
CharacterCollisionCheckTransformResults.prototype.copy = function copy22(other) {
  this.myInitialCheckTransformQuat.quat2_copy(other.myInitialCheckTransformQuat);
  this.myFinalCheckTransformQuat.quat2_copy(other.myFinalCheckTransformQuat);
  this.myCheckTransformFailed = other.myCheckTransformFailed;
};
CharacterCollisionSurfaceResults.prototype.reset = function reset8() {
  this.myHasSnappedOnSurface = false;
  this.myHasPoppedOutSurface = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = false;
  this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = false;
};
CharacterCollisionSurfaceResults.prototype.copy = function copy23(other) {
  this.myHasSnappedOnSurface = other.myHasSnappedOnSurface;
  this.myHasPoppedOutSurface = other.myHasPoppedOutSurface;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = other.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = other.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = other.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
};
CharacterCollisionSplitMovementResults.prototype.reset = function reset9() {
  this.myStepsToPerform = 0;
  this.myStepsPerformed = 0;
  this.myMovementInterrupted = false;
  this.myMovementChecked.vec3_zero();
};
CharacterCollisionSplitMovementResults.prototype.copy = function copy24(other) {
  this.myStepsToPerform = other.myStepsToPerform;
  this.myStepsPerformed = other.myStepsPerformed;
  this.myMovementInterrupted = other.myMovementInterrupted;
  this.myMovementChecked.vec3_copy(other.myMovementChecked);
};
CharacterCollisionDebugResults.prototype.reset = function reset10() {
  this._myRaycastsPerformed = 0;
};
CharacterCollisionDebugResults.prototype.copy = function copy25(other) {
  this._myRaycastsPerformed = other._myRaycastsPerformed;
};
CharacterCollisionInternalResults.prototype.reset = function reset11() {
};
CharacterCollisionInternalResults.prototype.copy = function copy26(other) {
  this.myLastRelevantInitialHorizontalMovement.vec3_copy(other.myLastRelevantInitialHorizontalMovement);
  this.myLastRelevantAdjustedInitialHorizontalMovement.vec3_copy(other.myLastRelevantAdjustedInitialHorizontalMovement);
  this.myLastRelevantFinalHorizontalMovement.vec3_copy(other.myLastRelevantFinalHorizontalMovement);
  this.myLastRelevantInitialVerticalMovement.vec3_copy(other.myLastRelevantInitialVerticalMovement);
  this.myLastRelevantAdjustedInitialVerticalMovement.vec3_copy(other.myLastRelevantAdjustedInitialVerticalMovement);
  this.myLastRelevantFinalVerticalMovement.vec3_copy(other.myLastRelevantFinalVerticalMovement);
  this.myLastRelevantHasWallSlid = other.myLastRelevantHasWallSlid;
  this.myHasWallSlidTowardOppositeDirection = other.myHasWallSlidTowardOppositeDirection;
  this.myLastRelevantWallSlideFlickerPrevented = other.myLastRelevantWallSlideFlickerPrevented;
  this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
  this.myWallSlide90DegreesDirectionSign = other.myWallSlide90DegreesDirectionSign;
  this.myWallSlide90DegreesRecomputeDirectionSign = other.myWallSlide90DegreesRecomputeDirectionSign;
};

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_params.js
var CollisionCheckParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxLength = 0;
    this.mySplitMovementMaxLengthEnabled = false;
    this.mySplitMovementMaxSteps = 0;
    this.mySplitMovementMaxStepsEnabled = false;
    this.mySplitMovementMinLength = 0;
    this.mySplitMovementMinLengthEnabled = false;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = false;
    this.mySplitMovementStopWhenVerticalMovementCanceled = false;
    this.mySplitMovementStopCallback = null;
    this.mySplitMovementStopReturnPrevious = false;
    this.myRadius = 0;
    this.myDistanceFromFeetToIgnore = 0;
    this.myDistanceFromHeadToIgnore = 0;
    this.myPositionOffsetLocal = vec3_create();
    this.myRotationOffsetLocalQuat = quat_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementStepEnabled = false;
    this.myHorizontalMovementStepMaxLength = 0;
    this.myHorizontalMovementRadialStepAmount = 0;
    this.myHorizontalMovementCheckDiagonalOutward = false;
    this.myHorizontalMovementCheckDiagonalInward = false;
    this.myHorizontalMovementCheckStraight = false;
    this.myHorizontalMovementCheckHorizontalBorder = false;
    this.myHorizontalMovementCheckVerticalStraight = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHalfConeAngle = 0;
    this.myHalfConeSliceAmount = 0;
    this.myCheckConeBorder = false;
    this.myCheckConeRay = false;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = true;
    this.myHorizontalPositionCheckVerticalDirectionType = 0;
    this.myCheckHorizontalFixedForwardEnabled = false;
    this.myCheckHorizontalFixedForward = vec3_create();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myFeetRadius = 0;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = false;
    this.myAdjustVerticalMovementWithGroundAngleUphill = false;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = null;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = false;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = null;
    this.myCheckVerticalFixedForwardEnabled = false;
    this.myCheckVerticalFixedForward = vec3_create();
    this.myCheckVerticalBothDirection = false;
    this.mySnapOnGroundEnabled = false;
    this.mySnapOnGroundExtraDistance = 0;
    this.mySnapOnCeilingEnabled = false;
    this.mySnapOnCeilingExtraDistance = 0;
    this.myGroundPopOutEnabled = false;
    this.myGroundPopOutExtraDistance = 0;
    this.myCeilingPopOutEnabled = false;
    this.myCeilingPopOutExtraDistance = 0;
    this.myVerticalMovementReduceEnabled = false;
    this.myGroundCircumferenceAddCenter = false;
    this.myGroundCircumferenceSliceAmount = 0;
    this.myGroundCircumferenceStepAmount = 0;
    this.myGroundCircumferenceRotationPerStep = 0;
    this.myVerticalAllowHitInsideCollisionIfOneOk = false;
    this.myCheckHeight = false;
    this.myCheckHeightVerticalMovement = false;
    this.myCheckHeightVerticalPosition = false;
    this.myCheckHeightTopMovement = false;
    this.myCheckHeightTopPosition = false;
    this.myCheckHeightConeOnCollision = false;
    this.myCheckHeightConeOnCollisionKeepHit = false;
    this.myHeightCheckStepAmountMovement = 0;
    this.myHeightCheckStepAmountPosition = 0;
    this.myCheckVerticalStraight = false;
    this.myCheckVerticalDiagonalRayOutward = false;
    this.myCheckVerticalDiagonalRayInward = false;
    this.myCheckVerticalDiagonalBorderOutward = false;
    this.myCheckVerticalDiagonalBorderInward = false;
    this.myCheckVerticalDiagonalBorderRayOutward = false;
    this.myCheckVerticalDiagonalBorderRayInward = false;
    this.myCheckVerticalSearchFartherVerticalHit = false;
    this.myGroundAngleToIgnore = 0;
    this.myGroundAngleToIgnoreWithPerceivedAngle = null;
    this.myCeilingAngleToIgnore = 0;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = null;
    this.myHorizontalMovementGroundAngleIgnoreHeight = null;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = null;
    this.myHorizontalPositionGroundAngleIgnoreHeight = null;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = null;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = null;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = null;
    this.myHeight = 0;
    this.myComputeGroundInfoEnabled = false;
    this.myComputeCeilingInfoEnabled = false;
    this.myDistanceToBeOnGround = 0;
    this.myDistanceToComputeGroundInfo = 0;
    this.myDistanceToBeOnCeiling = 0;
    this.myDistanceToComputeCeilingInfo = 0;
    this.myVerticalFixToBeOnGround = 0;
    this.myVerticalFixToComputeGroundInfo = 0;
    this.myVerticalFixToBeOnCeiling = 0;
    this.myVerticalFixToComputeCeilingInfo = 0;
    this.myGroundIsBaseInsideCollisionCheckEnabled = false;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = false;
    this.myIsOnGroundIfInsideHit = false;
    this.myIsOnCeilingIfInsideHit = false;
    this.myIsOnGroundMaxSurfaceAngle = null;
    this.myIsOnCeilingMaxSurfaceAngle = null;
    this.myFindGroundDistanceMaxOutsideDistance = 0;
    this.myFindGroundDistanceMaxInsideDistance = 0;
    this.myFindCeilingDistanceMaxOutsideDistance = 0;
    this.myFindCeilingDistanceMaxInsideDistance = 0;
    this.myAllowGroundSteepFix = false;
    this.myAllowCeilingSteepFix = false;
    this.myMustStayOnGround = false;
    this.myMustStayOnCeiling = false;
    this.myMustStayOnValidGroundAngleDownhill = false;
    this.myMustStayOnValidCeilingAngleDownhill = false;
    this.myRegatherGroundInfoOnSurfaceCheckFail = false;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = false;
    this.myMustStayBelowIgnorableGroundAngleDownhill = false;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = false;
    this.myMustStayBelowGroundAngleDownhill = null;
    this.myMustStayBelowCeilingAngleDownhill = null;
    this.myMovementMustStayOnGroundHitAngle = null;
    this.myMovementMustStayOnCeilingHitAngle = null;
    this.myTeleportMustBeOnIgnorableGroundAngle = false;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = false;
    this.myTeleportMustBeOnIgnorableCeilingAngle = false;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = false;
    this.myTeleportMustBeOnGroundAngle = null;
    this.myCheckTransformMustBeOnGroundAngle = null;
    this.myTeleportMustBeOnCeilingAngle = null;
    this.myCheckTransformMustBeOnCeilingAngle = null;
    this.myTeleportMustBeOnGround = false;
    this.myCheckTransformMustBeOnGround = false;
    this.myTeleportMustBeOnCeiling = false;
    this.myCheckTransformMustBeOnCeiling = false;
    this.mySlidingEnabled = false;
    this.mySlidingHorizontalMovementCheckBetterNormal = false;
    this.mySlidingMaxAttempts = 0;
    this.mySlidingCheckBothDirections = false;
    this.mySlidingFlickeringPreventionType = 0;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingAdjustSign90Degrees = false;
    this.myHorizontalBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalObjectsToIgnore = [];
    this.myVerticalBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalObjectsToIgnore = [];
    this.myExtraMovementCheckCallback = null;
    this.myExtraTeleportCheckCallback = null;
    this.myExtraCheckTransformCheckCallback = null;
    this.myDebugEnabled = false;
    this.myDebugHorizontalMovementEnabled = false;
    this.myDebugHorizontalPositionEnabled = false;
    this.myDebugVerticalMovementEnabled = false;
    this.myDebugVerticalPositionEnabled = false;
    this.myDebugSlidingEnabled = false;
    this.myDebugGroundInfoEnabled = false;
    this.myDebugCeilingInfoEnabled = false;
    this.myDebugRuntimeParamsEnabled = false;
    this.myDebugMovementEnabled = false;
  }
  copy(other) {
    this.mySplitMovementEnabled = other.mySplitMovementEnabled;
    this.mySplitMovementMaxLength = other.mySplitMovementMaxLength;
    this.mySplitMovementMaxLengthEnabled = other.mySplitMovementMaxLengthEnabled;
    this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
    this.mySplitMovementMaxStepsEnabled = other.mySplitMovementMaxStepsEnabled;
    this.mySplitMovementMinLength = other.mySplitMovementMinLength;
    this.mySplitMovementMinLengthEnabled = other.mySplitMovementMinLengthEnabled;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = other.mySplitMovementStopWhenHorizontalMovementCanceled;
    this.mySplitMovementStopWhenVerticalMovementCanceled = other.mySplitMovementStopWhenVerticalMovementCanceled;
    this.mySplitMovementStopCallback = other.mySplitMovementStopCallback;
    this.mySplitMovementStopReturnPrevious = other.mySplitMovementStopReturnPrevious;
    this.myRadius = other.myRadius;
    this.myDistanceFromFeetToIgnore = other.myDistanceFromFeetToIgnore;
    this.myDistanceFromHeadToIgnore = other.myDistanceFromHeadToIgnore;
    this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
    this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
    this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
    this.myHorizontalMovementStepEnabled = other.myHorizontalMovementStepEnabled;
    this.myHorizontalMovementStepMaxLength = other.myHorizontalMovementStepMaxLength;
    this.myHorizontalMovementRadialStepAmount = other.myHorizontalMovementRadialStepAmount;
    this.myHorizontalMovementCheckDiagonalOutward = other.myHorizontalMovementCheckDiagonalOutward;
    this.myHorizontalMovementCheckDiagonalInward = other.myHorizontalMovementCheckDiagonalInward;
    this.myHorizontalMovementCheckStraight = other.myHorizontalMovementCheckStraight;
    this.myHorizontalMovementCheckHorizontalBorder = other.myHorizontalMovementCheckHorizontalBorder;
    this.myHorizontalMovementCheckVerticalStraight = other.myHorizontalMovementCheckVerticalStraight;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = other.myHorizontalMovementCheckVerticalDiagonalUpwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = other.myHorizontalMovementCheckVerticalDiagonalUpwardInward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = other.myHorizontalMovementCheckVerticalDiagonalDownwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = other.myHorizontalMovementCheckVerticalDiagonalDownwardInward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = other.myHorizontalMovementCheckVerticalStraightDiagonalUpward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = other.myHorizontalMovementCheckVerticalStraightDiagonalDownward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
    this.myHalfConeAngle = other.myHalfConeAngle;
    this.myHalfConeSliceAmount = other.myHalfConeSliceAmount;
    this.myCheckConeBorder = other.myCheckConeBorder;
    this.myCheckConeRay = other.myCheckConeRay;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = other.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision;
    this.myHorizontalPositionCheckVerticalDirectionType = other.myHorizontalPositionCheckVerticalDirectionType;
    this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
    this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
    this.myFeetRadius = other.myFeetRadius;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = other.myAdjustVerticalMovementWithGroundAngleDownhill;
    this.myAdjustVerticalMovementWithGroundAngleUphill = other.myAdjustVerticalMovementWithGroundAngleUphill;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = other.myAdjustHorizontalMovementWithGroundAngleDownhill;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = other.myAdjustVerticalMovementWithCeilingAngleDownhill;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = other.myAdjustVerticalMovementWithCeilingAngleUphill;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = other.myAdjustHorizontalMovementWithCeilingAngleDownhill;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle;
    this.myCheckVerticalFixedForwardEnabled = other.myCheckVerticalFixedForwardEnabled;
    this.myCheckVerticalFixedForward.vec3_copy(other.myCheckVerticalFixedForward);
    this.myCheckVerticalBothDirection = other.myCheckVerticalBothDirection;
    this.mySnapOnGroundEnabled = other.mySnapOnGroundEnabled;
    this.mySnapOnGroundExtraDistance = other.mySnapOnGroundExtraDistance;
    this.mySnapOnCeilingEnabled = other.mySnapOnCeilingEnabled;
    this.mySnapOnCeilingExtraDistance = other.mySnapOnCeilingExtraDistance;
    this.myGroundPopOutEnabled = other.myGroundPopOutEnabled;
    this.myGroundPopOutExtraDistance = other.myGroundPopOutExtraDistance;
    this.myCeilingPopOutEnabled = other.myCeilingPopOutEnabled;
    this.myCeilingPopOutExtraDistance = other.myCeilingPopOutExtraDistance;
    this.myVerticalMovementReduceEnabled = other.myVerticalMovementReduceEnabled;
    this.myGroundCircumferenceAddCenter = other.myGroundCircumferenceAddCenter;
    this.myGroundCircumferenceSliceAmount = other.myGroundCircumferenceSliceAmount;
    this.myGroundCircumferenceStepAmount = other.myGroundCircumferenceStepAmount;
    this.myGroundCircumferenceRotationPerStep = other.myGroundCircumferenceRotationPerStep;
    this.myVerticalAllowHitInsideCollisionIfOneOk = other.myVerticalAllowHitInsideCollisionIfOneOk;
    this.myCheckHeight = other.myCheckHeight;
    this.myCheckHeightVerticalMovement = other.myCheckHeightVerticalMovement;
    this.myCheckHeightVerticalPosition = other.myCheckHeightVerticalPosition;
    this.myCheckHeightTopMovement = other.myCheckHeightTopMovement;
    this.myCheckHeightTopPosition = other.myCheckHeightTopPosition;
    this.myCheckHeightConeOnCollision = other.myCheckHeightConeOnCollision;
    this.myCheckHeightConeOnCollisionKeepHit = other.myCheckHeightConeOnCollisionKeepHit;
    this.myHeightCheckStepAmountMovement = other.myHeightCheckStepAmountMovement;
    this.myHeightCheckStepAmountPosition = other.myHeightCheckStepAmountPosition;
    this.myCheckVerticalStraight = other.myCheckVerticalStraight;
    this.myCheckVerticalDiagonalRayOutward = other.myCheckVerticalDiagonalRayOutward;
    this.myCheckVerticalDiagonalRayInward = other.myCheckVerticalDiagonalRayInward;
    this.myCheckVerticalDiagonalBorderOutward = other.myCheckVerticalDiagonalBorderOutward;
    this.myCheckVerticalDiagonalBorderInward = other.myCheckVerticalDiagonalBorderInward;
    this.myCheckVerticalDiagonalBorderRayOutward = other.myCheckVerticalDiagonalBorderRayOutward;
    this.myCheckVerticalDiagonalBorderRayInward = other.myCheckVerticalDiagonalBorderRayInward;
    this.myCheckVerticalSearchFartherVerticalHit = other.myCheckVerticalSearchFartherVerticalHit;
    this.myGroundAngleToIgnore = other.myGroundAngleToIgnore;
    this.myGroundAngleToIgnoreWithPerceivedAngle = other.myGroundAngleToIgnoreWithPerceivedAngle;
    this.myCeilingAngleToIgnore = other.myCeilingAngleToIgnore;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = other.myCeilingAngleToIgnoreWithPerceivedAngle;
    this.myHorizontalMovementGroundAngleIgnoreHeight = other.myHorizontalMovementGroundAngleIgnoreHeight;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = other.myHorizontalMovementCeilingAngleIgnoreHeight;
    this.myHorizontalPositionGroundAngleIgnoreHeight = other.myHorizontalPositionGroundAngleIgnoreHeight;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = other.myHorizontalPositionCeilingAngleIgnoreHeight;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = other.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = other.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
    this.myHeight = other.myHeight;
    this.myComputeGroundInfoEnabled = other.myComputeGroundInfoEnabled;
    this.myComputeCeilingInfoEnabled = other.myComputeCeilingInfoEnabled;
    this.myDistanceToBeOnGround = other.myDistanceToBeOnGround;
    this.myDistanceToComputeGroundInfo = other.myDistanceToComputeGroundInfo;
    this.myDistanceToBeOnCeiling = other.myDistanceToBeOnCeiling;
    this.myDistanceToComputeCeilingInfo = other.myDistanceToComputeCeilingInfo;
    this.myVerticalFixToBeOnGround = other.myVerticalFixToBeOnGround;
    this.myVerticalFixToComputeGroundInfo = other.myVerticalFixToComputeGroundInfo;
    this.myVerticalFixToBeOnCeiling = other.myVerticalFixToBeOnCeiling;
    this.myVerticalFixToComputeCeilingInfo = other.myVerticalFixToComputeCeilingInfo;
    this.myGroundIsBaseInsideCollisionCheckEnabled = other.myGroundIsBaseInsideCollisionCheckEnabled;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = other.myCeilingIsBaseInsideCollisionCheckEnabled;
    this.myIsOnGroundIfInsideHit = other.myIsOnGroundIfInsideHit;
    this.myIsOnCeilingIfInsideHit = other.myIsOnCeilingIfInsideHit;
    this.myIsOnGroundMaxSurfaceAngle = other.myIsOnGroundMaxSurfaceAngle;
    this.myIsOnCeilingMaxSurfaceAngle = other.myIsOnCeilingMaxSurfaceAngle;
    this.myFindGroundDistanceMaxOutsideDistance = other.myFindGroundDistanceMaxOutsideDistance;
    this.myFindGroundDistanceMaxInsideDistance = other.myFindGroundDistanceMaxInsideDistance;
    this.myFindCeilingDistanceMaxOutsideDistance = other.myFindCeilingDistanceMaxOutsideDistance;
    this.myFindCeilingDistanceMaxInsideDistance = other.myFindCeilingDistanceMaxInsideDistance;
    this.myAllowGroundSteepFix = other.myAllowGroundSteepFix;
    this.myAllowCeilingSteepFix = other.myAllowCeilingSteepFix;
    this.myMustStayOnGround = other.myMustStayOnGround;
    this.myMustStayOnCeiling = other.myMustStayOnCeiling;
    this.myMustStayOnValidGroundAngleDownhill = other.myMustStayOnValidGroundAngleDownhill;
    this.myMustStayOnValidCeilingAngleDownhill = other.myMustStayOnValidCeilingAngleDownhill;
    this.myRegatherGroundInfoOnSurfaceCheckFail = other.myRegatherGroundInfoOnSurfaceCheckFail;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = other.myRegatherCeilingInfoOnSurfaceCheckFail;
    this.myMustStayBelowGroundAngleDownhill = other.myMustStayBelowGroundAngleDownhill;
    this.myMustStayBelowCeilingAngleDownhill = other.myMustStayBelowCeilingAngleDownhill;
    this.myMustStayBelowIgnorableGroundAngleDownhill = other.myMustStayBelowIgnorableGroundAngleDownhill;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = other.myMustStayBelowIgnorableCeilingAngleDownhill;
    this.myMovementMustStayOnGroundHitAngle = other.myMovementMustStayOnGroundHitAngle;
    this.myMovementMustStayOnCeilingHitAngle = other.myMovementMustStayOnCeilingHitAngle;
    this.myTeleportMustBeOnIgnorableGroundAngle = other.myTeleportMustBeOnIgnorableGroundAngle;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = other.myCheckTransformMustBeOnIgnorableGroundAngle;
    this.myTeleportMustBeOnIgnorableCeilingAngle = other.myTeleportMustBeOnIgnorableCeilingAngle;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = other.myCheckTransformMustBeOnIgnorableCeilingAngle;
    this.myTeleportMustBeOnGroundAngle = other.myTeleportMustBeOnGroundAngle;
    this.myCheckTransformMustBeOnGroundAngle = other.myCheckTransformMustBeOnGroundAngle;
    this.myTeleportMustBeOnCeilingAngle = other.myTeleportMustBeOnCeilingAngle;
    this.myCheckTransformMustBeOnCeilingAngle = other.myCheckTransformMustBeOnCeilingAngle;
    this.myTeleportMustBeOnGround = other.myTeleportMustBeOnGround;
    this.myCheckTransformMustBeOnGround = other.myCheckTransformMustBeOnGround;
    this.myTeleportMustBeOnCeiling = other.myTeleportMustBeOnCeiling;
    this.myCheckTransformMustBeOnCeiling = other.myCheckTransformMustBeOnCeiling;
    this.mySlidingEnabled = other.mySlidingEnabled;
    this.mySlidingHorizontalMovementCheckBetterNormal = other.mySlidingHorizontalMovementCheckBetterNormal;
    this.mySlidingMaxAttempts = other.mySlidingMaxAttempts;
    this.mySlidingCheckBothDirections = other.mySlidingCheckBothDirections;
    this.mySlidingFlickeringPreventionType = other.mySlidingFlickeringPreventionType;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = other.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingAdjustSign90Degrees = other.mySlidingAdjustSign90Degrees;
    this.myHorizontalBlockLayerFlags.copy(other.myHorizontalBlockLayerFlags);
    this.myHorizontalObjectsToIgnore.pp_copy(other.myHorizontalObjectsToIgnore);
    this.myVerticalBlockLayerFlags.copy(other.myVerticalBlockLayerFlags);
    this.myVerticalObjectsToIgnore.pp_copy(other.myVerticalObjectsToIgnore);
    this.myExtraMovementCheckCallback = other.myExtraMovementCheckCallback;
    this.myExtraTeleportCheckCallback = other.myExtraTeleportCheckCallback;
    this.myExtraCheckTransformCheckCallback = other.myExtraCheckTransformCheckCallback;
    this.myDebugEnabled = other.myDebugEnabled;
    this.myDebugHorizontalMovementEnabled = other.myDebugHorizontalMovementEnabled;
    this.myDebugHorizontalPositionEnabled = other.myDebugHorizontalPositionEnabled;
    this.myDebugVerticalMovementEnabled = other.myDebugVerticalMovementEnabled;
    this.myDebugVerticalPositionEnabled = other.myDebugVerticalPositionEnabled;
    this.myDebugSlidingEnabled = other.myDebugSlidingEnabled;
    this.myDebugGroundInfoEnabled = other.myDebugGroundInfoEnabled;
    this.myDebugCeilingInfoEnabled = other.myDebugCeilingInfoEnabled;
    this.myDebugRuntimeParamsEnabled = other.myDebugRuntimeParamsEnabled;
    this.myDebugMovementEnabled = other.myDebugMovementEnabled;
  }
};
var CollisionRuntimeParams = class {
  constructor() {
    this.myOriginalPosition = vec3_create();
    this.myNewPosition = vec3_create();
    this.myOriginalHeight = 0;
    this.myOriginalForward = vec3_create();
    this.myOriginalUp = vec3_create();
    this.myOffsetUp = vec3_create();
    this.myOriginalMovement = vec3_create();
    this.myFixedMovement = vec3_create();
    this.myLastValidOriginalHorizontalMovement = vec3_create();
    this.myLastValidOriginalVerticalMovement = vec3_create();
    this.myLastValidSurfaceAdjustedHorizontalMovement = vec3_create();
    this.myLastValidSurfaceAdjustedVerticalMovement = vec3_create();
    this.myLastValidEndHorizontalMovement = vec3_create();
    this.myLastValidEndVerticalMovement = vec3_create();
    this.myIsOnGround = false;
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal = vec3_create();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal = vec3_create();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal = vec3_create();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal = vec3_create();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit = new RaycastHit();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit = new RaycastHit();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit = new RaycastHit();
    this.mySlidingWallNormal = new vec3_create();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement = vec3_create();
    this.myOriginalTeleportPosition = vec3_create();
    this.myFixedTeleportPosition = vec3_create();
    this.myOriginalPositionCheckPosition = vec3_create();
    this.myFixedPositionCheckPosition = vec3_create();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementMovementChecked = vec3_create();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  reset() {
    this.myOriginalPosition.vec3_zero();
    this.myNewPosition.vec3_zero();
    this.myOriginalHeight = 0;
    this.myOriginalForward.vec3_zero();
    this.myOriginalUp.vec3_zero();
    this.myOffsetUp.vec3_zero();
    this.myOriginalMovement.vec3_zero();
    this.myFixedMovement.vec3_zero();
    this.myLastValidOriginalHorizontalMovement.vec3_zero();
    this.myLastValidOriginalVerticalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_zero();
    this.myLastValidEndHorizontalMovement.vec3_zero();
    this.myLastValidEndVerticalMovement.vec3_zero();
    this.myIsOnGround = false;
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal.vec3_zero();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal.vec3_zero();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal.vec3_zero();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal.vec3_zero();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit.reset();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit.reset();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit.reset();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement.vec3_zero();
    this.mySlidingWallNormal.vec3_zero();
    this.myOriginalTeleportPosition.vec3_zero();
    this.myFixedTeleportPosition.vec3_zero();
    this.myOriginalPositionCheckPosition.vec3_zero();
    this.myFixedPositionCheckPosition.vec3_zero();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementMovementChecked.vec3_zero();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  copy(other) {
    this.myOriginalPosition.vec3_copy(other.myOriginalPosition);
    this.myNewPosition.vec3_copy(other.myNewPosition);
    this.myOriginalHeight = other.myOriginalHeight;
    this.myOriginalForward.vec3_copy(other.myOriginalForward);
    this.myOriginalUp.vec3_copy(other.myOriginalUp);
    this.myOffsetUp.vec3_copy(other.myOffsetUp);
    this.myOriginalMovement.vec3_copy(other.myOriginalMovement);
    this.myFixedMovement.vec3_copy(other.myFixedMovement);
    this.myLastValidOriginalHorizontalMovement.vec3_copy(other.myLastValidOriginalHorizontalMovement);
    this.myLastValidOriginalVerticalMovement.vec3_copy(other.myLastValidOriginalVerticalMovement);
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(other.myLastValidSurfaceAdjustedHorizontalMovement);
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(other.myLastValidSurfaceAdjustedVerticalMovement);
    this.myLastValidEndHorizontalMovement.vec3_copy(other.myLastValidEndHorizontalMovement);
    this.myLastValidEndVerticalMovement.vec3_copy(other.myLastValidEndVerticalMovement);
    this.myIsOnGround = other.myIsOnGround;
    this.myGroundAngle = other.myGroundAngle;
    this.myGroundPerceivedAngle = other.myGroundPerceivedAngle;
    this.myGroundNormal.vec3_copy(other.myGroundNormal);
    this.myGroundHitMaxAngle = other.myGroundHitMaxAngle;
    this.myGroundHitMaxNormal.vec3_copy(other.myGroundHitMaxNormal);
    this.myGroundDistance = other.myGroundDistance;
    this.myGroundIsBaseInsideCollision = other.myGroundIsBaseInsideCollision;
    this.myIsOnCeiling = other.myIsOnCeiling;
    this.myCeilingAngle = other.myCeilingAngle;
    this.myCeilingPerceivedAngle = other.myCeilingPerceivedAngle;
    this.myCeilingNormal.vec3_copy(other.myCeilingNormal);
    this.myCeilingHitMaxAngle = other.myCeilingHitMaxAngle;
    this.myCeilingHitMaxNormal.vec3_copy(other.myCeilingHitMaxNormal);
    this.myCeilingDistance = other.myCeilingDistance;
    this.myCeilingIsBaseInsideCollision = other.myCeilingIsBaseInsideCollision;
    this.myHorizontalMovementCanceled = other.myHorizontalMovementCanceled;
    this.myIsCollidingHorizontally = other.myIsCollidingHorizontally;
    this.myHorizontalCollisionHit.copy(other.myHorizontalCollisionHit);
    this.myVerticalMovementCanceled = other.myVerticalMovementCanceled;
    this.myIsCollidingVertically = other.myIsCollidingVertically;
    this.myVerticalCollisionHit.copy(other.myVerticalCollisionHit);
    this.myHasSnappedOnGround = other.myHasSnappedOnGround;
    this.myHasSnappedOnCeiling = other.myHasSnappedOnCeiling;
    this.myHasPoppedOutGround = other.myHasPoppedOutGround;
    this.myHasPoppedOutCeiling = other.myHasPoppedOutCeiling;
    this.myHasReducedVerticalMovement = other.myHasReducedVerticalMovement;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill;
    this.myIsSliding = other.myIsSliding;
    this.myIsSlidingIntoOppositeDirection = other.myIsSlidingIntoOppositeDirection;
    this.myIsSlidingFlickerPrevented = other.myIsSlidingFlickerPrevented;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingMovementAngle = other.mySlidingMovementAngle;
    this.mySlidingCollisionAngle = other.mySlidingCollisionAngle;
    this.mySlidingCollisionHit.copy(other.mySlidingCollisionHit);
    this.mySliding90DegreesSign = other.mySliding90DegreesSign;
    this.mySlidingRecompute90DegreesSign = other.mySlidingRecompute90DegreesSign;
    this.myLastValidIsSliding = other.myLastValidIsSliding;
    this.mySlidingPreviousHorizontalMovement.vec3_copy(other.mySlidingPreviousHorizontalMovement);
    this.mySlidingWallNormal.vec3_copy(other.mySlidingWallNormal);
    this.myOriginalTeleportPosition.vec3_copy(other.myOriginalTeleportPosition);
    this.myFixedTeleportPosition.vec3_copy(other.myFixedTeleportPosition);
    this.myTeleportCanceled = other.myTeleportCanceled;
    this.myIsPositionOk = other.myIsPositionOk;
    this.myOriginalPositionCheckPosition.vec3_copy(other.myOriginalPositionCheckPosition);
    this.myFixedPositionCheckPosition.vec3_copy(other.myFixedPositionCheckPosition);
    this.myIsTeleport = other.myIsTeleport;
    this.myIsMove = other.myIsMove;
    this.myIsPositionCheck = other.myIsPositionCheck;
    this.myIsPositionCheckAllowAdjustments = other.myIsPositionCheckAllowAdjustments;
    this.mySplitMovementSteps = other.mySplitMovementSteps;
    this.mySplitMovementStepsPerformed = other.mySplitMovementStepsPerformed;
    this.mySplitMovementStop = other.mySplitMovementStop;
    this.mySplitMovementMovementChecked.vec3_copy(other.mySplitMovementMovementChecked);
    this.myRealIsOnGround = other.myRealIsOnGround;
    this.myRealIsOnCeiling = other.myRealIsOnCeiling;
  }
};

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_base.js
var CollisionCheckBase = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myRaycastParams = new RaycastParams(Globals.getPhysics(this._myEngine));
    this._myRaycastResult = new RaycastResults();
    this._myFixRaycastResult = new RaycastResults();
    this._myBackupRaycastHit = new RaycastHit();
    this._myPrevCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myCheckBetterSlidingNormalCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myInternalSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOppositeDirectionCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOnVerticalCheckCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myCollisionCheckDisabled = false;
    this._myDebugEnabled = false;
    this._myTotalRaycasts = 0;
  }
  isCollisionCheckDisabled() {
    return this._myCollisionCheckDisabled;
  }
  setCollisionCheckDisabled(collisionCheckDisabled) {
    this._myCollisionCheckDisabled = collisionCheckDisabled;
  }
  _raycastAndDebug(origin, direction, distance2, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForMoveCollisionCheckDisabled(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForTeleportCollisionCheckDisabled(position, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForPositionCheckCollisionCheckDisabled(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _debugMovement(movement, fixedMovement, feetPosition, up, collisionCheckParams) {
    let originalHorizontalMovement = movement.vec3_removeComponentAlongAxis(up);
    let horizontalMovement = fixedMovement.vec3_removeComponentAlongAxis(up);
    let verticalMovement = fixedMovement.vec3_componentAlongAxis(up);
    let feetPositionPlusOffset = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-3));
    if (!originalHorizontalMovement.vec3_isZero()) {
      originalHorizontalMovement.vec3_normalize(originalHorizontalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPositionPlusOffset, originalHorizontalMovement, 0.2, vec4_create(0.5, 0.5, 1, 1));
    }
    if (!horizontalMovement.vec3_isZero()) {
      horizontalMovement.vec3_normalize(horizontalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPositionPlusOffset, horizontalMovement, 0.2, vec4_create(0, 0, 1, 1));
    }
    if (!verticalMovement.vec3_isZero()) {
      verticalMovement.vec3_normalize(verticalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPosition, verticalMovement, 0.2, vec4_create(0, 0, 1, 1));
    }
  }
  _debugRuntimeParams(collisionRuntimeParams) {
    if (collisionRuntimeParams.myHorizontalCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, collisionRuntimeParams.myHorizontalCollisionHit.myPosition, collisionRuntimeParams.myHorizontalCollisionHit.myNormal, 0.2, vec4_create(1, 0, 0, 1));
    }
    if (collisionRuntimeParams.mySlidingCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, collisionRuntimeParams.mySlidingCollisionHit.myPosition, collisionRuntimeParams.mySlidingCollisionHit.myNormal, 0.2, vec4_create(1, 0, 0, 1));
    }
    if (collisionRuntimeParams.myVerticalCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, collisionRuntimeParams.myVerticalCollisionHit.myPosition, collisionRuntimeParams.myVerticalCollisionHit.myNormal, 0.2, vec4_create(1, 0, 0, 1));
    }
  }
};
CollisionCheckBase.prototype._raycastAndDebug = function() {
  let tempRaycastResult = new RaycastResults();
  return function _raycastAndDebug(origin, direction, distance2, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
    this._myRaycastParams.myOrigin.vec3_copy(origin);
    this._myRaycastParams.myDirection.vec3_copy(direction);
    this._myRaycastParams.myDistance = distance2;
    if (isHorizontal) {
      this._myRaycastParams.myBlockLayerFlags.copy(collisionCheckParams.myHorizontalBlockLayerFlags);
      this._myRaycastParams.myObjectsToIgnore = collisionCheckParams.myHorizontalObjectsToIgnore;
    } else {
      this._myRaycastParams.myBlockLayerFlags.copy(collisionCheckParams.myVerticalBlockLayerFlags);
      this._myRaycastParams.myObjectsToIgnore = collisionCheckParams.myVerticalObjectsToIgnore;
    }
    this._myRaycastParams.myIgnoreHitsInsideCollision = ignoreHitsInsideCollision;
    let raycastResult = null;
    let raycastPerformanceDebugEnabled = false;
    if (raycastPerformanceDebugEnabled && Globals.isDebugEnabled(this._myEngine)) {
      let raycastAlways = false;
      if (raycastAlways || !this._myRaycastResult.isColliding()) {
        raycastResult = PhysicsUtils.raycast(this._myRaycastParams, tempRaycastResult);
      }
      if (!this._myRaycastResult.isColliding() && tempRaycastResult.isColliding()) {
        this._myRaycastResult.copy(tempRaycastResult);
      }
      raycastResult = this._myRaycastResult;
    } else {
      raycastResult = PhysicsUtils.raycast(this._myRaycastParams, this._myRaycastResult);
    }
    this._myTotalRaycasts++;
    if (this._myDebugEnabled && Globals.isDebugEnabled(this._myEngine)) {
      Globals.getDebugVisualManager(this._myEngine).drawRaycast(0, raycastResult);
    }
    return raycastResult;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForMoveCollisionCheckDisabled = function() {
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  return function _setRuntimeParamsForMoveCollisionCheckDisabled(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    collisionRuntimeParams.reset();
    collisionRuntimeParams.myRealIsOnGround = true;
    collisionRuntimeParams.myIsOnGround = true;
    collisionRuntimeParams.myGroundAngle = 0;
    collisionRuntimeParams.myGroundPerceivedAngle = 0;
    collisionRuntimeParams.myGroundNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myGroundHitMaxAngle = collisionRuntimeParams.myGroundAngle;
    collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    collisionRuntimeParams.myGroundDistance = 0;
    collisionRuntimeParams.myGroundIsBaseInsideCollision = false;
    collisionRuntimeParams.myRealIsOnCeiling = false;
    collisionRuntimeParams.myIsOnCeiling = false;
    collisionRuntimeParams.myCeilingAngle = 0;
    collisionRuntimeParams.myCeilingPerceivedAngle = 0;
    collisionRuntimeParams.myCeilingNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myCeilingHitMaxAngle = collisionRuntimeParams.myCeilingAngle;
    collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    collisionRuntimeParams.myCeilingDistance = 0;
    collisionRuntimeParams.myCeilingIsBaseInsideCollision = false;
    collisionRuntimeParams.mySplitMovementSteps = 1;
    collisionRuntimeParams.mySplitMovementStepsPerformed = 1;
    collisionRuntimeParams.mySplitMovementStop = false;
    collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movement);
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    collisionRuntimeParams.myOffsetUp = offsetTransformQuat.quat2_getUp(collisionRuntimeParams.myOffsetUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
    collisionRuntimeParams.myFixedMovement.vec3_copy(movement);
    collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
    collisionRuntimeParams.myIsMove = true;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForTeleportCollisionCheckDisabled = function() {
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  return function _setRuntimeParamsForTeleportCollisionCheckDisabled(position, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    collisionRuntimeParams.reset();
    collisionRuntimeParams.myRealIsOnGround = true;
    collisionRuntimeParams.myIsOnGround = true;
    collisionRuntimeParams.myGroundAngle = 0;
    collisionRuntimeParams.myGroundPerceivedAngle = 0;
    collisionRuntimeParams.myGroundNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myGroundHitMaxAngle = collisionRuntimeParams.myGroundAngle;
    collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    collisionRuntimeParams.myGroundDistance = 0;
    collisionRuntimeParams.myGroundIsBaseInsideCollision = false;
    collisionRuntimeParams.myRealIsOnCeiling = false;
    collisionRuntimeParams.myIsOnCeiling = false;
    collisionRuntimeParams.myCeilingAngle = 0;
    collisionRuntimeParams.myCeilingPerceivedAngle = 0;
    collisionRuntimeParams.myCeilingNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myCeilingHitMaxAngle = collisionRuntimeParams.myCeilingAngle;
    collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    collisionRuntimeParams.myCeilingDistance = 0;
    collisionRuntimeParams.myCeilingIsBaseInsideCollision = false;
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    collisionRuntimeParams.myOffsetUp = offsetTransformQuat.quat2_getUp(collisionRuntimeParams.myOffsetUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(position);
    collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(position);
    collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsTeleport = true;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForPositionCheckCollisionCheckDisabled = function() {
  let feetPosition = vec3_create();
  return function _setRuntimeParamsForPositionCheckCollisionCheckDisabled(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    feetPosition = transformQuat2.quat2_getPosition(feetPosition);
    this._setRuntimeParamsForTeleportCollisionCheckDisabled(feetPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams);
    collisionRuntimeParams.myIsPositionOk = true;
    collisionRuntimeParams.myIsPositionCheck = true;
    collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
    collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowFix;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
    collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
    collisionRuntimeParams.myTeleportCanceled = false;
    collisionRuntimeParams.myIsTeleport = false;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled = function() {
  return function _setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    collisionRuntimeParams.myRealIsOnGround = true;
    collisionRuntimeParams.myIsOnGround = true;
    collisionRuntimeParams.myGroundAngle = 0;
    collisionRuntimeParams.myGroundPerceivedAngle = 0;
    collisionRuntimeParams.myGroundNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myGroundHitMaxAngle = collisionRuntimeParams.myGroundAngle;
    collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    collisionRuntimeParams.myGroundDistance = 0;
    collisionRuntimeParams.myGroundIsBaseInsideCollision = false;
    collisionRuntimeParams.myRealIsOnCeiling = false;
    collisionRuntimeParams.myIsOnCeiling = false;
    collisionRuntimeParams.myCeilingAngle = 0;
    collisionRuntimeParams.myCeilingPerceivedAngle = 0;
    collisionRuntimeParams.myCeilingNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myCeilingHitMaxAngle = collisionRuntimeParams.myCeilingAngle;
    collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    collisionRuntimeParams.myCeilingDistance = 0;
    collisionRuntimeParams.myCeilingIsBaseInsideCollision = false;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_surface.js
var CollisionCheckSurface = class extends CollisionCheckBase {
  updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled(transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  computeSurfacePerceivedAngle(surfaceNormal, forward, up, isGround = true) {
  }
  _updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
  }
  _surfaceTooSteep(up, direction, collisionCheckParams, collisionRuntimeParams) {
  }
  _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
  }
  _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
  }
  _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
  }
  _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckSurface.prototype._updateSurfaceInfo = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let forwardForPerceivedAngle = vec3_create();
  let forwardForVertical = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    forwardForPerceivedAngle.vec3_copy(transformForward);
    forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
    if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
      forwardForVertical.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForVertical.vec3_copy(xAxis);
        } else {
          forwardForVertical.vec3_copy(zAxis);
        }
      }
      forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
      forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
      if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
        forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      }
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
  };
}();
CollisionCheckSurface.prototype._postSurfaceCheck = function() {
  let horizontalDirection = vec3_create();
  return function _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isVerticalMovementZero = originalVerticalMovement.vec3_isZero(1e-5);
    let isVerticalMovemenDownward = Math.pp_sign(originalVerticalMovement.vec3_lengthSigned(transformUp), -1) < 0;
    let horizontalMovementIsZero = fixedHorizontalMovement.vec3_isZero(1e-5);
    horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
    let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, horizontalDirection, transformUp, true);
    let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, horizontalDirection, transformUp, false);
    let mustRemainOnGroundOk = true;
    if (collisionCheckParams.myMustStayOnGround) {
      if (previousCollisionRuntimeParams.myIsOnGround && !collisionRuntimeParams.myIsOnGround && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnGroundOk = false;
      }
    }
    let mustRemainOnCeilingOk = true;
    if (collisionCheckParams.myMustStayOnCeiling) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !collisionRuntimeParams.myIsOnCeiling && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnCeilingOk = false;
      }
    }
    let mustStayBelowGroundAngleOk = true;
    if (collisionCheckParams.myMustStayBelowGroundAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowGroundAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowGroundAngleDownhill == null) {
        minAngle = collisionCheckParams.myGroundAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowGroundAngleDownhill, collisionCheckParams.myGroundAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundAngle <= minAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
        mustStayBelowGroundAngleOk = false;
      }
    }
    let mustStayBelowCeilingAngleOk = true;
    if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowCeilingAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill == null) {
        minAngle = collisionCheckParams.myCeilingAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowCeilingAngleDownhill, collisionCheckParams.myCeilingAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingAngle <= minAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
        mustStayBelowCeilingAngleOk = false;
      }
    }
    let mustStayOnGroundHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnGroundHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundHitMaxAngle <= collisionCheckParams.myMovementMustStayOnGroundHitAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundHitMaxAngle > collisionCheckParams.myMovementMustStayOnGroundHitAngle + 1e-4) {
        mustStayOnGroundHitAngleOk = false;
      }
    }
    let mustStayOnCeilingHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnCeilingHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingHitMaxAngle <= collisionCheckParams.myMovementMustStayOnCeilingHitAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingHitMaxAngle > collisionCheckParams.myMovementMustStayOnCeilingHitAngle + 1e-4) {
        mustStayOnCeilingHitAngleOk = false;
      }
    }
    let isOnValidGroundAngleUphill = true;
    let isOnValidGroundAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnGround && !horizontalMovementIsZero) {
        if (groundPerceivedAngle > 0) {
          isOnValidGroundAngleUphill = false;
          if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidGroundAngleUphill = Math.abs(groundPerceivedAngle) <= collisionCheckParams.myGroundAngleToIgnore + 1e-4;
          }
        } else if (groundPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidGroundAngleDownhill) {
              isOnValidGroundAngleDownhill = false;
            }
          }
        }
      }
    }
    let isOnValidCeilingAngleUphill = true;
    let isOnValidCeilingAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !horizontalMovementIsZero) {
        if (ceilingPerceivedAngle > 0) {
          isOnValidCeilingAngleUphill = false;
          if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidCeilingAngleUphill = Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
          }
        } else if (ceilingPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidCeilingAngleDownhill) {
              isOnValidCeilingAngleDownhill = false;
            }
          }
        }
      }
    }
    return mustRemainOnGroundOk && mustRemainOnCeilingOk && mustStayBelowGroundAngleOk && mustStayBelowCeilingAngleOk && mustStayOnGroundHitAngleOk && mustStayOnCeilingHitAngleOk && isOnValidGroundAngleUphill && isOnValidGroundAngleDownhill && isOnValidCeilingAngleUphill && isOnValidCeilingAngleDownhill;
  };
}();
CollisionCheckSurface.prototype._surfaceTooSteep = function() {
  let surfaceSteepResults = [false, false];
  return function _surfaceTooSteep(up, direction, collisionCheckParams, collisionRuntimeParams) {
    let groundTooSteep = false;
    let ceilingTooSteep = false;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, direction, up, true);
      groundTooSteep = groundPerceivedAngle > 0;
      if (groundTooSteep && collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
        groundTooSteep = Math.abs(groundPerceivedAngle) > collisionCheckParams.myGroundAngleToIgnore + 1e-4;
      }
    }
    if (!groundTooSteep) {
      if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, direction, up, false);
        ceilingTooSteep = ceilingPerceivedAngle > 0;
        if (ceilingTooSteep && collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          ceilingTooSteep = Math.abs(ceilingPerceivedAngle) > collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
        }
      }
    }
    surfaceSteepResults[0] = groundTooSteep;
    surfaceSteepResults[1] = ceilingTooSteep;
    return surfaceSteepResults;
  };
}();
CollisionCheckSurface.prototype._adjustVerticalMovementWithSurface = function() {
  let horizontalDirection = vec3_create();
  let extraVerticalMovement = vec3_create();
  return function _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
    outAdjustedVerticalMovement.vec3_copy(verticalMovement);
    if (horizontalMovement.vec3_isZero(1e-5)) {
      return outAdjustedVerticalMovement;
    }
    let extraVerticalLength = 0;
    horizontalDirection = horizontalMovement.vec3_normalize(horizontalDirection);
    if (previousCollisionRuntimeParams.myIsOnGround) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(previousCollisionRuntimeParams.myGroundNormal, horizontalDirection, up, true);
      let groundExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
      groundExtraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
      if (Math.abs(groundExtraVerticalLength) > 1e-5) {
        if (groundPerceivedAngle > 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = true;
          }
        } else if (groundPerceivedAngle < 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = true;
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(previousCollisionRuntimeParams.myCeilingNormal, horizontalDirection, up, false);
      let ceilingExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
      ceilingExtraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
      if (Math.abs(ceilingExtraVerticalLength) > 1e-5) {
        let sameSignThanGround = Math.pp_sign(extraVerticalLength) == Math.pp_sign(ceilingExtraVerticalLength);
        if (extraVerticalLength == 0 || sameSignThanGround && Math.abs(ceilingExtraVerticalLength) > Math.abs(extraVerticalLength)) {
          if (ceilingPerceivedAngle > 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
            }
          } else if (ceilingPerceivedAngle < 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
            }
          }
        }
      }
    }
    if (Math.abs(extraVerticalLength) > 1e-5) {
      let verticalMovementLength = verticalMovement.vec3_lengthSigned(up);
      let sameSignThanExtra = Math.pp_sign(extraVerticalLength) == Math.pp_sign(verticalMovementLength);
      extraVerticalMovement = up.vec3_scale(extraVerticalLength, extraVerticalMovement);
      if (verticalMovement.vec3_isZero(1e-5)) {
        outAdjustedVerticalMovement.vec3_copy(extraVerticalMovement);
      } else if (sameSignThanExtra) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else if (!sameSignThanExtra && (collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill || collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill)) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else {
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
      }
    }
    if (outAdjustedVerticalMovement.vec3_isZero(1e-6)) {
      outAdjustedVerticalMovement.vec3_zero();
    }
    return outAdjustedVerticalMovement;
  };
}();
CollisionCheckSurface.prototype._adjustHorizontalMovementWithSurface = function() {
  let extraHorizontalMovement = vec3_create();
  let groundHorizontalDirection = vec3_create();
  let ceilingHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = vec3_create();
  return function _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
    outAdjustedHorizontalMovement.vec3_copy(horizontalMovement);
    if (verticalMovement.vec3_isZero(1e-5)) {
      return outAdjustedHorizontalMovement;
    }
    let isMovementDownward = !verticalMovement.vec3_isConcordant(up);
    extraHorizontalMovement.vec3_zero();
    groundHorizontalDirection.vec3_zero();
    if (previousCollisionRuntimeParams.myIsOnGround) {
      groundHorizontalDirection = previousCollisionRuntimeParams.myGroundNormal.vec3_removeComponentAlongAxis(up, groundHorizontalDirection);
      if (!groundHorizontalDirection.vec3_isZero(1e-5)) {
        groundHorizontalDirection.vec3_normalize(groundHorizontalDirection);
        let groundExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myGroundAngle));
        groundExtraHorizontalLength *= isMovementDownward ? 1 : -1;
        if (Math.abs(groundExtraHorizontalLength) > 1e-5) {
          if (isMovementDownward) {
            if (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myGroundAngle >= collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle)) {
              extraHorizontalMovement = groundHorizontalDirection.vec3_scale(groundExtraHorizontalLength, extraHorizontalMovement);
              collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = true;
            }
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      ceilingHorizontalDirection = previousCollisionRuntimeParams.myCeilingNormal.vec3_removeComponentAlongAxis(up, ceilingHorizontalDirection);
      if (!ceilingHorizontalDirection.vec3_isZero(1e-5)) {
        ceilingHorizontalDirection.vec3_normalize(ceilingHorizontalDirection);
        let ceilingExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myCeilingAngle));
        ceilingExtraHorizontalLength *= isMovementDownward ? -1 : 1;
        if (Math.abs(ceilingExtraHorizontalLength) > 1e-5) {
          let sameDirectionAsGround = ceilingHorizontalDirection.vec3_isConcordant(groundHorizontalDirection);
          if (extraHorizontalMovement.vec3_isZero() || sameDirectionAsGround) {
            if (!isMovementDownward) {
              if (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myCeilingAngle >= collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle)) {
                scaledCeilingHorizontalDirection = ceilingHorizontalDirection.vec3_scale(ceilingExtraHorizontalLength, scaledCeilingHorizontalDirection);
                if (!groundHorizontalDirection.vec3_isZero()) {
                  scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_removeComponentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_componentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  if (scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection.vec3_isFartherAlongAxis(extraHorizontalMovement, groundHorizontalDirection)) {
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
                    extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                  } else if (!scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection.vec3_isZero(1e-5)) {
                    extraHorizontalMovement = extraHorizontalMovement.vec3_add(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection, extraHorizontalMovement);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                  }
                } else {
                  extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                  collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                }
              }
            }
          }
        }
      }
    }
    if (!extraHorizontalMovement.vec3_isZero()) {
      if (horizontalMovement.vec3_isZero(1e-5)) {
        outAdjustedHorizontalMovement.vec3_copy(extraHorizontalMovement);
      } else if (extraHorizontalMovement.vec3_isConcordant(horizontalMovement)) {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      } else {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      }
    }
    if (outAdjustedHorizontalMovement.vec3_isZero(1e-6)) {
      outAdjustedHorizontalMovement.vec3_zero();
    }
    return outAdjustedHorizontalMovement;
  };
}();
CollisionCheckSurface.prototype._computeExtraSurfaceVerticalMovement = function() {
  let direction = vec3_create();
  let tempVector = vec3_create();
  return function _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
    outExtraSurfaceVerticalMovement.vec3_zero();
    if (!horizontalMovement.vec3_isZero()) {
      if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle != 0) {
        direction = horizontalMovement.vec3_normalize(direction);
        let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, direction, up, true);
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnGroundEnabled || extraVerticalLength > 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      } else if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle != 0) {
        direction = horizontalMovement.vec3_normalize(direction);
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, direction, up, false);
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
        extraVerticalLength *= -1;
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnCeilingEnabled || extraVerticalLength < 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      }
    }
    return outExtraSurfaceVerticalMovement;
  };
}();
CollisionCheckSurface.prototype._gatherSurfaceInfo = function() {
  let verticalDirection = vec3_create();
  let startOffset = vec3_create();
  let endOffset = vec3_create();
  let heightOffset = vec3_create();
  let smallOffset = vec3_create();
  let smallStartPosition = vec3_create();
  let smallEndPosition = vec3_create();
  let surfaceNormal = vec3_create();
  let surfaceHitMaxNormal = vec3_create();
  let hitFromCurrentPosition = vec3_create();
  let startPosition = vec3_create();
  let endPosition = vec3_create();
  let direction = vec3_create();
  return function _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && (isGround && collisionCheckParams.myDebugGroundInfoEnabled || !isGround && collisionCheckParams.myDebugCeilingInfoEnabled);
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forwardForVertical, collisionCheckParams, collisionRuntimeParams);
    verticalDirection.vec3_copy(up);
    let distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnGround;
    let distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeGroundInfo;
    let distanceToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxOutsideDistance;
    let verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnGround;
    let verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeGroundInfo;
    let verticalFixToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxInsideDistance;
    let isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnGroundIfInsideHit;
    let isBaseInsideCollisionCheckEnabled = collisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled;
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
      distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnCeiling;
      distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeCeilingInfo;
      distanceToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxOutsideDistance;
      verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnCeiling;
      verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeCeilingInfo;
      verticalFixToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxInsideDistance;
      isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnCeilingIfInsideHit;
      isBaseInsideCollisionCheckEnabled = collisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled;
    }
    startOffset = verticalDirection.vec3_scale(Math.max(verticalFixToBeOnSurface, verticalFixToComputeSurfaceInfo, verticalFixToFindSurfaceDistance, 1e-5), startOffset);
    endOffset = verticalDirection.vec3_negate(endOffset).vec3_scale(Math.max(distanceToBeOnSurface, distanceToComputeSurfaceInfo, distanceToFindSurfaceDistance, 1e-5), endOffset);
    heightOffset.vec3_zero();
    if (!isGround) {
      heightOffset = up.vec3_scale(height, heightOffset);
    }
    smallOffset = verticalDirection.vec3_scale(1e-4, smallOffset);
    let isOnSurface = false;
    let surfaceAngle = 0;
    let surfacePerceivedAngle = 0;
    surfaceNormal.vec3_zero();
    let surfaceHitMaxAngle = 0;
    surfaceHitMaxNormal.vec3_zero();
    let surfaceDistance = null;
    let isBaseInsideCollision = checkPositions.length > 0;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      currentPosition.vec3_add(heightOffset, currentPosition);
      let baseHitIsInsideCollision = false;
      if (isBaseInsideCollisionCheckEnabled) {
        smallStartPosition = currentPosition.vec3_add(smallOffset, smallStartPosition);
        smallEndPosition = currentPosition.vec3_sub(smallOffset, smallEndPosition);
        let origin = smallStartPosition;
        direction = smallEndPosition.vec3_sub(origin, direction);
        let distance2 = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult = this._raycastAndDebug(origin, direction, distance2, false, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.isColliding()) {
          baseHitIsInsideCollision = raycastResult.myHits[0].myInsideCollision;
        }
      }
      isBaseInsideCollision &&= baseHitIsInsideCollision;
      if (!baseHitIsInsideCollision) {
        startPosition = currentPosition.vec3_add(startOffset, startPosition);
        endPosition = currentPosition.vec3_add(endOffset, endPosition);
        let origin = startPosition;
        direction = endPosition.vec3_sub(origin, direction);
        let distance2 = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult = this._raycastAndDebug(origin, direction, distance2, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.isColliding()) {
          hitFromCurrentPosition = raycastResult.myHits[0].myPosition.vec3_sub(currentPosition, hitFromCurrentPosition);
          let hitFromCurrentPositionLength = hitFromCurrentPosition.vec3_lengthSigned(verticalDirection);
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToBeOnSurface + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToBeOnSurface + 1e-5) {
            isOnSurface = true;
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToComputeSurfaceInfo + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToComputeSurfaceInfo + 1e-5) {
            let currentSurfaceNormal = raycastResult.myHits[0].myNormal;
            surfaceNormal.vec3_add(currentSurfaceNormal, surfaceNormal);
            let surfaceHitAngle = currentSurfaceNormal.vec3_angle(verticalDirection);
            if (surfaceHitAngle > surfaceHitMaxAngle) {
              surfaceHitMaxAngle = surfaceHitAngle;
              surfaceHitMaxNormal.vec3_copy(currentSurfaceNormal);
            }
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToFindSurfaceDistance + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToFindSurfaceDistance + 1e-5) {
            if (surfaceDistance == null) {
              surfaceDistance = -hitFromCurrentPositionLength;
            } else {
              if (Math.abs(hitFromCurrentPositionLength) < Math.abs(surfaceDistance)) {
                surfaceDistance = -hitFromCurrentPositionLength;
              }
            }
          }
        }
      } else if (isOnSurfaceIfInsideHit) {
        isOnSurface = true;
      }
    }
    if (!surfaceNormal.vec3_isZero()) {
      surfaceNormal.vec3_normalize(surfaceNormal);
      surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
      if (surfaceAngle <= 1e-4) {
        surfaceAngle = 0;
        surfaceNormal.vec3_copy(verticalDirection);
      } else if (surfaceAngle >= 180 - 1e-4) {
        surfaceAngle = 180;
        surfaceNormal = verticalDirection.vec3_negate(surfaceNormal);
      }
      surfacePerceivedAngle = this.computeSurfacePerceivedAngle(surfaceNormal, forwardForPerceivedAngle, up, isGround);
    }
    if (isGround) {
      collisionRuntimeParams.myRealIsOnGround = isOnSurface;
      collisionRuntimeParams.myGroundAngle = surfaceAngle;
      collisionRuntimeParams.myGroundPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myGroundNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myGroundHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myGroundDistance = surfaceDistance;
      collisionRuntimeParams.myGroundIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnGroundMaxSurfaceAngle == null || collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myIsOnGroundMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnGround = true;
      } else {
        collisionRuntimeParams.myIsOnGround = false;
      }
    } else {
      collisionRuntimeParams.myRealIsOnCeiling = isOnSurface;
      collisionRuntimeParams.myCeilingAngle = surfaceAngle;
      collisionRuntimeParams.myCeilingPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myCeilingNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myCeilingHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myCeilingDistance = surfaceDistance;
      collisionRuntimeParams.myCeilingIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnCeilingMaxSurfaceAngle == null || collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myIsOnCeilingMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnCeiling = true;
      } else {
        collisionRuntimeParams.myIsOnCeiling = false;
      }
    }
  };
}();
CollisionCheckSurface.prototype.computeSurfacePerceivedAngle = function() {
  let forwardOnSurface = vec3_create();
  let verticalDirection = vec3_create();
  return function computeSurfacePerceivedAngle2(surfaceNormal, forward, up, isGround = true) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
    surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
    let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
    if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_base.js
var CollisionCheckHorizontalBase = class extends CollisionCheckSurface {
  _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
  }
  _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
  }
};
CollisionCheckHorizontalBase.prototype._horizontalCheckRaycast = function() {
  let direction = vec3_create();
  let fixedFeetPosition = vec3_create();
  let fixedHitPosition = vec3_create();
  return function _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
    let origin = startPosition;
    direction = endPosition.vec3_sub(origin, direction);
    if (movementDirection != null && !direction.vec3_isConcordant(movementDirection)) {
      direction.vec3_negate(direction);
      origin = endPosition;
    }
    let distance2 = direction.vec3_length();
    direction.vec3_normalize(direction);
    let raycastResult = this._raycastAndDebug(origin, direction, distance2, ignoreHitsInsideCollision, true, collisionCheckParams, collisionRuntimeParams);
    let isOk = true;
    if (raycastResult.isColliding()) {
      let hitsToControl = checkAllHits ? raycastResult.myHits.length : 1;
      let validHitIndex = 0;
      for (let i = 0; i < hitsToControl; i++) {
        let hit = raycastResult.myHits[i];
        if ((ignoreGroundAngleCallback == null || !ignoreGroundAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore)) && (ignoreCeilingAngleCallback == null || !ignoreCeilingAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore))) {
          isOk = false;
          validHitIndex = i;
          break;
        }
      }
      if (!isOk && validHitIndex > 0) {
        for (let i = 0; i < validHitIndex; i++) {
          raycastResult.removeHit(0);
        }
      }
    }
    if (!isOk && fixHitOnCollision) {
      let hitPosition = raycastResult.myHits[0].myPosition;
      fixedFeetPosition = feetPosition.vec3_copyComponentAlongAxis(hitPosition, up, fixedFeetPosition);
      fixedHitPosition.vec3_copy(hitPosition);
      let directionOffsetEpsilonValue = 1e-4;
      direction = direction.vec3_componentAlongAxis(up, direction);
      if (!direction.vec3_isZero(1e-6)) {
        direction.vec3_normalize(direction);
        direction.vec3_scale(directionOffsetEpsilonValue, direction);
        fixedFeetPosition.vec3_add(direction, fixedFeetPosition);
        fixedHitPosition.vec3_add(direction, fixedHitPosition);
      }
      direction = fixedHitPosition.vec3_sub(fixedFeetPosition, direction);
      direction.vec3_normalize(direction);
      direction.vec3_scale(directionOffsetEpsilonValue, direction);
      fixedHitPosition = fixedHitPosition.vec3_add(direction, fixedHitPosition);
      let swapRaycastResult = this._myRaycastResult;
      this._myRaycastResult = this._myFixRaycastResult;
      isOk = this._horizontalCheckRaycast(fixedFeetPosition, fixedHitPosition, null, up, false, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, false, collisionCheckParams, collisionRuntimeParams);
      if (this._myRaycastResult.isColliding()) {
        this._myFixRaycastResult = swapRaycastResult;
      } else {
        isOk = false;
        this._myRaycastResult = swapRaycastResult;
      }
    }
    return isOk;
  };
}();
CollisionCheckHorizontalBase.prototype._ignoreSurfaceAngle = function() {
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  let movementDirection = vec3_create();
  let hitDirection = vec3_create();
  let hitMovement = vec3_create();
  let projectAlongAxis = vec3_create();
  return function _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
    let isIgnorable = false;
    let surfaceIgnoreHeight = null;
    let groundIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
    let ceilingIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight;
    if (isGround && groundIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(groundIgnoreHeight + 2e-4, 0, height);
    } else if (!isGround && ceilingIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(height - ceilingIgnoreHeight - 2e-4, 0, height);
    }
    let surfaceIgnoreMaxMovementLeft = null;
    if (isMovementCheck) {
      if (isGround && collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      } else if (!isGround && collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
      }
    }
    if (!hit.myInsideCollision) {
      movementDirection = movementOrForward.vec3_normalize(movementDirection);
      let surfaceAngle = hit.myNormal.vec3_angle(up);
      if (!isGround) {
        surfaceAngle = 180 - surfaceAngle;
      }
      if (isGround && collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(hit.myNormal, movementDirection, up, true);
          surfaceAngle = Math.abs(perceivedAngle);
        }
      } else if (!isGround && collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(hit.myNormal, movementDirection, up, false);
          surfaceAngle = Math.abs(perceivedAngle);
        }
      }
      if (isGround && (collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) || !isGround && (collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4)) {
        if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
          let surfaceHeightCheckOk = true;
          let maxMovementLeftCheckOk = true;
          if (surfaceIgnoreHeight != null) {
            surfaceHeightCheckOk = false;
            let feetPositionUp = feetPosition.vec3_valueAlongAxis(up);
            let hitUp = hit.myPosition.vec3_valueAlongAxis(up);
            let hitHeight = hitUp - feetPositionUp;
            if (isGround && hitHeight <= surfaceIgnoreHeight || !isGround && hitHeight >= surfaceIgnoreHeight) {
              surfaceHeightCheckOk = true;
            } else {
            }
          }
          if (surfaceHeightCheckOk && isMovementCheck) {
            if (surfaceIgnoreMaxMovementLeft != null) {
              let movementLength = movementOrForward.vec3_length();
              if (movementLength > surfaceIgnoreMaxMovementLeft) {
                maxMovementLeftCheckOk = false;
                let hitPosition = hit.myPosition;
                let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
                hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
                if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
                } else {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
                }
                hitMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, hitMovement);
                let hitMovementLength = hitMovement.vec3_length();
                let movementLeft = movementLength - hitMovementLength;
                if (movementLeft <= surfaceIgnoreMaxMovementLeft) {
                  maxMovementLeftCheckOk = true;
                } else {
                }
              }
            }
          }
          if (surfaceHeightCheckOk && maxMovementLeftCheckOk) {
            isIgnorable = true;
          }
        }
      }
    } else if (ignoreHitsInsideCollisionIfObjectToIgnore) {
      if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
        isIgnorable = true;
      }
    }
    if (isIgnorable) {
      if (outIgnoredObjects != null) {
        outIgnoredObjects.pp_pushUnique(hit.myObject, objectsEqualCallback);
      }
    }
    return isIgnorable;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_position.js
var CollisionCheckHorizontalPosition = class extends CollisionCheckHorizontalBase {
  _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckHorizontalPosition.prototype._horizontalPositionCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  let heightOffset = vec3_create();
  let heightStep = vec3_create();
  let currentHeightOffset = vec3_create();
  let hitHeightOffset = vec3_create();
  let hitHeightOffsetEpsilon = vec3_create();
  let downwardHeightOffset = vec3_create();
  let downwardHeightStep = vec3_create();
  let verticalDirection = vec3_create();
  let vertilCheckHit = new RaycastHit();
  return function _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalPositionEnabled;
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 180);
    let sliceAngle = halfConeAngle / collisionCheckParams.myHalfConeSliceAmount;
    let tempCheckPosition = _localGetCachedCheckPosition();
    checkPositions.push(feetPosition.vec3_add(forward.vec3_scale(collisionCheckParams.myRadius, tempCheckPosition), tempCheckPosition));
    for (let i = 1; i <= collisionCheckParams.myHalfConeSliceAmount; i++) {
      let currentAngle = i * sliceAngle;
      tempCheckPosition = _localGetCachedCheckPosition();
      let radialDirection = forward.vec3_rotateAxis(-currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
      tempCheckPosition = _localGetCachedCheckPosition();
      radialDirection = forward.vec3_rotateAxis(currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundObjectsToIgnore, true, false, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundCeilingObjectsToIgnore, false, false, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, ceilingObjectsToIgnore, false, false, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, ceilingObjectsToIgnore, null, false, false, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountPosition > 0 && height > 0) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountPosition;
        up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopPosition || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i != 0 && i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, currentHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalPosition) {
            let hitHeightOffsetEpsilonValue = 1e-4;
            if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 0 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
              verticalDirection.vec3_copy(up);
              this._horizontalPositionVerticalCheck(feetPosition, checkPositions, currentHeightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 1 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
                verticalDirection = up.vec3_negate(verticalDirection);
                downwardHeightOffset = currentHeightOffset.vec3_sub(heightStep, downwardHeightOffset);
                downwardHeightStep = heightStep.vec3_negate(downwardHeightStep);
                this._horizontalPositionVerticalCheck(feetPosition, checkPositions, downwardHeightOffset, downwardHeightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              }
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheckHorizontalPosition.prototype._horizontalPositionHorizontalCheck = function() {
  let basePosition = vec3_create();
  let forwardNegate = vec3_create();
  let currentRadialPosition = vec3_create();
  let previousRadialPosition = vec3_create();
  return function _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    let halfRadialPositions = Math.floor(checkPositions.length / 2) + 1;
    for (let j = 0; j < halfRadialPositions; j++) {
      if (j > 0) {
        let leftIndex = Math.max(0, j * 2);
        let rightIndex = Math.max(0, j * 2 - 1);
        let leftAndRightEqual = checkPositions[leftIndex].vec_equals(checkPositions[rightIndex], 1e-6);
        if (collisionCheckParams.myCheckConeBorder) {
          for (let r = 0; r < 2; r++) {
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            let previousIndex = Math.max(0, currentIndex - 2);
            previousRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, currentRadialPosition, forward.vec3_negate(forwardNegate), up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myCheckConeRay && isHorizontalCheckOk) {
          for (let r = 0; r < 2; r++) {
            if (r == 1 && leftAndRightEqual) {
              break;
            }
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(basePosition, currentRadialPosition, null, up, false, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, false, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
      } else {
        if (collisionCheckParams.myCheckConeRay) {
          currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(basePosition, currentRadialPosition, null, up, false, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, false, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        break;
      }
    }
    if (!isHorizontalCheckOk) {
      collisionRuntimeParams.myIsCollidingHorizontally = true;
      collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheckHorizontalPosition.prototype._horizontalPositionVerticalCheck = function() {
  let basePosition = vec3_create();
  let previousBasePosition = vec3_create();
  let currentRadialPosition = vec3_create();
  let previousRadialPosition = vec3_create();
  let previousCurrentRadialPosition = vec3_create();
  let previousPreviousRadialPosition = vec3_create();
  return function _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    previousBasePosition = basePosition.vec3_sub(heightStep, previousBasePosition);
    for (let j = 0; j <= checkPositions.length; j++) {
      let previousCheckPositionIsEqual = false;
      if (j == checkPositions.length) {
        currentRadialPosition.vec3_copy(basePosition);
        previousRadialPosition.vec3_copy(previousBasePosition);
      } else {
        currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
        previousRadialPosition = currentRadialPosition.vec3_sub(heightStep, previousRadialPosition);
        if (j > 0) {
          previousCheckPositionIsEqual = checkPositions[j].vec_equals(checkPositions[j - 1], 1e-6);
        }
      }
      if (collisionCheckParams.myCheckVerticalStraight && !previousCheckPositionIsEqual) {
        isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, currentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
        if (!isHorizontalCheckOk) {
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            collisionRuntimeParams.myIsCollidingHorizontally = true;
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          }
          if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
            break;
          }
        }
      }
      if (j < checkPositions.length) {
        if ((collisionCheckParams.myCheckVerticalDiagonalRayOutward || collisionCheckParams.myCheckVerticalDiagonalBorderRayOutward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(previousBasePosition, currentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if ((collisionCheckParams.myCheckVerticalDiagonalRayInward || collisionCheckParams.myCheckVerticalDiagonalBorderRayInward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, basePosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if (j > 0) {
          if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward || collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
            let previousIndex = Math.max(0, j - 2);
            previousCurrentRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousCurrentRadialPosition);
            previousPreviousRadialPosition = previousCurrentRadialPosition.vec3_sub(heightStep, previousPreviousRadialPosition);
            if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(previousPreviousRadialPosition, currentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
            if (collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, previousCurrentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_movement.js
var CollisionCheckHorizontalMovement = class extends CollisionCheckHorizontalPosition {
  _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckHorizontalMovement.prototype._horizontalMovementCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  let movementDirection = vec3_create();
  let heightOffset = vec3_create();
  let heightStep = vec3_create();
  let currentHeightOffset = vec3_create();
  let leftRadialDirection = vec3_create();
  let rightRadialDirection = vec3_create();
  return function _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalMovementEnabled;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    movementDirection = movement.vec3_normalize(movementDirection);
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let steplength = collisionCheckParams.myRadius / collisionCheckParams.myHorizontalMovementRadialStepAmount;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    {
      leftRadialDirection = movementDirection.vec3_rotateAxis(halfConeAngle, up, leftRadialDirection);
      rightRadialDirection = movementDirection.vec3_rotateAxis(-halfConeAngle, up, rightRadialDirection);
      for (let i = 1; i <= collisionCheckParams.myHorizontalMovementRadialStepAmount; i++) {
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = leftRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = rightRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
      }
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundObjectsToIgnore, true, true, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundCeilingObjectsToIgnore, false, true, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, ceilingObjectsToIgnore, false, true, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, ceilingObjectsToIgnore, null, false, true, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountMovement > 0 && height > 1e-6) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountMovement;
        heightStep = up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopMovement || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, currentHeightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalMovement) {
            this._horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, currentHeightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionRuntimeParams.myIsCollidingHorizontally) {
            break;
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheckHorizontalMovement.prototype._horizontalMovementVerticalCheck = function() {
  let movementStep = vec3_create();
  let movementDirection = vec3_create();
  let firstPosition = vec3_create();
  let secondPosition = vec3_create();
  let firstMovementPosition = vec3_create();
  let secondMovementPosition = vec3_create();
  let firstHeightPosition = vec3_create();
  let secondHeightPosition = vec3_create();
  let firstHeightMovementPosition = vec3_create();
  let secondHeightMovementPosition = vec3_create();
  return function _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondHeightPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition, secondMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward) {
            firstHeightMovementPosition = firstPosition.vec3_add(movementStep, firstHeightMovementPosition);
            firstHeightMovementPosition = firstHeightMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondPosition, firstHeightMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward) {
            secondHeightMovementPosition = secondPosition.vec3_add(movementStep, secondHeightMovementPosition);
            secondHeightMovementPosition = secondHeightMovementPosition.vec3_sub(heightStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, secondHeightMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (m == 0) {
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
              secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(secondHeightPosition, firstPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
              let firstHeightPosition2 = firstPosition.vec3_sub(heightStep);
              isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition2, secondPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightMovementPosition = secondPosition.vec3_sub(heightStep, secondHeightMovementPosition).vec3_add(movementStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondHeightMovementPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightMovementPosition, secondMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraight || collisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled && j == 0) {
          if (m == 0) {
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition, firstPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            firstHeightMovementPosition = firstMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightMovementPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled && j == 0) {
          firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, firstHeightMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
        if (!isHorizontalCheckOk) {
          collisionRuntimeParams.myIsCollidingHorizontally = true;
          collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          break;
        }
      }
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheckHorizontalMovement.prototype._horizontalMovementHorizontalCheck = function() {
  let movementStep = vec3_create();
  let movementDirection = vec3_create();
  let firstPosition = vec3_create();
  let secondPosition = vec3_create();
  let firstMovementPosition = vec3_create();
  let secondMovementPosition = vec3_create();
  return function _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, secondMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckHorizontalBorder) {
            if (m == 0) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(secondPosition, firstPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
            {
              firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
              secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(secondMovementPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckStraight || collisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, firstMovementPosition, null, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        collisionRuntimeParams.myIsCollidingHorizontally = true;
        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
        break;
      }
    }
    return isHorizontalCheckOk;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_sliding.js
var CollisionCheckHorizontalSliding = class extends CollisionCheckHorizontalMovement {
  _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
  }
  _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
  }
  _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
  }
  _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
  }
  _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
  _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
  }
};
CollisionCheckHorizontalSliding.prototype._horizontalSlide = function() {
  let previousHorizontalMovement = vec3_create();
  return function _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    this._mySlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    outSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, outSlideMovement);
    if (collisionCheckParams.mySlidingCheckBothDirections) {
      this._horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, this._myPrevCollisionRuntimeParams.myIsSliding, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement);
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding && collisionCheckParams.mySlidingFlickeringPreventionType > 0) {
      let isFlickering = this._horizontalSlideFlickerCheck(movement, outSlideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams);
      this._mySlidingCollisionRuntimeParams.myIsSliding = !isFlickering;
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding) {
      let backupFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
      collisionRuntimeParams.copy(this._mySlidingCollisionRuntimeParams);
      collisionRuntimeParams.myIsSlidingFlickerPrevented = backupFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    } else {
      collisionRuntimeParams.myIsSlidingFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
      outSlideMovement.vec3_zero();
    }
    return outSlideMovement;
  };
}();
CollisionCheckHorizontalSliding.prototype._horizontalSlideCheckOpposite = function() {
  let horizontalCollisionNormal = vec3_create();
  let oppositeSlideMovement = vec3_create();
  return function _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    horizontalCollisionNormal = preSlideCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, horizontalCollisionNormal);
    horizontalCollisionNormal.vec3_normalize(horizontalCollisionNormal);
    let angleNormalWithMovementThreshold = 20;
    if (horizontalCollisionNormal.vec3_angle(movement) > 180 - angleNormalWithMovementThreshold) {
      return;
    } else if (previousIsSliding && postSlideCollisionRuntimeParams.myIsSliding && outSlideMovement.vec3_isConcordant(previousHorizontalMovement)) {
      return;
    } else {
    }
    this._mySlidingOppositeDirectionCollisionRuntimeParams.copy(preSlideCollisionRuntimeParams);
    oppositeSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingOppositeDirectionCollisionRuntimeParams, previousCollisionRuntimeParams, true, oppositeSlideMovement);
    if (this._mySlidingOppositeDirectionCollisionRuntimeParams.myIsSliding) {
      let isOppositeBetter = false;
      if (postSlideCollisionRuntimeParams.myIsSliding) {
        if (movement.vec3_angle(oppositeSlideMovement) < movement.vec3_angle(outSlideMovement) - 1e-4) {
          isOppositeBetter = true;
        } else {
          if (Math.abs(movement.vec3_angle(oppositeSlideMovement) - movement.vec3_angle(outSlideMovement)) <= 1e-4) {
            if (previousHorizontalMovement.vec3_angle(oppositeSlideMovement) < previousHorizontalMovement.vec3_angle(outSlideMovement) - 1e-4) {
              let angleNormalWithMovementThreshold2 = 5;
              if (horizontalCollisionNormal.vec3_angle(movement) < 90 + angleNormalWithMovementThreshold2) {
                isOppositeBetter = true;
              }
            }
          }
        }
      } else {
        let angleEpsilon = 1e-3;
        if (movement.vec3_isConcordant(oppositeSlideMovement) && movement.vec3_angle(oppositeSlideMovement) < 90 - angleEpsilon) {
          isOppositeBetter = true;
        } else {
        }
      }
      if (isOppositeBetter) {
        outSlideMovement.vec3_copy(oppositeSlideMovement);
        postSlideCollisionRuntimeParams.copy(this._mySlidingOppositeDirectionCollisionRuntimeParams);
      } else {
      }
    } else {
    }
  };
}();
CollisionCheckHorizontalSliding.prototype._horizontalSlideFlickerCheck = function() {
  let previousHorizontalMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let fixedMovement = vec3_create();
  let flickerFixSlideMovement = vec3_create();
  return function _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isFlickering = false;
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    let shouldCheckFlicker = this._myPrevCollisionRuntimeParams.myIsSlidingFlickerPrevented || previousHorizontalMovement.vec3_isZero(1e-5);
    if (!shouldCheckFlicker) {
      if (this._myPrevCollisionRuntimeParams.myIsSliding || !collisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding) {
        let flickerCollisionAngle = 90;
        let flickerMovementAngle = 85;
        switch (collisionCheckParams.mySlidingFlickeringPreventionType) {
          case 1:
            shouldCheckFlicker = previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0);
            break;
          case 2:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            break;
          case 3:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) - flickerCollisionAngle) < 1e-5 && Math.abs(collisionRuntimeParams.mySlidingMovementAngle) > flickerMovementAngle + 1e-5;
            break;
          case 4:
            shouldCheckFlicker = true;
            break;
        }
      }
    }
    if (shouldCheckFlicker || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) {
      if (shouldCheckFlicker) {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = collisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter;
      } else {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = Math.max(0, this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter - 1);
      }
      if ((collisionCheckParams.mySlidingFlickeringPreventionType != 1 || collisionRuntimeParams.myIsSlidingFlickerPrevented || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) && (this._myPrevCollisionRuntimeParams.myIsSliding && previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0))) {
        isFlickering = true;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
      } else {
        this._mySlidingFlickeringFixCollisionRuntimeParams.reset();
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySliding90DegreesSign = collisionRuntimeParams.mySliding90DegreesSign;
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
        newFeetPosition = feetPosition.vec3_add(slideMovement, newFeetPosition);
        let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
        collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(movement, newFeetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, previousCollisionRuntimeParams, false, fixedMovement);
        collisionCheckParams.myDebugEnabled = backupDebugEnabled;
        if (fixedMovement.vec3_isZero(1e-5)) {
          this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.copy(this._mySlidingFlickeringFixCollisionRuntimeParams);
          flickerFixSlideMovement = this._internalHorizontalSlide(movement, newFeetPosition, height, up, forward, slideMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, flickerFixSlideMovement);
          if (collisionCheckParams.mySlidingCheckBothDirections) {
            this._horizontalSlideCheckOpposite(movement, newFeetPosition, height, up, forward, slideMovement, true, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, flickerFixSlideMovement);
          }
          if (this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.myIsSliding) {
            if (slideMovement.vec3_signTo(movement, up, 0) != flickerFixSlideMovement.vec3_signTo(movement, up, 0)) {
              isFlickering = true;
              collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
            }
          }
        }
      }
    } else {
    }
    if (isFlickering) {
    } else {
    }
    return isFlickering;
  };
}();
CollisionCheckHorizontalSliding.prototype._internalHorizontalSlide = function() {
  let invertedNormal = vec3_create();
  let slidingMovement = vec3_create();
  let movement90 = vec3_create();
  let currentMovement = vec3_create();
  let slideMovementForward = vec3_create();
  let fixedMovement = vec3_create();
  return function _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    invertedNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_negate(invertedNormal);
    invertedNormal.vec3_removeComponentAlongAxis(up, invertedNormal);
    invertedNormal[0] = Math.abs(invertedNormal[0]) < 0.01 ? 0 : invertedNormal[0];
    invertedNormal[2] = Math.abs(invertedNormal[2]) < 0.01 ? 0 : invertedNormal[2];
    invertedNormal.vec3_normalize(invertedNormal);
    collisionRuntimeParams.mySlidingCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    collisionRuntimeParams.mySlidingWallNormal.vec3_copy(collisionRuntimeParams.myHorizontalCollisionHit.myNormal);
    outSlideMovement.vec3_zero();
    slidingMovement.vec3_copy(invertedNormal);
    if (checkOppositeDirection) {
      slidingMovement.vec3_copy(movement);
      slidingMovement.vec3_normalize(slidingMovement);
    }
    if (!slidingMovement.vec3_isZero(1e-5)) {
      slidingMovement.vec3_scale(movement.vec3_length(), slidingMovement);
      let slidingSign = invertedNormal.vec3_signTo(movement, up);
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        let angleThreshold = 0.1;
        if (invertedNormal.vec3_angle(movement) < angleThreshold && collisionRuntimeParams.mySliding90DegreesSign != 0) {
          slidingSign = collisionRuntimeParams.mySliding90DegreesSign;
        } else if (collisionRuntimeParams.mySliding90DegreesSign == 0 || collisionRuntimeParams.mySlidingRecompute90DegreesSign) {
          collisionRuntimeParams.mySliding90DegreesSign = slidingSign;
        } else {
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
      }
      if (checkOppositeDirection) {
        slidingSign *= -1;
      }
      let currentAngle = 90 * slidingSign;
      let maxAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement.vec3_rotateAxis(90 * slidingSign, up, movement90), up) * slidingSign, true) * slidingSign;
      let minAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement, up) * slidingSign, true) * slidingSign;
      if (checkOppositeDirection) {
        maxAngle = currentAngle;
        minAngle = 0;
      } else {
        if (Math.abs(maxAngle) < Math.abs(minAngle)) {
          minAngle = 0;
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          minAngle = maxAngle;
        }
        if (Math.abs(maxAngle) < Math.abs(currentAngle) || Math.abs(Math.abs(maxAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = maxAngle;
        }
        if (Math.abs(currentAngle) < Math.abs(minAngle) || Math.abs(Math.abs(minAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = minAngle;
        }
      }
      if (checkOppositeDirection && !previousHorizontalMovement.vec3_isZero(1e-6)) {
        let angleWithPrevious = movement.vec3_angleSigned(previousHorizontalMovement, up);
        if (Math.pp_sign(angleWithPrevious) == Math.pp_sign(maxAngle) && Math.abs(maxAngle) > Math.abs(angleWithPrevious)) {
          currentAngle = angleWithPrevious;
        }
      }
      currentMovement.vec3_zero();
      let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
      collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
      for (let i = 0; i < collisionCheckParams.mySlidingMaxAttempts; i++) {
        this._myInternalSlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
        currentMovement = slidingMovement.vec3_rotateAxis(currentAngle, up, currentMovement);
        slideMovementForward.vec3_copy(forward);
        if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
          if (!currentMovement.vec3_isZero()) {
            slideMovementForward = currentMovement.vec3_normalize(slideMovementForward);
          }
        }
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(currentMovement, feetPosition, height, up, slideMovementForward, allowSurfaceSteepFix, collisionCheckParams, this._myInternalSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, true, fixedMovement);
        if (!fixedMovement.vec3_isZero(1e-5)) {
          outSlideMovement.vec3_copy(currentMovement);
          collisionRuntimeParams.copy(this._myInternalSlidingCollisionRuntimeParams);
          collisionRuntimeParams.myIsSliding = true;
          collisionRuntimeParams.myIsSlidingIntoOppositeDirection = checkOppositeDirection;
          collisionRuntimeParams.mySlidingMovementAngle = movement.vec3_angleSigned(currentMovement, up);
          collisionRuntimeParams.mySlidingCollisionAngle = invertedNormal.vec3_angleSigned(currentMovement, up);
          maxAngle = currentAngle;
          currentAngle = (maxAngle + minAngle) / 2;
        } else {
          if (currentAngle != maxAngle) {
            minAngle = currentAngle;
          }
          if (i == 0 && currentAngle != maxAngle) {
            currentAngle = maxAngle;
          } else {
            currentAngle = (minAngle + maxAngle) / 2;
          }
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          break;
        }
      }
      collisionCheckParams.myDebugEnabled = backupDebugEnabled;
    }
    if (!collisionRuntimeParams.myIsSliding) {
      collisionRuntimeParams.mySlidingCollisionHit.reset();
    } else {
    }
    return outSlideMovement;
  };
}();
CollisionCheckHorizontalSliding.prototype._horizontalCheckBetterSlideNormal = function() {
  let movementDirection = vec3_create();
  let hitDirection = vec3_create();
  let projectAlongAxis = vec3_create();
  let fixedMovement = vec3_create();
  let newFixedFeetPosition = vec3_create();
  let newFeetPosition = vec3_create();
  return function _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    movementDirection = movement.vec3_normalize(movementDirection);
    let hitPosition = collisionRuntimeParams.myHorizontalCollisionHit.myPosition;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
    if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
      projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
    } else {
      projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
    }
    fixedMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, fixedMovement);
    if (fixedMovement.vec3_isConcordant(movementDirection)) {
      fixedMovement = movementDirection.vec3_scale(Math.min(fixedMovement.vec3_length(), movement.vec3_length()), fixedMovement);
    } else {
      fixedMovement.vec3_zero();
    }
    if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalMovementEnabled && Globals.isDebugEnabled(this._myEngine)) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPosition, movementDirection, fixedMovement.vec3_length(), vec4_create(1, 0, 1, 1));
    }
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.copy(collisionRuntimeParams);
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally = false;
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.reset();
    newFixedFeetPosition = feetPosition.vec3_add(fixedMovement, newFixedFeetPosition);
    newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
    let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
    collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
    if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
      this._horizontalPositionCheck(originalFeetPosition, originalHeight, newFixedFeetPosition, height, up, forward, collisionCheckParams, this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
    collisionCheckParams.myDebugEnabled = backupDebugEnabled;
    if (this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally && !this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.myInsideCollision) {
      collisionRuntimeParams.copy(this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
  };
}();
CollisionCheckHorizontalSliding.prototype._isSlidingNormalValid = function() {
  let flatNormal = vec3_create();
  return function _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
    let isValid = false;
    flatNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatNormal);
    flatNormal.vec3_normalize(flatNormal);
    if (!flatNormal.vec3_isZero(1e-6)) {
      isValid = true;
    }
    return isValid;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal.js
var CollisionCheckHorizontal = class extends CollisionCheckHorizontalSliding {
  _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
  }
};
CollisionCheckHorizontal.prototype._horizontalCheck = function() {
  let fixedFeetPosition = vec3_create();
  let newFixedFeetPosition = vec3_create();
  let newFeetPosition = vec3_create();
  let horizontalDirection = vec3_create();
  return function _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingHorizontally = false;
    collisionRuntimeParams.myHorizontalCollisionHit.reset();
    outFixedMovement.vec3_zero();
    horizontalDirection = movement.vec3_normalize(horizontalDirection);
    let surfaceTooSteepResults = this._surfaceTooSteep(up, horizontalDirection, collisionCheckParams, previousCollisionRuntimeParams);
    if (movement.vec3_isZero(1e-6) || (!surfaceTooSteepResults[0] || allowSurfaceSteepFix && collisionCheckParams.myAllowGroundSteepFix) && (!surfaceTooSteepResults[1] || allowSurfaceSteepFix && collisionCheckParams.myAllowCeilingSteepFix)) {
      fixedFeetPosition = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-4, fixedFeetPosition), fixedFeetPosition);
      let fixedHeight = Math.max(0, height - collisionCheckParams.myDistanceFromFeetToIgnore - collisionCheckParams.myDistanceFromHeadToIgnore - 1e-4 * 2);
      let canMove = true;
      if (collisionCheckParams.myHorizontalMovementCheckEnabled && !movement.vec3_isZero(1e-6)) {
        canMove = this._horizontalMovementCheck(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, collisionCheckParams, collisionRuntimeParams);
      }
      if (canMove) {
        if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
          newFixedFeetPosition = fixedFeetPosition.vec3_add(movement, newFixedFeetPosition);
          newFeetPosition = feetPosition.vec3_add(movement, newFeetPosition);
          let canStay = this._horizontalPositionCheck(newFeetPosition, height, newFixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
          if (canStay) {
            outFixedMovement.vec3_copy(movement);
          }
          if (outFixedMovement.vec3_isZero(1e-6)) {
            outFixedMovement.vec3_zero();
          }
        } else {
          outFixedMovement.vec3_copy(movement);
        }
      } else if (!avoidSlidingExtraCheck && collisionCheckParams.mySlidingEnabled && collisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal) {
        this._horizontalCheckBetterSlideNormal(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_vertical.js
var CollisionCheckVertical = class extends CollisionCheckHorizontal {
  _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
  }
  _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
  }
  _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
  _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckVertical.prototype._verticalCheck = function() {
  let newFeetPosition = vec3_create();
  let additionalFixedMovement = vec3_create();
  let zero4 = vec3_create(0, 0, 0);
  return function _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingVertically = false;
    collisionRuntimeParams.myVerticalCollisionHit.reset();
    let movementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(up), -1);
    let isMovementDownward = movementSign < 0;
    outFixedMovement.vec3_copy(verticalMovement);
    if (collisionCheckParams.myVerticalMovementCheckEnabled) {
      outFixedMovement = this._verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
      if (!collisionRuntimeParams.myIsCollidingVertically && collisionCheckParams.myCheckVerticalBothDirection && (outFixedMovement.vec_equals(verticalMovement, 1e-5) || originalMovementSign == 0 || movementSign != originalMovementSign)) {
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        let isOppositeMovementDownward = !isMovementDownward;
        additionalFixedMovement = this._verticalMovementAdjustment(zero4, isOppositeMovementDownward, originalMovementSign, newFeetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, additionalFixedMovement);
        outFixedMovement.vec3_add(additionalFixedMovement, outFixedMovement);
        isMovementDownward = !isMovementDownward;
      }
    }
    if (!collisionRuntimeParams.myIsCollidingVertically && collisionCheckParams.myVerticalPositionCheckEnabled) {
      newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
      let canStay = this._verticalPositionCheck(newFeetPosition, isMovementDownward, height, up, forward, collisionCheckParams, collisionRuntimeParams);
      if (!canStay) {
        outFixedMovement.vec3_zero();
        collisionRuntimeParams.myHasSnappedOnGround = false;
        collisionRuntimeParams.myHasSnappedOnCeiling = false;
        collisionRuntimeParams.myHasPoppedOutGround = false;
        collisionRuntimeParams.myHasPoppedOutCeiling = false;
        collisionRuntimeParams.myHasReducedVerticalMovement = false;
      }
    } else if (collisionRuntimeParams.myIsCollidingVertically) {
      outFixedMovement.vec3_zero();
    }
    return outFixedMovement;
  };
}();
CollisionCheckVertical.prototype._verticalMovementAdjustment = function() {
  let startOffset = vec3_create();
  let endOffset = vec3_create();
  let tempVector = vec3_create();
  let furtherDirection = vec3_create();
  let furtherDirectionPosition = vec3_create();
  let upNegate = vec3_create();
  let origin = vec3_create();
  let direction = vec3_create();
  let verticalCollisionHit = new RaycastHit();
  return function _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugVerticalMovementEnabled;
    startOffset.vec3_zero();
    endOffset.vec3_zero();
    let popOutEnabled = false;
    let snapEnabled = false;
    if (isMovementDownward) {
      startOffset.vec3_zero();
      endOffset.vec3_copy(verticalMovement);
      if (collisionCheckParams.myGroundPopOutExtraDistance > 0 && collisionCheckParams.myGroundPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(collisionCheckParams.myGroundPopOutExtraDistance + 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    } else {
      startOffset = up.vec3_scale(height, startOffset);
      endOffset = up.vec3_scale(height, endOffset).vec3_add(verticalMovement, endOffset);
      if (collisionCheckParams.myCeilingPopOutExtraDistance > 0 && collisionCheckParams.myCeilingPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(-collisionCheckParams.myCeilingPopOutExtraDistance - 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    }
    if (isMovementDownward && originalMovementSign <= 0 && this._myPrevCollisionRuntimeParams.myIsOnGround && collisionCheckParams.mySnapOnGroundEnabled && collisionCheckParams.mySnapOnGroundExtraDistance > 0) {
      endOffset.vec3_add(up.vec3_scale(-collisionCheckParams.mySnapOnGroundExtraDistance - 1e-5, tempVector), endOffset);
      snapEnabled = true;
    } else if (!isMovementDownward && this._myPrevCollisionRuntimeParams.myIsOnCeiling && collisionCheckParams.mySnapOnCeilingEnabled && collisionCheckParams.mySnapOnCeilingExtraDistance > 0 && (originalMovementSign > 0 || originalMovementSign == 0 && (!this._myPrevCollisionRuntimeParams.myIsOnGround || !collisionCheckParams.mySnapOnGroundEnabled))) {
      endOffset.vec3_add(up.vec3_scale(collisionCheckParams.mySnapOnCeilingExtraDistance + 1e-5, tempVector), endOffset);
      snapEnabled = true;
    }
    outFixedMovement.vec3_zero();
    if (startOffset.vec3_distance(endOffset) > 1e-5) {
      let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
      furtherDirection.vec3_copy(up);
      if (!isMovementDownward) {
        furtherDirection.vec3_negate(furtherDirection);
      }
      let furtherDirectionPositionSet = false;
      for (let i = 0; i < checkPositions.length; i++) {
        let currentPosition = checkPositions[i];
        origin = currentPosition.vec3_add(startOffset, origin);
        direction = currentPosition.vec3_add(endOffset, direction).vec3_sub(origin, direction);
        let distance2 = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult = this._raycastAndDebug(origin, direction, distance2, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.myHits.length > 0) {
          if (furtherDirectionPositionSet) {
            if (raycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(furtherDirectionPosition, furtherDirection)) {
              furtherDirectionPosition.vec3_copy(raycastResult.myHits[0].myPosition);
              verticalCollisionHit.copy(raycastResult.myHits[0]);
            }
          } else {
            furtherDirectionPositionSet = true;
            furtherDirectionPosition.vec3_copy(raycastResult.myHits[0].myPosition);
            verticalCollisionHit.copy(raycastResult.myHits[0]);
          }
        }
      }
      if (furtherDirectionPositionSet) {
        upNegate = up.vec3_negate(upNegate);
        if (isMovementDownward) {
          outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition, outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
          if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
            collisionRuntimeParams.myHasSnappedOnGround = true;
          } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
            if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
              collisionRuntimeParams.myHasPoppedOutGround = true;
            } else {
              collisionRuntimeParams.myHasReducedVerticalMovement = true;
            }
          } else {
            collisionRuntimeParams.myHasReducedVerticalMovement = true;
          }
        } else {
          outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition.vec3_add(up.vec3_scale(height, outFixedMovement), outFixedMovement), outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
          if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
            collisionRuntimeParams.myHasSnappedOnCeiling = true;
          } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
            if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
              collisionRuntimeParams.myHasPoppedOutCeiling = true;
            } else {
              collisionRuntimeParams.myHasReducedVerticalMovement = true;
            }
          } else {
            collisionRuntimeParams.myHasReducedVerticalMovement = true;
          }
        }
        if (!popOutEnabled && !outFixedMovement.vec3_isConcordant(verticalMovement)) {
          outFixedMovement.vec3_zero();
        }
        if (!collisionCheckParams.myVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
          outFixedMovement.vec3_zero();
          collisionRuntimeParams.myHasSnappedOnGround = false;
          collisionRuntimeParams.myHasSnappedOnCeiling = false;
          collisionRuntimeParams.myHasPoppedOutGround = false;
          collisionRuntimeParams.myHasPoppedOutCeiling = false;
          collisionRuntimeParams.myHasReducedVerticalMovement = false;
          collisionRuntimeParams.myIsCollidingVertically = true;
          collisionRuntimeParams.myVerticalCollisionHit.copy(verticalCollisionHit);
        }
      } else {
        outFixedMovement.vec3_copy(verticalMovement);
      }
    } else {
      outFixedMovement.vec3_copy(verticalMovement);
    }
    if (outFixedMovement.vec3_length() < 1e-5) {
      outFixedMovement.vec3_zero();
    }
    return outFixedMovement;
  };
}();
CollisionCheckVertical.prototype._verticalPositionCheck = function() {
  let smallHeightFixOffset = vec3_create();
  let heightOffset = vec3_create();
  let startPosition = vec3_create();
  let endPosition = vec3_create();
  let direction = vec3_create();
  return function _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    if (height < 1e-5) {
      return true;
    }
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugVerticalPositionEnabled;
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
    let isVerticalPositionOk = true;
    let atLeastOneIsOk = false;
    let adjustmentEpsilon = 1e-4;
    smallHeightFixOffset = up.vec3_scale(adjustmentEpsilon, smallHeightFixOffset);
    heightOffset = up.vec3_scale(height - adjustmentEpsilon, heightOffset);
    if (height - adjustmentEpsilon < adjustmentEpsilon * 10) {
      heightOffset = up.vec3_scale(adjustmentEpsilon * 10, heightOffset);
    }
    let insideHitSet = false;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      if (checkUpward) {
        startPosition = currentPosition.vec3_add(smallHeightFixOffset, startPosition);
        endPosition = currentPosition.vec3_add(heightOffset, endPosition);
      } else {
        startPosition = currentPosition.vec3_add(heightOffset, startPosition);
        endPosition = currentPosition.vec3_add(smallHeightFixOffset, endPosition);
      }
      let origin = startPosition;
      direction = endPosition.vec3_sub(origin, direction);
      let distance2 = direction.vec3_length();
      direction.vec3_normalize(direction);
      let raycastResult = this._raycastAndDebug(origin, direction, distance2, false, false, collisionCheckParams, collisionRuntimeParams);
      if (raycastResult.isColliding()) {
        let firstHitOutsideCollision = raycastResult.getFirstHitOutsideCollision();
        if (firstHitOutsideCollision != null) {
          isVerticalPositionOk = false;
          collisionRuntimeParams.myVerticalCollisionHit.copy(firstHitOutsideCollision);
          break;
        } else if (!insideHitSet) {
          insideHitSet = true;
          collisionRuntimeParams.myVerticalCollisionHit.copy(raycastResult.myHits[0]);
          if (!collisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk) {
            isVerticalPositionOk = false;
            break;
          }
        }
      } else {
        atLeastOneIsOk = true;
      }
    }
    collisionRuntimeParams.myIsCollidingVertically = !isVerticalPositionOk || !atLeastOneIsOk;
    return !collisionRuntimeParams.myIsCollidingVertically;
  };
}();
CollisionCheckVertical.prototype._getVerticalCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create();
  return function _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    if (collisionCheckParams.myGroundCircumferenceAddCenter) {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = collisionCheckParams.myFeetRadius / collisionCheckParams.myGroundCircumferenceStepAmount;
    let sliceAngle = 360 / collisionCheckParams.myGroundCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < collisionCheckParams.myGroundCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = forward.vec3_rotateAxis(currentStepRotation, up, currentDirection);
      for (let j = 0; j < collisionCheckParams.myGroundCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, up, tempCheckPosition);
        checkPositions.push(feetPosition.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += collisionCheckParams.myGroundCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_move.js
var CollisionCheckMove = class extends CollisionCheckVertical {
  move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForMoveCollisionCheckDisabled(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  _move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
  }
  _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
  }
};
CollisionCheckMove.prototype._move = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let movementStep = vec3_create();
  let currentMovementStep = vec3_create();
  let movementChecked = vec3_create();
  let fixedMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let fixedMovementStep = vec3_create();
  let previousCollisionRuntimeParams = new CollisionRuntimeParams();
  let previousFixedMovement = vec3_create();
  let previousMovementChecked = vec3_create();
  return function _move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    if (horizontalMovement.vec3_isZero(1e-6)) {
      horizontalMovement.vec3_zero();
    }
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    if (verticalMovement.vec3_isZero(1e-6)) {
      verticalMovement.vec3_zero();
    }
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (!movement.vec3_isZero(1e-5) && collisionCheckParams.mySplitMovementEnabled) {
      let minLength = collisionCheckParams.mySplitMovementMinLengthEnabled ? collisionCheckParams.mySplitMovementMinLength : null;
      let maxLength = collisionCheckParams.mySplitMovementMaxLengthEnabled && collisionCheckParams.mySplitMovementMaxLength > 0 ? collisionCheckParams.mySplitMovementMaxLength : null;
      let maxSteps = collisionCheckParams.mySplitMovementMaxStepsEnabled && collisionCheckParams.mySplitMovementMaxSteps > 0 ? collisionCheckParams.mySplitMovementMaxSteps : 1;
      let movementLength = movement.vec3_length();
      let equalStepLength = movementLength / maxSteps;
      let stepLength = Math.pp_clamp(equalStepLength, minLength, maxLength);
      if (stepLength != equalStepLength) {
        movementStepAmount = Math.ceil(movementLength / stepLength);
        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(stepLength, movementStep);
        if (collisionCheckParams.mySplitMovementMaxStepsEnabled) {
          movementStepAmount = Math.min(movementStepAmount, maxSteps);
        }
      } else {
        movementStepAmount = maxSteps;
        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
      }
      movementStepAmount = Math.max(1, movementStepAmount);
      if (movementStepAmount == 1) {
        movementStep.vec3_copy(movement);
      }
    }
    fixedMovement.vec3_zero();
    movementChecked.vec3_zero();
    previousCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousFixedMovement.vec3_copy(fixedMovement);
    previousMovementChecked.vec3_copy(movementChecked);
    let stepsPerformed = 0;
    let splitMovementStop = false;
    for (let i = 0; i < movementStepAmount; i++) {
      if (movementStepAmount == 1 || i != movementStepAmount - 1) {
        currentMovementStep.vec3_copy(movementStep);
      } else {
        currentMovementStep = movement.vec3_sub(movementChecked, currentMovementStep);
      }
      newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
      fixedMovementStep.vec3_zero();
      fixedMovementStep = this._moveStep(currentMovementStep, newFeetPosition, transformUp, transformForward, height, true, collisionCheckParams, collisionRuntimeParams, fixedMovementStep);
      fixedMovement.vec3_add(fixedMovementStep, fixedMovement);
      movementChecked = movementChecked.vec3_add(movementStep, movementChecked);
      stepsPerformed = i + 1;
      if (collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled || collisionRuntimeParams.myHorizontalMovementCanceled && (collisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled || verticalMovement.vec3_isZero() && fixedMovementStep.vec3_isZero()) || collisionRuntimeParams.myVerticalMovementCanceled && (collisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled || horizontalMovement.vec3_isZero() && fixedMovementStep.vec3_isZero()) || collisionCheckParams.mySplitMovementStopCallback != null && collisionCheckParams.mySplitMovementStopCallback(collisionRuntimeParams)) {
        if (collisionCheckParams.mySplitMovementStopReturnPrevious) {
          collisionRuntimeParams.copy(previousCollisionRuntimeParams);
          fixedMovement.vec3_copy(previousFixedMovement);
          movementChecked.vec3_copy(previousMovementChecked);
          stepsPerformed -= 1;
        }
        splitMovementStop = true;
        break;
      }
      previousCollisionRuntimeParams.copy(collisionRuntimeParams);
      previousFixedMovement.vec3_copy(fixedMovement);
      previousMovementChecked.vec3_copy(movementChecked);
    }
    collisionRuntimeParams.mySplitMovementSteps = movementStepAmount;
    collisionRuntimeParams.mySplitMovementStepsPerformed = stepsPerformed;
    collisionRuntimeParams.mySplitMovementStop = splitMovementStop;
    collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movementChecked);
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOffsetUp.vec3_copy(transformUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
    collisionRuntimeParams.myFixedMovement.vec3_copy(fixedMovement);
    collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
    collisionRuntimeParams.myIsMove = true;
  };
}();
CollisionCheckMove.prototype._moveStep = function() {
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let fixedHorizontalMovement = vec3_create();
  let fixedVerticalMovement = vec3_create();
  let horizontalDirection = vec3_create();
  let forwardForHorizontal = vec3_create();
  let forwardForVertical = vec3_create();
  let forwardForPerceivedAngle = vec3_create();
  let newFeetPosition = vec3_create();
  let surfaceAdjustedVerticalMovement = vec3_create();
  let surfaceAdjustedHorizontalMovement = vec3_create();
  let fixedMovement = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    if (horizontalMovement.vec3_isZero(1e-6)) {
      horizontalMovement.vec3_zero();
    }
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    if (verticalMovement.vec3_isZero(1e-6)) {
      verticalMovement.vec3_zero();
    }
    if (horizontalMovement.vec3_isZero()) {
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    surfaceAdjustedHorizontalMovement = this._adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedHorizontalMovement);
    if (surfaceAdjustedHorizontalMovement.vec3_isZero(1e-5)) {
      surfaceAdjustedHorizontalMovement.vec3_zero();
    }
    this._syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
    {
      forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForHorizontal = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForHorizontal);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForHorizontal = horizontalMovement.vec3_normalize(forwardForHorizontal);
        } else {
          forwardForHorizontal.vec3_copy(transformForward);
        }
      } else {
        if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForHorizontal.vec3_copy(xAxis);
          } else {
            forwardForHorizontal.vec3_copy(zAxis);
          }
        }
        forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
        forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
        if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
          forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
        }
      }
      fixedHorizontalMovement.vec3_zero();
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        fixedHorizontalMovement = this._horizontalCheck(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
        if (collisionCheckParams.mySlidingEnabled && collisionRuntimeParams.myIsCollidingHorizontally && this._isSlidingNormalValid(surfaceAdjustedHorizontalMovement, transformUp, collisionRuntimeParams)) {
          fixedHorizontalMovement = this._horizontalSlide(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, fixedHorizontalMovement);
        } else {
        }
      }
      if (fixedHorizontalMovement.vec3_isZero(1e-6)) {
        fixedHorizontalMovement.vec3_zero();
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && fixedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
      }
    }
    {
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (fixedHorizontalMovement.vec3_isZero()) {
          if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
            forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
          } else if (!horizontalMovement.vec3_isZero()) {
            forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
          } else {
            forwardForVertical.vec3_copy(transformForward);
          }
        } else {
          forwardForVertical = fixedHorizontalMovement.vec3_normalize(forwardForVertical);
        }
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      surfaceAdjustedVerticalMovement = this._adjustVerticalMovementWithSurface(fixedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedVerticalMovement);
      newFeetPosition = feetPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      let originalMovementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(transformUp), 0);
      fixedVerticalMovement.vec3_zero();
      fixedVerticalMovement = this._verticalCheck(surfaceAdjustedVerticalMovement, originalMovementSign, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (fixedVerticalMovement.vec3_isZero(1e-6)) {
        fixedVerticalMovement.vec3_zero();
      }
    }
    outFixedMovement.vec3_zero();
    if (!collisionRuntimeParams.myIsCollidingVertically) {
      outFixedMovement = fixedHorizontalMovement.vec3_add(fixedVerticalMovement, outFixedMovement);
    } else {
      collisionRuntimeParams.myHorizontalMovementCanceled = true;
      collisionRuntimeParams.myVerticalMovementCanceled = true;
      fixedHorizontalMovement.vec3_zero();
      fixedVerticalMovement.vec3_zero();
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
        } else {
          forwardForVertical.vec3_copy(transformForward);
        }
      }
    }
    newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
    forwardForPerceivedAngle.vec3_copy(transformForward);
    if (!fixedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = fixedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!horizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
    if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && !collisionRuntimeParams.myHorizontalMovementCanceled) {
      let surfaceCheckOk = this._postSurfaceCheck(fixedHorizontalMovement, fixedVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
      if (!surfaceCheckOk) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
        collisionRuntimeParams.myVerticalMovementCanceled = true;
        fixedHorizontalMovement.vec3_zero();
        fixedVerticalMovement.vec3_zero();
        outFixedMovement.vec3_zero();
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else {
          forwardForPerceivedAngle.vec3_copy(transformForward);
        }
        if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myRealIsOnGround = this._myPrevCollisionRuntimeParams.myRealIsOnGround;
          collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
          collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
          collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
          collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
          collisionRuntimeParams.myGroundHitMaxAngle = this._myPrevCollisionRuntimeParams.myGroundHitMaxAngle;
          collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundHitMaxNormal);
          collisionRuntimeParams.myGroundDistance = this._myPrevCollisionRuntimeParams.myGroundDistance;
          collisionRuntimeParams.myGroundIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myGroundIsBaseInsideCollision;
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myRealIsOnCeiling = this._myPrevCollisionRuntimeParams.myRealIsOnCeiling;
          collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
          collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
          collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
          collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
          collisionRuntimeParams.myCeilingHitMaxAngle = this._myPrevCollisionRuntimeParams.myCeilingHitMaxAngle;
          collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingHitMaxNormal);
          collisionRuntimeParams.myCeilingDistance = this._myPrevCollisionRuntimeParams.myCeilingDistance;
          collisionRuntimeParams.myCeilingIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myCeilingIsBaseInsideCollision;
        }
      }
    }
    if (collisionCheckParams.myExtraMovementCheckCallback != null) {
      fixedMovement.vec3_copy(outFixedMovement);
      outFixedMovement = collisionCheckParams.myExtraMovementCheckCallback(movement, fixedMovement, feetPosition, transformUp, transformForward, height, collisionCheckParams, this._myPrevCollisionRuntimeParams, collisionRuntimeParams, outFixedMovement);
      fixedHorizontalMovement = outFixedMovement.vec3_removeComponentAlongAxis(transformUp, fixedHorizontalMovement);
      fixedVerticalMovement = outFixedMovement.vec3_componentAlongAxis(transformUp, fixedVerticalMovement);
    }
    {
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myIsSliding && !fixedHorizontalMovement.vec3_isZero()) {
          collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
        }
      }
      if (!horizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(horizontalMovement);
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(surfaceAdjustedHorizontalMovement);
      }
      if (!verticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(verticalMovement);
      }
      if (!surfaceAdjustedVerticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(surfaceAdjustedVerticalMovement);
      }
      if (!fixedHorizontalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidIsSliding = collisionRuntimeParams.myIsSliding;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = false;
        collisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(fixedHorizontalMovement);
        if (!collisionRuntimeParams.myIsSliding) {
        } else {
        }
      } else {
      }
      if (!fixedVerticalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(fixedVerticalMovement);
      }
    }
    let moveStepFixed = false;
    if (!collisionRuntimeParams.myHorizontalMovementCanceled && !fixedHorizontalMovement.vec3_isZero(1e-6)) {
      horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
      let surfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, this._myPrevCollisionRuntimeParams);
      if (surfaceTooSteepResults[0] || surfaceTooSteepResults[1]) {
        horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
        let newSurfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, collisionRuntimeParams);
        if (surfaceTooSteepResults[0] && newSurfaceTooSteepResults[0] || surfaceTooSteepResults[1] && newSurfaceTooSteepResults[1] || !allowSurfaceSteepFix || surfaceTooSteepResults[0] && !collisionCheckParams.myAllowGroundSteepFix || surfaceTooSteepResults[1] && !collisionCheckParams.myAllowCeilingSteepFix) {
          outFixedMovement.vec3_zero();
          collisionRuntimeParams.copy(this._myPrevCollisionRuntimeParams);
          this._moveStep(movement, feetPosition, transformUp, transformForward, height, false, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
          moveStepFixed = true;
        }
      }
    }
    if (!moveStepFixed) {
      if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugMovementEnabled && Globals.isDebugEnabled(this._myEngine)) {
        this._debugMovement(movement, outFixedMovement, newFeetPosition, transformUp, collisionCheckParams);
      }
      if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugRuntimeParamsEnabled && Globals.isDebugEnabled(this._myEngine)) {
        this._debugRuntimeParams(collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheckMove.prototype._syncCollisionRuntimeParamsWithPrevious = function() {
  let previousFixedHorizontalMovement = vec3_create();
  return function _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    collisionRuntimeParams.myIsSlidingFlickerPrevented = previousCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalVerticalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    collisionRuntimeParams.myLastValidIsSliding = previousCollisionRuntimeParams.myLastValidIsSliding;
    collisionRuntimeParams.mySliding90DegreesSign = previousCollisionRuntimeParams.mySliding90DegreesSign;
    collisionRuntimeParams.mySlidingRecompute90DegreesSign = previousCollisionRuntimeParams.mySlidingRecompute90DegreesSign;
    if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
      let angleWithPreviousThreshold = 0.5;
      if (!previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_isZero() && !surfaceAdjustedHorizontalMovement.vec3_isZero() && surfaceAdjustedHorizontalMovement.vec3_angle(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement) > angleWithPreviousThreshold) {
        if (!previousCollisionRuntimeParams.myLastValidIsSliding) {
          let angleSigned2 = surfaceAdjustedHorizontalMovement.vec3_angleSigned(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement, up);
          let angleSignedThreshold = 10;
          if (Math.abs(angleSigned2) < 180 - angleSignedThreshold) {
            collisionRuntimeParams.mySliding90DegreesSign = Math.pp_sign(angleSigned2);
          }
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
      }
    }
    previousFixedHorizontalMovement = previousCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(up, previousFixedHorizontalMovement);
    if (previousFixedHorizontalMovement.vec3_isZero(1e-6)) {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    } else {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousFixedHorizontalMovement);
    }
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_teleport.js
var CollisionCheckTeleport = class extends CollisionCheckMove {
  // #TODO Add teleport position/transform and return originalteleportransform
  // instead of position old transform / new transform
  teleport(position, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForTeleportCollisionCheckDisabled(position, transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._teleport(position, transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  _teleport(teleportPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
  }
};
CollisionCheckTeleport.prototype._teleport = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let originalFeetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let feetPositionOffsetToOriginal = vec3_create();
  let offsetTeleportPosition = vec3_create();
  let zero4 = vec3_create();
  let forwardForHorizontal = vec3_create();
  let forwardForVertical = vec3_create();
  let forwardForPerceivedAngle = vec3_create();
  let fixedHorizontalMovement = vec3_create();
  let fixedVerticalMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let endPosition = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _teleport(teleportPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    offsetTeleportPosition.vec3_copy(teleportPosition);
    originalFeetPosition = transformQuat2.quat2_getPosition(originalFeetPosition);
    feetPositionOffsetToOriginal = originalFeetPosition.vec3_sub(feetPosition, feetPositionOffsetToOriginal);
    if (feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
      feetPositionOffsetToOriginal.vec3_zero();
    } else {
      offsetTeleportPosition = offsetTeleportPosition.vec3_sub(feetPositionOffsetToOriginal, offsetTeleportPosition);
    }
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
    if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
      forwardForHorizontal.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForHorizontal.vec3_copy(xAxis);
        } else {
          forwardForHorizontal.vec3_copy(zAxis);
        }
      }
      forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
      forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
      if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
        forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      }
    }
    fixedHorizontalMovement = this._horizontalCheck(zero4, offsetTeleportPosition, height, transformUp, forwardForHorizontal, false, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      newFeetPosition = offsetTeleportPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        forwardForVertical.vec3_copy(transformForward);
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      let downward = -1;
      fixedVerticalMovement = this._verticalCheck(zero4, downward, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (!collisionRuntimeParams.myIsCollidingVertically) {
        newFeetPosition = newFeetPosition.vec3_add(fixedVerticalMovement, newFeetPosition);
        forwardForPerceivedAngle.vec3_copy(transformForward);
        if (collisionCheckParams.myComputeGroundInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        }
        if (!collisionRuntimeParams.myIsOnGround) {
          if (collisionCheckParams.myTeleportMustBeOnGround && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnGround && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (!collisionRuntimeParams.myIsOnCeiling) {
          if (collisionCheckParams.myTeleportMustBeOnCeiling && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnCeiling && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnGround) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnGroundAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnGroundAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnCeiling) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnCeilingAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnCeilingAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myTeleportCanceled) {
          if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myRealIsOnGround = this._myPrevCollisionRuntimeParams.myRealIsOnGround;
            collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
            collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
            collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
            collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
            collisionRuntimeParams.myGroundHitMaxAngle = this._myPrevCollisionRuntimeParams.myGroundHitMaxAngle;
            collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundHitMaxNormal);
            collisionRuntimeParams.myGroundDistance = this._myPrevCollisionRuntimeParams.myGroundDistance;
            collisionRuntimeParams.myGroundIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myGroundIsBaseInsideCollision;
          }
          if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myRealIsOnCeiling = this._myPrevCollisionRuntimeParams.myRealIsOnCeiling;
            collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
            collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
            collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
            collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
            collisionRuntimeParams.myCeilingHitMaxAngle = this._myPrevCollisionRuntimeParams.myCeilingHitMaxAngle;
            collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingHitMaxNormal);
            collisionRuntimeParams.myCeilingDistance = this._myPrevCollisionRuntimeParams.myCeilingDistance;
            collisionRuntimeParams.myCeilingIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myCeilingIsBaseInsideCollision;
          }
        }
      } else {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
    } else {
      collisionRuntimeParams.myTeleportCanceled = true;
    }
    if (!isPositionCheck) {
      if (collisionCheckParams.myExtraTeleportCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraTeleportCheckCallback(offsetTeleportPosition, endPosition, feetPosition, transformUp, transformForward, height, collisionCheckParams, this._myPrevCollisionRuntimeParams, collisionRuntimeParams, newFeetPosition);
      }
    } else {
      if (collisionCheckParams.myExtraCheckTransformCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraCheckTransformCheckCallback(endPosition, feetPosition, transformUp, transformForward, height, collisionCheckParams, this._myPrevCollisionRuntimeParams, collisionRuntimeParams, newFeetPosition);
      }
    }
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOffsetUp.vec3_copy(transformUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(teleportPosition);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(newFeetPosition);
      if (!feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
        collisionRuntimeParams.myFixedTeleportPosition = collisionRuntimeParams.myFixedTeleportPosition.vec3_add(feetPositionOffsetToOriginal, collisionRuntimeParams.myFixedTeleportPosition);
      }
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    } else {
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myOriginalPosition);
    }
    collisionRuntimeParams.myIsTeleport = true;
    if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugRuntimeParamsEnabled && Globals.isDebugEnabled(this._myEngine)) {
      this._debugRuntimeParams(collisionRuntimeParams);
    }
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_position.js
var CollisionCheckPosition = class extends CollisionCheckTeleport {
  positionCheck(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForPositionCheckCollisionCheckDisabled(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._positionCheck(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  _positionCheck(allowAdjustments, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckPosition.prototype._positionCheck = function() {
  let feetPosition = vec3_create();
  return function _positionCheck(allowAdjustments, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    feetPosition = transformQuat2.quat2_getPosition(feetPosition);
    this._teleport(feetPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams, true);
    collisionRuntimeParams.myIsPositionOk = !collisionRuntimeParams.myTeleportCanceled;
    collisionRuntimeParams.myIsPositionCheck = true;
    collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
    collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowAdjustments;
    if (!allowAdjustments) {
      collisionRuntimeParams.myIsPositionOk = collisionRuntimeParams.myIsPositionOk && collisionRuntimeParams.myOriginalPositionCheckPosition.vec_equals(collisionRuntimeParams.myFixedPositionCheckPosition, 1e-5);
    }
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
    collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
    collisionRuntimeParams.myTeleportCanceled = false;
    collisionRuntimeParams.myIsTeleport = false;
  };
}();

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check.js
var CollisionCheck = class extends CollisionCheckPosition {
};

// dist/gameplay/experimental/character_controller/collision/collision_check_bridge.js
var _myCollisionChecks = /* @__PURE__ */ new WeakMap();
function getCollisionCheck(engine = Globals.getMainEngine()) {
  return _myCollisionChecks.get(engine);
}
function setCollisionCheck(collisionCheck, engine = Globals.getMainEngine()) {
  _myCollisionChecks.set(engine, collisionCheck);
}
function isCollisionCheckDisabled(engine = Globals.getMainEngine()) {
  let collisionCheck = CollisionCheckBridge.getCollisionCheck(engine);
  if (collisionCheck != null) {
    return collisionCheck.isCollisionCheckDisabled();
  }
  return false;
}
function setCollisionCheckDisabled(collisionCheckDisabled, engine = Globals.getMainEngine()) {
  let collisionCheck = CollisionCheckBridge.getCollisionCheck(engine);
  if (collisionCheck != null) {
    collisionCheck.setCollisionCheckDisabled(collisionCheckDisabled);
  }
}
function initBridge(engine = Globals.getMainEngine()) {
  if (!_myCollisionChecks.has(engine)) {
    CollisionCheckBridge.setCollisionCheck(new CollisionCheck(engine), engine);
  }
}
var checkMovement = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkMovement2(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    CollisionCheckBridge.getCollisionCheck(engine).move(movement, currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTeleportToTransform = function() {
  let teleportPosition = vec3_create();
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTeleportToTransform2(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    teleportPosition = teleportTransformQuat.quat2_getPosition(teleportPosition);
    CollisionCheckBridge.getCollisionCheck(engine).teleport(teleportPosition, teleportTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTransform = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTransform2(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    CollisionCheckBridge.getCollisionCheck(engine).positionCheck(true, checkTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, checkTransformQuat, outCharacterCollisionResults);
  };
}();
var updateGroundInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateGroundInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeCeilingInfoEnabled = false;
    CollisionCheckBridge.getCollisionCheck(engine).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var updateCeilingInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateCeilingInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeGroundInfoEnabled = false;
    CollisionCheckBridge.getCollisionCheck(engine).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
function convertCharacterCollisionResultsToCollisionRuntimeParams(characterCollisionResults, outCollisionRuntimeParams) {
  outCollisionRuntimeParams.reset();
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPosition);
  characterCollisionResults.myTransformResults.myFinalTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myNewPosition);
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getForward(outCollisionRuntimeParams.myOriginalForward);
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getUp(outCollisionRuntimeParams.myOriginalUp);
  outCollisionRuntimeParams.myOriginalMovement.vec3_copy(characterCollisionResults.myMovementResults.myInitialMovement);
  outCollisionRuntimeParams.myFixedMovement.vec3_copy(characterCollisionResults.myMovementResults.myFinalMovement);
  outCollisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantInitialHorizontalMovement);
  outCollisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantInitialVerticalMovement);
  outCollisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement);
  outCollisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalVerticalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialHorizontalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialVerticalMovement);
  outCollisionRuntimeParams.myIsOnGround = characterCollisionResults.myGroundInfo.myOnSurface;
  outCollisionRuntimeParams.myGroundAngle = characterCollisionResults.myGroundInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myGroundPerceivedAngle = characterCollisionResults.myGroundInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myGroundNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myGroundHitMaxAngle = characterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myGroundDistance = characterCollisionResults.myGroundInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myGroundIsBaseInsideCollision = characterCollisionResults.myGroundInfo.myBaseInsideCollision;
  outCollisionRuntimeParams.myIsOnCeiling = characterCollisionResults.myCeilingInfo.myOnSurface;
  outCollisionRuntimeParams.myCeilingAngle = characterCollisionResults.myCeilingInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myCeilingPerceivedAngle = characterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myCeilingNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myCeilingHitMaxAngle = characterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myCeilingDistance = characterCollisionResults.myCeilingInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myCeilingIsBaseInsideCollision = characterCollisionResults.myCeilingInfo.myBaseInsideCollision;
  outCollisionRuntimeParams.myHorizontalMovementCanceled = characterCollisionResults.myHorizontalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingHorizontally = characterCollisionResults.myHorizontalMovementResults.myMovementCollided;
  outCollisionRuntimeParams.myHorizontalCollisionHit.copy(characterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myVerticalMovementCanceled = characterCollisionResults.myVerticalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingVertically = characterCollisionResults.myVerticalMovementResults.myMovementCollided;
  outCollisionRuntimeParams.myVerticalCollisionHit.copy(characterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myHasSnappedOnGround = characterCollisionResults.myGroundResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasSnappedOnCeiling = characterCollisionResults.myCeilingResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasPoppedOutGround = characterCollisionResults.myGroundResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHasPoppedOutCeiling = characterCollisionResults.myCeilingResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = characterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = characterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
  outCollisionRuntimeParams.myIsSliding = characterCollisionResults.myWallSlideResults.myHasSlid;
  outCollisionRuntimeParams.mySlidingMovementAngle = characterCollisionResults.myWallSlideResults.mySlideMovementAngle;
  outCollisionRuntimeParams.mySlidingCollisionAngle = characterCollisionResults.myWallSlideResults.mySlideMovementWallAngle;
  outCollisionRuntimeParams.mySlidingWallNormal.vec3_copy(characterCollisionResults.myWallSlideResults.myWallNormal);
  outCollisionRuntimeParams.myIsSlidingIntoOppositeDirection = characterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection;
  outCollisionRuntimeParams.myIsSlidingFlickerPrevented = characterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented;
  outCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = characterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter;
  outCollisionRuntimeParams.mySliding90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign;
  outCollisionRuntimeParams.mySlidingRecompute90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign;
  outCollisionRuntimeParams.myLastValidIsSliding = characterCollisionResults.myInternalResults.myLastRelevantHasWallSlid;
  outCollisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement);
  outCollisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat);
  outCollisionRuntimeParams.myFixedTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat);
  outCollisionRuntimeParams.myTeleportCanceled = characterCollisionResults.myTeleportResults.myTeleportFailed;
  outCollisionRuntimeParams.myIsPositionOk = characterCollisionResults.myCheckTransformResults.myCheckTransformFailed;
  characterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPositionCheckPosition);
  characterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myFixedPositionCheckPosition);
  outCollisionRuntimeParams.myIsTeleport = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TELEPORT;
  outCollisionRuntimeParams.myIsMove = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_MOVEMENT;
  outCollisionRuntimeParams.myIsPositionCheck = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TRANSFORM;
  outCollisionRuntimeParams.mySplitMovementSteps = characterCollisionResults.mySplitMovementResults.myStepsToPerform;
  outCollisionRuntimeParams.mySplitMovementStepsPerformed = characterCollisionResults.mySplitMovementResults.myStepsPerformed;
  outCollisionRuntimeParams.mySplitMovementStop = characterCollisionResults.mySplitMovementResults.myMovementInterrupted;
  outCollisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(characterCollisionResults.mySplitMovementResults.myMovementChecked);
  return outCollisionRuntimeParams;
}
var convertCollisionRuntimeParamsToCharacterCollisionResults = function() {
  let rotationQuat = quat_create();
  return function convertCollisionRuntimeParamsToCharacterCollisionResults2(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults) {
    outCharacterCollisionResults.reset();
    if (collisionRuntimeParams.myIsMove) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_MOVEMENT;
    } else if (collisionRuntimeParams.myIsTeleport) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TELEPORT;
    } else if (collisionRuntimeParams.myIsPositionCheck) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TRANSFORM;
    }
    rotationQuat.quat_setForward(collisionRuntimeParams.myOriginalForward, collisionRuntimeParams.myOriginalUp);
    outCharacterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myOriginalPosition, rotationQuat);
    outCharacterCollisionResults.myTransformResults.myFinalTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myNewPosition, rotationQuat);
    outCharacterCollisionResults.myMovementResults.myInitialMovement.vec3_copy(collisionRuntimeParams.myOriginalMovement);
    outCharacterCollisionResults.myMovementResults.myFinalMovement.vec3_copy(collisionRuntimeParams.myFixedMovement);
    outCharacterCollisionResults.myMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingHorizontally || collisionRuntimeParams.myIsCollidingVertically;
    if (collisionRuntimeParams.myIsCollidingHorizontally) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    } else if (collisionRuntimeParams.myIsCollidingVertically) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    }
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled;
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingHorizontally;
    outCharacterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    outCharacterCollisionResults.myHorizontalMovementResults.myInitialMovement = collisionRuntimeParams.myOriginalMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myHorizontalMovementResults.myInitialMovement);
    outCharacterCollisionResults.myHorizontalMovementResults.myFinalMovement = collisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myHorizontalMovementResults.myFinalMovement);
    outCharacterCollisionResults.myVerticalMovementResults.myMovementFailed = collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myVerticalMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingVertically;
    outCharacterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    outCharacterCollisionResults.myVerticalMovementResults.myInitialMovement = collisionRuntimeParams.myOriginalMovement.vec3_componentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myVerticalMovementResults.myInitialMovement);
    outCharacterCollisionResults.myVerticalMovementResults.myFinalMovement = collisionRuntimeParams.myFixedMovement.vec3_componentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myVerticalMovementResults.myFinalMovement);
    outCharacterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myInitialTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myFinalTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myTeleportFailed = collisionRuntimeParams.myTeleportCanceled;
    outCharacterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myInitialTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myFinalTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myCheckTransformFailed = !collisionRuntimeParams.myIsPositionOk;
    outCharacterCollisionResults.myWallSlideResults.myHasSlid = collisionRuntimeParams.myIsSliding;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementAngle = collisionRuntimeParams.mySlidingMovementAngle;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementWallAngle = collisionRuntimeParams.mySlidingCollisionAngle;
    outCharacterCollisionResults.myWallSlideResults.myWallNormal.vec3_copy(collisionRuntimeParams.mySlidingWallNormal);
    outCharacterCollisionResults.myGroundInfo.myOnSurface = collisionRuntimeParams.myIsOnGround;
    outCharacterCollisionResults.myGroundInfo.mySurfaceAngle = collisionRuntimeParams.myGroundAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myGroundPerceivedAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myGroundHitMaxAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundHitMaxNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceDistance = collisionRuntimeParams.myGroundDistance;
    outCharacterCollisionResults.myGroundInfo.myBaseInsideCollision = collisionRuntimeParams.myGroundIsBaseInsideCollision;
    outCharacterCollisionResults.myCeilingInfo.myOnSurface = collisionRuntimeParams.myIsOnCeiling;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceAngle = collisionRuntimeParams.myCeilingAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myCeilingPerceivedAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myCeilingHitMaxAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingHitMaxNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceDistance = collisionRuntimeParams.myCeilingDistance;
    outCharacterCollisionResults.myCeilingInfo.myBaseInsideCollision = collisionRuntimeParams.myCeilingIsBaseInsideCollision;
    outCharacterCollisionResults.myGroundResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnGround;
    outCharacterCollisionResults.myGroundResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutGround;
    outCharacterCollisionResults.myCeilingResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnCeiling;
    outCharacterCollisionResults.myCeilingResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutCeiling;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill;
    outCharacterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill;
    outCharacterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill;
    outCharacterCollisionResults.mySplitMovementResults.myStepsToPerform = collisionRuntimeParams.mySplitMovementSteps;
    outCharacterCollisionResults.mySplitMovementResults.myStepsPerformed = collisionRuntimeParams.mySplitMovementStepsPerformed;
    outCharacterCollisionResults.mySplitMovementResults.myMovementInterrupted = collisionRuntimeParams.mySplitMovementStop;
    outCharacterCollisionResults.mySplitMovementResults.myMovementChecked.vec3_copy(collisionRuntimeParams.mySplitMovementMovementChecked);
    outCharacterCollisionResults.myInternalResults.myLastRelevantInitialHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantInitialVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantFinalVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantHasWallSlid = collisionRuntimeParams.myLastValidIsSliding;
    outCharacterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection = collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
    outCharacterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
    outCharacterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter = collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign = collisionRuntimeParams.mySliding90DegreesSign;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign = collisionRuntimeParams.mySlidingRecompute90DegreesSign;
    outCharacterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_copy(currentTransformQuat);
    return outCharacterCollisionResults;
  };
}();
var convertCharacterColliderSetupToCollisionCheckParams = function() {
  return function convertCharacterColliderSetupToCollisionCheckParams2(characterColliderSetup, outCollisionCheckParams) {
    outCollisionCheckParams.myHeight = characterColliderSetup.myHeight;
    outCollisionCheckParams.myRadius = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeRadius;
    outCollisionCheckParams.myDistanceFromFeetToIgnore = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore;
    outCollisionCheckParams.myDistanceFromHeadToIgnore = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore;
    outCollisionCheckParams.myHorizontalMovementCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementStepEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementEnabled;
    outCollisionCheckParams.myHorizontalMovementStepMaxLength = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementMaxStepLength == null ? 0 : characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementMaxStepLength;
    outCollisionCheckParams.myHorizontalMovementRadialStepAmount = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckRadialSteps;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckHorizontalBorder = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myHalfConeAngle = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle;
    outCollisionCheckParams.myHalfConeSliceAmount = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices;
    outCollisionCheckParams.myCheckConeBorder = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalBorderCheckEnabled;
    outCollisionCheckParams.myCheckConeRay = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalDirectionType = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckDirection;
    outCollisionCheckParams.myCheckHeight = characterColliderSetup.myHorizontalCheckParams.myHorizontalHeightCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightConeOnCollision = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
    outCollisionCheckParams.myCheckHeightConeOnCollisionKeepHit = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
    outCollisionCheckParams.myHeightCheckStepAmountMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps;
    outCollisionCheckParams.myHeightCheckStepAmountPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps;
    outCollisionCheckParams.myCheckVerticalStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalStraightCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalSearchFartherVerticalHit = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckGetFarthestHit;
    outCollisionCheckParams.myCheckHorizontalFixedForwardEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckHorizontalFixedForward.vec3_copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForward);
    outCollisionCheckParams.myVerticalMovementCheckEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckEnabled;
    outCollisionCheckParams.myVerticalPositionCheckEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckEnabled;
    outCollisionCheckParams.myFeetRadius = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadius;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = characterColliderSetup.myGroundParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = characterColliderSetup.myCeilingParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myCheckVerticalFixedForwardEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckVerticalFixedForward.vec3_copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForward);
    outCollisionCheckParams.myCheckVerticalBothDirection = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckPerformCheckOnBothSides;
    outCollisionCheckParams.myVerticalMovementReduceEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckReductionEnabled;
    outCollisionCheckParams.myGroundCircumferenceAddCenter = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceCentralCheckEnabled;
    outCollisionCheckParams.myGroundCircumferenceSliceAmount = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCollisionCheckParams.myGroundCircumferenceStepAmount = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps;
    outCollisionCheckParams.myGroundCircumferenceRotationPerStep = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep;
    outCollisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk = characterColliderSetup.myVerticalCheckParams.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
    outCollisionCheckParams.myHorizontalBlockLayerFlags.copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckBlockLayerFlags);
    outCollisionCheckParams.myVerticalBlockLayerFlags.copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckBlockLayerFlags);
    outCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckObjectsToIgnore);
    outCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckObjectsToIgnore);
    outCollisionCheckParams.mySnapOnGroundEnabled = characterColliderSetup.myGroundParams.mySurfaceSnapEnabled;
    outCollisionCheckParams.mySnapOnGroundExtraDistance = characterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.mySnapOnCeilingEnabled = characterColliderSetup.myCeilingParams.mySurfaceSnapEnabled;
    outCollisionCheckParams.mySnapOnCeilingExtraDistance = characterColliderSetup.myCeilingParams.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.myGroundPopOutEnabled = characterColliderSetup.myGroundParams.mySurfacePopOutEnabled;
    outCollisionCheckParams.myGroundPopOutExtraDistance = characterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myCeilingPopOutEnabled = characterColliderSetup.myCeilingParams.mySurfacePopOutEnabled;
    outCollisionCheckParams.myCeilingPopOutExtraDistance = characterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myGroundAngleToIgnore = characterColliderSetup.myGroundParams.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myGroundParams.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myCeilingAngleToIgnore = characterColliderSetup.myCeilingParams.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myCeilingParams.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = characterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = characterColliderSetup.myGroundParams.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingParams.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = characterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = characterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myComputeGroundInfoEnabled = characterColliderSetup.myGroundParams.myCollectSurfaceInfo;
    outCollisionCheckParams.myComputeCeilingInfoEnabled = characterColliderSetup.myCeilingParams.myCollectSurfaceInfo;
    outCollisionCheckParams.myDistanceToBeOnGround = characterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeGroundInfo = characterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToBeOnCeiling = characterColliderSetup.myCeilingParams.myOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeCeilingInfo = characterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnGround = characterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeGroundInfo = characterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnCeiling = characterColliderSetup.myCeilingParams.myOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeCeilingInfo = characterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myGroundParams.myBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myCeilingParams.myBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myIsOnGroundIfInsideHit = characterColliderSetup.myGroundParams.myOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myIsOnCeilingIfInsideHit = characterColliderSetup.myCeilingParams.myOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myFindGroundDistanceMaxOutsideDistance = characterColliderSetup.myGroundParams.myFindSurfaceDistanceMaxOutsideDistance;
    outCollisionCheckParams.myFindGroundDistanceMaxInsideDistance = characterColliderSetup.myGroundParams.myFindSurfaceDistanceMaxInsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxOutsideDistance = characterColliderSetup.myCeilingParams.myFindSurfaceDistanceMaxOutsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxInsideDistance = characterColliderSetup.myCeilingParams.myFindSurfaceDistanceMaxInsideDistance;
    outCollisionCheckParams.myAllowGroundSteepFix = characterColliderSetup.myGroundParams.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myAllowCeilingSteepFix = characterColliderSetup.myCeilingParams.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myMustStayOnGround = characterColliderSetup.myGroundParams.myMovementMustStayOnSurface;
    outCollisionCheckParams.myMustStayOnCeiling = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurface;
    outCollisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail = characterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail = characterColliderSetup.myCeilingParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill = characterColliderSetup.myGroundParams.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowGroundAngleDownhill = characterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMovementMustStayOnGroundHitAngle = characterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myMovementMustStayOnCeilingHitAngle = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundParams.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingParams.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGroundAngle = characterColliderSetup.myGroundParams.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnGroundAngle = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnCeilingAngle = characterColliderSetup.myCeilingParams.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnCeilingAngle = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGround = characterColliderSetup.myGroundParams.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnGround = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.myTeleportMustBeOnCeiling = characterColliderSetup.myCeilingParams.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnCeiling = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.mySlidingEnabled = characterColliderSetup.myWallSlideParams.myWallSlideEnabled;
    outCollisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckGetBetterReferenceHit;
    outCollisionCheckParams.mySlidingMaxAttempts = characterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts;
    outCollisionCheckParams.mySlidingCheckBothDirections = characterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections;
    outCollisionCheckParams.mySlidingFlickeringPreventionType = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode;
    outCollisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
    outCollisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter;
    outCollisionCheckParams.mySlidingAdjustSign90Degrees = characterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign;
    outCollisionCheckParams.mySplitMovementEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementEnabled;
    outCollisionCheckParams.mySplitMovementMaxLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength == null ? 0 : characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength;
    outCollisionCheckParams.mySplitMovementMaxLengthEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength != null;
    outCollisionCheckParams.mySplitMovementMaxSteps = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps == null ? 0 : characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps;
    outCollisionCheckParams.mySplitMovementMaxStepsEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps != null;
    outCollisionCheckParams.mySplitMovementMinLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength == null ? 0 : characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength;
    outCollisionCheckParams.mySplitMovementMinLengthEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength != null;
    outCollisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnHorizontalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnVerticalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopCallback = null;
    outCollisionCheckParams.mySplitMovementStopReturnPrevious = characterColliderSetup.mySplitMovementParams.mySplitMovementStopReturnPreviousResults;
    outCollisionCheckParams.myPositionOffsetLocal.vec3_copy(characterColliderSetup.myAdditionalParams.myPositionOffsetLocal);
    outCollisionCheckParams.myRotationOffsetLocalQuat.quat_copy(characterColliderSetup.myAdditionalParams.myRotationOffsetLocalQuat);
    outCollisionCheckParams.myDebugEnabled = characterColliderSetup.myDebugParams.myVisualDebugEnabled;
    outCollisionCheckParams.myDebugHorizontalMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myDebugHorizontalPositionEnabled = characterColliderSetup.myDebugParams.myVisualDebugHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myDebugVerticalMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugVerticalMovementCheckEnabled;
    outCollisionCheckParams.myDebugVerticalPositionEnabled = characterColliderSetup.myDebugParams.myVisualDebugVerticalPositionCheckEnabled;
    outCollisionCheckParams.myDebugSlidingEnabled = characterColliderSetup.myDebugParams.myVisualDebugSlideEnabled;
    outCollisionCheckParams.myDebugGroundInfoEnabled = characterColliderSetup.myDebugParams.myVisualDebugGroundInfoEnabled;
    outCollisionCheckParams.myDebugCeilingInfoEnabled = characterColliderSetup.myDebugParams.myVisualDebugGroundInfoEnabled;
    outCollisionCheckParams.myDebugRuntimeParamsEnabled = characterColliderSetup.myDebugParams.myVisualDebugResultsEnabled;
    outCollisionCheckParams.myDebugMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugMovementEnabled;
    return outCollisionCheckParams;
  };
}();
var CollisionCheckBridge = {
  getCollisionCheck,
  setCollisionCheck,
  isCollisionCheckDisabled,
  setCollisionCheckDisabled,
  initBridge,
  checkMovement,
  checkTeleportToTransform,
  checkTransform,
  updateGroundInfo,
  updateCeilingInfo,
  convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults,
  convertCharacterColliderSetupToCollisionCheckParams
};

// dist/gameplay/experimental/character_controller/collision/character_collision_system.js
var CharacterCollisionSystem = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myLastCheckRaycastsPerformed = 0;
    this._myCurrentFrameRaycastsPerformed = 0;
    this._myMaxFrameRaycastsPerformed = 0;
    this.myEngine = engine;
    CollisionCheckBridge.initBridge(this.myEngine);
  }
  update(dt) {
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    this._myCurrentFrameRaycastsPerformed = 0;
    CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts = 0;
  }
  checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
  }
  checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateSurfaceInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    let currentFramePerformedRaycasts = this._myCurrentFrameRaycastsPerformed;
    this.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - currentFramePerformedRaycasts;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
};
CharacterCollisionSystem.prototype.checkTeleportToPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults) {
    teleportTransformQuat.quat2_copy(currentTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
  };
}();

// dist/gameplay/experimental/character_controller/collision/components/character_collision_system_component.js
var CharacterCollisionSystemComponent = class extends Component9 {
  static TypeName = "pp-character-collision-system";
  static Properties = {};
  init() {
    this._myCharacterCollisionSystem = null;
    if (!Globals.hasCharacterCollisionSystem(this.engine)) {
      this._myCharacterCollisionSystem = new CharacterCollisionSystem(this.engine);
      Globals.setCharacterCollisionSystem(this._myCharacterCollisionSystem, this.engine);
    }
  }
  update(dt) {
    if (this._myCharacterCollisionSystem != null) {
      this._myCharacterCollisionSystem.update(dt);
    }
  }
  onDestroy() {
    if (this._myCharacterCollisionSystem != null && Globals.getCharacterCollisionSystem(this.engine) == this._myCharacterCollisionSystem) {
      Globals.removeCharacterCollisionSystem(this.engine);
    }
  }
};

// dist/input/cauldron/components/input_manager_component.js
import { Component as Component10, Property as Property6 } from "@wonderlandengine/api";

// dist/input/gamepad/gamepad_buttons.js
var GamepadButtonID = {
  SELECT: 0,
  // Trigger
  SQUEEZE: 1,
  // Grip
  TOUCHPAD: 2,
  THUMBSTICK: 3,
  BOTTOM_BUTTON: 4,
  // A or X button on oculus quest gamepad
  TOP_BUTTON: 5,
  // B or Y button on oculus quest gamepad, reverts to TOUCHPAD button for gamepads that does not support TOP_BUTTON
  THUMB_REST: 6
};
var GamepadButtonEvent = {
  PRESS_START: 0,
  PRESS_END: 1,
  PRESSED: 2,
  // Every frame that it is pressed
  NOT_PRESSED: 3,
  // Every frame that it is not pressed
  TOUCH_START: 4,
  TOUCH_END: 5,
  TOUCHED: 6,
  // Every frame that it is touched
  NOT_TOUCHED: 7,
  // Every frame that it is not touched
  VALUE_CHANGED: 8,
  ALWAYS: 9
  // Every frame
};
var GamepadAxesID = {
  THUMBSTICK: 0
};
var GamepadAxesEvent = {
  X_CHANGED: 0,
  Y_CHANGED: 1,
  AXES_CHANGED: 2,
  ALWAYS: 3
};
var GamepadButtonInfo = class _GamepadButtonInfo {
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
    this.myPressed = false;
    this.myPrevIsPressed = false;
    this.myTouched = false;
    this.myPrevIsTouched = false;
    this.myValue = 0;
    this.myPrevValue = 0;
    this.myTimePressed = 0;
    this.myPrevTimePressed = 0;
    this.myTimeNotPressed = 0;
    this.myPrevTimeNotPressed = 0;
    this.myTimeTouched = 0;
    this.myPrevTimeTouched = 0;
    this.myTimeNotTouched = 0;
    this.myPrevTimeNotTouched = 0;
    this.myMultiplePressStartCount = 0;
    this.myPrevMultiplePressStartCount = 0;
    this.myMultiplePressEndCount = 0;
    this.myPrevMultiplePressEndCount = 0;
    this.myMultipleTouchStartCount = 0;
    this.myPrevMultipleTouchStartCount = 0;
    this.myMultipleTouchEndCount = 0;
    this.myPrevMultipleTouchEndCount = 0;
  }
  getID() {
    return this.myID;
  }
  getHandedness() {
    return this.myHandedness;
  }
  getValue() {
    return this.myValue;
  }
  isPressed() {
    return this.myPressed;
  }
  isTouched() {
    return this.myTouched;
  }
  isPressStart(multiplePressCount = null) {
    return this.myPressed && !this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressStartCount == multiplePressCount);
  }
  isPressEnd(multiplePressCount = null) {
    return !this.myPressed && this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressEndCount == multiplePressCount);
  }
  isTouchStart(multipleTouchCount = null) {
    return this.myTouched && !this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchStartCount == multipleTouchCount);
  }
  isTouchEnd(multipleTouchCount = null) {
    return !this.myTouched && this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchEndCount == multipleTouchCount);
  }
  clone() {
    let value = new _GamepadButtonInfo(this.myID, this.myHandedness);
    value.myPressed = this.myPressed;
    value.myPrevIsPressed = this.myPrevIsPressed;
    value.myTouched = this.myTouched;
    value.myPrevIsTouched = this.myPrevIsTouched;
    value.myValue = this.myValue;
    value.myPrevValue = this.myPrevValue;
    value.myTimePressed = this.myTimePressed;
    value.myPrevTimePressed = this.myPrevTimePressed;
    value.myTimeNotPressed = this.myTimeNotPressed;
    value.myPrevTimeNotPressed = this.myPrevTimeNotPressed;
    value.myTimeTouched = this.myTimeTouched;
    value.myPrevTimeTouched = this.myPrevTimeTouched;
    value.myTimeNotTouched = this.myTimeNotTouched;
    value.myPrevTimeNotTouched = this.myPrevTimeNotTouched;
    value.myMultiplePressStartCount = this.myMultiplePressStartCount;
    value.myPrevMultiplePressStartCount = this.myPrevMultiplePressStartCount;
    value.myMultiplePressEndCount = this.myMultiplePressEndCount;
    value.myPrevMultiplePressEndCount = this.myPrevMultiplePressEndCount;
    value.myMultipleTouchStartCount = this.myMultipleTouchStartCount;
    value.myPrevMultipleTouchStartCount = this.myPrevMultipleTouchStartCount;
    value.myMultipleTouchEndCount = this.myMultipleTouchEndCount;
    value.myPrevMultipleTouchEndCount = this.myPrevMultipleTouchEndCount;
    return value;
  }
};
var GamepadAxesInfo = class _GamepadAxesInfo {
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
    this.myAxes = vec2_create(0, 0);
    this.myPrevAxes = vec2_create(0, 0);
  }
  getID() {
    return this.myID;
  }
  getAxes() {
    return this.myAxes;
  }
  getHandedness() {
    return this.myHandedness;
  }
  clone() {
    let value = new _GamepadAxesInfo(this.myID, this.myHandedness);
    value.myAxes.vec2_copy(this.myAxes);
    value.myPrevAxes.vec2_copy(this.myPrevAxes);
    return value;
  }
};
var GamepadPulseInfo = class _GamepadPulseInfo {
  constructor() {
    this.myIntensity = 0;
    this.myDuration = 0;
    this.myDevicePulsing = false;
  }
  clone() {
    let value = new _GamepadPulseInfo();
    value.myIntensity = this.myIntensity;
    value.myDuration = this.myDuration;
    value.myDevicePulsing = this.myDevicePulsing;
    return value;
  }
};

// dist/input/gamepad/gamepad_cores/gamepad_core.js
var GamepadCore = class {
  constructor(handPose) {
    this._myHandPose = handPose;
    this._myManagingHandPose = false;
    this._myDestroyed = false;
  }
  getHandedness() {
    return this.getHandPose().getHandedness();
  }
  getHandPose() {
    return this._myHandPose;
  }
  getEngine() {
    return this.getHandPose().getEngine();
  }
  isGamepadCoreActive() {
    return true;
  }
  setManageHandPose(manageHandPose) {
    this._myManagingHandPose = manageHandPose;
  }
  isManagingHandPose() {
    return this._myManagingHandPose;
  }
  start() {
    if (this.getHandPose() && this.isManagingHandPose()) {
      this.getHandPose().start();
    }
    this._startHook();
  }
  preUpdate(dt) {
    if (this.getHandPose() && this.isManagingHandPose()) {
      this.getHandPose().update(dt);
    }
    this._preUpdateHook(dt);
  }
  postUpdate(dt) {
    this._postUpdateHook(dt);
  }
  getButtonData(buttonID) {
    let buttonData = this._createButtonData();
    return buttonData;
  }
  getAxesData(axesID) {
    let axesData = this._createAxesData();
    return axesData;
  }
  getHapticActuators() {
    let hapticActuators = [];
    return hapticActuators;
  }
  // Hooks
  _startHook() {
  }
  _preUpdateHook(dt) {
  }
  _postUpdateHook(dt) {
  }
  _destroyHook() {
  }
  // Hooks end
  _createButtonData() {
    return { myPressed: false, myTouched: false, myValue: 0 };
  }
  _createAxesData() {
    return vec2_create(0, 0);
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
    if (this.isManagingHandPose()) {
      this.getHandPose().destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/gamepad_cores/classic_gamepad_core.js
var ClassicGamepadCore = class extends GamepadCore {
  constructor(gamepadIndex, handPose) {
    super(handPose);
    this._myGamepadIndex = gamepadIndex;
    this._myCurrentGamepads = window.navigator.getGamepads();
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  _preUpdateHook(dt) {
    this._myCurrentGamepads = window.navigator.getGamepads();
  }
  isGamepadCoreActive() {
    let classicGamepad = this._getClassicGamepad();
    return classicGamepad != null && (classicGamepad.connected == null || classicGamepad.connected);
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      let button = null;
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[4];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[6];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[10];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[13];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[12];
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[5];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[7];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[11];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[0];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[3];
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      }
      if (button != null) {
        this._myButtonData.myPressed = button.pressed;
        this._myButtonData.myTouched = button.touched;
        this._myButtonData.myValue = button.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        this._myAxesData[0] = classicGamepad.axes[0];
        this._myAxesData[1] = classicGamepad.axes[1];
      } else {
        this._myAxesData[0] = classicGamepad.axes[2];
        this._myAxesData[1] = classicGamepad.axes[3];
      }
      this._myAxesData[1] = -this._myAxesData[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (classicGamepad.hapticActuators != null) {
        for (let i = 0; i < classicGamepad.hapticActuators.length; i++) {
          this._myHapticActuators.push(classicGamepad.hapticActuators[i]);
        }
      }
      if (classicGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(classicGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  _getClassicGamepad() {
    let classicGamepad = null;
    if (this._myGamepadIndex != null) {
      if (this._myGamepadIndex < this._myCurrentGamepads.length) {
        classicGamepad = this._myCurrentGamepads[this._myGamepadIndex];
      }
    } else {
      for (let i = 0; i < this._myCurrentGamepads.length; i++) {
        let gamepad = this._myCurrentGamepads[i];
        if (gamepad != null && (gamepad.connected == null || gamepad.connected)) {
          classicGamepad = gamepad;
          break;
        }
      }
    }
    return classicGamepad;
  }
};

// dist/input/cauldron/keyboard.js
var KeyID = {
  _0: "0",
  _1: "1",
  _2: "2",
  _3: "3",
  _4: "4",
  _5: "5",
  _6: "6",
  _7: "7",
  _8: "8",
  _9: "9",
  KeyA: "KeyA",
  KeyB: "KeyB",
  KeyC: "KeyC",
  KeyD: "KeyD",
  KeyE: "KeyE",
  KeyF: "KeyF",
  KeyG: "KeyG",
  KeyH: "KeyH",
  KeyI: "KeyI",
  KeyJ: "KeyJ",
  KeyK: "KeyK",
  KeyL: "KeyL",
  KeyM: "KeyM",
  KeyN: "KeyN",
  KeyO: "KeyO",
  KeyP: "KeyP",
  KeyQ: "KeyQ",
  KeyR: "KeyR",
  KeyS: "KeyS",
  KeyT: "KeyT",
  KeyU: "KeyU",
  KeyV: "KeyV",
  KeyW: "KeyW",
  KeyX: "KeyX",
  KeyY: "KeyY",
  KeyZ: "KeyZ",
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  E: "E",
  F: "F",
  G: "G",
  H: "H",
  I: "I",
  J: "J",
  K: "K",
  L: "L",
  M: "M",
  N: "N",
  O: "O",
  P: "P",
  Q: "Q",
  R: "R",
  S: "S",
  T: "T",
  U: "U",
  V: "V",
  W: "W",
  X: "X",
  Y: "Y",
  Z: "Z",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  e: "e",
  f: "f",
  g: "g",
  h: "h",
  i: "i",
  j: "j",
  k: "k",
  l: "l",
  m: "m",
  n: "n",
  o: "o",
  p: "p",
  q: "q",
  r: "r",
  s: "s",
  t: "t",
  u: "u",
  v: "v",
  w: "w",
  x: "x",
  y: "y",
  z: "z",
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  SPACE: " ",
  ENTER: "Enter",
  BACKSPACE: "Backspace",
  ESC: "Escape",
  SHIFT_LEFT: "ShiftLeft",
  SHIFT_RIGHT: "ShiftRight",
  CONTROL_LEFT: "ControlLeft",
  CONTROL_RIGHT: "ControlRight",
  ALT_LEFT: "AltLeft",
  ALT_RIGHT: "AltRight"
};
var Keyboard = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myKeyInfos = {};
    this._myKeyInfosIDs = [];
    for (let key in KeyID) {
      this.addKey(KeyID[key]);
    }
    this._myOnKeyDownEventListener = null;
    this._myOnKeyUpEventListener = null;
    this._myDestroyed = false;
  }
  isKeyPressed(keyID) {
    let pressed = false;
    if (this._myKeyInfos[keyID] != null) {
      pressed = this._myKeyInfos[keyID].myPressed;
    }
    return pressed;
  }
  isKeyPressStart(keyID) {
    let pressStart = false;
    if (this._myKeyInfos[keyID] != null) {
      pressStart = this._myKeyInfos[keyID].myPressStart;
    }
    return pressStart;
  }
  isKeyPressEnd(keyID) {
    let pressEnd = false;
    if (this._myKeyInfos[keyID] != null) {
      pressEnd = this._myKeyInfos[keyID].myPressEnd;
    }
    return pressEnd;
  }
  addKey(keyID) {
    this._myKeyInfos[keyID] = this._createKeyInfo();
    this._myKeyInfosIDs.push(keyID);
  }
  start() {
    this._myOnKeyDownEventListener = this._keyDown.bind(this);
    Globals.getWindow(this._myEngine).addEventListener("keydown", this._myOnKeyDownEventListener);
    this._myOnKeyUpEventListener = this._keyUp.bind(this);
    Globals.getWindow(this._myEngine).addEventListener("keyup", this._myOnKeyUpEventListener);
  }
  update(dt) {
    if (!Globals.getDocument(this._myEngine).hasFocus()) {
      for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
        let id = this._myKeyInfosIDs[i];
        let keyInfo = this._myKeyInfos[id];
        if (keyInfo.myPressed) {
          keyInfo.myPressed = false;
          keyInfo.myPressEndToProcess = true;
        }
      }
    }
    for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
      let id = this._myKeyInfosIDs[i];
      let keyInfo = this._myKeyInfos[id];
      keyInfo.myPressStart = keyInfo.myPressStartToProcess;
      keyInfo.myPressEnd = keyInfo.myPressEndToProcess;
      keyInfo.myPressStartToProcess = false;
      keyInfo.myPressEndToProcess = false;
    }
  }
  _keyDown(event) {
    this._keyPressedChanged(event.key, true);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, true);
    }
  }
  _keyUp(event) {
    this._keyPressedChanged(event.key, false);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, false);
    }
  }
  _keyPressedChanged(keyID, pressed) {
    if (this._myKeyInfos[keyID] != null) {
      let keyInfo = this._myKeyInfos[keyID];
      if (pressed) {
        keyInfo.myPressed = true;
        keyInfo.myPressStartToProcess = true;
      } else {
        keyInfo.myPressed = false;
        keyInfo.myPressEndToProcess = true;
      }
    }
  }
  _createKeyInfo() {
    return { myPressed: false, myPressStart: false, myPressStartToProcess: false, myPressEnd: false, myPressEndToProcess: false };
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getWindow(this._myEngine).removeEventListener("keydown", this._myOnKeyDownEventListener);
    Globals.getWindow(this._myEngine).removeEventListener("keyup", this._myOnKeyUpEventListener);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/gamepad_cores/keyboard_gamepad_core.js
var KeyboardGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return true;
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    let keyboard = Globals.getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyE);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyQ);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyX);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyR);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyC);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyF);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyV);
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyU);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyO);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyM);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyY);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyN);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyH);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyB);
            break;
        }
      }
    }
    if (this._myButtonData.myPressed) {
      this._myButtonData.myTouched = true;
      this._myButtonData.myValue = 1;
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    let keyboard = Globals.getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        if (keyboard.isKeyPressed(KeyID.KeyW))
          this._myAxesData[1] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyS))
          this._myAxesData[1] += -1;
        if (keyboard.isKeyPressed(KeyID.KeyD))
          this._myAxesData[0] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyA))
          this._myAxesData[0] += -1;
      } else {
        if (keyboard.isKeyPressed(KeyID.KeyI) || keyboard.isKeyPressed(KeyID.UP))
          this._myAxesData[1] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyK) || keyboard.isKeyPressed(KeyID.DOWN))
          this._myAxesData[1] += -1;
        if (keyboard.isKeyPressed(KeyID.KeyL) || keyboard.isKeyPressed(KeyID.RIGHT))
          this._myAxesData[0] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyJ) || keyboard.isKeyPressed(KeyID.LEFT))
          this._myAxesData[0] += -1;
      }
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// dist/input/gamepad/gamepad_cores/xr_gamepad_core.js
var XRGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._mySelectPressed = false;
    this._mySqueezePressed = false;
    this._myXRSessionActive = false;
    this._myInputSource = null;
    this._myGamepad = null;
    this._mySelectStartEventListener = null;
    this._mySelectEndEventListener = null;
    this._mySqueezeStartEventListener = null;
    this._mySqueezeEndEventListener = null;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this._myXRSessionActive && this._myGamepad != null && (this._myGamepad.connected == null || this._myGamepad.connected);
  }
  _startHook() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.getEngine());
  }
  _preUpdateHook(dt) {
    let prevInputSource = this._myInputSource;
    this._myInputSource = this.getHandPose().getInputSource();
    if (prevInputSource != this._myInputSource) {
      this._mySelectPressed = false;
      this._mySqueezePressed = false;
    }
    if (this._myInputSource != null) {
      this._myGamepad = this._myInputSource.gamepad;
    } else {
      this._myGamepad = null;
    }
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    if (this.isGamepadCoreActive()) {
      if (buttonID < this._myGamepad.buttons.length) {
        let gamepadButton = this._myGamepad.buttons[buttonID];
        if (buttonID != GamepadButtonID.SELECT && buttonID != GamepadButtonID.SQUEEZE) {
          this._myButtonData.myPressed = gamepadButton.pressed;
        } else {
          this._myButtonData.myPressed = this._getSpecialButtonPressed(buttonID);
        }
        this._myButtonData.myTouched = gamepadButton.touched;
        this._myButtonData.myValue = gamepadButton.value;
      } else if (buttonID == GamepadButtonID.TOP_BUTTON && this._myGamepad.buttons.length >= 3) {
        let touchButton = this._myGamepad.buttons[2];
        this._myButtonData.myPressed = touchButton.pressed;
        this._myButtonData.myTouched = touchButton.touched;
        this._myButtonData.myValue = touchButton.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    if (this.isGamepadCoreActive()) {
      let internalAxes = this._myGamepad.axes;
      if (internalAxes.length == 4) {
        if (Math.abs(internalAxes[0]) > Math.abs(internalAxes[2])) {
          this._myAxesData[0] = internalAxes[0];
        } else {
          this._myAxesData[0] = internalAxes[2];
        }
        if (Math.abs(internalAxes[1]) > Math.abs(internalAxes[3])) {
          this._myAxesData[1] = internalAxes[1];
        } else {
          this._myAxesData[1] = internalAxes[3];
        }
      } else if (internalAxes.length == 2) {
        this._myAxesData[0] = internalAxes[0];
        this._myAxesData[1] = internalAxes[1];
      }
      this._myAxesData[1] = -this._myAxesData[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    if (this.isGamepadCoreActive()) {
      if (this._myGamepad.hapticActuators != null) {
        for (let i = 0; i < this._myGamepad.hapticActuators.length; i++) {
          this._myHapticActuators.push(this._myGamepad.hapticActuators[i]);
        }
      }
      if (this._myGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(this._myGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  // This is to be more compatible
  _getSpecialButtonPressed(buttonID) {
    let pressed = false;
    if (this.isGamepadCoreActive()) {
      if (buttonID == GamepadButtonID.SELECT) {
        pressed = this._mySelectPressed;
      } else if (buttonID == GamepadButtonID.SQUEEZE) {
        pressed = this._mySqueezePressed;
      }
    }
    return pressed;
  }
  _onXRSessionStart(session) {
    this._mySelectStartEventListener = this._selectStart.bind(this);
    this._mySelectEndEventListener = this._selectEnd.bind(this);
    this._mySqueezeStartEventListener = this._squeezeStart.bind(this);
    this._mySqueezeEndEventListener = this._squeezeEnd.bind(this);
    session.addEventListener("selectstart", this._mySelectStartEventListener);
    session.addEventListener("selectend", this._mySelectEndEventListener);
    session.addEventListener("squeezestart", this._mySqueezeStartEventListener);
    session.addEventListener("squeezeend", this._mySqueezeEndEventListener);
    this._myXRSessionActive = true;
  }
  _onXRSessionEnd(session) {
    this._mySelectStartEventListener = null;
    this._mySelectEndEventListener = null;
    this._mySqueezeStartEventListener = null;
    this._mySqueezeEndEventListener = null;
    this._mySelectPressed = false;
    this._mySqueezePressed = false;
    this._myXRSessionActive = false;
  }
  // Select and Squeeze are managed this way to be more compatible
  _selectStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = true;
    }
  }
  _selectEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = false;
    }
  }
  _squeezeStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = true;
    }
  }
  _squeezeEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = false;
    }
  }
  _destroyHook() {
    XRUtils.getSession(this.getEngine())?.removeEventListener("selectstart", this._mySelectStartEventListener);
    XRUtils.getSession(this.getEngine())?.removeEventListener("selectend", this._mySelectEndEventListener);
    XRUtils.getSession(this.getEngine())?.removeEventListener("squeezestart", this._mySqueezeStartEventListener);
    XRUtils.getSession(this.getEngine())?.removeEventListener("squeezeend", this._mySqueezeEndEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this.getEngine());
  }
};

// dist/input/cauldron/input_manager.js
import { Emitter as Emitter7 } from "@wonderlandengine/api";

// dist/input/gamepad/base_gamepad.js
import { Emitter as Emitter5 } from "@wonderlandengine/api";
var BaseGamepad = class {
  constructor(handedness) {
    this._myHandedness = handedness;
    this._myButtonInfos = {};
    this._myButtonInfosIDs = [];
    for (let key in GamepadButtonID) {
      this._myButtonInfos[GamepadButtonID[key]] = new GamepadButtonInfo(GamepadButtonID[key], this._myHandedness);
      this._myButtonInfosIDs.push(GamepadButtonID[key]);
    }
    this._myAxesInfos = {};
    this._myAxesInfosIDs = [];
    for (let key in GamepadAxesID) {
      this._myAxesInfos[GamepadAxesID[key]] = new GamepadAxesInfo(GamepadAxesID[key], this._myHandedness);
      this._myAxesInfosIDs.push(GamepadAxesID[key]);
    }
    this._myButtonEmitters = [];
    for (let key in GamepadButtonID) {
      this._myButtonEmitters[GamepadButtonID[key]] = [];
      for (let eventKey in GamepadButtonEvent) {
        this._myButtonEmitters[GamepadButtonID[key]][GamepadButtonEvent[eventKey]] = new Emitter5();
      }
    }
    this._myAxesEmitters = [];
    for (let key in GamepadAxesID) {
      this._myAxesEmitters[GamepadAxesID[key]] = [];
      for (let eventKey in GamepadAxesEvent) {
        this._myAxesEmitters[GamepadAxesID[key]][GamepadAxesEvent[eventKey]] = new Emitter5();
      }
    }
    this._myPulseInfo = new GamepadPulseInfo();
    this._myDestroyed = false;
    this._myMultiplePressMaxDelay = 0.4;
    this._myMultipleTouchMaxDelay = 0.4;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getButtonInfo(buttonID) {
    return this._myButtonInfos[buttonID];
  }
  registerButtonEventListener(buttonID, buttonEvent, id, listener) {
    this._myButtonEmitters[buttonID][buttonEvent].add(listener, { id });
  }
  unregisterButtonEventListener(buttonID, buttonEvent, id) {
    this._myButtonEmitters[buttonID][buttonEvent].remove(id);
  }
  getAxesInfo(axesID) {
    return this._myAxesInfos[axesID];
  }
  registerAxesEventListener(axesID, axesEvent, id, listener) {
    this._myAxesEmitters[axesID][axesEvent].add(listener, { id });
  }
  unregisterAxesEventListener(axesID, axesEvent, id) {
    this._myAxesEmitters[axesID][axesEvent].remove(id);
  }
  pulse(intensity, duration = 0) {
    this._myPulseInfo.myIntensity = Math.pp_clamp(intensity, 0, 1);
    this._myPulseInfo.myDuration = Math.max(duration, 0);
  }
  stopPulse() {
    this._myPulseInfo.myIntensity = 0;
    this._myPulseInfo.myDuration = 0;
  }
  isPulsing() {
    return this._myPulseInfo.myIntensity > 0 || this._myPulseInfo.myDuration > 0;
  }
  getPulseInfo() {
    return this._myPulseInfo;
  }
  getMultiplePressMaxDelay() {
    return this._myMultiplePressMaxDelay;
  }
  setMultiplePressMaxDelay(maxDelay) {
    this._myMultiplePressMaxDelay = maxDelay;
  }
  getMultipleTouchMaxDelay() {
    return this._myMultipleTouchMaxDelay;
  }
  setMultipleTouchMaxDelay(maxDelay) {
    this._myMultipleTouchMaxDelay = maxDelay;
  }
  // Hooks
  getHandPose() {
    return null;
  }
  _startHook() {
  }
  _preUpdate(dt) {
  }
  _postUpdate(dt) {
  }
  _getButtonData(buttonID) {
    let buttonData = this._createButtonData();
    return buttonData;
  }
  _getAxesData(axesID) {
    let axesData = this._createAxesData();
    return axesData;
  }
  _getHapticActuators() {
    let hapticActuator = [];
    return hapticActuator;
  }
  _destroyHook() {
  }
  // Hooks End
  start() {
    this._startHook();
  }
  update(dt) {
    this._preUpdate(dt);
    this._preUpdateButtonInfos();
    this._updateButtonInfos();
    this._postUpdateButtonInfos(dt);
    this._preUpdateAxesInfos();
    this._updateAxesInfos();
    this._postUpdateAxesInfos();
    this._updatePulse(dt);
    this._postUpdate(dt);
  }
  _preUpdateButtonInfos() {
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let info2 = this._myButtonInfos[id];
      info2.myPrevIsPressed = info2.myPressed;
      info2.myPrevIsTouched = info2.myTouched;
      info2.myPrevValue = info2.myValue;
    }
  }
  _updateButtonInfos() {
    this._updateSingleButtonInfo(GamepadButtonID.SELECT);
    this._updateSingleButtonInfo(GamepadButtonID.SQUEEZE);
    this._updateSingleButtonInfo(GamepadButtonID.TOUCHPAD);
    this._updateSingleButtonInfo(GamepadButtonID.THUMBSTICK);
    this._updateSingleButtonInfo(GamepadButtonID.BOTTOM_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.TOP_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.THUMB_REST);
  }
  _updateSingleButtonInfo(buttonID) {
    let buttonInfo = this._myButtonInfos[buttonID];
    let buttonData = this._getButtonData(buttonID);
    buttonInfo.myPressed = buttonData.myPressed;
    buttonInfo.myTouched = buttonData.myTouched;
    buttonInfo.myValue = buttonData.myValue;
    if (buttonInfo.myPressed) {
      buttonInfo.myTouched = true;
      if (buttonInfo.myValue == 0) {
        buttonInfo.myValue = 1;
      }
    }
  }
  _postUpdateButtonInfos(dt) {
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let info2 = this._myButtonInfos[id];
      if (info2.myPressed) {
        info2.myTimePressed += dt;
        if (!info2.myPrevIsPressed) {
          info2.myMultiplePressStartCount += 1;
          info2.myPrevTimeNotPressed = info2.myTimeNotPressed;
          info2.myTimeNotPressed = 0;
        }
        if (info2.myPrevTimeNotPressed + info2.myTimePressed > this._myMultiplePressMaxDelay && info2.myMultiplePressEndCount > 0) {
          info2.myPrevMultiplePressEndCount = info2.myMultiplePressEndCount;
          info2.myMultiplePressEndCount = 0;
        }
        if (info2.myTimePressed > this._myMultiplePressMaxDelay && info2.myMultiplePressStartCount > 0) {
          info2.myPrevMultiplePressStartCount = info2.myMultiplePressStartCount;
          info2.myMultiplePressStartCount = 0;
        }
      } else {
        info2.myTimeNotPressed += dt;
        if (info2.myPrevIsPressed) {
          info2.myMultiplePressEndCount += 1;
          info2.myPrevTimePressed = info2.myTimePressed;
          info2.myTimePressed = 0;
        }
        if (info2.myPrevTimePressed + info2.myTimeNotPressed > this._myMultiplePressMaxDelay && info2.myMultiplePressStartCount > 0) {
          info2.myPrevMultiplePressStartCount = info2.myMultiplePressStartCount;
          info2.myMultiplePressStartCount = 0;
        }
        if (info2.myTimeNotPressed > this._myMultiplePressMaxDelay && info2.myMultiplePressEndCount > 0) {
          info2.myPrevMultiplePressEndCount = info2.myMultiplePressEndCount;
          info2.myMultiplePressEndCount = 0;
        }
      }
      if (info2.myTouched) {
        info2.myTimeTouched += dt;
        if (!info2.myPrevIsTouched) {
          info2.myMultipleTouchStartCount += 1;
          info2.myPrevTimeNotTouched = info2.myTimeNotTouched;
          info2.myTimeNotTouched = 0;
        }
        if (info2.myPrevTimeNotTouched + info2.myTimeTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchEndCount > 0) {
          info2.myPrevMultipleTouchEndCount = info2.myMultipleTouchEndCount;
          info2.myMultipleTouchEndCount = 0;
        }
        if (info2.myTimeTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchStartCount > 0) {
          info2.myPrevMultipleTouchStartCount = info2.myMultipleTouchStartCount;
          info2.myMultipleTouchStartCount = 0;
        }
      } else {
        info2.myTimeNotTouched += dt;
        if (info2.myPrevIsTouched) {
          info2.myMultipleTouchEndCount += 1;
          info2.myPrevTimeTouched = info2.myTimeTouched;
          info2.myTimeTouched = 0;
        }
        if (info2.myPrevTimeTouched + info2.myTimeNotTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchStartCount > 0) {
          info2.myPrevMultipleTouchStartCount = info2.myMultipleTouchStartCount;
          info2.myMultipleTouchStartCount = 0;
        }
        if (info2.myTimeNotTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchEndCount > 0) {
          info2.myPrevMultipleTouchEndCount = info2.myMultipleTouchEndCount;
          info2.myMultipleTouchEndCount = 0;
        }
      }
    }
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      let buttonEventEmitters = this._myButtonEmitters[id];
      if (buttonInfo.myPressed && !buttonInfo.myPrevIsPressed) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESS_START];
        emitter2.notify(buttonInfo, this);
      }
      if (!buttonInfo.myPressed && buttonInfo.myPrevIsPressed) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESS_END];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myPressed) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESSED];
        emitter2.notify(buttonInfo, this);
      } else {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.NOT_PRESSED];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myTouched && !buttonInfo.myPrevIsTouched) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCH_START];
        emitter2.notify(buttonInfo, this);
      }
      if (!buttonInfo.myTouched && buttonInfo.myPrevIsTouched) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCH_END];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myTouched) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCHED];
        emitter2.notify(buttonInfo, this);
      } else {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.NOT_TOUCHED];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myValue != buttonInfo.myPrevValue) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.VALUE_CHANGED];
        emitter2.notify(buttonInfo, this);
      }
      let emitter = buttonEventEmitters[GamepadButtonEvent.ALWAYS];
      emitter.notify(buttonInfo, this);
    }
    this._mySelectStart = false;
    this._mySelectEnd = false;
    this._mySqueezeStart = false;
    this._mySqueezeEnd = false;
  }
  _preUpdateAxesInfos() {
    for (let i = 0; i < this._myAxesInfosIDs.length; i++) {
      let id = this._myAxesInfosIDs[i];
      let info2 = this._myAxesInfos[id];
      info2.myPrevAxes[0] = info2.myAxes[0];
      info2.myPrevAxes[1] = info2.myAxes[1];
    }
  }
  _updateAxesInfos() {
    this._updateSingleAxesInfo(GamepadAxesID.THUMBSTICK);
  }
  _updateSingleAxesInfo(axesID) {
    let axesInfo = this._myAxesInfos[axesID];
    let axesData = this._getAxesData(axesID);
    axesInfo.myAxes[0] = axesData[0];
    axesInfo.myAxes[1] = axesData[1];
  }
  _postUpdateAxesInfos() {
    for (let key in GamepadAxesID) {
      let axesInfo = this._myAxesInfos[GamepadAxesID[key]];
      let axesEventEmitters = this._myAxesEmitters[GamepadAxesID[key]];
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0]) {
        let emitter2 = axesEventEmitters[GamepadAxesEvent.X_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      if (axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        let emitter2 = axesEventEmitters[GamepadAxesEvent.Y_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0] || axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        let emitter2 = axesEventEmitters[GamepadAxesEvent.AXES_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      let emitter = axesEventEmitters[GamepadAxesEvent.ALWAYS];
      emitter.notify(axesInfo, this);
    }
  }
  _updatePulse(dt) {
    if (this._myPulseInfo.myDevicePulsing || this._myPulseInfo.myIntensity > 0) {
      let hapticActuators = this._getHapticActuators();
      if (hapticActuators.length > 0) {
        if (this._myPulseInfo.myIntensity > 0) {
          for (let i = 0; i < hapticActuators.length; i++) {
            let hapticActuator = hapticActuators[i];
            hapticActuator.pulse(this._myPulseInfo.myIntensity, Math.max(250, this._myPulseInfo.myDuration * 1e3));
          }
          this._myPulseInfo.myDevicePulsing = true;
        } else if (this._myPulseInfo.myDevicePulsing) {
          for (let i = 0; i < hapticActuators.length; i++) {
            let hapticActuator = hapticActuators[i];
            hapticActuator.pulse(0, 1);
            try {
              if (hapticActuator.reset != null) {
                hapticActuator.reset();
              }
            } catch (error3) {
            }
          }
          this._myPulseInfo.myDevicePulsing = false;
        }
      } else {
        this._myPulseInfo.myDevicePulsing = false;
      }
    }
    this._myPulseInfo.myDuration -= dt;
    if (this._myPulseInfo.myDuration <= 0) {
      this._myPulseInfo.myIntensity = 0;
      this._myPulseInfo.myDuration = 0;
    }
  }
  _createButtonData() {
    return { myPressed: false, myTouched: false, myValue: 0 };
  }
  _createAxesData() {
    return vec2_create(0, 0);
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/universal_gamepad.js
var UniversalGamepad = class extends BaseGamepad {
  constructor(handedness) {
    super(handedness);
    this._myGamepadCores = {};
    this._myGamepadCoresIDs = [];
    this._myStarted = false;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  addGamepadCore(id, gamepadCore) {
    if (gamepadCore.getHandedness() == this.getHandedness()) {
      this._myGamepadCores[id] = gamepadCore;
      this._myGamepadCoresIDs.push(id);
      if (this._myStarted) {
        gamepadCore.start();
      }
    }
  }
  getGamepadCore(id) {
    return this._myGamepadCores[id];
  }
  removeGamepadCore(id) {
    let gamepadCore = this._myGamepadCores[id];
    if (gamepadCore != null) {
      delete this._myGamepadCores[id];
      this._myGamepadCoresIDs.pp_removeEqual(id);
    }
  }
  removeAllGamepadCores() {
    this._myGamepadCores = {};
    this._myGamepadCoresIDs = [];
  }
  getHandPose() {
    let handPose = null;
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let currentCoreHandPose = core.getHandPose();
        if (handPose == null || currentCoreHandPose != null && currentCoreHandPose.isValid()) {
          handPose = currentCoreHandPose;
        }
      }
      if (handPose != null && handPose.isValid()) {
        break;
      }
    }
    return handPose;
  }
  _startHook() {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.start();
    }
    this._myStarted = true;
  }
  _preUpdate(dt) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.preUpdate(dt);
    }
  }
  _postUpdate(dt) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.postUpdate(dt);
    }
  }
  _getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let coreButtonData = core.getButtonData(buttonID);
        this._myButtonData.myPressed = this._myButtonData.myPressed || coreButtonData.myPressed;
        this._myButtonData.myTouched = this._myButtonData.myTouched || coreButtonData.myTouched;
        if (Math.abs(coreButtonData.myValue) > Math.abs(this._myButtonData.myValue)) {
          this._myButtonData.myValue = coreButtonData.myValue;
        }
      }
    }
    return this._myButtonData;
  }
  _getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let coreAxesData = core.getAxesData(axesID);
        if (Math.abs(coreAxesData[0]) > Math.abs(this._myAxesData[0])) {
          this._myAxesData[0] = coreAxesData[0];
        }
        if (Math.abs(coreAxesData[1]) > Math.abs(this._myAxesData[1])) {
          this._myAxesData[1] = coreAxesData[1];
        }
      }
    }
    return this._myAxesData;
  }
  _getHapticActuators() {
    this._myHapticActuators.pp_clear();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let coreHapticActuators = core.getHapticActuators();
        for (let j = 0; j < coreHapticActuators.length; j++) {
          this._myHapticActuators.push(coreHapticActuators[j]);
        }
      }
    }
    return this._myHapticActuators;
  }
  _destroyHook() {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.destroy();
    }
  }
};

// dist/input/gamepad/cauldron/gamepads_manager.js
var GamepadsManager = class {
  constructor() {
    this._myGamepads = [];
    this._myGamepads[Handedness.LEFT] = new UniversalGamepad(Handedness.LEFT);
    this._myGamepads[Handedness.RIGHT] = new UniversalGamepad(Handedness.RIGHT);
    this._myDestroyed = false;
  }
  start() {
    for (let key in this._myGamepads) {
      this._myGamepads[key].start();
    }
  }
  update(dt) {
    for (let key in this._myGamepads) {
      this._myGamepads[key].update(dt);
    }
  }
  getLeftGamepad() {
    return this._myGamepads[Handedness.LEFT];
  }
  getRightGamepad() {
    return this._myGamepads[Handedness.RIGHT];
  }
  getGamepad(handedness) {
    return this._myGamepads[handedness];
  }
  getGamepads() {
    return this._myGamepads;
  }
  destroy() {
    this._myDestroyed = true;
    for (let key in this._myGamepads) {
      this._myGamepads[key].destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/pose/base_pose.js
import { Emitter as Emitter6 } from "@wonderlandengine/api";
var BasePoseParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myReferenceObject = null;
    this.myForwardFixed = true;
    this.myUpdateOnViewReset = false;
    this.myForceEmulatedVelocities = false;
    this.myEngine = engine;
  }
};
var BasePose = class {
  constructor(basePoseParams = new BasePoseParams()) {
    this._myForwardFixed = basePoseParams.myForwardFixed;
    this._myForceEmulatedVelocities = basePoseParams.myForceEmulatedVelocities;
    this._myUpdateOnViewReset = basePoseParams.myUpdateOnViewReset;
    this._myReferenceObject = basePoseParams.myReferenceObject;
    this._myEngine = basePoseParams.myEngine;
    this._myPosition = vec3_create();
    this._myRotationQuat = quat2_create();
    this._myPrevPosition = vec3_create();
    this._myPrevRotationQuat = quat_create();
    this._myLinearVelocity = vec3_create();
    this._myAngularVelocityRadians = vec3_create();
    this._myValid = false;
    this._myLinearVelocityEmulated = true;
    this._myAngularVelocityEmulated = true;
    this._myPrePoseUpdatedEventEmitter = new Emitter6();
    this._myPoseUpdatedEmitter = new Emitter6();
    this._myPostPoseUpdatedEventEmitter = new Emitter6();
    this._myViewResetEventListener = null;
    this._myDestroyed = false;
  }
  getEngine() {
    return this._myEngine;
  }
  // If the reference object is set, the transform will be converted using it as a parent,
  // otherwise the transform will be local, as if the parent/reference object was the identity transform
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setForwardFixed(forwardFixed) {
    this._myForwardFixed = forwardFixed;
  }
  isForwardFixed() {
    return this._myForwardFixed;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  setUpdateOnViewReset(updateOnViewReset) {
    this._myUpdateOnViewReset = updateOnViewReset;
  }
  isUpdateOnViewReset() {
    return this._myUpdateOnViewReset;
  }
  getReferenceSpace() {
    return XRUtils.getReferenceSpace(this._myEngine);
  }
  getPosition(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotation(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationDegrees(out, referenceObjectOverride);
  }
  getRotationDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotationRadians(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotationQuat(out = quat_create(), referenceObjectOverride = void 0) {
  }
  getTransform(out = mat4_create(), referenceObjectOverride = void 0) {
    return this.getTransformMatrix(out, referenceObjectOverride);
  }
  getTransformMatrix(out = mat4_create(), referenceObjectOverride = void 0) {
  }
  getTransformQuat(out = quat2_create(), referenceObjectOverride = void 0) {
  }
  getLinearVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getAngularVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getAngularVelocityDegrees(out, referenceObjectOverride);
  }
  getAngularVelocityDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getAngularVelocityRadians(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  isValid() {
    return this._myValid;
  }
  isLinearVelocityEmulated() {
    return this._myLinearVelocityEmulated;
  }
  isAngularVelocityEmulated() {
    return this._myAngularVelocityEmulated;
  }
  registerPrePoseUpdatedEventEventListener(id, listener) {
    this._myPrePoseUpdatedEventEmitter.add(listener, { id });
  }
  unregisterPrePoseUpdatedEventEventListener(id) {
    this._myPrePoseUpdatedEventEmitter.remove(id);
  }
  registerPoseUpdatedEventListener(id, listener) {
    this._myPoseUpdatedEmitter.add(listener, { id });
  }
  unregisterPoseUpdatedEventListener(id) {
    this._myPoseUpdatedEmitter.remove(id);
  }
  registerPostPoseUpdatedEventEventListener(id, listener) {
    this._myPostPoseUpdatedEventEmitter.add(listener, { id });
  }
  unregisterPostPoseUpdatedEventEventListener(id) {
    this._myPostPoseUpdatedEventEmitter.remove(id);
  }
  start() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myEngine);
  }
  update(dt) {
    this._update(dt, true, false);
  }
  // Hooks
  _isReadyToGetPose() {
    return true;
  }
  _getPose(xrFrame) {
    return null;
  }
  _updateHook(dt, updateVelocity, xrPose) {
  }
  _onXRSessionStartHook(manualCall, session) {
  }
  _onXRSessionEndHook() {
  }
  _onViewResetHook() {
  }
  _destroyHook() {
  }
  // Hooks End
  _update(dt, updateVelocity, manualUpdate) {
    this._myPrevPosition.vec3_copy(this._myPosition);
    this._myPrevRotationQuat.quat_copy(this._myRotationQuat);
    let xrFrame = XRUtils.getFrame(this._myEngine);
    if (xrFrame && this._isReadyToGetPose()) {
      let xrPose = null;
      try {
        xrPose = this._getPose(xrFrame);
      } catch (error3) {
      }
      if (xrPose) {
        this._myPosition[0] = xrPose.transform.position.x;
        this._myPosition[1] = xrPose.transform.position.y;
        this._myPosition[2] = xrPose.transform.position.z;
        this._myRotationQuat[0] = xrPose.transform.orientation.x;
        this._myRotationQuat[1] = xrPose.transform.orientation.y;
        this._myRotationQuat[2] = xrPose.transform.orientation.z;
        this._myRotationQuat[3] = xrPose.transform.orientation.w;
        this._myRotationQuat.quat_normalize(this._myRotationQuat);
        if (updateVelocity) {
          if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
            this._myLinearVelocity[0] = xrPose.linearVelocity.x;
            this._myLinearVelocity[1] = xrPose.linearVelocity.y;
            this._myLinearVelocity[2] = xrPose.linearVelocity.z;
            this._myLinearVelocityEmulated = false;
          } else {
            this._computeEmulatedLinearVelocity(dt);
            this._myLinearVelocityEmulated = true;
          }
          if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
            this._myAngularVelocityRadians[0] = xrPose.angularVelocity.x;
            this._myAngularVelocityRadians[1] = xrPose.angularVelocity.y;
            this._myAngularVelocityRadians[2] = xrPose.angularVelocity.z;
            this._myAngularVelocityEmulated = false;
          } else {
            this._computeEmulatedAngularVelocity(dt);
            this._myAngularVelocityEmulated = true;
          }
        }
        this._myValid = true;
      } else {
        if (updateVelocity) {
          this._myLinearVelocity[0] = 0;
          this._myLinearVelocity[1] = 0;
          this._myLinearVelocity[2] = 0;
          this._myAngularVelocityRadians[0] = 0;
          this._myAngularVelocityRadians[1] = 0;
          this._myAngularVelocityRadians[2] = 0;
        }
        this._myValid = false;
        this._myLinearVelocityEmulated = true;
        this._myAngularVelocityEmulated = true;
      }
      this._updateHook(dt, updateVelocity, xrPose);
    } else {
      if (updateVelocity) {
        this._myLinearVelocity[0] = 0;
        this._myLinearVelocity[1] = 0;
        this._myLinearVelocity[2] = 0;
        this._myAngularVelocityRadians[0] = 0;
        this._myAngularVelocityRadians[1] = 0;
        this._myAngularVelocityRadians[2] = 0;
      }
      this._myValid = false;
      this._myLinearVelocityEmulated = true;
      this._myAngularVelocityEmulated = true;
      this._updateHook(dt, updateVelocity, null);
    }
    this._myPrePoseUpdatedEventEmitter.notify(dt, this, manualUpdate);
    this._myPoseUpdatedEmitter.notify(dt, this, manualUpdate);
    this._myPostPoseUpdatedEventEmitter.notify(dt, this, manualUpdate);
  }
  _computeEmulatedLinearVelocity(dt) {
    if (dt > 0) {
      this._myPosition.vec3_sub(this._myPrevPosition, this._myLinearVelocity);
      this._myLinearVelocity.vec3_scale(1 / dt, this._myLinearVelocity);
    } else {
      this._myLinearVelocity[0] = 0;
      this._myLinearVelocity[1] = 0;
      this._myLinearVelocity[2] = 0;
    }
  }
  _onXRSessionStart(manualCall, session) {
    let referenceSpace = XRUtils.getReferenceSpace(this._myEngine);
    if (referenceSpace.addEventListener != null) {
      this._myViewResetEventListener = this._onViewReset.bind(this);
      referenceSpace.addEventListener("reset", this._myViewResetEventListener);
    }
    this._onXRSessionStartHook(manualCall, session);
  }
  _onXRSessionEnd() {
    this._onXRSessionEndHook();
    this._myViewResetEventListener = null;
  }
  _onViewReset() {
    if (this._myUpdateOnViewReset) {
      this._update(0, false, true);
    }
    this._onViewResetHook();
  }
  _computeEmulatedAngularVelocity() {
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
    XRUtils.getReferenceSpace(this._myEngine)?.removeEventListener?.("reset", this._myViewResetEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
BasePose.prototype.getPosition = function() {
  let transform = mat4_create();
  return function getPosition4(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myPosition);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertPositionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype.getRotationDegrees = function() {
  let rotationQuat = quat_create();
  return function getRotationDegrees4(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationQuat(rotationQuat, referenceObjectOverride).quat_toDegrees(out);
  };
}();
BasePose.prototype.getRotationRadians = function() {
  let rotationQuat = quat_create();
  return function getRotationRadians4(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationQuat(rotationQuat, referenceObjectOverride).quat_toRadians(out);
  };
}();
BasePose.prototype.getRotationQuat = function() {
  let playerRotationQuat = quat_create();
  let up = vec3_create();
  return function getRotationQuat4(out = quat_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat_copy(this._myRotationQuat);
    if (this._myForwardFixed) {
      out.quat_rotateAxisRadians(Math.PI, out.quat_getUp(up), out);
    }
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getRotationQuat(playerRotationQuat), out);
  };
}();
BasePose.prototype.getTransformMatrix = function() {
  let transformQuat2 = quat2_create();
  return function getTransformMatrix2(out = mat4_create(), referenceObjectOverride = void 0) {
    return this.getTransformQuat(transformQuat2, referenceObjectOverride).quat2_toMatrix(out);
  };
}();
BasePose.prototype.getTransformQuat = function() {
  let rotationQuat = quat_create();
  let playerTransformQuat = quat2_create();
  return function getTransformQuat2(out = quat2_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat2_identity();
    out.quat2_setPositionRotationQuat(this._myPosition, this.getRotationQuat(rotationQuat, referenceObjectOverride));
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getTransformQuat(playerTransformQuat), out);
  };
}();
BasePose.prototype.getLinearVelocity = function() {
  let transform = mat4_create();
  return function getLinearVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myLinearVelocity);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertDirectionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype.getAngularVelocityDegrees = function() {
  let velocityRadians = vec3_create();
  return function getAngularVelocityDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getAngularVelocityRadians(velocityRadians, referenceObjectOverride).vec3_toDegrees(out);
  };
}();
BasePose.prototype.getAngularVelocityRadians = function() {
  let transform = mat4_create();
  return function getAngularVelocityRadians(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myAngularVelocityRadians);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertDirectionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype._computeEmulatedAngularVelocity = function() {
  let rotationRadians = vec3_create();
  let prevRotationRadians = vec3_create();
  return function _computeEmulatedAngularVelocity(dt) {
    if (dt > 0) {
      rotationRadians = this._myRotationQuat.quat_toRadians(rotationRadians);
      prevRotationRadians = this._myPrevRotationQuat.quat_toRadians(prevRotationRadians);
      rotationRadians.vec3_sub(prevRotationRadians, this._myAngularVelocityRadians);
      this._myAngularVelocityRadians.vec3_scale(1 / dt, this._myAngularVelocityRadians);
    } else {
      this._myAngularVelocityRadians[0] = 0;
      this._myAngularVelocityRadians[1] = 0;
      this._myAngularVelocityRadians[2] = 0;
    }
  };
}();

// dist/input/pose/hand_pose.js
var HandPoseParams = class extends BasePoseParams {
  constructor(engine) {
    super(engine);
    this.myFixTrackedHandRotation = true;
  }
};
var HandPose = class extends BasePose {
  constructor(handedness, handPoseParams = new HandPoseParams()) {
    super(handPoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myFixTrackedHandRotation = handPoseParams.myFixTrackedHandRotation;
    this._myTrackedHand = false;
    this._myInputSourcesChangeEventListener = null;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getInputSource() {
    return this._myInputSource;
  }
  getInputSourceType() {
    if (this._myInputSource == null) {
      return null;
    }
    return InputUtils.getInputSourceType(this._myInputSource);
  }
  isFixTrackedHandRotation() {
    return this._myFixTrackedHandRotation;
  }
  setFixTrackedHandRotation(fixTrackedHandRotation) {
    this.myFixTrackedHandRotation = fixTrackedHandRotation;
  }
  getRotationQuat(out = quat_create(), referenceObjectOverride = void 0) {
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getPose(this._myInputSource.gripSpace, this.getReferenceSpace());
  }
  _onXRSessionStartHook(manualCall, session) {
    this._myInputSourcesChangeEventListener = () => {
      this._myInputSource = null;
      if (session.inputSources != null && session.inputSources.length > 0) {
        for (let i = 0; i < session.inputSources.length; i++) {
          let inputSource = session.inputSources[i];
          if (inputSource.handedness == this._myHandedness) {
            this._myInputSource = inputSource;
            this._myTrackedHand = InputUtils.getInputSourceType(this._myInputSource) == InputSourceType.TRACKED_HAND;
          }
        }
      }
    };
    this._myInputSourcesChangeEventListener();
    session.addEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
    this._myInputSourcesChangeEventListener = null;
  }
  _destroyHook() {
    XRUtils.getSession(this.getEngine())?.removeEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
};
HandPose.prototype.getRotationQuat = function() {
  let playerRotationQuat = quat_create();
  let up = vec3_create();
  let right = vec3_create();
  let forward = vec3_create();
  return function getRotationQuat4(out = quat_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat_copy(this._myRotationQuat);
    if (this._myForwardFixed) {
      out.quat_rotateAxisRadians(Math.PI, out.quat_getUp(up), out);
    }
    if (this._myFixTrackedHandRotation && this._myTrackedHand) {
      out.quat_rotateAxis(-60, out.quat_getRight(right), out);
      let forwardRotation = 20;
      forwardRotation = this._myHandedness == Handedness.LEFT ? forwardRotation : -forwardRotation;
      out.quat_rotateAxis(forwardRotation, out.quat_getForward(forward), out);
    }
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getRotationQuat(playerRotationQuat), out);
  };
}();

// dist/input/pose/head_pose.js
var HeadPose = class extends BasePose {
  _getPose(xrFrame) {
    return xrFrame.getViewerPose(this.getReferenceSpace());
  }
};

// dist/input/pose/tracked_hand_joint_pose.js
var TrackedHandJointPose = class extends BasePose {
  constructor(handedness, trackedHandJointID, basePoseParams = new BasePoseParams()) {
    super(basePoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myTrackedHandJointID = trackedHandJointID;
    this._myJointRadius = 0;
    this._myInputSourcesChangeEventListener = null;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getTrackedHandJointID() {
    return this._myTrackedHandJointID;
  }
  setTrackedHandJointID(trackedHandJointID) {
    this._myTrackedHandJointID = trackedHandJointID;
  }
  getJointRadius() {
    return this._myJointRadius;
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getJointPose(this._myInputSource.hand.get(this._myTrackedHandJointID), this.getReferenceSpace());
  }
  _updateHook(dt, updateVelocity, xrPose) {
    if (xrPose != null) {
      this._myJointRadius = xrPose.radius;
    }
  }
  _onXRSessionStartHook(manualCall, session) {
    this._myInputSourcesChangeEventListener = () => {
      this._myInputSource = null;
      if (session.inputSources != null && session.inputSources.length > 0) {
        for (let i = 0; i < session.inputSources.length; i++) {
          let inputSource = session.inputSources[i];
          if (inputSource.handedness == this._myHandedness) {
            if (InputUtils.getInputSourceType(inputSource) == InputSourceType.TRACKED_HAND) {
              this._myInputSource = inputSource;
            }
          }
        }
      }
    };
    this._myInputSourcesChangeEventListener();
    session.addEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
    this._myInputSourcesChangeEventListener = null;
  }
  _destroyHook() {
    XRUtils.getSession(this.getEngine())?.removeEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
};

// dist/input/pose/tracked_hand_pose.js
var TrackedHandPoseParams = class extends BasePoseParams {
  constructor(addAllJointIDs = true, engine = Globals.getMainEngine()) {
    super(engine);
    this.myTrackedHandJointIDList = [];
    if (addAllJointIDs) {
      for (let key in TrackedHandJointID) {
        this.myTrackedHandJointIDList.push([TrackedHandJointID[key]]);
      }
    }
  }
};
var TrackedHandPose = class {
  constructor(handedness, trackedHandPoseParams = new TrackedHandPoseParams()) {
    this._myHandedness = handedness;
    this._myForwardFixed = trackedHandPoseParams.myForwardFixed;
    this._myForceEmulatedVelocities = trackedHandPoseParams.myForceEmulatedVelocities;
    this._myReferenceObject = trackedHandPoseParams.myReferenceObject;
    this._myEngine = trackedHandPoseParams.myEngine;
    this._myTrackedHandJointPoseParams = new BasePoseParams(this._myEngine);
    this._myTrackedHandJointPoseParams.myForwardFixed = this._myForwardFixed;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    this._myTrackedHandJointPoses = [];
    for (let jointID of trackedHandPoseParams.myTrackedHandJointIDList) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoses[jointID] = trackedHandJointPose;
    }
  }
  start() {
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.start();
    }
  }
  update(dt) {
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.update(dt);
    }
  }
  getEngine() {
    this._myEngine;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getJointPose(jointID) {
    return this._myTrackedHandJointPoses[jointID];
  }
  getJointPoseByIndex(jointIDIndex) {
    return this._myTrackedHandJointPoses[InputUtils.getJointIDByIndex(jointIDIndex)];
  }
  getJointPoses() {
    return this._myTrackedHandJointPoses;
  }
  addTrackedHandJointID(jointID) {
    if (!this._myTrackedHandJointPoses.pp_has((element) => element.getTrackedHandJointID() == jointID)) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoses.push(trackedHandJointPose);
    }
  }
  removeTrackedHandJointID(jointID) {
    this._myTrackedHandJointPoses.pp_remove((element) => element.getTrackedHandJointID() == jointID);
  }
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setReferenceObject(referenceObject);
    }
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setForwardFixed(forwardFixed) {
    this._myForwardFixed = forwardFixed;
    this._myTrackedHandJointPoseParams.myForwardFixed = this._myForwardFixed;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setForwardFixed(forwardFixed);
    }
  }
  isForwardFixed() {
    return this._myForwardFixed;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setForceEmulatedVelocities(forceEmulatedVelocities);
    }
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  destroy() {
    this._myDestroyed = true;
    for (let jointPose of this._myTrackedHandJointPoses) {
      jointPose.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/cauldron/mouse.js
import { ViewComponent as ViewComponent3 } from "@wonderlandengine/api";
var MouseButtonID = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
var Mouse = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myButtonInfos = {};
    this._myButtonInfosIDs = [];
    for (let key in MouseButtonID) {
      this._myButtonInfos[MouseButtonID[key]] = this._createButtonInfo();
      this._myButtonInfosIDs.push(MouseButtonID[key]);
    }
    this._myPreventContextMenuEventListener = this._preventContextMenu.bind(this);
    this._myPreventMiddleButtonScrollEventListener = this._preventMiddleButtonScroll.bind(this);
    this._myInternalMousePosition = vec2_create();
    this._myScreenSize = vec2_create();
    this._updateScreenSize();
    this._myResetMovingDelay = 0.15;
    this._myResetMovingTimer = new Timer(this._myResetMovingDelay, false);
    this._myMoving = false;
    this._myInsideView = false;
    this._myValid = false;
    this._myPointerUpOnPointerLeave = true;
    this._myContextMenuActive = true;
    this._myMiddleButtonScrollActive = true;
    this._myPointerID = null;
    this._myLastValidPointerEvent = null;
    this._myPointerEventValidCallbacks = {};
    this._myPointerEventValidCallbacksIDs = [];
    this._myPointerMoveEventListener = null;
    this._myPointerDownEventListener = null;
    this._myPointerUpEventListener = null;
    this._myPointerLeaveEventListener = null;
    this._myPointerEnterEventListener = null;
    this._myMouseDownEventListener = null;
    this._myMouseUpEventListener = null;
    this._myDestroyed = false;
    this._myProjectionMatrixInverse = mat4_create();
    this._myRotationQuat = quat_create();
    this._myOriginWorld = vec3_create();
    this._myDirectionWorld = vec3_create();
  }
  start() {
    this._myPointerMoveEventListener = this._onPointerAction.bind(this, this._onPointerMove.bind(this));
    Globals.getBody(this._myEngine).addEventListener("pointermove", this._myPointerMoveEventListener);
    this._myPointerDownEventListener = this._onPointerAction.bind(this, this._onPointerDown.bind(this));
    Globals.getBody(this._myEngine).addEventListener("pointerdown", this._myPointerDownEventListener);
    this._myPointerUpEventListener = this._onPointerAction.bind(this, this._onPointerUp.bind(this));
    Globals.getBody(this._myEngine).addEventListener("pointerup", this._myPointerUpEventListener);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    Globals.getBody(this._myEngine).addEventListener("pointerleave", this._myPointerLeaveEventListener);
    this._myPointerEnterEventListener = this._onPointerEnter.bind(this);
    Globals.getBody(this._myEngine).addEventListener("pointerenter", this._myPointerEnterEventListener);
    this._myMouseDownEventListener = this._onMouseAction.bind(this, this._onPointerDown.bind(this));
    Globals.getBody(this._myEngine).addEventListener("mousedown", this._myMouseDownEventListener);
    this._myMouseUpEventListener = this._onMouseAction.bind(this, this._onPointerUp.bind(this));
    Globals.getBody(this._myEngine).addEventListener("mouseup", this._myMouseUpEventListener);
  }
  update(dt) {
    if (this._myResetMovingTimer.isRunning()) {
      this._myResetMovingTimer.update(dt);
      if (this._myResetMovingTimer.isDone()) {
        this._myResetMovingTimer.reset();
        this._myMoving = false;
      }
    }
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      buttonInfo.myPressStart = buttonInfo.myPressStartToProcess;
      buttonInfo.myPressEnd = buttonInfo.myPressEndToProcess;
      buttonInfo.myPressStartToProcess = false;
      buttonInfo.myPressEndToProcess = false;
    }
    this._updateScreenSize();
    if (!this.isAnyButtonPressed() && !this._myMoving) {
      this._myPointerID = null;
    }
    if (this._myLastValidPointerEvent != null) {
      let lastValidPointerEventStillValid = this._isPointerEventValid(this._myLastValidPointerEvent);
      if (!lastValidPointerEventStillValid) {
        if (this._myInsideView) {
          this._onPointerLeave(this._myLastValidPointerEvent);
        }
        this._myLastValidPointerEvent = null;
      }
    }
  }
  isValid() {
    return this._myValid;
  }
  isButtonPressed(buttonID) {
    let pressed = false;
    if (this._myButtonInfosIDs[buttonID] != null) {
      pressed = this._myButtonInfos[buttonID].myPressed;
    }
    return pressed;
  }
  isAnyButtonPressed() {
    let pressed = false;
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      if (buttonInfo.myPressed) {
        pressed = true;
        break;
      }
    }
    return pressed;
  }
  isButtonPressStart(buttonID) {
    let pressStart = false;
    if (this._myButtonInfosIDs[buttonID] != null) {
      pressStart = this._myButtonInfos[buttonID].myPressStart;
    }
    return pressStart;
  }
  isButtonPressEnd(buttonID = null) {
    let pressEnd = false;
    if (this._myButtonInfosIDs[buttonID] != null) {
      pressEnd = this._myButtonInfos[buttonID].myPressEnd;
    }
    return pressEnd;
  }
  isMoving() {
    return this._myMoving;
  }
  isInsideView() {
    return this._myInsideView;
  }
  isTargetingRenderCanvas() {
    return this.isInsideView() && this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.target == Globals.getCanvas(this._myEngine);
  }
  // The origin and direction are set by the mouse
  raycastWorld(raycastParams, raycastResults = new RaycastResults()) {
    this.getOriginWorld(raycastParams.myOrigin);
    this.getDirectionWorld(raycastParams.myDirection);
    raycastResults = PhysicsUtils.raycast(raycastParams, raycastResults, Globals.getPhysics(this._myEngine));
    return raycastResults;
  }
  getPositionScreen(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myInternalMousePosition[0];
    mousePosition[1] = this._myScreenSize[1] - 1 - this._myInternalMousePosition[1];
    return mousePosition;
  }
  getPositionScreenNormalized(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myScreenSize[0] == 0 ? 0 : this._myInternalMousePosition[0] / this._myScreenSize[0] * 2 - 1;
    mousePosition[1] = this._myScreenSize[1] == 0 ? 0 : (this._myScreenSize[1] - 1 - this._myInternalMousePosition[1]) / this._myScreenSize[1] * 2 - 1;
    return mousePosition;
  }
  getScreenSize() {
    return this._myScreenSize;
  }
  getPositionWorld(distanceFromCamera, out = vec3_create()) {
    let originWorld = this.getOriginWorld(this._myOriginWorld);
    let directionWorld = this.getDirectionWorld(this._myDirectionWorld);
    out = originWorld.vec3_add(directionWorld.vec3_scale(distanceFromCamera, out), out);
    return out;
  }
  getOriginWorld(out = vec3_create()) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getPosition(out);
    } else {
      Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getPosition(out);
    }
    return out;
  }
  getDirectionWorld(out = vec3_create()) {
    let right = this._myInternalMousePosition[0] / this._myScreenSize[0];
    let up = this._myInternalMousePosition[1] / this._myScreenSize[1];
    let directionLocal = out;
    directionLocal.vec3_set(right * 2 - 1, -up * 2 + 1, -1);
    let projectionMatrixInvert = this._myProjectionMatrixInverse;
    if (XRUtils.isSessionActive(this._myEngine)) {
      projectionMatrixInvert = Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getComponent(ViewComponent3).projectionMatrix.mat4_invert(projectionMatrixInvert);
    } else {
      projectionMatrixInvert = Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getComponent(ViewComponent3).projectionMatrix.mat4_invert(projectionMatrixInvert);
    }
    directionLocal.vec3_transformMat4(projectionMatrixInvert, directionLocal);
    directionLocal.vec3_normalize(directionLocal);
    let directionWorld = directionLocal;
    if (XRUtils.isSessionActive(this._myEngine)) {
      directionWorld = directionLocal.vec3_transformQuat(Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    } else {
      directionWorld = directionLocal.vec3_transformQuat(Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    }
    directionWorld.vec3_normalize(directionWorld);
    return out;
  }
  setTouchValid(touchValid) {
    let callbackID = "pp_internal_touch_valid_callback";
    if (touchValid) {
      this.removePointerEventValidCallback(callbackID);
    } else {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.pointerType == "mouse";
      });
    }
  }
  setTargetOnlyRenderCanvas(targetOnlyRenderCanvas) {
    let callbackID = "pp_internal_target_only_render_canvas_callback";
    if (targetOnlyRenderCanvas) {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.target == Globals.getCanvas(this._myEngine);
      });
    } else {
      this.removePointerEventValidCallback(callbackID);
    }
  }
  getLastValidPointerEvent() {
    return this._myLastValidPointerEvent;
  }
  // Can be used to specify that only some pointerType are valid (eg: mouse, touch, pen) or just some target (eg: Globals.getCanvas(this._myEngine))
  addPointerEventValidCallback(id, callback) {
    this._myPointerEventValidCallbacks[id] = callback;
    this._myPointerEventValidCallbacksIDs.push(id);
  }
  removePointerEventValidCallback(id) {
    delete this._myPointerEventValidCallbacks[id];
    this._myPointerEventValidCallbacksIDs.pp_removeEqual(id);
  }
  isPointerUpOnPointerLeave() {
    return this._myPointerUpOnPointerLeave;
  }
  setPointerUpOnPointerLeave(pointerUpOnPointerLeave) {
    this._myPointerUpOnPointerLeave = pointerUpOnPointerLeave;
  }
  isContextMenuActive() {
    return this._myContextMenuActive;
  }
  setContextMenuActive(active) {
    if (this._myContextMenuActive != active) {
      if (active) {
        Globals.getBody(this._myEngine).removeEventListener("contextmenu", this._myPreventContextMenuEventListener);
      } else {
        Globals.getBody(this._myEngine).addEventListener("contextmenu", this._myPreventContextMenuEventListener, false);
      }
      this._myContextMenuActive = active;
    }
  }
  isMiddleButtonScrollActive() {
    return this._myMiddleButtonScrollActive;
  }
  setMiddleButtonScrollActive(active) {
    if (this._myMiddleButtonScrollActive != active) {
      if (active) {
        Globals.getBody(this._myEngine).removeEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener);
      } else {
        Globals.getBody(this._myEngine).addEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener, false);
      }
      this._myMiddleButtonScrollActive = active;
    }
  }
  setResetMovingDelay(delay) {
    this._myResetMovingDelay = delay;
  }
  getResetMovingDelay() {
    return this._myResetMovingDelay;
  }
  _onPointerAction(actionCallback, event) {
    if (!this._isPointerEventIDValid(event))
      return;
    if (!this._isPointerEventValid(event)) {
      if (this._myInsideView) {
        this._onPointerLeave(event);
      }
      return;
    }
    if (!this._myInsideView) {
      this._onPointerEnter(event);
    }
    actionCallback(event);
    this._updatePositionAndScreen(event);
    this._updatePointerData(event);
  }
  _onMouseAction(actionCallback, event) {
    if (!this._myInsideView)
      return;
    if (!this._isMouseAllowed())
      return;
    if (!this._isPointerEventIDValid(this._myLastValidPointerEvent))
      return;
    if (!this._isPointerEventValid(this._myLastValidPointerEvent))
      return;
    actionCallback(event);
  }
  _onPointerMove(event) {
    this._myResetMovingTimer.start(this._myResetMovingDelay);
    this._myMoving = true;
  }
  _onPointerDown(event) {
    let buttonInfo = this._myButtonInfos[event.button];
    if (!buttonInfo.myPressed) {
      buttonInfo.myPressed = true;
      buttonInfo.myPressStartToProcess = true;
    }
  }
  _onPointerUp(event) {
    let buttonInfo = this._myButtonInfos[event.button];
    if (buttonInfo.myPressed) {
      buttonInfo.myPressed = false;
      buttonInfo.myPressEndToProcess = true;
    }
  }
  _onPointerLeave(event) {
    if (!this._myInsideView || this._myLastValidPointerEvent == null || event.pointerId != this._myLastValidPointerEvent.pointerId)
      return;
    this._myInsideView = false;
    this._myMoving = false;
    if (this._myPointerUpOnPointerLeave) {
      for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
        let id = this._myButtonInfosIDs[i];
        let buttonInfo = this._myButtonInfos[id];
        if (buttonInfo.myPressed) {
          buttonInfo.myPressed = false;
          buttonInfo.myPressEndToProcess = true;
        }
      }
    }
    this._myPointerID = null;
  }
  _onPointerEnter(event) {
    if (this._myInsideView && this._myPointerID != null || !this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    this._myInsideView = true;
    this._updatePositionAndScreen(event);
    this._updatePointerData(event);
  }
  _preventContextMenu(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    event.preventDefault();
  }
  _preventMiddleButtonScroll(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    if (event.button == 1) {
      event.preventDefault();
      return false;
    }
  }
  _updatePositionAndScreen(event) {
    this._updateScreenSize();
    this._myInternalMousePosition[0] = event.clientX;
    this._myInternalMousePosition[1] = event.clientY;
    this._myValid = true;
  }
  _updateScreenSize() {
    let bounds = Globals.getBody(this._myEngine).getBoundingClientRect();
    this._myScreenSize[0] = bounds.width;
    this._myScreenSize[1] = bounds.height;
  }
  _updatePointerData(event) {
    this._myPointerID = event.pointerId;
    this._myLastValidPointerEvent = event;
  }
  _isPointerEventIDValid(event) {
    if (event == null)
      return false;
    return this._myPointerID == null || this._myPointerID == event.pointerId;
  }
  _isPointerEventValid(event) {
    if (event == null)
      return false;
    let valid = true;
    for (let i = 0; i < this._myPointerEventValidCallbacksIDs.length; i++) {
      let id = this._myPointerEventValidCallbacksIDs[i];
      let callback = this._myPointerEventValidCallbacks[id];
      if (!callback(event)) {
        valid = false;
        break;
      }
    }
    return valid;
  }
  _isMouseAllowed() {
    return this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.pointerId == 1;
  }
  _createButtonInfo() {
    return { myPressed: false, myPressStart: false, myPressStartToProcess: false, myPressEnd: false, myPressEndToProcess: false };
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getBody(this._myEngine).removeEventListener("pointermove", this._myPointerMoveEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerleave", this._myPointerLeaveEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerenter", this._myPointerEnterEventListener);
    Globals.getBody(this._myEngine).removeEventListener("mousedown", this._myMouseDownEventListener);
    Globals.getBody(this._myEngine).removeEventListener("mouseup", this._myMouseUpEventListener);
    Globals.getBody(this._myEngine).removeEventListener("contextmenu", this._myPreventContextMenuEventListener);
    Globals.getBody(this._myEngine).removeEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/cauldron/input_manager.js
var InputManager = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myMouse = new Mouse(this._myEngine);
    this._myKeyboard = new Keyboard(this._myEngine);
    this._myHeadPose = new HeadPose(new BasePoseParams(this._myEngine));
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandPoses = [];
    this._myHandPoses[Handedness.LEFT] = new HandPose(Handedness.LEFT, new HandPoseParams(this._myEngine));
    this._myHandPoses[Handedness.RIGHT] = new HandPose(Handedness.RIGHT, new HandPoseParams(this._myEngine));
    this._myHandPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myTrackedHandPoses = [];
    this._myTrackedHandPoses[Handedness.LEFT] = new TrackedHandPose(Handedness.LEFT, new TrackedHandPoseParams(true, this._myEngine));
    this._myTrackedHandPoses[Handedness.RIGHT] = new TrackedHandPose(Handedness.RIGHT, new TrackedHandPoseParams(true, this._myEngine));
    this._myTrackedHandPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myTrackedHandPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myTrackedHandPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myTrackedHandPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myGamepadsManager = new GamepadsManager(this._myEngine);
    this._myStarted = false;
    this._myTrackedHandPosesEnabled = true;
    this._myTrackedHandPosesStarted = false;
    this._myPreUpdateEmitter = new Emitter7();
    this._myPostUpdateEmitter = new Emitter7();
    this._myDestroyed = false;
  }
  start() {
    this._myMouse.start();
    this._myKeyboard.start();
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHeadPose.start();
    for (let key in this._myHandPoses) {
      this._myHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandPoses[key].start();
    }
    if (this._myTrackedHandPosesEnabled) {
      this._startTrackedHandPoses();
    }
    this._myGamepadsManager.start();
    this._myStarted = true;
  }
  update(dt) {
    this._myPreUpdateEmitter.notify(dt, this);
    this._myMouse.update(dt);
    this._myKeyboard.update(dt);
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHeadPose.update(dt);
    for (let key in this._myHandPoses) {
      this._myHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandPoses[key].update(dt);
    }
    this._updateTrackedHandPoses();
    this._myGamepadsManager.update(dt);
    this._myPostUpdateEmitter.notify(dt, this);
  }
  getMouse() {
    return this._myMouse;
  }
  getKeyboard() {
    return this._myKeyboard;
  }
  getGamepadsManager() {
    return this._myGamepadsManager;
  }
  getHeadPose() {
    return this._myHeadPose;
  }
  getLeftHandPose() {
    return this._myHandPoses[Handedness.LEFT];
  }
  getRightHandPose() {
    return this._myHandPoses[Handedness.RIGHT];
  }
  getHandPose(handedness) {
    return this._myHandPoses[handedness];
  }
  getHandPoses() {
    return this._myHandPoses;
  }
  getLeftTrackedHandPose() {
    return this._myTrackedHandPoses[Handedness.LEFT];
  }
  getRightTrackedHandPose() {
    return this._myTrackedHandPoses[Handedness.RIGHT];
  }
  getTrackedHandPose(handedness) {
    return this._myTrackedHandPoses[handedness];
  }
  getTrackedHandPoses() {
    return this._myTrackedHandPoses;
  }
  areTrackedHandPosesEnabled() {
    return this._myTrackedHandPosesEnabled;
  }
  setTrackedHandPosesEnabled(enabled) {
    this._myTrackedHandPosesEnabled = enabled;
    if (this._myStarted && this._myTrackedHandPosesEnabled) {
      this._startTrackedHandPoses();
    }
  }
  registerPreUpdateCallback(id, callback) {
    this._myPreUpdateEmitter.add(callback, { id });
  }
  unregisterPreUpdateCallback(id) {
    this._myPreUpdateEmitter.remove(id);
  }
  registerPostUpdateCallback(id, callback) {
    this._myPostUpdateEmitter.add(callback, { id });
  }
  unregisterPostUpdateCallback(id) {
    this._myPostUpdateEmitter.remove(id);
  }
  _startTrackedHandPoses() {
    if (!this._myTrackedHandPosesStarted) {
      for (let key in this._myTrackedHandPoses) {
        this._myTrackedHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
        this._myTrackedHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
        this._myTrackedHandPoses[key].start();
      }
      this._myTrackedHandPosesStarted = true;
    }
  }
  _updateTrackedHandPoses(dt) {
    if (this._myTrackedHandPosesEnabled && this._myTrackedHandPosesStarted) {
      for (let key in this._myTrackedHandPoses) {
        this._myTrackedHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
        this._myTrackedHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
        this._myTrackedHandPoses[key].update(dt);
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myMouse.destroy();
    this._myKeyboard.destroy();
    this._myHeadPose.destroy();
    for (let key in this._myHandPoses) {
      this._myHandPoses[key].destroy();
    }
    for (let key in this._myTrackedHandPoses) {
      this._myTrackedHandPoses[key].destroy();
    }
    this._myGamepadsManager.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/cauldron/components/input_manager_component.js
var InputManagerComponent = class extends Component10 {
  static TypeName = "pp-input-manager";
  static Properties = {
    _myPoseForwardFixed: Property6.bool(true),
    _myPreventMouseContextMenu: Property6.bool(true),
    _myPreventMouseMiddleButtonScroll: Property6.bool(true),
    _myEnableTrackedHandPoses: Property6.bool(true)
  };
  init() {
    this._myInputManager = null;
    this._myPoseForwardFixedGlobal = null;
    if (!Globals.hasInputManager(this.engine)) {
      this._myInputManager = new InputManager(this.engine);
      this._myInputManager.setTrackedHandPosesEnabled(this._myEnableTrackedHandPoses);
      Globals.setInputManager(this._myInputManager, this.engine);
    }
    if (!Globals.hasPoseForwardFixed(this.engine)) {
      this._myPoseForwardFixedGlobal = this._myPoseForwardFixed;
      Globals.setPoseForwardFixed(this._myPoseForwardFixedGlobal, this.engine);
    }
  }
  start() {
    if (this._myInputManager != null) {
      this._myInputManager.start();
      this._setupMousePrevent();
      this._addGamepadCores();
    }
  }
  update(dt) {
    if (this._myInputManager != null) {
      this._myInputManager.update(dt);
    }
  }
  _setupMousePrevent() {
    if (this._myPreventMouseContextMenu) {
      this._myInputManager.getMouse().setContextMenuActive(false);
    }
    if (this._myPreventMouseMiddleButtonScroll) {
      this._myInputManager.getMouse().setMiddleButtonScrollActive(false);
    }
  }
  _addGamepadCores() {
    let leftHandPose = this._myInputManager.getLeftHandPose();
    let rightHandPose = this._myInputManager.getRightHandPose();
    let leftXRGamepadCore = new XRGamepadCore(leftHandPose);
    let rightXRGamepadCore = new XRGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_xr_gamepad", leftXRGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_xr_gamepad", rightXRGamepadCore);
    let leftKeyboardGamepadCore = new KeyboardGamepadCore(leftHandPose);
    let rightKeyboardGamepadCore = new KeyboardGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_keyboard_gamepad", leftKeyboardGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_keyboard_gamepad", rightKeyboardGamepadCore);
    let leftClassicGamepadCore = new ClassicGamepadCore(null, leftHandPose);
    let rightClassicGamepadCore = new ClassicGamepadCore(null, rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_classic_gamepad", leftClassicGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_classic_gamepad", rightClassicGamepadCore);
  }
  onDestroy() {
    if (this._myInputManager != null && Globals.getInputManager(this.engine) == this._myInputManager) {
      Globals.removeInputManager(this.engine);
      this._myInputManager.destroy();
    }
    if (this._myPoseForwardFixedGlobal != null && Globals.isPoseForwardFixed(this.engine) == this._myPoseForwardFixedGlobal) {
      Globals.removePoseForwardFixed(this.engine);
    }
  }
};

// dist/tool/cauldron/components/enable_tool_component.js
import { Component as Component11, Property as Property7 } from "@wonderlandengine/api";
var EnableToolComponent = class extends Component11 {
  static TypeName = "pp-enable-tools";
  static Properties = {
    _myEnable: Property7.bool(true)
  };
  init() {
    this._myToolEnabled = null;
    if (!Globals.hasToolEnabled(this.engine)) {
      this._myToolEnabled = this._myEnable;
      Globals.setToolEnabled(this._myToolEnabled, this.engine);
    }
  }
  onDestroy() {
    if (this._myToolEnabled != null && Globals.isToolEnabled(this.engine) == this._myToolEnabled) {
      Globals.removeToolEnabled(this.engine);
    }
  }
};

// dist/tool/console_vr/components/init_console_vr_component.js
import { Component as Component12, Property as Property8 } from "@wonderlandengine/api";

// dist/tool/console_vr/console_original_functions.js
var _myConsoleOriginalLog = console.log;
var _myConsoleOriginalError = console.error;
var _myConsoleOriginalWarn = console.warn;
var _myConsoleOriginalInfo = console.info;
var _myConsoleOriginalDebug = console.debug;
var _myConsoleOriginalAssert = console.assert;
var _myConsoleOriginalClear = console.clear;
function log2(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getLog(engine).apply(console, args);
}
function error2(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getError(engine).apply(console, args);
}
function warn2(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getWarn(engine).apply(console, args);
}
function info(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getInfo(engine).apply(console, args);
}
function debug(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getDebug(engine).apply(console, args);
}
function assert(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getAssert(engine).apply(console, args);
}
function clear3(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getClear(engine).apply(console, args);
}
function getLog(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalLog;
}
function getError(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalError;
}
function getWarn(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalWarn;
}
function getInfo(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalInfo;
}
function getDebug(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalDebug;
}
function getAssert(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalAssert;
}
function getClear(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalClear;
}
var ConsoleOriginalFunctions = {
  log: log2,
  error: error2,
  warn: warn2,
  info,
  debug,
  assert,
  clear: clear3,
  getLog,
  getError,
  getWarn,
  getInfo,
  getDebug,
  getAssert,
  getClear
};

// dist/tool/console_vr/console_vr.js
var ConsoleVR = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myForwardToBrowserConsole = true;
  }
  log(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.log(this._myEngine, ...args);
    }
  }
  error(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.error(this._myEngine, ...args);
    }
  }
  warn(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.warn(this._myEngine, ...args);
    }
  }
  info(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.info(this._myEngine, ...args);
    }
  }
  debug(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.debug(this._myEngine, ...args);
    }
  }
  assert(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.assert(this._myEngine, ...args);
    }
  }
  clear(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.clear(this._myEngine, ...args);
    }
  }
  setForwardToBrowserConsole(forwardToBrowserConsole) {
    this._myForwardToBrowserConsole = forwardToBrowserConsole;
  }
  isForwardToBrowserConsole() {
    return this._myForwardToBrowserConsole;
  }
};

// dist/tool/console_vr/components/init_console_vr_component.js
var InitConsoleVRComponent = class extends Component12 {
  static TypeName = "pp-init-console-vr";
  static Properties = {
    _myInit: Property8.bool(true)
  };
  init() {
    this._myConsoleVR = null;
    if (this._myInit) {
      if (!Globals.hasConsoleVR(this.engine)) {
        this._myConsoleVR = new ConsoleVR(this.engine);
        Globals.setConsoleVR(this._myConsoleVR, this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myConsoleVR != null && Globals.getConsoleVR(this.engine) == this._myConsoleVR) {
      Globals.removeConsoleVR(this.engine);
    }
  }
};

// dist/tool/easy_tune/components/init_easy_tune_variables_component.js
import { Component as Component13, Property as Property9 } from "@wonderlandengine/api";

// dist/tool/easy_tune/easy_tune_variables.js
var EasyTuneVariables = class {
  constructor() {
    this._myVariables = /* @__PURE__ */ new Map();
  }
  add(variable, overwriteCurrentOne = false) {
    if (overwriteCurrentOne || !this._myVariables.has(variable.getName())) {
      this._myVariables.set(variable.getName(), variable);
    }
  }
  remove(variableName) {
    this._myVariables.delete(variableName);
  }
  get(variableName) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      return variable.getValue();
    }
    return null;
  }
  set(variableName, value, resetDefaultValue = false) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      variable.setValue(value, resetDefaultValue);
    }
  }
  has(variableName) {
    return this._myVariables.has(variableName);
  }
  length() {
    return this._myVariables.size;
  }
  isWidgetCurrentVariable(variableName) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      return variable.isWidgetCurrentVariable();
    }
    return false;
  }
  getEasyTuneVariable(variableName) {
    return this._myVariables.get(variableName);
  }
  getEasyTuneVariablesList() {
    return Array.from(this._myVariables.values());
  }
  getEasyTuneVariablesNames() {
    return Array.from(this._myVariables.keys());
  }
  fromJSON(json, resetDefaultValue = false, manualImport = false) {
    let objectJSON = JSON.parse(json);
    for (let variable of this._myVariables.values()) {
      if (variable.isManualImportEnabled() && manualImport || variable.isAutoImportEnabled() && !manualImport) {
        let variableValueJSON = objectJSON[variable.getName()];
        if (variableValueJSON !== void 0) {
          variable.fromJSON(variableValueJSON, resetDefaultValue);
        }
      }
    }
  }
  toJSON() {
    let objectJSON = {};
    for (let variable of this._myVariables.values()) {
      if (variable.isExportEnabled()) {
        objectJSON[variable.getName()] = variable.toJSON();
      }
    }
    return JSON.stringify(objectJSON);
  }
  registerValueChangedEventListener(variableName, callbackID, callback) {
    this._myVariables.get(variableName).registerValueChangedEventListener(callbackID, callback);
  }
  unregisterValueChangedEventListener(variableName, callbackID, callback) {
    this._myVariables.get(variableName).unregisterValueChangedEventListener(callbackID);
  }
};

// dist/tool/easy_tune/components/init_easy_tune_variables_component.js
var InitEasyTuneVariablesComponent = class extends Component13 {
  static TypeName = "pp-init-easy-tune-variables";
  static Properties = {
    _myInit: Property9.bool(true)
  };
  init() {
    this._myEasyTuneVariables = null;
    if (this._myInit) {
      if (!Globals.hasEasyTuneVariables(this.engine)) {
        this._myEasyTuneVariables = new EasyTuneVariables();
        Globals.setEasyTuneVariables(this._myEasyTuneVariables, this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myEasyTuneVariables != null && Globals.getEasyTuneVariables(this.engine) == this._myEasyTuneVariables) {
      Globals.removeEasyTuneVariables(this.engine);
    }
  }
};

// dist/pp/components/add_pp_to_window_component.js
import { Component as Component14, Property as Property10 } from "@wonderlandengine/api";
var AddPPToWindowComponent = class extends Component14 {
  static TypeName = "pp-add-pp-to-window";
  static Properties = {
    _myAdd: Property10.bool(true)
  };
  init() {
    if (this._myAdd) {
      Globals.getWindow(this.engine).PP = {};
      this._addProperties(dist_exports);
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        Globals.getWindow(this.engine).PP[propertyName] = object[propertyName];
      }
    }
  }
  onDestroy() {
    Globals.getWindow(this.engine).PP = void 0;
  }
};

// dist/pp/components/get_default_resources_component.js
import { Component as Component15, Property as Property11 } from "@wonderlandengine/api";
var GetDefaultResourcesComponent = class extends Component15 {
  static TypeName = "pp-get-default-resources";
  static Properties = {
    _myPlane: Property11.mesh(),
    _myCube: Property11.mesh(),
    _mySphere: Property11.mesh(),
    _myCone: Property11.mesh(),
    _myCylinder: Property11.mesh(),
    _myCircle: Property11.mesh(),
    _myFlatOpaque: Property11.material(),
    _myFlatTransparentNoDepth: Property11.material(),
    _myPhongOpaque: Property11.material(),
    _myText: Property11.material()
  };
  init() {
    this._myDefaultResources = null;
    if (!Globals.hasDefaultResources(this.engine)) {
      this._myDefaultResources = new DefaultResources();
      this._myDefaultResources.myMeshes.myPlane = MeshUtils.clone(this._myPlane);
      this._myDefaultResources.myMeshes.myCube = MeshUtils.clone(this._myCube);
      this._myDefaultResources.myMeshes.mySphere = MeshUtils.clone(this._mySphere);
      this._myDefaultResources.myMeshes.myCone = MeshUtils.clone(this._myCone);
      this._myDefaultResources.myMeshes.myCylinder = MeshUtils.clone(this._myCylinder);
      this._myDefaultResources.myMeshes.myCircle = MeshUtils.clone(this._myCircle);
      this._myDefaultResources.myMeshes.myInvertedCube = MeshUtils.invert(this._myCube);
      this._myDefaultResources.myMeshes.myInvertedSphere = MeshUtils.invert(this._mySphere);
      this._myDefaultResources.myMeshes.myInvertedCone = MeshUtils.invert(this._myCone);
      this._myDefaultResources.myMeshes.myInvertedCylinder = MeshUtils.invert(this._myCylinder);
      this._myDefaultResources.myMeshes.myDoubleSidedPlane = MeshUtils.makeDoubleSided(this._myPlane);
      this._myDefaultResources.myMeshes.myDoubleSidedCube = MeshUtils.makeDoubleSided(this._myCube);
      this._myDefaultResources.myMeshes.myDoubleSidedSphere = MeshUtils.makeDoubleSided(this._mySphere);
      this._myDefaultResources.myMeshes.myDoubleSidedCone = MeshUtils.makeDoubleSided(this._myCone);
      this._myDefaultResources.myMeshes.myDoubleSidedCylinder = MeshUtils.makeDoubleSided(this._myCylinder);
      this._myDefaultResources.myMeshes.myDoubleSidedCircle = MeshUtils.makeDoubleSided(this._myCircle);
      if (this._myFlatOpaque != null) {
        this._myDefaultResources.myMaterials.myFlatOpaque = this._myFlatOpaque.clone();
      }
      if (this._myFlatTransparentNoDepth != null) {
        this._myDefaultResources.myMaterials.myFlatTransparentNoDepth = this._myFlatTransparentNoDepth.clone();
      }
      if (this._myPhongOpaque != null) {
        this._myDefaultResources.myMaterials.myPhongOpaque = this._myPhongOpaque.clone();
      }
      if (this._myText != null) {
        this._myDefaultResources.myMaterials.myText = this._myText.clone();
      }
      Globals.setDefaultResources(this._myDefaultResources, this.engine);
    }
  }
  onDestroy() {
    if (this._myDefaultResources != null && Globals.getDefaultResources(this.engine) == this._myDefaultResources) {
      Globals.removeDefaultResources(this.engine);
    }
  }
};

// dist/pp/components/get_scene_objects_component.js
import { Component as Component16, Property as Property12 } from "@wonderlandengine/api";
var GetSceneObjectsComponent = class extends Component16 {
  static TypeName = "pp-get-scene-objects";
  static Properties = {
    _myScene: Property12.object(),
    _myPlayer: Property12.object(),
    _myReferenceSpace: Property12.object(),
    // If u don't have a pivot under the player you set this to null, by default will be the same as the player
    _myCameraNonXR: Property12.object(),
    _myEyeLeft: Property12.object(),
    _myEyeRight: Property12.object(),
    _myHandLeft: Property12.object(),
    _myHandRight: Property12.object(),
    _myHead: Property12.object()
  };
  init() {
    this._mySceneObjects = null;
    if (!Globals.hasSceneObjects(this.engine)) {
      this._mySceneObjects = new SceneObjects();
      this._mySceneObjects.myScene = this._myScene;
      this._mySceneObjects.myPlayerObjects.myPlayer = this._myPlayer;
      this._mySceneObjects.myPlayerObjects.myReferenceSpace = this._myReferenceSpace;
      this._mySceneObjects.myPlayerObjects.myCameraNonXR = this._myCameraNonXR;
      this._mySceneObjects.myPlayerObjects.myEyeLeft = this._myEyeLeft;
      this._mySceneObjects.myPlayerObjects.myEyeRight = this._myEyeRight;
      this._mySceneObjects.myPlayerObjects.myHandLeft = this._myHandLeft;
      this._mySceneObjects.myPlayerObjects.myHandRight = this._myHandRight;
      this._mySceneObjects.myPlayerObjects.myEyes = [];
      this._mySceneObjects.myPlayerObjects.myEyes[Handedness.LEFT] = this._myEyeLeft;
      this._mySceneObjects.myPlayerObjects.myEyes[Handedness.RIGHT] = this._myEyeRight;
      this._mySceneObjects.myPlayerObjects.myHands = [];
      this._mySceneObjects.myPlayerObjects.myHands[Handedness.LEFT] = this._myHandLeft;
      this._mySceneObjects.myPlayerObjects.myHands[Handedness.RIGHT] = this._myHandRight;
      this._mySceneObjects.myPlayerObjects.myHead = this._myHead;
      if (this._mySceneObjects.myPlayerObjects.myReferenceSpace == null) {
        this._mySceneObjects.myPlayerObjects.myReferenceSpace = this._mySceneObjects.myPlayerObjects.myPlayer;
      }
      this._mySceneObjects.myCauldron = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myCauldron.pp_setName("Cauldron");
      this._mySceneObjects.myDynamics = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myDynamics.pp_setName("Dynamics");
      this._mySceneObjects.myParticles = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myParticles.pp_setName("Particles");
      this._mySceneObjects.myVisualElements = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myVisualElements.pp_setName("Visual Elements");
      this._mySceneObjects.myTools = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myTools.pp_setName("Tools");
      this._mySceneObjects.myPlayerObjects.myCauldron = this._mySceneObjects.myPlayerObjects.myPlayer.pp_addObject();
      this._mySceneObjects.myPlayerObjects.myCauldron.pp_setName("Cauldron");
      this._mySceneObjects.myPlayerObjects.myHeadDebugs = this._mySceneObjects.myPlayerObjects.myHead.pp_addObject();
      this._mySceneObjects.myPlayerObjects.myHeadDebugs.pp_setName("Head Debugs");
      Globals.setSceneObjects(this._mySceneObjects, this.engine);
    }
  }
  onDestroy() {
    if (this._mySceneObjects != null && Globals.getSceneObjects(this.engine) == this._mySceneObjects) {
      Globals.removeSceneObjects(this.engine);
    }
  }
};

// dist/pp/components/pp_gateway_component.js
var _myRegisteredEngines = /* @__PURE__ */ new WeakMap();
var PPGatewayComponent = class extends Component17 {
  static TypeName = "pp-gateway";
  static Properties = {
    _myEnableDebug: Property13.bool(true),
    _myEnableTool: Property13.bool(true),
    _myAddPPToWindow: Property13.bool(true),
    _myAddWLToWindow: Property13.bool(true),
    ...InputManagerComponent.Properties,
    ...AudioManagerComponent.Properties,
    ...VisualManagerComponent.Properties,
    ...CharacterCollisionSystemComponent.Properties,
    ...ObjectPoolManagerComponent.Properties,
    ...SaveManagerComponent.Properties,
    ...AnalyticsManagerComponent.Properties,
    ...DebugManagerComponent.Properties,
    ...GetSceneObjectsComponent.Properties,
    ...GetDefaultResourcesComponent.Properties
  };
  static onRegister(engine) {
    if (!_myRegisteredEngines.has(engine)) {
      _myRegisteredEngines.set(engine, null);
      initPP(engine);
    }
  }
  init() {
    this._myGetDefaultResourcesComponent = this.object.pp_addComponent(GetDefaultResourcesComponent, this._getProperties(GetDefaultResourcesComponent.Properties), false);
    this._myGetSceneObjectsComponent = this.object.pp_addComponent(GetSceneObjectsComponent, this._getProperties(GetSceneObjectsComponent.Properties), false);
    this._myEnableDebugComponent = null;
    if (this._myEnableDebug) {
      this._myEnableDebugComponent = this.object.pp_addComponent(EnableDebugComponent, false);
    }
    this._myEnableToolComponent = null;
    if (this._myEnableTool) {
      this._myEnableToolComponent = this.object.pp_addComponent(EnableToolComponent, false);
    }
    this._myAddPPToWindowComponent = null;
    if (this._myAddPPToWindow) {
      this._myAddPPToWindowComponent = this.object.pp_addComponent(AddPPToWindowComponent, false);
    }
    this._myAddWLToWindowComponent = null;
    if (this._myAddWLToWindow) {
      this._myAddWLToWindowComponent = this.object.pp_addComponent(AddWLToWindowComponent, false);
    }
    this._myInitConsoleVRComponent = this.object.pp_addComponent(InitConsoleVRComponent, false);
    this._myInitEasyTuneVariablesComponent = this.object.pp_addComponent(InitEasyTuneVariablesComponent, false);
    this._myObjectPoolManagerComponent = this.object.pp_addComponent(ObjectPoolManagerComponent, this._getProperties(ObjectPoolManagerComponent.Properties), false);
    this._myInputManagerComponent = this.object.pp_addComponent(InputManagerComponent, this._getProperties(InputManagerComponent.Properties), false);
    this._myAudioManagerComponent = this.object.pp_addComponent(AudioManagerComponent, this._getProperties(AudioManagerComponent.Properties), false);
    this._myVisualManagerComponent = this.object.pp_addComponent(VisualManagerComponent, this._getProperties(VisualManagerComponent.Properties), false);
    this._myCharacterCollisionSystemComponent = this.object.pp_addComponent(CharacterCollisionSystemComponent, this._getProperties(CharacterCollisionSystemComponent.Properties), false);
    this._mySaveManagerComponent = this.object.pp_addComponent(SaveManagerComponent, this._getProperties(SaveManagerComponent.Properties), false);
    this._myAnalyticsManagerComponent = this.object.pp_addComponent(AnalyticsManagerComponent, this._getProperties(AnalyticsManagerComponent.Properties), false);
    this._myDebugManagerComponent = this.object.pp_addComponent(DebugManagerComponent, this._getProperties(DebugManagerComponent.Properties), false);
  }
  start() {
    this._myGetDefaultResourcesComponent.active = true;
    this._myGetSceneObjectsComponent.active = true;
    if (this._myEnableDebugComponent != null) {
      this._myEnableDebugComponent.active = true;
    }
    if (this._myEnableToolComponent != null) {
      this._myEnableToolComponent.active = true;
    }
    if (this._myAddPPToWindowComponent != null) {
      this._myAddPPToWindowComponent.active = true;
    }
    if (this._myAddWLToWindowComponent != null) {
      this._myAddWLToWindowComponent.active = true;
    }
    this._myInitConsoleVRComponent.active = true;
    this._myInitEasyTuneVariablesComponent.active = true;
    this._myObjectPoolManagerComponent.active = true;
    this._myInputManagerComponent.active = true;
    this._myAudioManagerComponent.active = true;
    this._myVisualManagerComponent.active = true;
    this._myCharacterCollisionSystemComponent.active = true;
    this._mySaveManagerComponent.active = true;
    this._myAnalyticsManagerComponent.active = true;
    this._myDebugManagerComponent.active = true;
  }
  _getProperties(propertiesToGet) {
    let properties = {};
    let propertyNames = Object.getOwnPropertyNames(propertiesToGet);
    for (let propertyName of propertyNames) {
      if (this[propertyName] != void 0) {
        properties[propertyName] = this[propertyName];
      }
    }
    return properties;
  }
};

// dist/audio/audio_utils.js
import { Howler as Howler3 } from "howler";
function isPlaybackBlocked() {
  let blocked = false;
  if (Howler3 != null && Howler3.state != "running") {
    blocked = true;
  }
  return blocked;
}
var AudioUtils = {
  isPlaybackBlocked
};

// dist/audio/howler/howler_audio_player.js
var HowlerAudioPlayer = class extends AudioPlayer {
  constructor(howl, audioSetup = null) {
    super(audioSetup, howl);
    if (audioSetup == null) {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudioSetup.myLoop = this._myAudio._loop;
      this._myAudioSetup.myAutoPlay = this._myAudio._autoplay;
      this._myAudioSetup.myVolume = this._myAudio._volume;
      this._myAudioSetup.myRate = this._myAudio._rate;
      this._myAudioSetup.myPool = this._myAudio._pool;
      this._myAudioSetup.myPreload = this._myAudio._preload;
      this._myAudioSetup.myPosition = this._myAudio._pos != null ? this._myAudio._pos.vec3_clone() : null;
      this._myAudioSetup.mySpatial = this._myAudio._pos != null;
      this._myAudioSetup.myReferenceDistance = this._myAudio._pannerAttr.refDistance;
    } else {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudio.loop(this._myAudioSetup.myLoop);
      this._myAudio._autoplay = this._myAudioSetup.myAutoPlay;
      this._myAudio.volume(this._myAudioSetup.myVolume);
      this._myAudio.rate(this._myAudioSetup.myRate);
      this._myAudio._pool = this._myAudioSetup.myPool;
      this._myAudio._preload = this._myAudioSetup.myPreload;
      this.updatePosition(this._myAudioSetup.myPosition);
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
      if (this._myAudioSetup.myAutoPlay) {
        this._myAudio.play();
      }
    }
    this._addListeners();
  }
};

// dist/audio/components/mute_everything_component.js
import { Component as Component18 } from "@wonderlandengine/api";
import { Howler as Howler4 } from "howler";
var MuteEverythingComponent = class extends Component18 {
  static TypeName = "pp-mute-everything";
  static Properties = {};
  start() {
    Howler4.mute(true);
  }
};

// dist/audio/components/spatial_audio_listener_component.js
import { Component as Component19 } from "@wonderlandengine/api";
import { Howler as Howler5 } from "howler";
var SpatialAudioListenerComponent = class extends Component19 {
  static TypeName = "pp-spatial-audio-listener";
  static Properties = {};
  init() {
    this._myOrigin = vec3_create();
    this._myForward = vec3_create();
    this._myUp = vec3_create();
  }
  start() {
    this._updateAudioListener();
  }
  update(dt) {
    this._updateAudioListener();
  }
  _updateAudioListener() {
    this.object.pp_getPosition(this._myOrigin);
    this.object.pp_getForward(this._myForward);
    this.object.pp_getUp(this._myUp);
    Howler5.pos(this._myOrigin[0], this._myOrigin[1], this._myOrigin[2]);
    Howler5.orientation(this._myForward[0], this._myForward[1], this._myForward[2], this._myUp[0], this._myUp[1], this._myUp[2]);
  }
};

// dist/cauldron/benchmarks/benchmark_max_physx_component.js
import { Component as Component20, PhysXComponent as PhysXComponent3, Property as Property14, Shape } from "@wonderlandengine/api";

// dist/cauldron/physics/physics_collision_collector.js
import { CollisionEventType, Emitter as Emitter8, PhysXComponent as PhysXComponent2 } from "@wonderlandengine/api";
var PhysicsCollisionCollector = class {
  constructor(physXComponent, trigger = false) {
    this._myPhysX = physXComponent;
    this._myTrigger = trigger;
    this._myCollisions = [];
    this._myCollisionsStart = [];
    this._myCollisionsEnd = [];
    this._myUpdateActive = false;
    this._myCollisionsStartToProcess = [];
    this._myCollisionsEndToProcess = [];
    this._myCollisionCallbackID = null;
    this._myActive = false;
    this.setActive(true);
    this._myLogEnabled = false;
    this._myTriggerDesyncFixDelay = new Timer(0.1);
    this._myCollisionEmitter = new Emitter8();
    this._myCollisionStartEmitter = new Emitter8();
    this._myCollisionEndEmitter = new Emitter8();
    this._myDestroyed = false;
  }
  getPhysX() {
    return this._myPhysX;
  }
  getCollisions() {
    return this._myCollisions;
  }
  getCollisionsStart() {
    return this._myCollisionsStart;
  }
  getCollisionsEnd() {
    return this._myCollisionsEnd;
  }
  isActive() {
    return this._myActive;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      this._myCollisions.pp_clear();
      this._myCollisionsStart.pp_clear();
      this._myCollisionsEnd.pp_clear();
      this._myUpdateActive = false;
      this._myCollisionsStartToProcess.pp_clear();
      this._myCollisionsEndToProcess.pp_clear();
      if (this._myActive) {
        this._myCollisionCallbackID = this._myPhysX.onCollision(this._onCollision.bind(this));
      } else if (this._myCollisionCallbackID != null) {
        this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
        this._myCollisionCallbackID = null;
      }
    }
  }
  // Set to true only if u are going to actually update this object and don't want to lose any collision start/end events prior to updating the first time after activation
  setUpdateActive(active) {
    this._myUpdateActive = active;
  }
  // Update is not mandatory, use it only if u want to access collisions start and end
  update(dt) {
    if (!this._myActive) {
      return;
    }
    this._myUpdateActive = true;
    let prevCollisionsStartToProcess = this._myCollisionsStartToProcess;
    this._myCollisionsStartToProcess = this._myCollisionsStart;
    this._myCollisionsStartToProcess.pp_clear();
    this._myCollisionsStart = prevCollisionsStartToProcess;
    let prevCollisionsEndToProcess = this._myCollisionsEndToProcess;
    this._myCollisionsEndToProcess = this._myCollisionsEnd;
    this._myCollisionsEndToProcess.pp_clear();
    this._myCollisionsEnd = prevCollisionsEndToProcess;
    if (this._myTrigger) {
      this._triggerDesyncFix(dt);
    }
  }
  isLogEnabled() {
    return this._myLogEnabled;
  }
  setLogEnabled(enabled) {
    this._myLogEnabled = enabled;
  }
  registerCollisionEventListener(id, listener) {
    this._myCollisionEmitter.add(listener, { id });
  }
  unregisterCollisionEventListener(id) {
    this._myCollisionEmitter.remove(id);
  }
  registerCollisionStartEventListener(id, listener) {
    this._myCollisionStartEmitter.add(listener, { id });
  }
  unregisterCollisionStartEventListener(id) {
    this._myCollisionStartEmitter.remove(id);
  }
  registerCollisionEndEventListener(id, listener) {
    this._myCollisionEndEmitter.add(listener, { id });
  }
  unregisterCollisionEndEventListener(id) {
    this._myCollisionEndEmitter.remove(id);
  }
  _onCollision(type, physXComponent) {
    if (type == CollisionEventType.Touch || type == CollisionEventType.TriggerTouch) {
      this._onCollisionStart(type, physXComponent);
    } else if (type == CollisionEventType.TouchLost || type == CollisionEventType.TriggerTouchLost) {
      this._onCollisionEnd(type, physXComponent);
    }
    this._myCollisionEmitter.notify(this._myPhysX, physXComponent, type);
  }
  _onCollisionStart(type, physXComponent) {
    if (this._myLogEnabled) {
      let objectFound = false;
      for (let object of this._myCollisions) {
        if (object.pp_equals(physXComponent.object)) {
          objectFound = true;
          break;
        }
      }
      if (objectFound) {
        console.error("Collision Start on object already collected");
      }
    }
    this._myCollisions.push(physXComponent.object);
    if (this._myUpdateActive) {
      this._myCollisionsStartToProcess.push(physXComponent.object);
      this._myCollisionsEndToProcess.pp_removeAll(function(element) {
        return element.pp_equals(physXComponent.object);
      });
    }
    if (this._myLogEnabled) {
      console.log("Collision Start -", this._myCollisions.length);
    }
    this._myCollisionStartEmitter.notify(this._myPhysX, physXComponent, type);
  }
  _onCollisionEnd(type, physXComponent) {
    if (this._myLogEnabled) {
      let objectFound = false;
      for (let object of this._myCollisions) {
        if (object.pp_equals(physXComponent.object)) {
          objectFound = true;
          break;
        }
      }
      if (!objectFound) {
        console.error("Collision End on object not collected");
      }
    }
    this._myCollisions.pp_removeAll(function(element) {
      return element.pp_equals(physXComponent.object);
    });
    if (this._myUpdateActive) {
      this._myCollisionsEndToProcess.push(physXComponent.object);
      this._myCollisionsStartToProcess.pp_removeAll(function(element) {
        return element.pp_equals(physXComponent.object);
      });
    }
    if (this._myLogEnabled) {
      console.log("Collision End -", this._myCollisions.length);
    }
    this._myCollisionEndEmitter.notify(this._myPhysX, physXComponent, type);
  }
  _triggerDesyncFix(dt) {
  }
  destroy() {
    this._myDestroyed = true;
    if (this._myCollisionCallbackID != null) {
      this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
      this._myCollisionCallbackID = null;
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PhysicsCollisionCollector.prototype._triggerDesyncFix = function() {
  let findAllCallback = function(element) {
    let physX = element.pp_getComponentSelf(PhysXComponent2);
    return physX == null || !physX.active;
  };
  return function _triggerDesyncFix(dt) {
    this._myTriggerDesyncFixDelay.update(dt);
    if (this._myTriggerDesyncFixDelay.isDone()) {
      this._myTriggerDesyncFixDelay.start();
      let collisionsToEnd = this._myCollisions.pp_findAll(findAllCallback);
      if (collisionsToEnd.length > 0) {
        for (let i = 0; i < collisionsToEnd.length; i++) {
          let collision = collisionsToEnd[i];
          let physX = collision.pp_getComponentSelf(PhysXComponent2);
          if (physX) {
            this._onCollisionEnd(CollisionEventType.TriggerTouchLost, physX);
          } else {
            console.error("NO PHYSX, HOW?");
          }
        }
      }
    }
  };
}();

// dist/cauldron/benchmarks/benchmark_max_physx_component.js
var BenchmarkMaxPhysXComponent = class extends Component20 {
  static TypeName = "pp-benchmark-max-physx";
  static Properties = {
    _myStaticDomeSize: Property14.float(40),
    _myStaticPhysXCount: Property14.int(1e3),
    _myDynamicDomeSize: Property14.float(80),
    _myDynamicPhysXCount: Property14.int(250),
    _myKinematicDomeSize: Property14.float(120),
    _myKinematicPhysXCount: Property14.int(250),
    _myRaycastCount: Property14.int(100),
    _myVisualizeRaycast: Property14.bool(false),
    _myVisualizeRaycastDelay: Property14.float(0.5),
    // You can use this to test with convex mesh, 
    // but u first need to add a physx with a convex mesh to the scene and read the shapeData index on the component to set it as _myShapeIndex
    _myUseConvexMesh: Property14.bool(false),
    _myShapeIndex: Property14.int(0),
    _myShapeScaleMultiplier: Property14.float(1),
    // Used to adjust the scale of the convex mesh if too big or small based on how u imported it
    _myLogEnabled: Property14.bool(true),
    _myClearConsoleBeforeLog: Property14.bool(true)
  };
  start() {
    this._myValid = false;
    if (!Globals.isDebugEnabled(this.engine))
      return;
    this._myValid = true;
    this._myStarted = false;
    this._myPreStartTimer = new Timer(1);
  }
  _start() {
    this._myParentObject = this.object.pp_addObject();
    this._myRaycastParams = new RaycastParams(Globals.getPhysics(this.engine));
    this._myRaycastResults = new RaycastResults();
    this._myStaticPhysXObjects = [];
    this._myStaticPhysXComponents = [];
    this._myStaticPhysXCollectors = [];
    this._myDynamicPhysXObjects = [];
    this._myDynamicPhysXComponents = [];
    this._myDynamicPhysXCollectors = [];
    this._myKinematicPhysXObjects = [];
    this._myKinematicPhysXComponents = [];
    this._myKinematicPhysXCollectors = [];
    this._spawnDome(true, false);
    this._spawnDome(false, false);
    this._spawnDome(false, true);
    this._myStartTimer = new Timer(1);
    this._myTimer = new Timer(0);
    this._myDebugTimer = new Timer(this._myVisualizeRaycastDelay);
    this._myLogEnabledTimer = new Timer(1);
    this._myFPSHistory = [];
    for (let i = 0; i < 7; i++) {
      this._myFPSHistory.push(0);
    }
    this._myAddVelocityDelay = 10;
    this._myTranslateVec3 = vec3_create();
    this._myRotateVec3 = vec3_create();
    this._myStarted = true;
  }
  update(dt) {
    if (!this._myValid)
      return;
    if (!this._myStarted) {
      this._myPreStartTimer.update(dt);
      if (this._myPreStartTimer.isDone()) {
        this._start();
      }
    } else {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._myTimer.update(dt);
        this._myDebugTimer.update(dt);
        this._myLogEnabledTimer.update(dt);
        if (this._myTimer.isDone()) {
          this._myTimer.start();
          let debugEnabled = false;
          if (this._myDebugTimer.isDone()) {
            this._myDebugTimer.start();
            debugEnabled = true;
          }
          debugEnabled = debugEnabled && this._myVisualizeRaycast;
          this._raycastTest(debugEnabled);
        }
        this._myFPSHistory.pop();
        this._myFPSHistory.unshift(Math.round(1 / dt));
        if (this._myLogEnabled) {
          if (this._myLogEnabledTimer.isDone()) {
            this._myLogEnabledTimer.start();
            if (this._myClearConsoleBeforeLog) {
              console.clear();
            }
            console.log("Static PhysX Dome Size:", this._myStaticPhysXObjects.length);
            console.log("Dynamic PhysX Dome Size:", this._myDynamicPhysXObjects.length);
            console.log("Kinematic PhysX Dome Size:", this._myKinematicPhysXObjects.length);
            let staticCollisions = 0;
            for (let collector of this._myStaticPhysXCollectors) {
              staticCollisions += collector.getCollisions().length;
            }
            let dynamicCollisions = 0;
            for (let collector of this._myDynamicPhysXCollectors) {
              dynamicCollisions += collector.getCollisions().length;
            }
            let kinematicCollisions = 0;
            for (let collector of this._myKinematicPhysXCollectors) {
              kinematicCollisions += collector.getCollisions().length;
            }
            let totalCollisions = (staticCollisions + dynamicCollisions + kinematicCollisions) / 2;
            console.log("Current Collisions Count:", totalCollisions);
            console.log("Raycast Count:", this._myRaycastCount);
            console.log("FPS History:");
            let fpsString = "";
            for (let fps of this._myFPSHistory) {
              fpsString = fpsString.concat(fps, "\n");
            }
            console.log(fpsString);
          }
        }
      }
      if (this._myAddVelocityDelay > 0) {
        this._myAddVelocityDelay--;
        if (this._myAddVelocityDelay == 0) {
          for (let physX of this._myDynamicPhysXComponents) {
            physX.kinematic = false;
            let strength = 50;
            physX.linearVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
            physX.angularVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
          }
        }
      }
      for (let physX of this._myKinematicPhysXObjects) {
        let strength = 5 * dt;
        this._myTranslateVec3.vec3_set(Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength));
        physX.pp_translate(this._myTranslateVec3);
        let rotateStrength = 50 * dt;
        this._myRotateVec3.vec3_set(Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength));
        physX.pp_rotate(this._myRotateVec3);
      }
    }
  }
  _raycastTest(debugEnabled) {
    let raycastCount = this._myRaycastCount;
    let distance2 = 1e4;
    for (let i = 0; i < raycastCount; i++) {
      let origin = [Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign()];
      let direction = [Math.pp_random(-1, 1), Math.pp_random(-1, 1), Math.pp_random(-1, 1)];
      direction.vec3_normalize(direction);
      this._myRaycastParams.myOrigin.vec3_copy(origin);
      this._myRaycastParams.myDirection.vec3_copy(direction);
      this._myRaycastParams.myDistance = distance2;
      this._myRaycastParams.myBlockLayerFlags.setAllFlagsActive();
      let raycastResults = PhysicsUtils.raycast(this._myRaycastParams, this._myRaycastResults);
      if (debugEnabled && Globals.isDebugEnabled(this.engine)) {
        Globals.getDebugVisualManager(this.engine).drawRaycast(this._myDebugTimer.getDuration(), raycastResults, true, 5, 0.015);
      }
    }
  }
  _spawnDome(staticDome, dynamicDome) {
    let maxCount = this._myStaticPhysXCount;
    let physXList = this._myStaticPhysXObjects;
    let cloves = Math.ceil(Math.sqrt(this._myStaticPhysXCount));
    if (!staticDome) {
      if (dynamicDome) {
        cloves = Math.ceil(Math.sqrt(this._myDynamicPhysXCount));
        maxCount = this._myDynamicPhysXCount;
        physXList = this._myDynamicPhysXObjects;
      } else {
        cloves = Math.ceil(Math.sqrt(this._myKinematicPhysXCount));
        maxCount = this._myKinematicPhysXCount;
        physXList = this._myKinematicPhysXObjects;
      }
    }
    let angleForClove = Math.PI * 2 / cloves;
    let minDistance = Math.max(0, this._myStaticDomeSize - 20);
    let maxDistance = this._myStaticDomeSize + 20;
    if (!staticDome) {
      if (dynamicDome) {
        minDistance = Math.max(0, this._myDynamicDomeSize - 20);
        maxDistance = this._myDynamicDomeSize + 20;
      } else {
        minDistance = Math.max(0, this._myKinematicDomeSize - 20);
        maxDistance = this._myKinematicDomeSize + 20;
      }
    }
    let minExtraRotation = 0;
    let maxExtraRotation = Math.pp_toRadians(10);
    let upDirection = vec3_create(0, 1, 0);
    let horizontalDirection = vec3_create(0, 0, -1);
    for (let i = 0; i < cloves / 2; i++) {
      let verticalDirection = vec3_create(0, 1, 0);
      let rotationAxis = vec3_create();
      horizontalDirection.vec3_cross(verticalDirection, rotationAxis);
      rotationAxis.vec3_normalize(rotationAxis);
      for (let j = 0; j < cloves; j++) {
        if (physXList.length < maxCount) {
          let distance2 = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance2, physXDirection);
          this._addPhysX(physXDirection, staticDome, dynamicDome);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
        if (physXList.length < maxCount) {
          let distance2 = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance2, physXDirection);
          this._addPhysX(physXDirection, staticDome, dynamicDome);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
      }
      horizontalDirection.vec3_rotateAxisRadians(angleForClove, upDirection, horizontalDirection);
    }
  }
  _addPhysX(physXDirection, staticDome, dynamicDome) {
    let position = physXDirection;
    let scale4 = Math.pp_random(1, 10);
    let shape = Math.pp_randomPick(Shape.Sphere, Shape.Box);
    if (this._myUseConvexMesh) {
      shape = Shape.ConvexMesh;
      scale4 *= this._myShapeScaleMultiplier;
    }
    let physX = this._myParentObject.pp_addObject();
    physX.pp_setPosition(position);
    let physXComponent = physX.pp_addComponent(PhysXComponent3, {
      "shape": shape,
      "shapeData": { index: this._myShapeIndex },
      "extents": vec3_create(scale4, scale4, scale4),
      "static": staticDome,
      "kinematic": !dynamicDome,
      "mass": 1
    });
    if (staticDome) {
      this._myStaticPhysXObjects.push(physX);
      this._myStaticPhysXComponents.push(physXComponent);
      this._myStaticPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else if (dynamicDome) {
      this._myDynamicPhysXObjects.push(physX);
      this._myDynamicPhysXComponents.push(physXComponent);
      this._myDynamicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else {
      this._myKinematicPhysXObjects.push(physX);
      this._myKinematicPhysXComponents.push(physXComponent);
      this._myKinematicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    }
  }
  onDestroy() {
    for (let collector of this._myStaticPhysXCollectors) {
      collector.destroy();
    }
    for (let collector of this._myDynamicPhysXCollectors) {
      collector.destroy();
    }
    for (let collector of this._myKinematicPhysXCollectors) {
      collector.destroy();
    }
  }
};

// dist/cauldron/benchmarks/benchmark_max_visible_triangles_component.js
import { Alignment as Alignment3, Component as Component21, Justification as Justification3, MeshComponent as MeshComponent7, Property as Property15, TextComponent as TextComponent4 } from "@wonderlandengine/api";
var BenchmarkMaxVisibleTrianglesComponent = class extends Component21 {
  static TypeName = "pp-benchmark-max-visible-triangles";
  static Properties = {
    _myTargetFrameRate: Property15.int(-1),
    // -1 means it will auto detect it at start
    _myTargetFrameRateThreshold: Property15.int(3),
    _myStartPlaneCount: Property15.int(1),
    _myPlaneTriangles: Property15.int(100),
    _mySecondsBeforeDoubling: Property15.float(0.5),
    // Higher gives a better frame rate evaluation
    _myDTHistoryToIgnorePercentage: Property15.float(0.25),
    _myCloneMaterial: Property15.bool(false),
    _myCloneMesh: Property15.bool(false),
    _myLogEnabled: Property15.bool(true),
    _myStartOnXRStart: Property15.bool(false),
    _myDisplayInFrontOfPlayer: Property15.bool(true),
    _myDisplayInFrontOfPlayerDistance: Property15.float(10),
    _myPlaneMaterial: Property15.material(),
    _myBackgroundMaterial: Property15.material(),
    _myTextMaterial: Property15.material(null)
  };
  _start() {
    this._myBackgroundSize = 4;
    this._myBackgroundObject.pp_setActive(true);
    this._myBackgroundObject.pp_setScale(this._myBackgroundSize + 0.1);
    this._myBackgroundObject.pp_translateLocal(vec3_create(0, 0, -1e-3));
    this._myDoubleTimer = new Timer(this._mySecondsBeforeDoubling);
    this._myDone = false;
    this._myCurrentPlanes = this._myStartPlaneCount;
    this._myDTHistory = [];
    this._myUpperLimit = -1;
    this._myLowerLimit = 0;
    this._myPlanes = [];
    this._mySkipNextFrames = 0;
    this._myMaxWaitFrames = 0;
    this._myMaxPlanesReached = false;
    this._myFirstTime = true;
  }
  _update(dt) {
    {
      if (dt < 1e-5) {
        return;
      }
      if (dt > 0.5 && this._myMaxWaitFrames > 0) {
        this._myMaxWaitFrames--;
        return;
      }
      this._myMaxWaitFrames = 10;
      if (this._mySkipNextFrames > 0) {
        this._mySkipNextFrames--;
        return;
      }
    }
    if (!this._myDone) {
      this._myDoubleTimer.update(dt);
      this._myDTHistory.push(dt);
      if (this._myDoubleTimer.isDone()) {
        this._myDoubleTimer.start();
        let frameRate = this._computeAverageFrameRate(false);
        if (this._myFirstTime) {
          this._myFirstTime = false;
        } else {
          let lagging = false;
          if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
            this._myUpperLimit = this._myCurrentPlanes;
            lagging = true;
            if (this._myUpperLimit == 1) {
              this._myLowerLimit = 1;
            }
          } else {
            this._myLowerLimit = this._myCurrentPlanes;
            if (this._myUpperLimit > 0) {
              this._myUpperLimit = Math.max(this._myUpperLimit, this._myLowerLimit);
            }
          }
          this._myTriangleTextComponent.text = "Triangles: " + this._myCurrentPlanes * this._myRealTrianglesAmount;
          this._myPlaneTextComponent.text = "Planes: " + this._myCurrentPlanes;
          this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
          if (lagging) {
            this._myTriangleTextComponent.material.color = this._myLagColor;
            this._myPlaneTextComponent.material.color = this._myLagColor;
            this._myFPSTextComponent.material.color = this._myLagColor;
          } else {
            this._myTriangleTextComponent.material.color = this._myNormalColor;
            this._myPlaneTextComponent.material.color = this._myNormalColor;
            this._myFPSTextComponent.material.color = this._myNormalColor;
          }
          let reset12 = false;
          if (this._myUpperLimit > 0 && (!lagging && this._myUpperLimit - this._myLowerLimit <= Math.max(2, 1e3 / this._myRealTrianglesAmount)) || lagging && this._myUpperLimit - this._myLowerLimit <= 1 || !lagging && this._myMaxPlanesReached) {
            if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
              this._myLowerLimit = Math.max(1, Math.floor(this._myUpperLimit / 2.5));
              this._myUpperLimit = 0;
              reset12 = true;
              if (this._myLogEnabled) {
                console.log("Rst - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
              }
            } else {
              if (this._myMaxPlanesReached) {
                if (this._myLogEnabled) {
                  console.log("Aborted - Max Planes Reached");
                  this._myDoneTextComponent.text = "Aborted - Max Planes Reached";
                }
              } else {
                this._displayPlanes(this._myLowerLimit);
                if (this._myLogEnabled) {
                  console.log("\nEnd - Triangles:", this._myLowerLimit * this._myRealTrianglesAmount, "- Planes:", this._myLowerLimit, "- Frame Rate:", frameRate);
                  console.log("Plane Triangles (Adjusted):", this._myRealTrianglesAmount);
                  console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
                }
                this._myTriangleTextComponent.text = "Triangles: " + this._myLowerLimit * this._myRealTrianglesAmount;
                this._myPlaneTextComponent.text = "Planes: " + this._myLowerLimit;
                this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
                this._myDoneTextComponent.text = "End";
              }
              this._myDone = true;
            }
          }
          if (lagging && !reset12) {
            if (this._myLogEnabled) {
              console.log("Lag - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
            }
          }
          if (!this._myDone) {
            if (this._myUpperLimit > 0) {
              this._myCurrentPlanes = Math.floor((this._myUpperLimit + this._myLowerLimit) / 2);
              this._myCurrentPlanes = Math.max(this._myCurrentPlanes, 1);
            } else if (!reset12) {
              this._myCurrentPlanes = this._myLowerLimit * 2;
            } else {
              this._myCurrentPlanes = this._myLowerLimit;
            }
            if (this._myCurrentPlanes > 5e4) {
              this._myCurrentPlanes = 5e4;
              this._myMaxPlanesReached = true;
            } else {
              this._myMaxPlanesReached = false;
            }
          }
        }
        if (!this._myDone) {
          this._displayPlanes(this._myCurrentPlanes);
          this._myElapsedTime = 0;
          this._myFrameCount = 0;
          this._mySkipNextFrames = 30;
        }
      }
    }
  }
  _displayPlanes(count) {
    while (this._myPlanes.length > count) {
      let plane = this._myPlanes.pop();
      Globals.getObjectPoolManager(this.engine).release(this._myPoolID, plane);
    }
    while (this._myPlanes.length < count) {
      let plane = Globals.getObjectPoolManager(this.engine).get(this._myPoolID);
      this._myPlanes.push(plane);
    }
    let gridSize = 1;
    while (gridSize * gridSize < count) {
      gridSize++;
    }
    let spaceBetween = 0.01;
    let totalSpaceBetween = spaceBetween * (gridSize - 1);
    let planeSize = (this._myBackgroundSize * 2 - totalSpaceBetween) / (gridSize * 2);
    let currentCount = count;
    for (let i = 0; i < gridSize && currentCount > 0; i++) {
      for (let j = 0; j < gridSize && currentCount > 0; j++) {
        let plane = this._myPlanes[currentCount - 1];
        plane.pp_setScale(planeSize);
        let position = [-this._myBackgroundSize + planeSize + j * planeSize * 2 + j * spaceBetween, this._myBackgroundSize - planeSize - i * planeSize * 2 - i * spaceBetween, 0];
        plane.pp_setPositionLocal(position);
        plane.pp_setActive(true);
        currentCount--;
      }
    }
  }
  start() {
    this._myValid = false;
    if (!Globals.isDebugEnabled(this.engine))
      return;
    this._myValid = true;
    if (this._myPlaneMaterial == null) {
      this._myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myPhongOpaque.clone();
      this._myPlaneMaterial.diffuseColor = vec4_create(0.95, 0.95, 0.95, 1);
      this._myPlaneMaterial.ambientColor = vec4_create(0, 0, 0, 1);
      this._myPlaneMaterial.ambientFactor = 0.5;
    }
    if (this._myBackgroundMaterial == null) {
      this._myBackgroundMaterial = Globals.getDefaultMaterials(this.engine).myPhongOpaque.clone();
      this._myBackgroundMaterial.diffuseColor = vec4_create(0.25, 0.25, 0.25, 1);
      this._myBackgroundMaterial.ambientColor = vec4_create(0, 0, 0, 1);
      this._myBackgroundMaterial.ambientFactor = 0.5;
    }
    if (this._myTextMaterial == null) {
      this._myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
    }
    this._myLagColor = vec4_create(0.6, 0, 0, 1);
    this._myNormalColor = vec4_create(0.25, 0.25, 0.25, 1);
    this._myRealTrianglesAmount = 0;
    let parent = this.object;
    if (this._myDisplayInFrontOfPlayer) {
      parent = Globals.getPlayerObjects(this.engine).myHead.pp_addObject();
      parent.pp_rotateAxis(180, vec3_create(0, 1, 0));
      parent.pp_translateLocal(vec3_create(0, 0, this._myDisplayInFrontOfPlayerDistance));
    }
    this._myTrianglesObject = parent.pp_addObject();
    this._myBackgroundObject = this._myTrianglesObject.pp_addObject();
    {
      let meshComponent = this._myBackgroundObject.pp_addComponent(MeshComponent7);
      meshComponent.mesh = MeshUtils.createPlane(this.engine);
      meshComponent.material = this._myBackgroundMaterial.clone();
    }
    this._myPlaneObject = this._myTrianglesObject.pp_addObject();
    {
      let meshComponent = this._myPlaneObject.pp_addComponent(MeshComponent7);
      meshComponent.mesh = this._createPlaneMesh(this._myPlaneTriangles);
      this._myRealTrianglesAmount = meshComponent.mesh.indexData.length / 3;
      meshComponent.material = this._myPlaneMaterial.clone();
    }
    let poolParams = new ObjectPoolParams();
    if (!this._myCloneMesh) {
      poolParams.myInitialPoolSize = 3e4;
    } else {
      if (this._myRealTrianglesAmount <= 4) {
        poolParams.myInitialPoolSize = 15e3;
      } else if (this._myRealTrianglesAmount <= 8) {
        poolParams.myInitialPoolSize = 1e4;
      } else if (this._myRealTrianglesAmount <= 64) {
        poolParams.myInitialPoolSize = 7500;
      } else {
        poolParams.myInitialPoolSize = 5e3;
      }
    }
    poolParams.myPercentageToAddWhenEmpty = 0;
    poolParams.myAmountToAddWhenEmpty = 1e4;
    poolParams.myCloneParams = new CloneParams();
    poolParams.myCloneParams.myComponentDeepCloneParams.setDeepCloneComponentVariable(MeshComponent7.TypeName, "material", this._myCloneMaterial);
    poolParams.myCloneParams.myComponentDeepCloneParams.setDeepCloneComponentVariable(MeshComponent7.TypeName, "mesh", this._myCloneMesh);
    this._myPoolID = this.type + "_" + Math.pp_randomUUID();
    Globals.getObjectPoolManager(this.engine).addPool(this._myPoolID, new ObjectPool(this._myPlaneObject, poolParams));
    this._myBackgroundObject.pp_setActive(false);
    this._myPlaneObject.pp_setActive(false);
    this._myStartTimer = new Timer(2);
    this._mySessionStarted = false;
    this._myTextsObject = this._myTrianglesObject.pp_addObject();
    this._myTriangleTextObject = this._myTextsObject.pp_addObject();
    this._myTriangleTextComponent = this._myTriangleTextObject.pp_addComponent(TextComponent4);
    this._myTriangleTextComponent.alignment = Alignment3.Left;
    this._myTriangleTextComponent.justification = Justification3.Line;
    this._myTriangleTextComponent.material = this._myTextMaterial.clone();
    this._myTriangleTextComponent.material.color = this._myNormalColor;
    this._myTriangleTextComponent.text = " ";
    this._myPlaneTextObject = this._myTextsObject.pp_addObject();
    this._myPlaneTextComponent = this._myPlaneTextObject.pp_addComponent(TextComponent4);
    this._myPlaneTextComponent.alignment = Alignment3.Left;
    this._myPlaneTextComponent.justification = Justification3.Line;
    this._myPlaneTextComponent.material = this._myTextMaterial.clone();
    this._myPlaneTextComponent.material.color = this._myNormalColor;
    this._myPlaneTextComponent.text = " ";
    this._myFPSTextObject = this._myTextsObject.pp_addObject();
    this._myFPSTextComponent = this._myFPSTextObject.pp_addComponent(TextComponent4);
    this._myFPSTextComponent.alignment = Alignment3.Left;
    this._myFPSTextComponent.justification = Justification3.Line;
    this._myFPSTextComponent.material = this._myTextMaterial.clone();
    this._myFPSTextComponent.material.color = this._myNormalColor;
    this._myFPSTextComponent.text = " ";
    this._myDoneTextObject = this._myTrianglesObject.pp_addObject();
    this._myDoneTextComponent = this._myDoneTextObject.pp_addComponent(TextComponent4);
    this._myDoneTextComponent.alignment = Alignment3.Center;
    this._myDoneTextComponent.justification = Justification3.Line;
    this._myDoneTextComponent.material = this._myTextMaterial.clone();
    this._myDoneTextComponent.material.color = this._myNormalColor;
    this._myDoneTextComponent.text = " ";
    this._myTextsObject.pp_setPositionLocal(vec3_create(0, 4.3, 0));
    this._myTextsObject.pp_setScale(2.75);
    this._myTriangleTextObject.pp_setPositionLocal(vec3_create(-1.4, 0, 0));
    this._myPlaneTextObject.pp_setPositionLocal(vec3_create(0.55, 0, 0));
    this._myFPSTextObject.pp_setPositionLocal(vec3_create(-0.315, 0, 0));
    this._myDoneTextObject.pp_setPositionLocal(vec3_create(0, -4.6, 0));
    this._myDoneTextObject.pp_setScale(4);
    this._myDTHistory = [];
    this._myFramesToSkip = 10;
  }
  update(dt) {
    if (!this._myValid)
      return;
    if (this._myFramesToSkip == 0) {
      if (this._mySessionStarted || !this._myStartOnXRStart) {
        if (this._myStartTimer.isRunning()) {
          this._myStartTimer.update(dt);
          this._myDTHistory.push(dt);
          if (this._myStartTimer.isDone()) {
            this._myStableFrameRate = this._computeAverageFrameRate(true);
            if (this._myTargetFrameRate > 0) {
              this._myStableFrameRate = this._myTargetFrameRate;
            }
            if (this._myLogEnabled) {
              console.log("\nPlane Triangles (Adjusted):", this._myRealTrianglesAmount);
              console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
              console.log("");
            }
            this._start();
          }
        } else {
          this._update(dt);
        }
      } else {
        this._mySessionStarted = XRUtils.getSession(this.engine) != null;
      }
    } else {
      this._myFramesToSkip--;
    }
  }
  _computeAverageFrameRate(firstCompute) {
    let frameRate = 0;
    this._myDTHistory.sort();
    let elementsToRemove = Math.floor(this._myDTHistory.length * Math.min(0.9, this._myDTHistoryToIgnorePercentage * (firstCompute ? 2 : 1)));
    for (let i = 0; i < elementsToRemove && this._myDTHistory.length > 1; i++) {
      this._myDTHistory.pop();
    }
    let averageDT = 0;
    for (let dt of this._myDTHistory) {
      averageDT += dt;
    }
    averageDT /= this._myDTHistory.length;
    frameRate = Math.round(1 / averageDT);
    this._myDTHistory = [];
    return frameRate;
  }
  _createPlaneMesh(trianglesAmount) {
    let squaresAmount = Math.ceil(trianglesAmount / 2);
    let row = 1;
    let column = 1;
    let closestSqrt = 1;
    while (closestSqrt * closestSqrt < squaresAmount) {
      closestSqrt++;
    }
    row = closestSqrt;
    column = closestSqrt;
    while (row > 1 && column > 1 && row * column > squaresAmount && (row - 1) * column >= squaresAmount) {
      row--;
    }
    let meshCreationParams = new MeshCreationParams(this.engine);
    for (let i = 0; i < row + 1; i++) {
      for (let j = 0; j < column + 1; j++) {
        let x = 2 / column * j;
        let y = 2 / row * i;
        let vertexCreationParams = new MeshCreationVertexParams();
        vertexCreationParams.myPosition = vec3_create();
        vertexCreationParams.myPosition[0] = x - 1;
        vertexCreationParams.myPosition[1] = y - 1;
        vertexCreationParams.myPosition[2] = 0;
        vertexCreationParams.myTextureCoordinates = vec2_create();
        vertexCreationParams.myTextureCoordinates[0] = x / 2;
        vertexCreationParams.myTextureCoordinates[1] = y / 2;
        vertexCreationParams.myNormal = vec3_create();
        vertexCreationParams.myNormal[0] = 0;
        vertexCreationParams.myNormal[1] = 0;
        vertexCreationParams.myNormal[2] = 1;
        meshCreationParams.myVertexes.push(vertexCreationParams);
      }
    }
    for (let i = 0; i < row; i++) {
      for (let j = 0; j < column; j++) {
        let firstTriangle = new MeshCreationTriangleParams();
        firstTriangle.myIndexes[0] = i * (column + 1) + j;
        firstTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        firstTriangle.myIndexes[2] = (i + 1) * (column + 1) + j;
        let secondTriangle = new MeshCreationTriangleParams();
        secondTriangle.myIndexes[0] = (i + 1) * (column + 1) + j;
        secondTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        secondTriangle.myIndexes[2] = (i + 1) * (column + 1) + j + 1;
        meshCreationParams.myTriangles.push(firstTriangle);
        meshCreationParams.myTriangles.push(secondTriangle);
      }
    }
    let mesh = MeshUtils.create(meshCreationParams);
    return mesh;
  }
  onDestroy() {
    Globals.getObjectPoolManager(this.engine)?.destroyPool(this._myPoolID);
  }
};

// dist/cauldron/components/clear_console_on_xr_session_start_component.js
import { Component as Component22, Property as Property16 } from "@wonderlandengine/api";
var ClearConsoleOnXRSessionStartComponent = class extends Component22 {
  static TypeName = "pp-clear-console-on-xr-session-start";
  static Properties = {
    _myFirstTimeOnly: Property16.bool(true)
  };
  start() {
    this._myFirstTime = true;
    XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, false, this.engine);
  }
  _onXRSessionStart() {
    if (!this._myFirstTimeOnly || this._myFirstTime) {
      this._myFirstTime = false;
      console.clear();
    }
  }
  onDestroy() {
    XRUtils.unregisterSessionStartEventListener(this, this.engine);
  }
};

// dist/cauldron/components/set_active_component.js
import { Component as Component23, Property as Property17 } from "@wonderlandengine/api";
var SetActiveComponent = class extends Component23 {
  static TypeName = "pp-set-active";
  static Properties = {
    _myActive: Property17.bool(true),
    _mySetActiveOn: Property17.enum(["Self", "Children", "Descendants", "Hierarchy"], "Hierarchy"),
    _mySetActiveWhen: Property17.enum(["Init", "Start", "First Update", "Enter XR", "Exit XR", "First Enter XR", "First Exit XR"], "Init")
  };
  init() {
    if (this.active && this._mySetActiveWhen == 0) {
      this._setActive();
    }
  }
  start() {
    if (this._mySetActiveWhen == 1) {
      this._setActive();
    }
    this._myFirstUpdate = true;
    this._myFirstXRStart = true;
    this._myFirstXREnd = true;
    if (this._mySetActiveWhen == 3 || this._mySetActiveWhen == 5) {
      XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, true, this.engine);
    }
    if (this._mySetActiveWhen == 4 || this._mySetActiveWhen == 6) {
      XRUtils.registerSessionEndEventListener(this, this._onXRSessionEnd.bind(this), this.engine);
    }
  }
  update(dt) {
    if (this._mySetActiveWhen == 2 && this._myFirstUpdate) {
      this._setActive();
    }
    this._myFirstUpdate = false;
  }
  _onXRSessionStart() {
    if (this._mySetActiveWhen == 3 || this._mySetActiveWhen == 5 && this._myFirstXRStart) {
      this._setActive();
    }
    this._myFirstXRStart = false;
  }
  _onXRSessionEnd() {
    if (this._mySetActiveWhen == 4 || this._mySetActiveWhen == 6 && this._myFirstXREnd) {
      this._setActive();
    }
    this._myFirstXREnd = false;
  }
  _setActive() {
    if (this._mySetActiveOn == 0) {
      this.object.pp_setActiveSelf(this._myActive);
    } else if (this._mySetActiveOn == 1) {
      this.object.pp_setActiveChildren(this._myActive);
    } else if (this._mySetActiveOn == 2) {
      this.object.pp_setActiveDescendants(this._myActive);
    } else {
      this.object.pp_setActive(this._myActive);
    }
  }
  onDestroy() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
};

// dist/cauldron/components/adjust_hierarchy_physx_scale_component.js
import { Component as Component24, PhysXComponent as PhysXComponent4, Property as Property18 } from "@wonderlandengine/api";
var AdjustHierarchyPhysXScaleComponent = class extends Component24 {
  static TypeName = "pp-adjust-hierarchy-physx-scale";
  static Properties = {
    _myWhen: Property18.enum(["Init", "Start", "First Update"], "Start")
  };
  init() {
    if (this.active && this._myWhen == 0) {
      this._adjustScale();
    }
  }
  start() {
    if (this._myWhen == 1) {
      this._adjustScale();
    }
    this._myFirst = true;
  }
  update(dt) {
    if (this._myWhen == 2 && this._myFirst) {
      this._myFirst = false;
      this._adjustScale();
    }
  }
  _adjustScale() {
    let scale4 = this.object.pp_getScale();
    let physXComponents = this.object.pp_getComponents(PhysXComponent4);
    for (let physX of physXComponents) {
      physX.extents[0] = physX.extents[0] * scale4[0];
      physX.extents[1] = physX.extents[1] * scale4[1];
      physX.extents[2] = physX.extents[2] * scale4[2];
      if (physX.active) {
        physX.active = false;
        physX.active = true;
      }
    }
  }
};

// dist/cauldron/components/show_fps_component.js
import { Alignment as Alignment4, Component as Component25, Justification as Justification4, Property as Property19 } from "@wonderlandengine/api";
var ShowFPSComponent = class extends Component25 {
  static TypeName = "pp-show-fps";
  static Properties = {
    _myRefreshSeconds: Property19.float(0.25),
    _myScreenPositionX: Property19.float(1),
    _myScreenPositionY: Property19.float(-1),
    _myScreenPositionZ: Property19.float(1),
    _myScale: Property19.float(1.5),
    _myTextMaterial: Property19.material()
  };
  start() {
    this._myColor = vec4_create(1, 1, 1, 1);
    if (this._myTextMaterial != null) {
      this._myColor.vec4_copy(this._myTextMaterial.color);
    }
    this._myScreenPosition = vec3_create(this._myScreenPositionX, this._myScreenPositionY, this._myScreenPositionZ);
    this._myCurrentFPS = 0;
    this._myTimer = new Timer(this._myRefreshSeconds);
    this._myTotalDT = 0;
    this._myFrames = 0;
  }
  update(dt) {
    if (Globals.isDebugEnabled(this.engine)) {
      this._myTotalDT += dt;
      this._myFrames++;
      this._myTimer.update(dt);
      if (this._myTimer.isDone()) {
        this._myTimer.start();
        this._myCurrentFPS = Math.round(this._myFrames / this._myTotalDT);
        this._myTotalDT = 0;
        this._myFrames = 0;
      }
      Globals.getDebugVisualManager(this.engine).drawUIText(0, this._myCurrentFPS.toFixed(0), this._myScreenPosition, this._myScale, this._myColor, Alignment4.Right, Justification4.Bottom);
    }
  }
};

// dist/cauldron/fsm/fsm.js
import { Emitter as Emitter9 } from "@wonderlandengine/api";
var StateData = class {
  constructor(stateID, stateObject) {
    this.myID = stateID;
    this.myObject = stateObject;
  }
};
var TransitionData = class {
  constructor(transitionID, fromStateData, toStateData, transitionObject, skipStateFunction) {
    this.myID = transitionID;
    this.myFromState = fromStateData;
    this.myToState = toStateData;
    this.myObject = transitionObject;
    this.mySkipStateFunction = skipStateFunction;
  }
};
var PerformMode = {
  IMMEDIATE: 0,
  DELAYED: 1
};
var PerformDelayedMode = {
  QUEUE: 0,
  KEEP_FIRST: 1,
  KEEP_LAST: 2
};
var SkipStateFunction = {
  NONE: 0,
  END: 1,
  START: 2,
  BOTH: 3
};
var FSM = class _FSM {
  constructor(performMode = PerformMode.IMMEDIATE, performDelayedMode = PerformDelayedMode.QUEUE) {
    this._myCurrentStateData = null;
    this._myStates = /* @__PURE__ */ new Map();
    this._myTransitions = /* @__PURE__ */ new Map();
    this._myLogEnabled = false;
    this._myLogShowDelayedInfo = false;
    this._myLogFSMName = "FSM";
    this._myPerformMode = performMode;
    this._myPerformDelayedMode = performDelayedMode;
    this._myPendingPerforms = [];
    this._myCurrentlyPerformedTransition = null;
    this._myInitEmitter = new Emitter9();
    this._myInitIDEmitters = /* @__PURE__ */ new Map();
    this._myTransitionEmitter = new Emitter9();
    this._myTransitionIDEmitters = [];
  }
  addState(stateID, state = null) {
    let stateObject = null;
    if (!state || typeof state == "function") {
      stateObject = {};
      if (typeof state == "function") {
        stateObject.update = function update() {
          return state(...arguments);
        };
      } else {
        stateObject.update = null;
      }
      stateObject.clone = function clone10() {
        let cloneObject = {};
        cloneObject.update = this.update;
        cloneObject.clone = this.clone;
        return cloneObject;
      };
    } else {
      stateObject = state;
    }
    let stateData = new StateData(stateID, stateObject);
    this._myStates.set(stateID, stateData);
    this._myTransitions.set(stateID, /* @__PURE__ */ new Map());
  }
  addTransition(fromStateID, toStateID, transitionID, transition = null, skipStateFunction = SkipStateFunction.NONE) {
    let transitionObject = null;
    if (!transition || typeof transition == "function") {
      transitionObject = {};
      if (typeof transition == "function") {
        transitionObject.perform = function perform() {
          return transition(...arguments);
        };
      } else {
        transitionObject.perform = null;
      }
      transitionObject.clone = function clone10() {
        let cloneObject = {};
        cloneObject.perform = this.perform;
        cloneObject.clone = this.clone;
        return cloneObject;
      };
    } else {
      transitionObject = transition;
    }
    if (this.hasState(fromStateID) && this.hasState(toStateID)) {
      let transitionsFromState = this._getTransitionsFromState(fromStateID);
      let transitionData = new TransitionData(transitionID, this.getState(fromStateID), this.getState(toStateID), transitionObject, skipStateFunction);
      transitionsFromState.set(transitionID, transitionData);
    } else {
      if (!this.hasState(fromStateID) && !this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID, "- to state not found:", toStateID);
      } else if (!this.hasState(fromStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID);
      } else if (!this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- to state not found:", toStateID);
      }
    }
  }
  init(initStateID, initTransition = null, ...args) {
    let initTransitionObject = initTransition;
    if (initTransition && typeof initTransition == "function") {
      initTransitionObject = {};
      initTransitionObject.performInit = initTransition;
    }
    if (this.hasState(initStateID)) {
      let initStateData = this._myStates.get(initStateID);
      if (this._myLogEnabled) {
        console.log(this._myLogFSMName, "- Init:", initStateID);
      }
      if (initTransitionObject && initTransitionObject.performInit) {
        initTransitionObject.performInit(this, initStateData, ...args);
      } else if (initStateData.myObject && initStateData.myObject.init) {
        initStateData.myObject.init(this, initStateData, ...args);
      }
      this._myCurrentStateData = initStateData;
      this._myInitEmitter.notify(this, initStateData, initTransitionObject, ...args);
      if (this._myInitIDEmitters.size > 0) {
        let emitter = this._myInitIDEmitters.get(initStateID);
        if (emitter != null) {
          emitter.notify(this, initStateData, initTransitionObject, ...args);
        }
      }
    } else if (this._myLogEnabled) {
      console.warn(this._myLogFSMName, "- Init state not found:", initStateID);
    }
  }
  update(dt, ...args) {
    if (this._myPendingPerforms.length > 0) {
      for (let i = 0; i < this._myPendingPerforms.length; i++) {
        this._perform(this._myPendingPerforms[i].myID, PerformMode.DELAYED, ...this._myPendingPerforms[i].myArgs);
      }
      this._myPendingPerforms = [];
    }
    if (this._myCurrentStateData && this._myCurrentStateData.myObject && this._myCurrentStateData.myObject.update) {
      this._myCurrentStateData.myObject.update(dt, this, ...args);
    }
  }
  perform(transitionID, ...args) {
    if (this._myPerformMode == PerformMode.DELAYED) {
      this.performDelayed(transitionID, ...args);
    } else {
      this.performImmediate(transitionID, ...args);
    }
  }
  performDelayed(transitionID, ...args) {
    let performDelayed = false;
    switch (this._myPerformDelayedMode) {
      case PerformDelayedMode.QUEUE:
        this._myPendingPerforms.push(new _PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
      case PerformDelayedMode.KEEP_FIRST:
        if (!this.hasPendingPerforms()) {
          this._myPendingPerforms.push(new _PendingPerform(transitionID, ...args));
          performDelayed = true;
        }
        break;
      case PerformDelayedMode.KEEP_LAST:
        this.resetPendingPerforms();
        this._myPendingPerforms.push(new _PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
    }
    return performDelayed;
  }
  performImmediate(transitionID, ...args) {
    return this._perform(transitionID, PerformMode.IMMEDIATE, ...args);
  }
  canPerform(transitionID) {
    return this.hasTransitionFromState(this._myCurrentStateData.myID, transitionID);
  }
  canGoTo(stateID, transitionID = null) {
    return this.hasTransitionFromStateToState(this._myCurrentStateData.myID, stateID, transitionID);
  }
  isInState(stateID) {
    return this._myCurrentStateData != null && this._myCurrentStateData.myID == stateID;
  }
  isPerformingTransition() {
    return this._myCurrentlyPerformedTransition != null;
  }
  getCurrentlyPerformedTransition() {
    return this._myCurrentlyPerformedTransition;
  }
  hasBeenInit() {
    return this._myCurrentStateData != null;
  }
  reset() {
    this.resetState();
    this.resetPendingPerforms();
  }
  resetState() {
    this._myCurrentStateData = null;
  }
  resetPendingPerforms() {
    this._myPendingPerforms = [];
  }
  getCurrentState() {
    return this._myCurrentStateData;
  }
  getCurrentTransitions() {
    return this.getTransitionsFromState(this._myCurrentStateData.myID);
  }
  getCurrentTransitionsToState(stateID) {
    return this.getTransitionsFromStateToState(this._myCurrentStateData.myID, stateID);
  }
  getState(stateID) {
    return this._myStates.get(stateID);
  }
  getStates() {
    return this._myStates.values();
  }
  getTransitions() {
    let transitions = [];
    for (let transitionsFromState of this._myTransitions.values()) {
      for (let transitionData of transitionsFromState.values()) {
        transitions.push(transitionData);
      }
    }
    return transitions;
  }
  getTransitionsFromState(fromStateID) {
    let transitionsFromState = this._getTransitionsFromState(fromStateID);
    return Array.from(transitionsFromState.values());
  }
  getTransitionsFromStateToState(fromStateID, toStateID) {
    let transitionsFromState = this._getTransitionsFromState(fromStateID);
    let transitionsToState = [];
    for (let transitionData of transitionsFromState.values()) {
      if (transitionData.myToState.myID == toStateID) {
        transitionsToState.push(transitionData);
      }
    }
    return transitionsToState;
  }
  removeState(stateID) {
    if (this.hasState(stateID)) {
      this._myStates.delete(stateID);
      this._myTransitions.delete(stateID);
      for (let transitionsFromState of this._myTransitions.values()) {
        let toDelete = [];
        for (let [transitionID, transitionData] of transitionsFromState.entries()) {
          if (transitionData.myToState.myID == stateID) {
            toDelete.push(transitionID);
          }
        }
        for (let transitionID of toDelete) {
          transitionsFromState.delete(transitionID);
        }
      }
      return true;
    }
    return false;
  }
  removeTransitionFromState(fromStateID, transitionID) {
    let fromTransitions = this._getTransitionsFromState(fromStateID);
    if (fromTransitions) {
      return fromTransitions.delete(transitionID);
    }
    return false;
  }
  hasState(stateID) {
    return this._myStates.has(stateID);
  }
  hasTransitionFromState(fromStateID, transitionID) {
    let transitions = this.getTransitionsFromState(fromStateID);
    let transitionIndex = transitions.findIndex(function(transition) {
      return transition.myID == transitionID;
    });
    return transitionIndex >= 0;
  }
  hasTransitionFromStateToState(fromStateID, toStateID, transitionID = null) {
    let transitions = this.getTransitionsFromStateToState(fromStateID, toStateID);
    let hasTransition = false;
    if (transitionID) {
      let transitionIndex = transitions.findIndex(function(transition) {
        return transition.myID == transitionID;
      });
      hasTransition = transitionIndex >= 0;
    } else {
      hasTransition = transitions.length > 0;
    }
    return hasTransition;
  }
  setPerformMode(performMode) {
    this._myPerformMode = performMode;
  }
  getPerformMode() {
    return this._myPerformMode;
  }
  setPerformDelayedMode(performDelayedMode) {
    this._myPerformDelayedMode = performDelayedMode;
  }
  getPerformDelayedMode() {
    return this._myPerformDelayedMode;
  }
  hasPendingPerforms() {
    return this._myPendingPerforms.length > 0;
  }
  getPendingPerforms() {
    return this._myPendingPerforms.pp_clone();
  }
  clone(deepClone = false) {
    if (!this.isCloneable(deepClone)) {
      return null;
    }
    let cloneFSM = new _FSM();
    cloneFSM._myLogEnabled = this._myLogEnabled;
    cloneFSM._myLogShowDelayedInfo = this._myLogShowDelayedInfo;
    cloneFSM._myLogFSMName = this._myLogFSMName;
    cloneFSM._myPerformMode = this._myPerformMode;
    cloneFSM._myPerformDelayedMode = this._myPerformDelayedMode;
    cloneFSM._myPendingPerforms = this._myPendingPerforms.pp_clone();
    for (let entry of this._myStates.entries()) {
      let stateData = null;
      if (deepClone) {
        stateData = new StateData(entry[1].myID, entry[1].myObject.clone());
      } else {
        stateData = new StateData(entry[1].myID, entry[1].myObject);
      }
      cloneFSM._myStates.set(stateData.myID, stateData);
    }
    for (let entry of this._myTransitions.entries()) {
      let transitionsFromState = /* @__PURE__ */ new Map();
      cloneFSM._myTransitions.set(entry[0], transitionsFromState);
      for (let transitonEntry of entry[1].entries()) {
        let transitionData = null;
        let fromState = cloneFSM.getState(transitonEntry[1].myFromState.myID);
        let toState = cloneFSM.getState(transitonEntry[1].myToState.myID);
        if (deepClone) {
          transitionData = new TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject.clone(), transitonEntry[1].mySkipStateFunction);
        } else {
          transitionData = new TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject, transitonEntry[1].mySkipStateFunction);
        }
        transitionsFromState.set(transitionData.myID, transitionData);
      }
    }
    if (this._myCurrentStateData) {
      cloneFSM._myCurrentStateData = cloneFSM.getState(this._myCurrentStateData.myID);
    }
    return cloneFSM;
  }
  isCloneable(deepClone = false) {
    if (!deepClone) {
      return true;
    }
    let deepCloneable = true;
    for (let entry of this._myStates.entries()) {
      deepCloneable = deepCloneable && entry[1].myObject.clone != null;
    }
    for (let entry of this._myTransitions.entries()) {
      for (let transitonEntry of entry[1].entries()) {
        deepCloneable = deepCloneable && transitonEntry[1].myObject.clone != null;
      }
    }
    return deepCloneable;
  }
  setLogEnabled(active, fsmName = null, showDelayedInfo = false) {
    this._myLogEnabled = active;
    this._myLogShowDelayedInfo = showDelayedInfo;
    if (fsmName) {
      this._myLogFSMName = "FSM: ".concat(fsmName);
    }
  }
  registerInitEventListener(listenerID, listener) {
    this._myInitEmitter.add(listener, { id: listenerID });
  }
  unregisterInitEventListener(listenerID) {
    this._myInitEmitter.remove(listenerID);
  }
  registerInitIDEventListener(initStateID, listenerID, listener) {
    let initStateIDEmitter = this._myInitIDEmitters.get(initStateID);
    if (initStateIDEmitter == null) {
      this._myInitIDEmitters.set(initStateID, new Emitter9());
      initStateIDEmitter = this._myInitIDEmitters.get(initStateID);
    }
    initStateIDEmitter.add(listener, { id: listenerID });
  }
  unregisterInitIDEventListener(initStateID, listenerID) {
    let initStateIDEmitter = this._myInitIDEmitters.get(initStateID);
    if (initStateIDEmitter != null) {
      initStateIDEmitter.remove(listenerID);
      if (initStateIDEmitter.isEmpty) {
        this._myInitIDEmitters.delete(initStateID);
      }
    }
  }
  registerTransitionEventListener(listenerID, listener) {
    this._myTransitionEmitter.add(listener, { id: listenerID });
  }
  unregisterTransitionEventListener(listenerID) {
    this._myTransitionEmitter.remove(listenerID);
  }
  // The fsm IDs can be null, that means that the listener is called whenever only the valid IDs match
  // This let you register to all the transitions with a specific ID and from of a specific state but to every state (toStateID == null)
  registerTransitionIDEventListener(fromStateID, toStateID, transitionID, listenerID, listener) {
    let internalTransitionIDEmitter = null;
    for (let value of this._myTransitionIDEmitters) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDEmitter = value[3];
        break;
      }
    }
    if (internalTransitionIDEmitter == null) {
      let transitionIDEmitter = [];
      transitionIDEmitter[0] = fromStateID;
      transitionIDEmitter[1] = toStateID;
      transitionIDEmitter[2] = transitionID;
      transitionIDEmitter[3] = new Emitter9();
      internalTransitionIDEmitter = transitionIDEmitter[3];
      this._myTransitionIDEmitters.push(transitionIDEmitter);
    }
    internalTransitionIDEmitter.add(listener, { id: listenerID });
  }
  unregisterTransitionIDEventListener(fromStateID, toStateID, transitionID, listenerID) {
    let internalTransitionIDEmitter = null;
    for (let value of this._myTransitionIDEmitters) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDEmitter = value[3];
        break;
      }
    }
    if (internalTransitionIDEmitter != null) {
      internalTransitionIDEmitter.remove(listenerID);
      if (internalTransitionIDEmitter.isEmpty) {
        this._myTransitionIDEmitters.pp_remove((element) => element[0] == fromStateID && element[1] == toStateID && element[2] == transitionID);
      }
    }
  }
  _perform(transitionID, performMode, ...args) {
    if (this.isPerformingTransition()) {
      let currentlyPerformedTransition = this.getCurrentlyPerformedTransition();
      let consoleArguments = [this._myLogFSMName, "- Trying to perform:", transitionID];
      if (this._myLogShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      consoleArguments.push("- But another transition is currently being performed -", currentlyPerformedTransition.myID);
      console.warn(...consoleArguments);
      return false;
    }
    if (this._myCurrentStateData) {
      if (this.canPerform(transitionID)) {
        let transitions = this._myTransitions.get(this._myCurrentStateData.myID);
        let transitionToPerform = transitions.get(transitionID);
        this._myCurrentlyPerformedTransition = transitionToPerform;
        let fromState = this._myCurrentStateData;
        let toState = this._myStates.get(transitionToPerform.myToState.myID);
        if (this._myLogEnabled) {
          let consoleArguments = [this._myLogFSMName, "- From:", fromState.myID, "- To:", toState.myID, "- With:", transitionID];
          if (this._myLogShowDelayedInfo) {
            consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
          }
          console.log(...consoleArguments);
        }
        if (transitionToPerform.mySkipStateFunction != SkipStateFunction.END && transitionToPerform.mySkipStateFunction != SkipStateFunction.BOTH && fromState.myObject && fromState.myObject.end) {
          fromState.myObject.end(this, transitionToPerform, ...args);
        }
        if (transitionToPerform.myObject && transitionToPerform.myObject.perform) {
          transitionToPerform.myObject.perform(this, transitionToPerform, ...args);
        }
        if (transitionToPerform.mySkipStateFunction != SkipStateFunction.START && transitionToPerform.mySkipStateFunction != SkipStateFunction.BOTH && toState.myObject && toState.myObject.start) {
          toState.myObject.start(this, transitionToPerform, ...args);
        }
        this._myCurrentStateData = transitionToPerform.myToState;
        this._myTransitionEmitter.notify(this, fromState, toState, transitionToPerform, performMode, ...args);
        if (this._myTransitionIDEmitters.length > 0) {
          let internalTransitionIDEmitters = [];
          for (let value of this._myTransitionIDEmitters) {
            if ((value[0] == null || value[0] == fromState.myID) && (value[1] == null || value[1] == toState.myID) && (value[2] == null || value[2] == transitionToPerform.myID)) {
              internalTransitionIDEmitters.push(value[3]);
            }
          }
          for (let emitter of internalTransitionIDEmitters) {
            emitter.notify(this, fromState, toState, transitionToPerform, performMode, ...args);
          }
        }
        this._myCurrentlyPerformedTransition = null;
        return true;
      } else if (this._myLogEnabled) {
        let consoleArguments = [this._myLogFSMName, "- No Transition:", transitionID, "- From:", this._myCurrentStateData.myID];
        if (this._myLogShowDelayedInfo) {
          consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
        }
        console.warn(...consoleArguments);
      }
    } else if (this._myLogEnabled) {
      let consoleArguments = [this._myLogFSMName, "- FSM not initialized yet"];
      if (this._myLogShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      console.warn(...consoleArguments);
    }
    return false;
  }
  _getTransitionsFromState(fromStateID) {
    return this._myTransitions.get(fromStateID);
  }
};
var _PendingPerform = class {
  constructor(transitionID, ...args) {
    this.myID = transitionID;
    this.myArgs = args;
  }
};

// dist/cauldron/fsm/state.js
var State = class {
  // Called every frame if this is the current state
  // You can retrieve this state data by calling fsm.getCurrentState()
  update(dt, fsm, ...args) {
  }
  // Called when the fsm is started with this init state if no init transition object is specified or it does not have a performInit function
  // Since the state is set as the current one after the init, you can't use fsm.getCurrentState() to get it, so it is forwarded as a param if needed
  init(fsm, state, ...args) {
  }
  // Called when entering this state if no transition object is specified or it does not have a perform function
  // You can get this state data by accesing to the to state data inside the transition
  start(fsm, transition, ...args) {
  }
  // Called when exiting this state if no transition function is specified
  // You can get this state data by accesing to the from state data inside the transition
  end(fsm, transition, ...args) {
  }
};

// dist/cauldron/fsm/transition.js
var Transition = class {
  // Called if this is used as an init transition for the fsm
  performInit(fsm, initState, ...args) {
  }
  // Called when performing a transition
  // You can find the from and to states inside the transition params
  perform(fsm, transition, ...args) {
  }
};

// dist/cauldron/fsm/states/timer_state.js
var TimerState = class extends State {
  constructor(duration = 0, transitionToPerformOnEnd = null, ...transitionArgs) {
    super();
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
    this._myTimer = new Timer(duration, false);
  }
  setDuration(duration) {
    this._myTimer.setDuration(duration);
  }
  setTransitionToPerformOnEnd(transitionToPerformOnEnd, ...transitionArgs) {
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
  }
  onEnd(callback, id = null) {
    this._myTimer.onEnd(callback, id);
  }
  unregisterOnEnd(id = null) {
    this._myTimer.unregisterOnEnd(id);
  }
  update(dt, fsm) {
    this._myTimer.update(dt);
    if (this._myTimer.isDone()) {
      if (this._myTransitionToPerformOnEnd != null) {
        fsm.perform(this._myTransitionToPerformOnEnd, ...this._myTransitionArgs);
      }
    }
  }
  start(fsm, transition, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
    this._myTimer.start(duration);
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
  init(fsm, state, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
    this._myTimer.start(duration);
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
};

// dist/cauldron/utils/color_utils.js
function rgbToHSV(rgb) {
  let hsv = rgb.pp_clone();
  let r = rgb[0];
  let g = rgb[1];
  let b = rgb[2];
  let max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min, h, s = max === 0 ? 0 : d / max, v = max;
  switch (max) {
    case min:
      h = 0;
      break;
    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;
    case b:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
  return hsv;
}
function hsvToRGB(hsv) {
  let rgb = hsv.pp_clone();
  let h = hsv[0];
  let s = hsv[1];
  let v = hsv[2];
  let r, g, b, i, f, p, q, t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
  return rgb;
}
function rgbCodeToHuman(rgb) {
  return ColorUtils.color1To255(rgb);
}
function rgbHumanToCode(rgb) {
  return ColorUtils.color255To1(rgb);
}
function hsvCodeToHuman(hsv) {
  return ColorUtils.color1To255(hsv);
}
function hsvHumanToCode(hsv) {
  return ColorUtils.color255To1(hsv);
}
function color255To1(color) {
  let result = color.pp_clone();
  for (let i = 0; i < result.length; i++) {
    result[i] /= 255;
    result[i] = Math.pp_clamp(result[i], 0, 1);
  }
  return result;
}
function color1To255(color) {
  let result = color.pp_clone();
  for (let i = 0; i < result.length; i++) {
    result[i] = Math.round(result[i] * 255);
    result[i] = Math.pp_clamp(result[i], 0, 255);
  }
  return result;
}
var ColorUtils = {
  rgbToHSV,
  hsvToRGB,
  rgbCodeToHuman,
  rgbHumanToCode,
  hsvCodeToHuman,
  hsvHumanToCode,
  color255To1,
  color1To255
};

// dist/cauldron/utils/material_utils.js
import { MeshComponent as MeshComponent8 } from "@wonderlandengine/api";
var setAlpha = function() {
  let color = vec4_create();
  return function setAlpha2(material, alpha) {
    if (material.color != null) {
      color.vec4_copy(material.color);
      color[3] = alpha;
      material.color = color;
    }
    if (material.diffuseColor != null) {
      color.vec4_copy(material.diffuseColor);
      color[3] = alpha;
      material.diffuseColor = color;
    }
    if (material.ambientColor != null) {
      color.vec4_copy(material.ambientColor);
      color[3] = alpha;
      material.ambientColor = color;
    }
  };
}();
function setObjectAlpha(object, alpha) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      MaterialUtils.setAlpha(meshComponent.material, alpha);
    }
  }
}
function setObjectMaterial(object, material, cloneMaterial = false) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (cloneMaterial) {
      meshComponent.material = material.clone();
    } else {
      meshComponent.material = material;
    }
  }
}
function setObjectClonedMaterials(object) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      meshComponent.material = meshComponent.material.clone();
    }
  }
}
function setObjectSpecularColor(object, color) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material.specularColor != null) {
      meshComponent.material.specularColor = color;
    }
  }
}
function setObjectFogColor(object, color) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material.fogColor != null) {
      meshComponent.material.fogColor = color;
    }
  }
}
var MaterialUtils = {
  setAlpha,
  setObjectAlpha,
  setObjectMaterial,
  setObjectClonedMaterials,
  setObjectSpecularColor,
  setObjectFogColor
};

// dist/cauldron/utils/text_utils.js
import { TextComponent as TextComponent5 } from "@wonderlandengine/api";
function setClonedMaterials(object) {
  let textComponents = object.pp_getComponents(TextComponent5);
  for (let textComponent of textComponents) {
    if (textComponent.material != null) {
      textComponent.material = textComponent.material.clone();
    }
  }
}
var TextUtils = {
  setClonedMaterials
};

// dist/cauldron/utils/analytics_utils.js
var _myAnalyticsEnabled = false;
var _mySendDataCallback = null;
var _myEventsSentOnce = [];
var _myDataLogEnabled = false;
var _myEventsLogEnabled = false;
var _myErrorsLogEnabled = false;
function setAnalyticsEnabled(enabled) {
  _myAnalyticsEnabled = enabled;
}
function isAnalyticsEnabled() {
  return _myAnalyticsEnabled;
}
function setSendDataCallback(callback) {
  _mySendDataCallback = callback;
}
function sendData(...args) {
  try {
    if (_myAnalyticsEnabled) {
      if (_myDataLogEnabled) {
        console.log("Analytics Data: " + args);
      }
      if (_mySendDataCallback != null) {
        _mySendDataCallback(...args);
      } else if (_myErrorsLogEnabled) {
        console.error("You need to set the send data callback");
      }
    }
  } catch (error3) {
    if (_myErrorsLogEnabled) {
      console.error(error3);
    }
  }
}
function sendEvent(eventName, value = null, sendOnce = false) {
  try {
    if (_myAnalyticsEnabled) {
      let sendEventAllowed = true;
      if (sendOnce) {
        sendEventAllowed = !AnalyticsUtils.hasEventAlreadyBeenSent(eventName);
      }
      if (sendEventAllowed) {
        if (_myEventsLogEnabled) {
          if (value != null) {
            console.log("Analytics Event: " + eventName + " - Value: " + value);
          } else {
            console.log("Analytics Event: " + eventName);
          }
        }
        if (_mySendDataCallback != null) {
          if (value != null) {
            _mySendDataCallback("event", eventName, { "value": value });
          } else {
            _mySendDataCallback("event", eventName);
          }
          if (sendOnce) {
            _myEventsSentOnce.pp_pushUnique(eventName);
          }
        } else if (_myErrorsLogEnabled) {
          console.error("You need to set the send data callback");
        }
      }
    }
  } catch (error3) {
    if (_myErrorsLogEnabled) {
      console.error(error3);
    }
  }
}
function sendEventOnce(eventName, value = null) {
  AnalyticsUtils.sendEvent(eventName, value, true);
}
function clearEventSentOnceState(eventName) {
  _myEventsSentOnce.pp_removeEqual(eventName);
}
function clearAllEventsSentOnceState() {
  _myEventsSentOnce.pp_clear();
}
function hasEventAlreadyBeenSent(eventName) {
  return _myEventsSentOnce.pp_hasEqual(eventName);
}
function getEventsAlreadyBeenSent() {
  return _myEventsSentOnce;
}
function setDataLogEnabled(enabled) {
  _myDataLogEnabled = enabled;
}
function isDataLogEnabled() {
  return _myDataLogEnabled;
}
function setEventsLogEnabled(enabled) {
  _myEventsLogEnabled = enabled;
}
function isEventsLogEnabled() {
  return _myEventsLogEnabled;
}
function setErrorsLogEnabled(enabled) {
  _myErrorsLogEnabled = enabled;
}
function isErrorsLogEnabled() {
  return _myErrorsLogEnabled;
}
var AnalyticsUtils = {
  setAnalyticsEnabled,
  isAnalyticsEnabled,
  setSendDataCallback,
  sendData,
  sendEvent,
  sendEventOnce,
  clearEventSentOnceState,
  clearAllEventsSentOnceState,
  hasEventAlreadyBeenSent,
  getEventsAlreadyBeenSent,
  setDataLogEnabled,
  isDataLogEnabled,
  setEventsLogEnabled,
  isEventsLogEnabled,
  setErrorsLogEnabled,
  isErrorsLogEnabled
};

// dist/debug/components/debug_transform_component.js
import { Component as Component26, Property as Property20 } from "@wonderlandengine/api";
var DebugTransformComponent = class extends Component26 {
  static TypeName = "pp-debug-transform";
  static Properties = {
    _myLength: Property20.float(0.1),
    _myThickness: Property20.float(5e-3)
  };
  start() {
    this._myStarted = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._myDebugVisualTransform = null;
      this._myDebugTransformParams = new VisualTransformParams(this.engine);
      this._myDebugTransformParams.myLength = this._myLength;
      this._myDebugTransformParams.myThickness = this._myThickness;
      this._myDebugVisualTransform = new VisualTransform(this._myDebugTransformParams);
      this._myDebugVisualTransform.setVisible(Globals.isDebugEnabled(this.engine));
      this._myStarted = true;
    }
  }
  update(dt) {
    if (Globals.isDebugEnabled(this.engine)) {
      if (this._myStarted) {
        this.object.pp_getTransform(this._myDebugTransformParams.myTransform);
        this._myDebugVisualTransform.paramsUpdated();
        this._myDebugVisualTransform.setVisible(true);
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myDebugVisualTransform.destroy();
    }
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_overwriter.js
var DebugFunctionsOverwriterParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myObjectsByReference = [];
    this.myObjectsByPath = [];
    this.myClassesByReference = [];
    this.myClassesByPath = [];
    this.myFunctionsByPath = [];
    this.myExcludeConstructors = false;
    this.myExcludeJSObjectFunctions = false;
    this.myFunctionNamesToInclude = [];
    this.myFunctionNamesToExclude = [];
    this.myFunctionPathsToInclude = [];
    this.myFunctionPathsToExclude = [];
    this.myObjectAddObjectDescendantsDepthLevel = 0;
    this.myObjectAddClassDescendantsDepthLevel = 0;
    this.myObjectNamesToInclude = [];
    this.myObjectNamesToExclude = [];
    this.myClassNamesToInclude = [];
    this.myClassNamesToExclude = [];
    this.myObjectPathsToInclude = [];
    this.myObjectPathsToExclude = [];
    this.myClassPathsToInclude = [];
    this.myClassPathsToExclude = [];
    this.myLogEnabled = false;
    this.myEngine = engine;
  }
};
var DebugFunctionsOverwriter = class {
  constructor(params = new DebugFunctionsOverwriterParams()) {
    this._myParams = params;
    this._myPropertiesAlreadyOverwritten = /* @__PURE__ */ new Map();
  }
  overwriteFunctions() {
    let classesAndParents = this._getReferencesAndParents(this._myParams.myClassesByReference, this._myParams.myClassesByPath, true);
    let objectsAndParents = this._getReferencesAndParents(this._myParams.myObjectsByReference, this._myParams.myObjectsByPath, false);
    let functionsAndParents = this._getReferencesAndParents([], this._myParams.myFunctionsByPath, false);
    this._objectAddDescendants(objectsAndParents, classesAndParents);
    for (let referenceAndParent of classesAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, true);
    }
    for (let referenceAndParent of objectsAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, false);
    }
    for (let referenceAndParent of functionsAndParents) {
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      this._overwriteFunction(referenceParent, referenceName, null, null, referencePath, false, true);
    }
  }
  // Hooks
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass2, isFunction2) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
  }
  // Hooks end
  _overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, isClass2) {
    let includePathList = this._myParams.myObjectPathsToInclude;
    let excludePathList = this._myParams.myObjectPathsToExclude;
    let includeNameList = this._myParams.myObjectNamesToInclude;
    let excludeNameList = this._myParams.myObjectNamesToExclude;
    if (isClass2) {
      includePathList = this._myParams.myClassPathsToInclude;
      excludePathList = this._myParams.myClassPathsToExclude;
      includeNameList = this._myParams.myClassNamesToInclude;
      excludeNameList = this._myParams.myClassNamesToExclude;
    }
    let validReferencePath = this._filterName(referencePath, includePathList, excludePathList);
    let validReferenceName = this._filterName(referenceNameForFilter, includeNameList, excludeNameList);
    if (validReferencePath && validReferenceName) {
      let propertyNames = JSUtils.getObjectPropertyNames(reference);
      if (propertyNames.pp_hasEqual("constructor")) {
        propertyNames.unshift("constructor");
      }
      for (let propertyName of propertyNames) {
        let overwriteTargetReference = null;
        let referenceParentForConstructor = null;
        let referenceNameForConstructor = null;
        if (isClass2) {
          let fixedReference = reference;
          if (referenceParent != null) {
            let ownReferenceDescriptor = Object.getOwnPropertyDescriptor(referenceParent, referenceName);
            if (ownReferenceDescriptor != null && ownReferenceDescriptor.value != null) {
              fixedReference = ownReferenceDescriptor.value;
            }
          }
          overwriteTargetReference = fixedReference.prototype;
          if (overwriteTargetReference == null) {
            overwriteTargetReference = fixedReference;
          } else {
            try {
              let referenceProperty = JSUtils.getObjectProperty(overwriteTargetReference, propertyName);
              if (referenceProperty == null) {
                overwriteTargetReference = fixedReference;
              }
            } catch (error3) {
              overwriteTargetReference = fixedReference;
            }
          }
          referenceParentForConstructor = referenceParent;
          referenceNameForConstructor = referenceName;
        } else {
          overwriteTargetReference = reference;
        }
        this._overwriteFunction(overwriteTargetReference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, false);
      }
    }
  }
  _overwriteFunction(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2) {
    try {
      let propertyCountedAlready = this._myPropertiesAlreadyOverwritten.get(propertyName) != null && this._myPropertiesAlreadyOverwritten.get(propertyName).pp_hasEqual(reference);
      if (!propertyCountedAlready) {
        if (JSUtils.isFunctionByName(reference, propertyName) || propertyName == "constructor" && JSUtils.isClassByName(reference, propertyName)) {
          if (!this._myParams.myExcludeJSObjectFunctions || !this._isJSObjectFunction(propertyName)) {
            let validFunctionName = this._filterName(propertyName, this._myParams.myFunctionNamesToInclude, this._myParams.myFunctionNamesToExclude);
            let validFunctionPath = this._filterName((referencePath != null ? referencePath + "." : "") + propertyName, this._myParams.myFunctionPathsToInclude, this._myParams.myFunctionPathsToExclude);
            if (validFunctionName && validFunctionPath) {
              if (!this._myPropertiesAlreadyOverwritten.has(propertyName)) {
                this._myPropertiesAlreadyOverwritten.set(propertyName, []);
              }
              let overwriteSuccess = false;
              let isConstructor = false;
              if (propertyName != "constructor") {
                try {
                  let newFunction = this._getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2);
                  if (newFunction != JSUtils.getObjectProperty(reference, propertyName)) {
                    overwriteSuccess = JSUtils.overwriteObjectProperty(newFunction, reference, propertyName, false, true, this._myParams.myLogEnabled);
                  } else {
                    overwriteSuccess = true;
                  }
                } catch (error3) {
                  overwriteSuccess = false;
                  if (this._myParams.myLogEnabled) {
                    console.error(error3);
                  }
                }
              } else if (!this._myParams.myExcludeConstructors && isClass2 && referenceParentForConstructor != null) {
                let referenceForConstructor = JSUtils.getObjectProperty(referenceParentForConstructor, referenceNameForConstructor);
                if (referenceForConstructor != null && referenceForConstructor.prototype != null) {
                  isConstructor = true;
                  try {
                    let newConstructor = this._getOverwrittenConstructor(referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2);
                    if (newConstructor != referenceForConstructor) {
                      overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceParentForConstructor, referenceNameForConstructor, false, true, this._myParams.myLogEnabled);
                      if (overwriteSuccess) {
                        overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceForConstructor.prototype, propertyName, false, true, this._myParams.myLogEnabled);
                      }
                    } else {
                      overwriteSuccess = true;
                    }
                  } catch (error3) {
                    overwriteSuccess = false;
                    if (this._myParams.myLogEnabled) {
                      console.error(error3);
                    }
                  }
                }
              }
              if (overwriteSuccess) {
                this._myPropertiesAlreadyOverwritten.get(propertyName).push(reference);
                this._onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor);
              } else {
                this._onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor);
              }
            }
          }
        }
      }
    } catch (error3) {
      if (this._myParams.myLogEnabled) {
        console.error(error3);
      }
    }
  }
  _getReferencesAndParents(byReferenceList, byPathList, isClass2) {
    let referenceAndParents = [];
    let equalCallback = (first2, second) => first2[0] == second[0];
    for (let pathPair of byPathList) {
      let path = pathPair;
      let referenceName = "";
      let referencePath = pathPair;
      let referenceNameForFilter = "";
      if (pathPair != null && Array.isArray(pathPair) && pathPair.length != null && pathPair.length == 2 && typeof pathPair[1] == "string") {
        path = pathPair[0];
        referencePath = pathPair[1];
      }
      referenceName = JSUtils.getObjectNameFromPath(path);
      referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      let reference = JSUtils.getObjectFromPath(path, Globals.getWindow(this._myParams.myEngine));
      let referenceParent = JSUtils.getObjectParentFromPath(path, Globals.getWindow(this._myParams.myEngine));
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, referenceParent, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    for (let referencePair of byReferenceList) {
      let reference = referencePair;
      let referenceName = "";
      let referencePath = "";
      let referenceNameForFilter = "";
      if (referencePair != null && referencePair.length != null && referencePair.length == 2 && typeof referencePair[1] == "string") {
        reference = referencePair[0];
        referencePath = referencePair[1];
        referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      } else {
        referencePath = isClass2 ? reference.name : null;
        referenceNameForFilter = isClass2 ? reference.name : null;
      }
      if (isClass2) {
        referenceName = reference.name;
      } else {
        referenceName = JSUtils.getObjectNameFromPath(referencePath);
      }
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, null, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    return referenceAndParents;
  }
  _objectAddDescendants(objectsAndParents, classesAndParents) {
    let equalCallback = (first2, second) => first2[0] == second[0];
    let objectsToVisit = [];
    for (let objectAndParent of objectsAndParents) {
      objectsToVisit.pp_pushUnique([objectAndParent[0], 0, objectAndParent[3]], equalCallback);
    }
    while (objectsToVisit.length > 0) {
      let objectToVisit = objectsToVisit.shift();
      let object = objectToVisit[0];
      let objectLevel = objectToVisit[1];
      let objectPath = objectToVisit[2];
      if (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1 || objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1) {
        let propertyNames = null;
        try {
          propertyNames = JSUtils.getObjectPropertyNames(object);
        } catch (error3) {
          continue;
        }
        for (let propertyName of propertyNames) {
          let objectProperty = null;
          try {
            objectProperty = JSUtils.getObjectProperty(object, propertyName);
            if (objectProperty == null) {
              continue;
            }
          } catch (error3) {
            continue;
          }
          let currentPath = "";
          let currentName = "";
          if (objectPath != null) {
            currentName = propertyName;
            currentPath = objectPath + "." + currentName;
          } else {
            currentName = propertyName;
            currentPath = currentName;
          }
          let isClass2 = JSUtils.isClassByName(object, propertyName);
          let isObject2 = JSUtils.isObjectByName(object, propertyName);
          let includePathList = this._myParams.myObjectPathsToInclude;
          let excludePathList = this._myParams.myObjectPathsToExclude;
          let includeNameList = this._myParams.myObjectNamesToInclude;
          let excludeNameList = this._myParams.myObjectNamesToExclude;
          if (isClass2) {
            includePathList = this._myParams.myClassPathsToInclude;
            excludePathList = this._myParams.myClassPathsToExclude;
            includeNameList = this._myParams.myClassNamesToInclude;
            excludeNameList = this._myParams.myClassNamesToExclude;
          }
          let validReferencePath = this._filterName(currentPath, includePathList, excludePathList);
          let validReferenceName = this._filterName(propertyName, includeNameList, excludeNameList);
          if (validReferencePath && validReferenceName) {
            if (isObject2 && (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1)) {
              objectsAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isClass2 && propertyName != "constructor" && (objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1)) {
              classesAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isObject2) {
              objectsToVisit.pp_pushUnique([objectProperty, objectLevel + 1, currentPath], equalCallback);
            }
          }
        }
      }
    }
  }
  _filterName(name, includeList, excludeList) {
    let validName = includeList.length == 0;
    for (let includeName of includeList) {
      if (name.match(includeName) != null) {
        validName = true;
        break;
      }
    }
    if (validName) {
      for (let excludeName of excludeList) {
        if (name.match(excludeName) != null) {
          validName = false;
          break;
        }
      }
    }
    return validName;
  }
  _isJSObjectFunction(propertyName) {
  }
};
DebugFunctionsOverwriter.prototype._isJSObjectFunction = function() {
  let jsObjectFunctions = [
    "__defineGetter__",
    "__defineSetter__",
    "hasOwnProperty",
    "__lookupGetter__",
    "__lookupSetter__",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toString",
    "valueOf",
    "__proto__",
    "toLocaleString",
    "arguments",
    "caller",
    "apply",
    "bind",
    "call",
    "callee"
  ];
  return function _isJSObjectFunction(propertyName) {
    return jsObjectFunctions.pp_hasEqual(propertyName);
  };
}();

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analyzer.js
var DebugFunctionsPerformanceAnalyzerParams = class extends DebugFunctionsOverwriterParams {
  constructor() {
    super();
    this.myExecutionTimeAnalysisEnabled = true;
    this.myAddPathPrefixToFunctionID = true;
    this.myFilterDebugFunctionsPerformanceAnalyzerClasses = true;
  }
};
var DebugFunctionPerformanceAnalysisResults = class {
  constructor() {
    this.myReference = null;
    this.myName = "";
    this.myPath = "";
    this.myID = "";
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  reset() {
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  max(other) {
    this.myCallsCount = Math.max(this.myCallsCount, other.myCallsCount);
    this.myTotalExecutionTime = Math.max(this.myTotalExecutionTime, other.myTotalExecutionTime);
    this.myTotalExecutionTimePercentage = Math.max(this.myTotalExecutionTimePercentage, other.myTotalExecutionTimePercentage);
    this.myAverageExecutionTime = Math.max(this.myAverageExecutionTime, other.myAverageExecutionTime);
  }
  copy(other) {
    this.myReference = other.myReference;
    this.myName = other.myName;
    this.myPath = other.myPath;
    this.myID = other.myID;
    this.myCallsCount = other.myCallsCount;
    this.myTotalExecutionTime = other.myTotalExecutionTime;
    this.myTotalExecutionTimePercentage = other.myTotalExecutionTimePercentage;
    this.myAverageExecutionTime = other.myAverageExecutionTime;
    this.myTimeElapsedSinceLastReset = other.myTimeElapsedSinceLastReset;
    this._myTotalExecutionTimeInternal = other._myTotalExecutionTimeInternal;
  }
};
var DebugFunctionsPerformanceAnalyzerSortOrder = {
  NONE: 0,
  CALLS_COUNT: 1,
  TOTAL_EXECUTION_TIME: 2,
  AVERAGE_EXECUTION_TIME: 3
};
var DebugFunctionsPerformanceAnalyzer = class _DebugFunctionsPerformanceAnalyzer extends DebugFunctionsOverwriter {
  constructor(params = new DebugFunctionsPerformanceAnalyzerParams()) {
    super(params);
    this._myFunctionPerformanceAnalysisResults = /* @__PURE__ */ new Map();
    this._myFunctionPerformanceAnalysisMaxResults = /* @__PURE__ */ new Map();
    this._myResultsAlreadyAdded = false;
    this._myExecutionTimes = {
      myOverheadExecutionTimeSinceLastReset: 0,
      myLastFunctionExecutionTime: 0,
      myOriginalFunctionOverheadExecutionTimes: []
    };
    this._myTimeOfLastReset = Globals.getWindow(this._myParams.myEngine).performance.now();
    this._myMaxTimeElapsedSinceLastReset = 0;
    let originalPush = Array.prototype["push"];
    let originalPop = Array.prototype["pop"];
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.push = function() {
      return originalPush.bind(this)(...arguments);
    };
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.pop = function() {
      return originalPop.bind(this)(...arguments);
    };
  }
  overwriteFunctions() {
    super.overwriteFunctions();
    this.resetResults();
    this.resetMaxResults();
  }
  getTimeElapsedSinceLastReset() {
    return Globals.getWindow(this._myParams.myEngine).performance.now() - this._myTimeOfLastReset - this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset;
  }
  getMaxTimeElapsedSinceLastReset() {
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    return this._myMaxTimeElapsedSinceLastReset;
  }
  resetResults() {
    this._updateDerivatesResults();
    this._updateMaxResults();
    for (let property of this._myFunctionPerformanceAnalysisResults.keys()) {
      this._myFunctionPerformanceAnalysisResults.get(property).reset();
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset = 0;
    this._myTimeOfLastReset = Globals.getWindow(this._myParams.myEngine).performance.now();
  }
  resetMaxResults() {
    this._myMaxTimeElapsedSinceLastReset = 0;
    for (let property of this._myFunctionPerformanceAnalysisMaxResults.keys()) {
      this._myFunctionPerformanceAnalysisMaxResults.get(property).reset();
    }
  }
  getResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  getMaxResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisMaxResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, false);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass2, isFunction2) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, true);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
    this._myResultsAlreadyAdded = false;
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
    if (this._myResultsAlreadyAdded) {
      let propertyID = this._getPropertyID(propertyName, referencePath, isFunction2, isConstructor);
      this._myFunctionPerformanceAnalysisResults.delete(propertyID);
    }
  }
  _sortResults(results, sortOrder) {
    let sortedResults = results;
    if (sortOrder != DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
      sortedResults = new Map([...results.entries()].sort(function(first2, second) {
        let sortResult = 0;
        if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT) {
          sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
          if (sortResult == 0) {
            sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            }
          }
        } else if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME) {
          sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
            }
          }
        } else {
          sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
            }
          }
        }
        return sortResult;
      }));
    }
    return sortedResults;
  }
  _getPropertyID(propertyName, referencePath, isFunction2, isConstructor) {
    let id = isConstructor ? "constructor" : propertyName;
    if (referencePath != null && this._myParams.myAddPathPrefixToFunctionID) {
      if (!isFunction2) {
        id = referencePath + "." + id;
      } else {
        id = referencePath;
      }
    }
    return id;
  }
  _updateDerivatesResults() {
    let timeElapsedSinceLastReset = this.getTimeElapsedSinceLastReset();
    let beforeTime = Globals.getWindow(this._myParams.myEngine).performance.now();
    for (let property of this._myFunctionPerformanceAnalysisResults.keys()) {
      let results = this._myFunctionPerformanceAnalysisResults.get(property);
      if (timeElapsedSinceLastReset != 0) {
        results.myTotalExecutionTimePercentage = results.myTotalExecutionTime / timeElapsedSinceLastReset;
      } else {
        if (results.myCallsCount != 0) {
          results.myTotalExecutionTimePercentage = 1;
        } else {
          results.myTotalExecutionTimePercentage = 0;
        }
      }
      if (results.myCallsCount != 0) {
        results.myAverageExecutionTime = results.myTotalExecutionTime / results.myCallsCount;
      } else {
        results.myAverageExecutionTime = 0;
      }
      results.myTimeElapsedSinceLastReset = timeElapsedSinceLastReset;
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += Globals.getWindow(this._myParams.myEngine).performance.now() - beforeTime;
  }
  _updateMaxResults() {
    let beforeTime = Globals.getWindow(this._myParams.myEngine).performance.now();
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    for (let property of this._myFunctionPerformanceAnalysisResults.keys()) {
      if (this._myFunctionPerformanceAnalysisMaxResults.has(property)) {
        this._myFunctionPerformanceAnalysisMaxResults.get(property).max(this._myFunctionPerformanceAnalysisResults.get(property));
      } else {
        let maxResults = new DebugFunctionPerformanceAnalysisResults();
        maxResults.copy(this._myFunctionPerformanceAnalysisResults.get(property));
        this._myFunctionPerformanceAnalysisMaxResults.set(property, maxResults);
      }
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += Globals.getWindow(this._myParams.myEngine).performance.now() - beforeTime;
  }
  _getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, isConstructor) {
    let newFunction = JSUtils.getObjectProperty(reference, propertyName);
    if (!this._myParams.myFilterDebugFunctionsPerformanceAnalyzerClasses || !this._isPerformanceAnalyzer(reference, propertyName, isClass2)) {
      if (propertyName != "_myPerformanceAnalyzerOriginalFunction") {
        let propertyID = this._getPropertyID(propertyName, referencePath, isFunction2, isConstructor);
        this._myResultsAlreadyAdded = this._myFunctionPerformanceAnalysisResults.has(propertyID);
        let analysisResults = new DebugFunctionPerformanceAnalysisResults();
        analysisResults.myReference = reference;
        analysisResults.myName = propertyName;
        analysisResults.myPath = referencePath;
        analysisResults.myID = referencePath;
        this._myFunctionPerformanceAnalysisResults.set(propertyID, analysisResults);
        try {
          let window2 = Globals.getWindow(this._myParams.myEngine);
          let functionPerformanceAnalysisResults = this._myFunctionPerformanceAnalysisResults.get(propertyID);
          let executionTimes = this._myExecutionTimes;
          let originalFunction = reference[propertyName];
          let functionCallOverhead = 175e-6;
          let overheadError = 35e-5;
          let executionTimeAnalysisEnabled = this._myParams.myExecutionTimeAnalysisEnabled;
          if (!isConstructor) {
            newFunction = function() {
              let startTime = window2.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let boundOriginalFunction = null;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window2.performance.now();
                endOriginalFunctionTime = window2.performance.now();
                try {
                  boundOriginalFunction = originalFunction.bind(this);
                  startOriginalFunctionTime = window2.performance.now();
                  returnValue = boundOriginalFunction(...arguments);
                  endOriginalFunctionTime = window2.performance.now();
                } catch (error3) {
                  endOriginalFunctionTime = window2.performance.now();
                  errorToThrow = error3;
                }
              } else {
                try {
                  boundOriginalFunction = originalFunction.bind(this);
                  returnValue = boundOriginalFunction(...arguments);
                } catch (error3) {
                  errorToThrow = error3;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window2.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window2.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          } else {
            newFunction = function() {
              let startTime = window2.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window2.performance.now();
                endOriginalFunctionTime = window2.performance.now();
                try {
                  startOriginalFunctionTime = window2.performance.now();
                  returnValue = new originalFunction(...arguments);
                  endOriginalFunctionTime = window2.performance.now();
                } catch (error3) {
                  endOriginalFunctionTime = window2.performance.now();
                  errorToThrow = error3;
                }
              } else {
                try {
                  returnValue = new originalFunction(...arguments);
                } catch (error3) {
                  errorToThrow = error3;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window2.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window2.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          }
          if (newFunction != null) {
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerHasBeenOverwritten", {
              value: true,
              enumerable: false,
              configurable: false,
              writable: false
            });
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerOriginalFunction", {
              value: originalFunction,
              enumerable: false,
              configurable: false,
              writable: false
            });
          }
        } catch (error3) {
          if (this._myParams.myLogEnabled) {
            console.error("Function:", propertyName, "of:", reference, "can't be overwritten.\nError:", error3);
          }
        }
      }
    }
    return newFunction;
  }
  _isPerformanceAnalyzer(reference, propertyName, isClass2) {
    let isPerformanceAnalyzer = false;
    if (isClass2) {
      if (reference == _DebugFunctionsPerformanceAnalyzer.prototype || reference == DebugFunctionPerformanceAnalysisResults.prototype) {
        isPerformanceAnalyzer = true;
      }
    }
    return isPerformanceAnalyzer;
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analysis_results_logger.js
var DebugFunctionsPerformanceAnalysisResultsLoggerParams = class {
  constructor() {
    this.myPerformanceAnalyzer = null;
    this.myLogTitle = "Functions Performance Analysis Results";
    this.mySecondsBetweenLogs = 1;
    this.myLogFunction = "log";
    this.myFormatLog = true;
    this.myFormatLogIndentationCharacter = "-";
    this.myLogMaxResults = false;
    this.myLogSortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE;
    this.myLogMaxAmountOfFunctions = null;
    this.myLogFunctionsWithCallsCountAbove = null;
    this.myLogFunctionsWithTotalExecutionTimePercentageAbove = null;
    this.myLogCallsCountResults = false;
    this.myLogTotalExecutionTimeResults = false;
    this.myLogTotalExecutionTimePercentageResults = false;
    this.myLogAverageExecutionTimeResults = false;
    this.myClearConsoleBeforeLog = false;
  }
};
var DebugFunctionsPerformanceAnalysisResultsLogger = class {
  constructor(params) {
    this._myParams = params;
    this._myLogTimer = new Timer(this._myParams.mySecondsBetweenLogs);
    this._myMaxNameLength = 0;
    this._myMaxCallsCountLength = 0;
    this._myMaxTotalExecutionTimeLength = 0;
    this._myMaxTotalExecutionTimePercentageLength = 0;
    this._myMaxAverageExecutionTimeLength = 0;
  }
  update(dt) {
    if (this._myParams.myPerformanceAnalyzer == null) {
      return;
    }
    this._myLogTimer.update(dt);
    if (this._myLogTimer.isDone()) {
      this._myLogTimer.start();
      let timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getTimeElapsedSinceLastReset();
      if (this._myParams.myLogMaxResults) {
        timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getMaxTimeElapsedSinceLastReset();
      }
      let analysisResults = null;
      if (!this._myParams.myLogMaxResults) {
        analysisResults = this._myParams.myPerformanceAnalyzer.getResults(this._myParams.myLogSortOrder);
      } else {
        analysisResults = this._myParams.myPerformanceAnalyzer.getMaxResults(this._myParams.myLogSortOrder);
      }
      if (this._myParams.myLogFunctionsWithCallsCountAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myCallsCount > this._myParams.myLogFunctionsWithCallsCountAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myTotalExecutionTimePercentage * 100 > this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogMaxAmountOfFunctions != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < this._myParams.myLogMaxAmountOfFunctions && i < keys.length; i++) {
          let counter = analysisResultsClone.get(keys[i]);
          analysisResults.set(keys[i], counter);
        }
      }
      if (this._myParams.myClearConsoleBeforeLog) {
        console.clear();
      }
      let analysisResultsToLog = /* @__PURE__ */ new Map();
      for (let key of analysisResults.keys()) {
        let currentResults = analysisResults.get(key);
        let resultsToLog = {};
        if (this._myParams.myLogCallsCountResults) {
          resultsToLog.myCallsCount = currentResults.myCallsCount;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          resultsToLog.myTotalExecutionTime = currentResults.myTotalExecutionTime;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          resultsToLog.myTotalExecutionTimePercentage = currentResults.myTotalExecutionTimePercentage;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          resultsToLog.myAverageExecutionTime = currentResults.myAverageExecutionTime;
        }
        analysisResultsToLog.set(key, resultsToLog);
      }
      let resultsText = "";
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        this._myMaxNameLength = Math.max(this._myMaxNameLength, name.length);
        this._myMaxCallsCountLength = Math.max(this._myMaxCallsCountLength, results.myCallsCount.toFixed(0).length);
        this._myMaxTotalExecutionTimeLength = Math.max(this._myMaxTotalExecutionTimeLength, results.myTotalExecutionTime.toFixed(5).length);
        this._myMaxTotalExecutionTimePercentageLength = Math.max(this._myMaxTotalExecutionTimePercentageLength, (results.myTotalExecutionTimePercentage * 100).toFixed(2).length);
        this._myMaxAverageExecutionTimeLength = Math.max(this._myMaxAverageExecutionTimeLength, results.myAverageExecutionTime.toFixed(5).length);
      }
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        let parametersToLog = 0;
        if (this._myParams.myLogCallsCountResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          parametersToLog++;
        }
        let textOrdered = [];
        let callsCountText = parametersToLog > 1 ? "Calls Count: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxCallsCountLength - results.myCallsCount.toFixed(0).length; i++) {
            callsCountText += " ";
          }
        }
        callsCountText += results.myCallsCount.toFixed(0);
        let totalExecutionTimeText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimeLength - results.myTotalExecutionTime.toFixed(5).length; i++) {
            totalExecutionTimeText += " ";
          }
        }
        totalExecutionTimeText += results.myTotalExecutionTime.toFixed(5) + "ms";
        let totalExecutionTimePercentageText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimePercentageLength - (results.myTotalExecutionTimePercentage * 100).toFixed(2).length; i++) {
            totalExecutionTimePercentageText += " ";
          }
        }
        totalExecutionTimePercentageText += (results.myTotalExecutionTimePercentage * 100).toFixed(2) + "%";
        let averageExecutionTimeText = parametersToLog > 1 ? "Average Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxAverageExecutionTimeLength - results.myAverageExecutionTime.toFixed(5).length; i++) {
            averageExecutionTimeText += " ";
          }
        }
        averageExecutionTimeText += results.myAverageExecutionTime.toFixed(5) + "ms";
        if (!this._myParams.myLogCallsCountResults) {
          callsCountText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimeResults) {
          totalExecutionTimeText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimePercentageResults) {
          totalExecutionTimePercentageText = null;
        }
        if (!this._myParams.myLogAverageExecutionTimeResults) {
          averageExecutionTimeText = null;
        }
        switch (this._myParams.myLogSortOrder) {
          case DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME:
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(callsCountText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.AVERAGE_EXECUTION_TIME:
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(callsCountText);
            break;
          default:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
        }
        resultsText += "\n";
        if (this._myParams.myFormatLog) {
          let nameIndented = name + " ";
          while (nameIndented.length < this._myMaxNameLength + 1) {
            nameIndented += this._myParams.myFormatLogIndentationCharacter;
          }
          nameIndented += this._myParams.myFormatLogIndentationCharacter + " ";
          resultsText += nameIndented;
        } else {
          resultsText += name + " - ";
        }
        let avoidFirst = true;
        for (let text of textOrdered) {
          if (text != null) {
            if (avoidFirst) {
              avoidFirst = false;
            } else {
              resultsText += " - ";
            }
            resultsText += text;
          }
        }
      }
      if (this._myParams.myLogTotalExecutionTimeResults || this._myParams.myLogTotalExecutionTimePercentageResults || this._myParams.myLogAverageExecutionTimeResults) {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n\nTotal Time:", timeSinceLastReset.toFixed(5), "ms\n", resultsText);
      } else {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n", resultsText);
      }
    }
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_functions_performance_analyzer_component.js
import { Component as Component27, Property as Property21 } from "@wonderlandengine/api";
var DebugFunctionsPerformanceAnalyzerComponent = class extends Component27 {
  static TypeName = "pp-debug-functions-performance-analyzer";
  static Properties = {
    _myObjectsByPath: Property21.string(""),
    _myClassesByPath: Property21.string(""),
    _myFunctionsByPath: Property21.string(""),
    _myDelayStart: Property21.float(0),
    _myLogTitle: Property21.string("Functions Performance Analysis Results"),
    _myLogFunction: Property21.enum(["Log", "Error", "Warn", "Debug"], "Log"),
    _mySecondsBetweenLogs: Property21.float(1),
    _myLogMaxResults: Property21.bool(false),
    _myLogSortOrder: Property21.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
    _myLogCallsCountResults: Property21.bool(true),
    _myLogTotalExecutionTimeResults: Property21.bool(true),
    _myLogTotalExecutionTimePercentageResults: Property21.bool(true),
    _myLogAverageExecutionTimeResults: Property21.bool(true),
    _myLogMaxAmountOfFunctions: Property21.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property21.int(-1),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property21.float(-1),
    _myFunctionPathsToInclude: Property21.string(""),
    _myFunctionPathsToExclude: Property21.string(""),
    _myExcludeConstructors: Property21.bool(false),
    _myExcludeJSObjectFunctions: Property21.bool(true),
    _myAddPathPrefixToFunctionID: Property21.bool(true),
    _myObjectAddObjectDescendantsDepthLevel: Property21.int(0),
    _myObjectAddClassDescendantsDepthLevel: Property21.int(0),
    _myClearConsoleBeforeLog: Property21.bool(false),
    _myResetMaxResultsShortcutEnabled: Property21.bool(false),
    _myClassesByReference: Property21.enum(["Code Driven"], "Code Driven"),
    _myObjectsByReference: Property21.enum(["Code Driven"], "Code Driven")
  };
  init() {
    this._myActive = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._myActive = true;
      this._myFunctionsPerformanceAnalyzer = null;
      this._myFunctionsPerformanceAnalysisResultsLogger = null;
      this._mySkipFirstUpdate = true;
      this._myStartTimer = new Timer(this._myDelayStart);
      if (this._myDelayStart == 0) {
        this._myStartTimer.end();
        this._mySkipFirstUpdate = false;
        this._start();
      }
    }
  }
  update(dt) {
    if (this._myActive) {
      if (this._mySkipFirstUpdate) {
        this._mySkipFirstUpdate = false;
        return;
      }
      if (this._myStartTimer.isRunning()) {
        this._myStartTimer.update(dt);
        if (this._myStartTimer.isDone()) {
          this._start();
        }
      } else {
        this._myFunctionsPerformanceAnalysisResultsLogger.update(dt);
        this._myFunctionsPerformanceAnalyzer.resetResults();
      }
      if (this._myResetMaxResultsShortcutEnabled) {
        if (Globals.getLeftGamepad(this.engine).getButtonInfo(GamepadButtonID.SELECT).isPressEnd(3)) {
          this._myFunctionsPerformanceAnalyzer.resetMaxResults();
        }
      }
    }
  }
  _start() {
    let functionsPerformanceAnalyzerParams = new DebugFunctionsPerformanceAnalyzerParams(this.engine);
    if (this._myObjectsByPath.length > 0) {
      let toIncludeList = [...this._myObjectsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myObjectsByPath.push(...toIncludeList);
    }
    if (this._myClassesByPath.length > 0) {
      let toIncludeList = [...this._myClassesByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myClassesByPath.push(...toIncludeList);
    }
    if (this._myFunctionsByPath.length > 0) {
      let toIncludeList = [...this._myFunctionsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionsByPath.push(...toIncludeList);
    }
    functionsPerformanceAnalyzerParams.myExcludeConstructors = this._myExcludeConstructors;
    functionsPerformanceAnalyzerParams.myExcludeJSObjectFunctions = this._myExcludeJSObjectFunctions;
    functionsPerformanceAnalyzerParams.myAddPathPrefixToFunctionID = this._myAddPathPrefixToFunctionID;
    if (this._myFunctionPathsToInclude.length > 0) {
      let toIncludeList = [...this._myFunctionPathsToInclude.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToInclude.push(...toIncludeList);
    }
    if (this._myFunctionPathsToExclude.length > 0) {
      let toExcludeList = [...this._myFunctionPathsToExclude.split(",")];
      for (let i = 0; i < toExcludeList.length; i++) {
        toExcludeList[i] = toExcludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToExclude.push(...toExcludeList);
    }
    functionsPerformanceAnalyzerParams.myObjectAddObjectDescendantsDepthLevel = this._myObjectAddObjectDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myObjectAddClassDescendantsDepthLevel = this._myObjectAddClassDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myExecutionTimeAnalysisEnabled = this._myLogTotalExecutionTimeResults || this._myLogTotalExecutionTimePercentageResults || this._myLogAverageExecutionTimeResults;
    functionsPerformanceAnalyzerParams.myClassesByReference = this._myClassesByReference != 0 ? this._myClassesByReference : [];
    functionsPerformanceAnalyzerParams.myObjectsByReference = this._myObjectsByReference != 0 ? this._myObjectsByReference : [];
    this._myFunctionsPerformanceAnalyzer = new DebugFunctionsPerformanceAnalyzer(functionsPerformanceAnalyzerParams);
    this._myFunctionsPerformanceAnalyzer.overwriteFunctions();
    let functionsPerformanceAnalysisResultsLoggerParams = new DebugFunctionsPerformanceAnalysisResultsLoggerParams();
    functionsPerformanceAnalysisResultsLoggerParams.myPerformanceAnalyzer = this._myFunctionsPerformanceAnalyzer;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTitle = this._myLogTitle;
    functionsPerformanceAnalysisResultsLoggerParams.mySecondsBetweenLogs = this._mySecondsBetweenLogs;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunction = ["log", "error", "warn", "debug"][this._myLogFunction];
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxAmountOfFunctions = this._myLogMaxAmountOfFunctions >= 0 ? this._myLogMaxAmountOfFunctions : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithCallsCountAbove = this._myLogFunctionsWithCallsCountAbove >= 0 ? this._myLogFunctionsWithCallsCountAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithTotalExecutionTimePercentageAbove = this._myLogFunctionsWithTotalExecutionTimePercentageAbove >= 0 ? this._myLogFunctionsWithTotalExecutionTimePercentageAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxResults = this._myLogMaxResults;
    functionsPerformanceAnalysisResultsLoggerParams.myClearConsoleBeforeLog = this._myClearConsoleBeforeLog;
    functionsPerformanceAnalysisResultsLoggerParams.myLogSortOrder = this._myLogSortOrder;
    functionsPerformanceAnalysisResultsLoggerParams.myLogCallsCountResults = this._myLogCallsCountResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimeResults = this._myLogTotalExecutionTimeResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimePercentageResults = this._myLogTotalExecutionTimePercentageResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogAverageExecutionTimeResults = this._myLogAverageExecutionTimeResults;
    this._myFunctionsPerformanceAnalysisResultsLogger = new DebugFunctionsPerformanceAnalysisResultsLogger(functionsPerformanceAnalysisResultsLoggerParams);
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_functions_performance_analyzer_component.js
import { Component as Component28, Property as Property22 } from "@wonderlandengine/api";
var DebugPPFunctionsPerformanceAnalyzerComponent = class extends Component28 {
  static TypeName = "pp-debug-pp-functions-performance-analyzer";
  static Properties = {
    _myDelayStart: Property22.float(0),
    _myLogFunction: Property22.enum(["Log", "Error", "Warn", "Debug"], "Log"),
    _mySecondsBetweenLogs: Property22.float(1),
    _myLogMaxResults: Property22.bool(false),
    _myLogSortOrder: Property22.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
    _myLogCallsCountResults: Property22.bool(true),
    _myLogTotalExecutionTimeResults: Property22.bool(true),
    _myLogTotalExecutionTimePercentageResults: Property22.bool(true),
    _myLogAverageExecutionTimeResults: Property22.bool(true),
    _myLogMaxAmountOfFunctions: Property22.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property22.int(-1),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property22.float(-1),
    _myFunctionPathsToInclude: Property22.string(""),
    _myFunctionPathsToExclude: Property22.string(""),
    _myExcludeConstructors: Property22.bool(false),
    _myClearConsoleBeforeLog: Property22.bool(false),
    _myResetMaxResultsShortcutEnabled: Property22.bool(false)
  };
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "PP",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_array_functions_performance_analyzer_component.js
import { Component as Component29, Property as Property23 } from "@wonderlandengine/api";
var DebugArrayFunctionsPerformanceAnalyzerComponent = class extends Component29 {
  static TypeName = "pp-debug-array-functions-performance-analyzer";
  static Properties = {
    _myIncludeOnlyMainArrayTypes: Property23.bool(true),
    _myIncludeOnlyArrayExtensionFunctions: Property23.bool(false),
    _myDelayStart: Property23.float(0),
    _myLogFunction: Property23.enum(["Log", "Error", "Warn", "Debug"], "Log"),
    _mySecondsBetweenLogs: Property23.float(1),
    _myLogMaxResults: Property23.bool(false),
    _myLogSortOrder: Property23.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
    _myLogCallsCountResults: Property23.bool(true),
    _myLogTotalExecutionTimeResults: Property23.bool(true),
    _myLogTotalExecutionTimePercentageResults: Property23.bool(true),
    _myLogAverageExecutionTimeResults: Property23.bool(true),
    _myLogMaxAmountOfFunctions: Property23.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property23.int(-1),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property23.float(-1),
    _myFunctionPathsToInclude: Property23.string(""),
    _myFunctionPathsToExclude: Property23.string(""),
    _myExcludeConstructors: Property23.bool(false),
    _myClearConsoleBeforeLog: Property23.bool(false),
    _myResetMaxResultsShortcutEnabled: Property23.bool(false)
  };
  init() {
    let classesByPath = "Array, Uint8ClampedArray, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array";
    if (this._myIncludeOnlyMainArrayTypes) {
      classesByPath = "Array, Uint8Array, Uint16Array, Float32Array";
    }
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myClassesByPath: classesByPath,
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "Array Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude + (this._myFunctionPathsToInclude.length > 0 && this._myIncludeOnlyArrayExtensionFunctions ? ", " : "") + (this._myIncludeOnlyArrayExtensionFunctions ? "pp_, vec_, vec2_, vec3_, vec4_, quat_, quat2_, mat3_, mat4_, _pp_, _vec_, _quat_" : ""),
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_array_creation_performance_analyzer_component.js
import { Component as Component30, Property as Property24 } from "@wonderlandengine/api";
var DebugPPArrayCreationPerformanceAnalyzerComponent = class extends Component30 {
  static TypeName = "pp-debug-pp-array-creation-performance-analyzer";
  static Properties = {
    _myDelayStart: Property24.float(0),
    _myLogFunction: Property24.enum(["Log", "Error", "Warn", "Debug"], "Log"),
    _mySecondsBetweenLogs: Property24.float(1),
    _myLogMaxResults: Property24.bool(false),
    _myLogSortOrder: Property24.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
    _myLogCallsCountResults: Property24.bool(true),
    _myLogTotalExecutionTimeResults: Property24.bool(true),
    _myLogTotalExecutionTimePercentageResults: Property24.bool(true),
    _myLogAverageExecutionTimeResults: Property24.bool(true),
    _myLogMaxAmountOfFunctions: Property24.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property24.int(-1),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property24.float(-1),
    _myClearConsoleBeforeLog: Property24.bool(false),
    _myResetMaxResultsShortcutEnabled: Property24.bool(false)
  };
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: [
        [Vec2Utils, "Vec2Utils"],
        [Vec3Utils, "Vec3Utils"],
        [Vec4Utils, "Vec4Utils"],
        [QuatUtils, "QuatUtils"],
        [Quat2Utils, "Quat2Utils"],
        [Mat3Utils, "Mat3Utils"],
        [Mat4Utils, "Mat4Utils"]
      ],
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Array Creation Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: "create",
      _myExcludeConstructors: true,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_function_performance_analyzer_component.js
import { Component as Component31, Property as Property25 } from "@wonderlandengine/api";
var DebugWLFunctionsPerformanceAnalyzerComponent = class extends Component31 {
  static TypeName = "pp-debug-wl-functions-performance-analyzer";
  static Properties = {
    _myDelayStart: Property25.float(0),
    _myLogFunction: Property25.enum(["Log", "Error", "Warn", "Debug"], "Log"),
    _mySecondsBetweenLogs: Property25.float(1),
    _myLogMaxResults: Property25.bool(false),
    _myLogSortOrder: Property25.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
    _myLogCallsCountResults: Property25.bool(true),
    _myLogTotalExecutionTimeResults: Property25.bool(true),
    _myLogTotalExecutionTimePercentageResults: Property25.bool(true),
    _myLogAverageExecutionTimeResults: Property25.bool(true),
    _myLogMaxAmountOfFunctions: Property25.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property25.int(-1),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property25.float(-1),
    _myFunctionPathsToInclude: Property25.string(""),
    _myFunctionPathsToExclude: Property25.string(""),
    _myExcludeConstructors: Property25.bool(false),
    _myClearConsoleBeforeLog: Property25.bool(false),
    _myResetMaxResultsShortcutEnabled: Property25.bool(false)
  };
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "WL",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "WL Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_components_function_performance_analyzer_component.js
import { AnimationComponent as AnimationComponent2, CollisionComponent as CollisionComponent2, Component as Component32, InputComponent as InputComponent3, LightComponent as LightComponent2, MeshComponent as MeshComponent9, PhysXComponent as PhysXComponent5, Property as Property26, TextComponent as TextComponent6, ViewComponent as ViewComponent4 } from "@wonderlandengine/api";
var DebugWLComponentsFunctionsPerformanceAnalyzerComponent = class extends Component32 {
  static TypeName = "pp-debug-wl-components-functions-performance-analyzer";
  static Properties = {
    _myAnalyzeComponentTypes: Property26.bool(true),
    _myAnalyzeComponentInstances: Property26.bool(false),
    _myComponentInstanceID: Property26.enum(["Object ID", "Object Name", "Object ID - Object Name"], "Object ID - Object Name"),
    _myDelayStart: Property26.float(0),
    _myLogFunction: Property26.enum(["Log", "Error", "Warn", "Debug"], "Log"),
    _mySecondsBetweenLogs: Property26.float(1),
    _myLogMaxResults: Property26.bool(false),
    _myLogSortOrder: Property26.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
    _myLogCallsCountResults: Property26.bool(true),
    _myLogTotalExecutionTimeResults: Property26.bool(true),
    _myLogTotalExecutionTimePercentageResults: Property26.bool(true),
    _myLogAverageExecutionTimeResults: Property26.bool(true),
    _myLogMaxAmountOfFunctions: Property26.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property26.int(-1),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property26.float(-1),
    _myFunctionPathsToInclude: Property26.string(""),
    _myFunctionPathsToExclude: Property26.string(""),
    _myExcludeConstructors: Property26.bool(false),
    _myClearConsoleBeforeLog: Property26.bool(false),
    _myResetMaxResultsShortcutEnabled: Property26.bool(false)
  };
  init() {
    this._myStartTimer = new Timer(this._myDelayStart);
    if (this._myDelayStart == 0) {
      this._myStartTimer.end();
      this._start();
    }
  }
  update(dt) {
    if (this._myStartTimer.isRunning()) {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._start();
      }
    }
  }
  _start() {
    let objectsByReference = [];
    let classesByReference = [];
    if (this._myAnalyzeComponentInstances) {
      this._addComponentInstanceReferences(objectsByReference);
    }
    if (this._myAnalyzeComponentTypes) {
      this._addComponentTypeReferences(classesByReference);
    }
    this._myAnalyzerComponent = this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: objectsByReference,
      _myClassesByReference: classesByReference,
      _myDelayStart: 0,
      _myLogTitle: "WL Components Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddClassDescendantsDepthLevel: 0,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
  _addComponentTypeReferences(classesByReference) {
    let nativeComponentClasses = [
      AnimationComponent2,
      CollisionComponent2,
      InputComponent3,
      LightComponent2,
      MeshComponent9,
      PhysXComponent5,
      TextComponent6,
      ViewComponent4
    ];
    for (let nativeComponentClass of nativeComponentClasses) {
      classesByReference.push([nativeComponentClass.prototype, '{"' + nativeComponentClass.TypeName + '"}']);
    }
    for (let componentClass of ComponentUtils.getJavascriptComponentClassesByIndex(this.engine)) {
      classesByReference.push([componentClass.prototype, '{"' + componentClass.TypeName + '"}']);
    }
  }
  _addComponentInstanceReferences(objectsByReference) {
    for (let componentInstance of ComponentUtils.getJavascriptComponentInstances(this.engine)) {
      let id = "";
      switch (this._myComponentInstanceID) {
        case 0:
          id = componentInstance.object.pp_getID();
          break;
        case 1:
          id = componentInstance.object.pp_getName();
          break;
        case 2:
          id = componentInstance.object.pp_getID();
          if (componentInstance.object.pp_getName().length > 0) {
            id = id + " - " + componentInstance.object.pp_getName();
          }
          break;
      }
      objectsByReference.push([
        componentInstance,
        '{"' + componentInstance.type + '"}[' + id + "]"
      ]);
    }
  }
};

// dist/gameplay/cauldron/cauldron/direction_2D_to_3D_converter.js
var Direction2DTo3DConverterParams = class {
  constructor() {
    this.myStartFlyingForward = false;
    this.myStartFlyingRight = false;
    this.myAutoUpdateFlyForward = false;
    this.myAutoUpdateFlyRight = false;
    this.myResetFlyForwardWhenZero = false;
    this.myResetFlyRightWhenZero = false;
    this.myMinAngleToFlyForwardUp = 90;
    this.myMinAngleToFlyForwardDown = 90;
    this.myMinAngleToFlyRightUp = 90;
    this.myMinAngleToFlyRightDown = 90;
    this.myAdjustForwardWhenCloseToUp = true;
    this.myAdjustRightWhenCloseToUp = true;
    this.myAdjustForwardWhenCloseToUpAngleThreshold = 10;
    this.myAdjustRightWhenCloseToUpAngleThreshold = 10;
    this.myInvertForwardWhenUpsideDown = false;
    this.myInvertRightWhenUpsideDown = false;
    this.myAdjustLastValidFlatForwardOverConversionReferenceRotation = true;
    this.myAdjustLastValidFlatRightOverConversionReferenceRotation = true;
  }
};
var Direction2DTo3DConverter = class {
  constructor(params = new Direction2DTo3DConverterParams()) {
    this._myParams = params;
    this._myFlyingForward = this._myParams.myStartFlyingForward;
    this._myFlyingRight = this._myParams.myStartFlyingRight;
    this._myLastConvertRotationQuat = quat_create();
    this._myLastConvertRotationQuatValid = false;
    this._myLastValidFlatForward = vec3_create();
    this._myLastValidFlatRight = vec3_create();
  }
  // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
  // It's also needed to specify the fly axis, if different from the @conversionTransform up
  // If @direction3DUp is null, @conversionTransform up is used
  convert(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create()) {
    return this.convertTransform(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  isFlying() {
    return this._myFlyingForward || this._myFlyingRight;
  }
  isFlyingForward() {
    return this._myFlyingForward;
  }
  isFlyingRight() {
    return this._myFlyingRight;
  }
  startFlying() {
    this._myFlyingForward = true;
    this._myFlyingRight = true;
  }
  startFlyingForward() {
    this._myFlyingForward = true;
  }
  startFlyingRight() {
    this._myFlyingRight = true;
  }
  stopFlying() {
    this._myFlyingForward = false;
    this._myFlyingRight = false;
  }
  stopFlyingForward() {
    this._myFlyingForward = false;
  }
  stopFlyingRight() {
    this._myFlyingRight = false;
  }
  resetFly() {
    this.resetFlyForward();
    this.resetFlyRight();
  }
  resetFlyForward() {
    if (this._myParams.myStartFlyingForward) {
      this.startFlyingForward();
    } else {
      this.stopFlyingForward();
    }
  }
  resetFlyRight() {
    if (this._myParams.myStartFlyingRight) {
      this.startFlyingRight();
    } else {
      this.stopFlyingRight();
    }
  }
  resetLastValidFlatDirections() {
    this._myLastValidFlatForward.vec3_zero();
    this._myLastValidFlatRight.vec3_zero();
  }
  resetLastValidFlatForward() {
    this._myLastValidFlatForward.vec3_zero();
  }
  resetLastValidFlatRight() {
    this._myLastValidFlatRight.vec3_zero();
  }
  resetLastConvertTransform() {
    this._myLastConvertRotationQuatValid = false;
    this._myLastConvertRotationQuat.quat_identity();
  }
  // Convert Alternatives
  // If @direction3DUp is null, vec3_create(0, 1, 0) is used
  // Does not work properly if @conversionForward is aligned with @direction3DUp
  convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
  // It's also needed to specify the fly axis, if different from the @conversionTransform up
  // If @direction3DUp is null, conversionTransform up is used
  convertTransform(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create()) {
    return this.convertTransformMatrix(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create()) {
  }
};
Direction2DTo3DConverter.prototype.convertForward = function() {
  let rotationQuat = quat_create();
  return function convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat.quat_identity();
    rotationQuat.quat_setForward(conversionForward, direction3DUp);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformMatrix = function() {
  let rotationQuat = quat_create();
  return function convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat = conversionTransformMatrix.mat4_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformQuat = function() {
  let rotationQuat = quat_create();
  return function convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat = conversionTransformQuat.quat2_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertRotationQuat = function() {
  let forward = vec3_create();
  let right = vec3_create();
  let up = vec3_create();
  let direction3DUpNegate = vec3_create();
  let forwardScaled = vec3_create();
  let rightScaled = vec3_create();
  let rotationToNewConvertPivoted = quat_create();
  return function convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create()) {
    outDirection3D.vec3_zero();
    if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation || this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
      if (direction3DUp != null) {
        if (this._myLastConvertRotationQuatValid) {
          rotationToNewConvertPivoted = this._myLastConvertRotationQuat.quat_rotationToQuat(conversionRotationQuat, rotationToNewConvertPivoted).quat_rotationAroundAxisQuat(direction3DUp, rotationToNewConvertPivoted);
          if (Math.pp_angleClamp(rotationToNewConvertPivoted.quat_getAngle(), true) > Math.PP_EPSILON_DEGREES) {
            if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation) {
              this._myLastValidFlatForward.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatForward);
            }
            if (this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
              this._myLastValidFlatRight.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatRight);
            }
          }
        }
      }
    }
    if (direction2D.vec2_isZero()) {
      let resetFlyForward = this._myParams.myAutoUpdateFlyForward && this._myParams.myResetFlyForwardWhenZero;
      if (resetFlyForward) {
        this.resetFlyForward();
      }
      let resetFlyRight = this._myParams.myAutoUpdateFlyRight && this._myParams.myResetFlyRightWhenZero;
      if (resetFlyRight) {
        this.resetFlyRight();
      }
    } else {
      forward = conversionRotationQuat.quat_getForward(forward);
      right = conversionRotationQuat.quat_getRight(right);
      up = conversionRotationQuat.quat_getUp(up);
      if (direction3DUp != null) {
        let upsideDown = !direction3DUp.vec3_isConcordant(up);
        direction3DUpNegate = direction3DUp.vec3_negate(direction3DUpNegate);
        if (this._myParams.myAutoUpdateFlyForward) {
          let angleForwardWithDirectionUp = forward.vec3_angle(direction3DUp);
          this._myFlyingForward = this._myFlyingForward || (angleForwardWithDirectionUp < 90 - this._myParams.myMinAngleToFlyForwardUp || angleForwardWithDirectionUp > 90 + this._myParams.myMinAngleToFlyForwardDown);
        }
        if (this._myParams.myAutoUpdateFlyRight) {
          let angleRightWithDirectionUp = right.vec3_angle(direction3DUp);
          this._myFlyingRight = this._myFlyingRight || (angleRightWithDirectionUp < 90 - this._myParams.myMinAngleToFlyRightUp || angleRightWithDirectionUp > 90 + this._myParams.myMinAngleToFlyRightDown);
        }
        if (!this._myFlyingForward) {
          if (this._myParams.myAdjustForwardWhenCloseToUp && !this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON) && (forward.vec3_angle(direction3DUp) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || forward.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold)) {
            forward.pp_copy(this._myLastValidFlatForward);
          } else if (upsideDown && this._myParams.myInvertForwardWhenUpsideDown) {
            forward.vec3_negate(forward);
          }
          forward = forward.vec3_removeComponentAlongAxis(direction3DUp, forward);
          forward.vec3_normalize(forward);
          if (forward.vec3_isZero(Math.PP_EPSILON)) {
            if (!this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
              forward.pp_copy(this._myLastValidFlatForward);
            } else {
              forward.vec3_set(0, 0, 1);
            }
          }
        }
        if (!this._myFlyingRight) {
          if (this._myParams.myAdjustRightWhenCloseToUp && !this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON) && (right.vec3_angle(direction3DUp) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || right.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold)) {
            right.pp_copy(this._myLastValidFlatRight);
          } else if (upsideDown && this._myParams.myInvertRightWhenUpsideDown) {
            right.vec3_negate(right);
          }
          right = right.vec3_removeComponentAlongAxis(direction3DUp, right);
          right.vec3_normalize(right);
          if (right.vec3_isZero(Math.PP_EPSILON)) {
            if (!this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
              right.pp_copy(this._myLastValidFlatRight);
            } else {
              right.vec3_set(-1, 0, 0);
            }
          }
        }
        if (forward.vec3_angle(direction3DUp) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold && forward.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || direction2D[1] != 0 && this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
          this._myLastValidFlatForward = forward.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatForward);
          this._myLastValidFlatForward.vec3_normalize(this._myLastValidFlatForward);
        }
        if (right.vec3_angle(direction3DUp) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold && right.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || direction2D[0] != 0 && this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
          this._myLastValidFlatRight = right.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatRight);
          this._myLastValidFlatRight.vec3_normalize(this._myLastValidFlatRight);
        }
      }
      outDirection3D = right.vec3_scale(direction2D[0], rightScaled).vec3_add(forward.vec3_scale(direction2D[1], forwardScaled), outDirection3D);
      if (direction3DUp != null && !this._myFlyingForward && !this._myFlyingRight) {
        outDirection3D = outDirection3D.vec3_removeComponentAlongAxis(direction3DUp, outDirection3D);
      }
      outDirection3D.vec3_normalize(outDirection3D);
    }
    this._myLastConvertRotationQuat.quat_copy(conversionRotationQuat);
    this._myLastConvertRotationQuatValid = true;
    return outDirection3D;
  };
}();

// dist/gameplay/cauldron/cauldron/number_over_factor.js
var NumberOverFactor = class {
  constructor(fromNumberOverFactor, toNumberOverFactor = null, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (toNumberOverFactor == null) {
      toNumberOverFactor = fromNumberOverFactor;
    }
    this._myFromNumber = fromNumberOverFactor;
    this._myToNumber = toNumberOverFactor;
    this._myFromFactor = fromFactor;
    this._myToFactor = toFactor;
    this._myEasingFunction = easingFunction;
    this._myRoundingFunction = roundingFunction;
  }
  get(factor) {
    let interpolationFactor = this._myEasingFunction(Math.pp_mapToRange(factor, this._myFromFactor, this._myToFactor, 0, 1));
    let numberOverFactor = Math.pp_lerp(this._myFromNumber, this._myToNumber, interpolationFactor);
    if (this._myRoundingFunction) {
      numberOverFactor = this._myRoundingFunction(numberOverFactor, this._myFromNumber, this._myToNumber);
    }
    return numberOverFactor;
  }
  getAverage(factor) {
    return this.get(factor);
  }
  getRange(factor) {
    let numberOverFactor = this.get(factor);
    return [numberOverFactor, numberOverFactor];
  }
  getMax(factor) {
    return this.get(factor);
  }
  getMin(factor) {
    return this.get(factor);
  }
  isInside(number, factor) {
    let numberOverFactor = this.get(factor);
    return numberOverFactor == number;
  }
  isInsideAngleRange(number, factor) {
    return this.isInsideAngleRangeDegrees(number, factor);
  }
  isInsideAngleRangeDegrees(number, factor) {
    let numberOverFactor = this.get(factor);
    let clampedNumber = Math.pp_angleClampDegrees(number);
    let clampedNumberOverFactor = Math.pp_angleClampDegrees(numberOverFactor);
    return clampedNumber == clampedNumberOverFactor;
  }
  isInsideAngleRangeRadians(number, factor) {
    let numberOverFactor = this.get(factor);
    let clampedNumber = Math.pp_angleClampRadians(number);
    let clampedNumberOverFactor = Math.pp_angleClampRadians(numberOverFactor);
    return clampedNumber == clampedNumberOverFactor;
  }
};
var IntOverFactor = class extends NumberOverFactor {
  constructor(fromNumberOverFactor, toNumberOverFactor, fromFactor, toFactor, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(numberToRound, fromNumberOverFactor2, toNumberOverFactor2) {
        let roundedNumber = null;
        let useFloor = fromNumberOverFactor2 <= toNumberOverFactor2;
        if (useFloor) {
          roundedNumber = Math.floor(numberToRound);
        } else {
          roundedNumber = Math.ceil(numberToRound);
        }
        return roundedNumber;
      };
    }
    super(fromNumberOverFactor, toNumberOverFactor, fromFactor, toFactor, easingFunction, roundingFunction);
  }
};
var NumberRangeOverFactor = class {
  constructor(fromRange, toRange = null, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (toRange == null) {
      toRange = fromRange;
    }
    this._myFromNumberOverFactor = new NumberOverFactor(fromRange[0], toRange[0], fromFactor, toFactor, easingFunction, roundingFunction);
    this._myToNumberOverFactor = new NumberOverFactor(fromRange[1], toRange[1], fromFactor, toFactor, easingFunction, roundingFunction);
    this._myRoundingFunction = roundingFunction;
  }
  get(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    let randomNumberOverFactor = null;
    if (this._myRoundingFunction) {
      randomNumberOverFactor = Math.pp_randomInt(fromNumberOverFactor, toNumberOverFactor);
    } else {
      randomNumberOverFactor = Math.pp_random(fromNumberOverFactor, toNumberOverFactor);
    }
    return randomNumberOverFactor;
  }
  getAverage(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    let averageNumberOverFactor = (fromNumberOverFactor + toNumberOverFactor) / 2;
    if (this._myRoundingFunction) {
      averageNumberOverFactor = this._myRoundingFunction(averageNumberOverFactor, fromNumberOverFactor, toNumberOverFactor);
    }
    return averageNumberOverFactor;
  }
  getRange(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return [fromNumberOverFactor, toNumberOverFactor];
  }
  getMax(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.max(fromNumberOverFactor, toNumberOverFactor);
  }
  getMin(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.min(fromNumberOverFactor, toNumberOverFactor);
  }
  isInside(number, factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    let min = Math.min(fromNumberOverFactor, toNumberOverFactor);
    let max = Math.max(fromNumberOverFactor, toNumberOverFactor);
    return number >= min && number <= max;
  }
  isInsideAngleRange(number, factor) {
    return this.isInsideAngleRangeDegrees(number, factor);
  }
  isInsideAngleRangeDegrees(number, factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.pp_isInsideAngleRangeDegrees(number, fromNumberOverFactor, toNumberOverFactor);
  }
  isInsideAngleRangeRadians(number, factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.pp_isInsideAngleRangeRadians(number, fromNumberOverFactor, toNumberOverFactor);
  }
};
var IntRangeOverFactor = class extends NumberRangeOverFactor {
  constructor(fromRange, toRange, fromFactor, toFactor, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(numberToRound, fromNumberOverFactor, toNumberOverFactor) {
        let roundedNumber = null;
        let useFloor = fromNumberOverFactor <= toNumberOverFactor;
        if (useFloor) {
          roundedNumber = Math.floor(numberToRound);
        } else {
          roundedNumber = Math.ceil(numberToRound);
        }
        return roundedNumber;
      };
    }
    super(fromRange, toRange, fromFactor, toFactor, easingFunction, roundingFunction);
  }
};

// dist/gameplay/grab_throw/grabbable_component.js
import { Component as Component33, Emitter as Emitter10, PhysXComponent as PhysXComponent6, Property as Property27 } from "@wonderlandengine/api";
var GrabbableComponent = class extends Component33 {
  static TypeName = "pp-grabbable";
  static Properties = {
    _myThrowLinearVelocityMultiplier: Property27.float(1),
    _myThrowAngularVelocityMultiplier: Property27.float(1),
    _myKinematicValueOnRelease: Property27.enum(["True", "False", "Own"], "False"),
    _myParentOnRelease: Property27.enum(["Scene", "Own"], "Own")
  };
  init() {
    this._myGrabbed = false;
    this._myGrabber = null;
    this._myOldParent = null;
    this._myPhysX = null;
    this._myOldKinematicValue = null;
    this._myGrabEmitter = new Emitter10();
    this._myThrowEmitter = new Emitter10();
    this._myReleaseEmitter = new Emitter10();
  }
  start() {
    this._myOldParent = this.object.pp_getParent();
    this._myPhysX = this.object.pp_getComponent(PhysXComponent6);
  }
  onDeactivate() {
    this.release();
  }
  grab(grabber) {
    if (!this.isGrabbed()) {
      this._myOldKinematicValue = this._myPhysX.kinematic;
    }
    this.release();
    this._myPhysX.kinematic = true;
    this._myOldParent = this.object.pp_getParent();
    this.object.pp_setParent(grabber);
    this._myGrabbed = true;
    this._myGrabEmitter.notify(grabber, this);
  }
  throw(linearVelocity, angularVelocity) {
    if (this._myGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myPhysX.linearVelocity = linearVelocity.vec3_scale(this._myThrowLinearVelocityMultiplier);
      this._myPhysX.angularVelocity = angularVelocity.vec3_scale(this._myThrowAngularVelocityMultiplier);
      this._myThrowEmitter.notify(grabber, this);
      this._myReleaseEmitter.notify(grabber, this, true);
    }
  }
  release() {
    if (this._myGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myReleaseEmitter.notify(grabber, this, false);
    }
  }
  getLinearVelocity() {
    let linearVelocity = vec3_create();
    this._myPhysX.linearVelocity.vec3_clone(linearVelocity);
    return linearVelocity;
  }
  getAngularVelocity() {
    return this.getAngularVelocityDegrees();
  }
  getAngularVelocityDegrees() {
    let angularVelocityDegrees = vec3_create();
    this._myPhysX.angularVelocity.vec3_toDegrees(angularVelocityDegrees);
    return angularVelocityDegrees;
  }
  getAngularVelocityRadians() {
    let angularVelocityRadians = vec3_create();
    this._myPhysX.angularVelocity.vec3_clone(angularVelocityRadians);
    return angularVelocityRadians;
  }
  isGrabbed() {
    return this._myGrabbed;
  }
  getGrabber() {
    return this._myGrabber;
  }
  registerGrabEventListener(id, listener) {
    this._myGrabEmitter.add(listener, { id });
  }
  unregisterGrabEventListener(id) {
    this._myGrabEmitter.remove(id);
  }
  registerThrowEventListener(id, listener) {
    this._myThrowEmitter.add(listener, { id });
  }
  unregisterThrowEventListener(id) {
    this._myThrowEmitter.remove(id);
  }
  registerReleaseEventListener(id, listener) {
    this._myReleaseEmitter.add(listener, { id });
  }
  unregisterReleaseEventListener(id) {
    this._myReleaseEmitter.remove(id);
  }
  _release() {
    if (this._myParentOnRelease == 0) {
      this.object.pp_setParent(Globals.getSceneObjects(this.engine).myDynamics);
    } else {
      this.object.pp_setParent(this._myOldParent);
    }
    this._myGrabbed = false;
    this._myGrabber = null;
    if (this._myKinematicValueOnRelease == 0) {
      this._myPhysX.kinematic = true;
    } else if (this._myKinematicValueOnRelease == 1) {
      this._myPhysX.kinematic = false;
    } else if (this._myOldKinematicValue != null) {
      this._myPhysX.kinematic = this._myOldKinematicValue;
    }
    if (this._myPhysX.kinematic) {
      this._myPhysX.linearVelocity = vec3_create();
      this._myPhysX.angularVelocity = vec3_create();
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
  pp_clonePostProcess(clonedComponent) {
    clonedComponent.start();
  }
};

// dist/gameplay/grab_throw/grabber_hand_component.js
import { Component as Component34, Emitter as Emitter11, PhysXComponent as PhysXComponent7, Property as Property28 } from "@wonderlandengine/api";
var GrabberHandComponent = class extends Component34 {
  static TypeName = "pp-grabber-hand";
  static Properties = {
    _myHandedness: Property28.enum(["Left", "Right"], "Left"),
    _myGrabButton: Property28.enum(["Select", "Squeeze", "Both", "Both Exclusive"], "Squeeze"),
    // @"Both Exclusive" means u can use both buttons but you have to use the same button you grabbed with to throw
    _mySnapOnPivot: Property28.bool(false),
    _myMaxNumberOfObjects: Property28.int(1),
    // How many objects you can grab at the same time
    // ADVANCED SETTINGS
    _myThrowVelocitySource: Property28.enum(["Hand", "Grabbable"], "Hand"),
    _myThrowLinearVelocityMultiplier: Property28.float(1),
    // Multiply the overall throw speed, so slow throws will be multiplied too
    _myThrowMaxLinearSpeed: Property28.float(15),
    _myThrowAngularVelocityMultiplier: Property28.float(0.5),
    _myThrowMaxAngularSpeed: Property28.float(1080),
    // @Degrees
    _myThrowLinearVelocityBoost: Property28.float(1.75),
    // This boost is applied from 0% to 100% based on how fast you throw, so slow throws are not affected
    _myThrowLinearVelocityBoostMinSpeedThreshold: Property28.float(0.6),
    // 0% boost is applied if plain throw speed is under this value
    _myThrowLinearVelocityBoostMaxSpeedThreshold: Property28.float(2.5)
    // 100% boost is applied if plain throw speed is over this value
  };
  init() {
    this._myGrabbables = [];
    this._myGamepad = null;
    this._myActiveGrabButton = null;
    this._myLinearVelocityHistorySize = 5;
    this._myLinearVelocityHistorySpeedAverageSamplesFromStart = 1;
    this._myLinearVelocityHistoryDirectionAverageSamplesFromStart = 3;
    this._myLinearVelocityHistoryDirectionAverageSkipFromStart = 0;
    this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
    this._myHandLinearVelocityHistory.fill(vec3_create());
    this._myAngularVelocityHistorySize = 1;
    this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
    this._myHandAngularVelocityHistory.fill(vec3_create());
    this._myThrowMaxAngularSpeedRadians = Math.pp_toRadians(this._myThrowMaxAngularSpeed);
    this._myGrabEmitter = new Emitter11();
    this._myThrowEmitter = new Emitter11();
    this._myDebugEnabled = false;
  }
  start() {
    if (this._myHandedness == HandednessIndex.LEFT) {
      this._myGamepad = Globals.getLeftGamepad(this.engine);
    } else {
      this._myGamepad = Globals.getRightGamepad(this.engine);
    }
    this._myPhysX = this.object.pp_getComponent(PhysXComponent7);
    this._myCollisionsCollector = new PhysicsCollisionCollector(this._myPhysX, true);
  }
  update(dt) {
    this._myCollisionsCollector.update(dt);
    if (this._myGrabbables.length > 0) {
      this._updateLinearVelocityHistory();
      this._updateAngularVelocityHistory();
    }
  }
  grab(grabButton = null) {
    this._grab(grabButton);
  }
  throw(throwButton = null) {
    this._throw(throwButton);
  }
  getGamepad() {
    return this._myGamepad;
  }
  getHandedness() {
    return InputUtils.getHandednessByIndex(this._myHandedness);
  }
  registerGrabEventListener(id, listener) {
    this._myGrabEmitter.add(listener, { id });
  }
  unregisterGrabEventListener(id) {
    this._myGrabEmitter.remove(id);
  }
  registerThrowEventListener(id, listener) {
    this._myThrowEmitter.add(listener, { id });
  }
  unregisterThrowEventListener(id) {
    this._myThrowEmitter.remove(id);
  }
  onActivate() {
    if (this._myGamepad != null) {
      if (this._myGrabButton == 0) {
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SELECT));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SELECT));
      } else if (this._myGrabButton == 1) {
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SQUEEZE));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SQUEEZE));
      } else {
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SQUEEZE));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SQUEEZE));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SELECT));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SELECT));
      }
    }
  }
  onDeactivate() {
    this.throw();
    if (this._myGamepad != null) {
      if (this._myGrabButton == 0) {
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this);
      } else if (this._myGrabButton == 1) {
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this);
      } else {
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this);
      }
    }
  }
  _grab(grabButton) {
    if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
      return;
    }
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == grabButton || grabButton == null) {
      let grabbablesToGrab = [];
      let collisions = this._myCollisionsCollector.getCollisions();
      for (let i = 0; i < collisions.length; i++) {
        let grabbable = collisions[i].pp_getComponent(GrabbableComponent);
        if (grabbable && grabbable.active) {
          grabbablesToGrab.push(grabbable);
        }
      }
      let grabberPosition = this.object.pp_getPosition();
      grabbablesToGrab.sort(function(first2, second) {
        let firstPosition = first2.object.pp_getPosition();
        let secondPosition = second.object.pp_getPosition();
        let firstDistance = firstPosition.vec3_distance(grabberPosition);
        let secondDistance = secondPosition.vec3_distance(grabberPosition);
        return Math.pp_sign(firstDistance - secondDistance, 0);
      });
      for (let grabbableToGrab of grabbablesToGrab) {
        if (!this._isAlreadyGrabbed(grabbableToGrab)) {
          let grabbableData = new _GrabberHandComponentGrabbableData(grabbableToGrab, this._myThrowVelocitySource == 1, this._myLinearVelocityHistorySize, this._myAngularVelocityHistorySize);
          this._myGrabbables.push(grabbableData);
          grabbableToGrab.grab(this.object);
          grabbableToGrab.registerReleaseEventListener(this, this._onRelease.bind(this));
          if (this._mySnapOnPivot) {
            grabbableToGrab.object.pp_resetPositionLocal();
          }
          this._myGrabEmitter.notify(this, grabbableToGrab);
        }
        if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
          break;
        }
      }
      if (this._myGrabbables.length > 0) {
        if (this._myActiveGrabButton == null) {
          this._myActiveGrabButton = grabButton;
        }
      }
    }
  }
  _throw(throwButton) {
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == throwButton || throwButton == null) {
      if (this._myGrabbables.length > 0) {
        let linearVelocity = null;
        let angularVelocity = null;
        if (this._myThrowVelocitySource == 0) {
          linearVelocity = this._computeReleaseLinearVelocity(this._myHandLinearVelocityHistory);
          angularVelocity = this._computeReleaseAngularVelocity(this._myHandAngularVelocityHistory);
        }
        for (let grabbableData of this._myGrabbables) {
          let grabbable = grabbableData.getGrabbable();
          grabbable.unregisterReleaseEventListener(this);
          if (this._myThrowVelocitySource == 1) {
            linearVelocity = this._computeReleaseLinearVelocity(grabbableData.getLinearVelocityHistory());
            angularVelocity = this._computeReleaseAngularVelocity(grabbableData.getAngularVelocityHistory());
          }
          grabbable.throw(linearVelocity, angularVelocity);
          this._myThrowEmitter.notify(this, grabbable);
        }
        this._myGrabbables = [];
      }
      this._myActiveGrabButton = null;
    }
  }
  _onRelease(grabber, grabbable) {
    grabbable.unregisterReleaseEventListener(this);
    this._myGrabbables.pp_remove((element) => element.getGrabbable() == grabbable);
    if (this._myGrabbables.length <= 0) {
      this._myActiveGrabButton = null;
    }
  }
  _updateLinearVelocityHistory() {
    let handPose = this._myGamepad.getHandPose();
    this._myHandLinearVelocityHistory.unshift(handPose.getLinearVelocity());
    this._myHandLinearVelocityHistory.pop();
    for (let grabbable of this._myGrabbables) {
      grabbable.updateLinearVelocityHistory();
    }
  }
  _updateAngularVelocityHistory() {
    let handPose = this._myGamepad.getHandPose();
    this._myHandAngularVelocityHistory.unshift(handPose.getAngularVelocityRadians());
    this._myHandAngularVelocityHistory.pop();
    for (let grabbable of this._myGrabbables) {
      grabbable.updateAngularVelocityHistory();
    }
  }
  _computeReleaseLinearVelocity(linearVelocityHistory) {
    let speed = linearVelocityHistory[0].vec3_length();
    for (let i = 1; i < this._myLinearVelocityHistorySpeedAverageSamplesFromStart; i++) {
      speed += linearVelocityHistory[i].vec3_length();
    }
    speed /= this._myLinearVelocityHistorySpeedAverageSamplesFromStart;
    let speedEaseMultiplier = Math.pp_mapToRange(speed, this._myThrowLinearVelocityBoostMinSpeedThreshold, this._myThrowLinearVelocityBoostMaxSpeedThreshold, 0, 1);
    speedEaseMultiplier = EasingFunction.easeIn(speedEaseMultiplier);
    let extraSpeed = speed * (speedEaseMultiplier * this._myThrowLinearVelocityBoost);
    speed += extraSpeed;
    speed *= this._myThrowLinearVelocityMultiplier;
    speed = Math.pp_clamp(speed, 0, this._myThrowMaxLinearSpeed);
    if (this._myDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      this._debugDirectionLines(linearVelocityHistory);
    }
    let directionCurrentWeight = this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let lastDirectionIndex = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let direction = vec3_create();
    for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
      let currentDirection = linearVelocityHistory[i];
      currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
      direction.vec3_add(currentDirection, direction);
      directionCurrentWeight--;
    }
    direction.vec3_normalize(direction);
    direction.vec3_scale(speed, direction);
    return direction;
  }
  _computeReleaseAngularVelocity(angularVelocityHistory) {
    let angularVelocity = angularVelocityHistory[0];
    let speed = angularVelocity.vec3_length();
    speed = Math.pp_clamp(speed * this._myThrowAngularVelocityMultiplier, 0, this._myThrowMaxAngularSpeedRadians);
    let direction = angularVelocity;
    direction.vec3_normalize(direction);
    direction.vec3_scale(speed, direction);
    return direction;
  }
  _debugDirectionLines(linearVelocityHistory) {
    for (let j = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart; j > this._myLinearVelocityHistoryDirectionAverageSkipFromStart; j--) {
      let directionCurrentWeight = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let lastDirectionIndex = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let direction = vec3_create();
      for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
        let currentDirection = linearVelocityHistory[i].pp_clone();
        currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
        direction.vec3_add(currentDirection, direction);
        directionCurrentWeight--;
      }
      direction.vec3_normalize(direction);
      let color = 1 / j;
      Globals.getDebugVisualManager(this.engine).drawLine(5, this.object.pp_getPosition(), direction, 0.2, vec4_create(color, color, color, 1));
    }
  }
  _isAlreadyGrabbed(grabbable) {
    let found = this._myGrabbables.pp_find((element) => element.getGrabbable() == grabbable);
    return found != null;
  }
};
var _GrabberHandComponentGrabbableData = class {
  constructor(grabbable, useGrabbableAsVelocitySource, linearVelocityHistorySize, angularVelocityHistorySize) {
    this._myGrabbable = grabbable;
    this._myUseGrabbableAsVelocitySource = useGrabbableAsVelocitySource;
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory = new Array(linearVelocityHistorySize);
      this._myLinearVelocityHistory.fill(vec3_create());
      this._myAngularVelocityHistory = new Array(angularVelocityHistorySize);
      this._myAngularVelocityHistory.fill(vec3_create());
    }
  }
  getGrabbable() {
    return this._myGrabbable;
  }
  getLinearVelocityHistory() {
    return this._myLinearVelocityHistory;
  }
  getAngularVelocityHistory() {
    return this._myAngularVelocityHistory;
  }
  updateLinearVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory.unshift(this._myGrabbable.getLinearVelocity());
      this._myLinearVelocityHistory.pop();
    }
  }
  updateAngularVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myAngularVelocityHistory.unshift(this._myGrabbable.getAngularVelocityRadians());
      this._myAngularVelocityHistory.pop();
    }
  }
  onDestroy() {
    this._myCollisionsCollector.destroy();
  }
};

// dist/gameplay/integrations/construct_arcade/ca_utils.js
var _myDummyServer = null;
var _myUseDummyServerOnSDKMissing = false;
var _myUseDummyServerOnError = false;
var CAError = {
  NONE: 0,
  CA_SDK_MISSING: 1,
  DUMMY_NOT_INITIALIZED: 2,
  GET_LEADERBOARD_FAILED: 3,
  SUBMIT_SCORE_FAILED: 4,
  GET_USER_FAILED: 5,
  USER_NOT_LOGGED_IN: 6,
  USER_HAS_NO_SCORE: 7
};
function setUseDummyServerOnSDKMissing(useDummyServer) {
  _myUseDummyServerOnSDKMissing = useDummyServer;
}
function setUseDummyServerOnError(useDummyServer) {
  _myUseDummyServerOnError = useDummyServer;
}
function setDummyServer(dummyServer) {
  _myDummyServer = dummyServer;
}
function isUseDummyServerOnSDKMissing() {
  return _myUseDummyServerOnSDKMissing;
}
function isUseDummyServerOnError() {
  return _myUseDummyServerOnError;
}
function getDummyServer() {
  return _myDummyServer;
}
function isSDKAvailable() {
  return window.heyVR != null;
}
function getSDK() {
  return window.heyVR;
}
function getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    try {
      _getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount).then(function(result) {
        if (result.leaderboard != null) {
          if (!aroundPlayer) {
            if (onDoneCallback != null) {
              onDoneCallback(result.leaderboard);
            }
          } else {
            let userLeaderboard = result.leaderboard;
            CAUtils.getUser(function(user) {
              let userName = user.displayName;
              let userValid = false;
              for (let userLeaderboardEntry of userLeaderboard) {
                if (userLeaderboardEntry.displayName == userName) {
                  userValid = true;
                  break;
                }
              }
              if (userValid) {
                if (onDoneCallback != null) {
                  onDoneCallback(userLeaderboard);
                }
              } else {
                if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                  CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.USER_HAS_NO_SCORE);
                } else if (onErrorCallback != null) {
                  let error3 = {};
                  error3.reason = "Searching for around player but the user has not submitted a score yet";
                  error3.type = CAError.USER_HAS_NO_SCORE;
                  onErrorCallback(error3, null);
                }
              }
            }, function(error3, result2) {
              if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, error3.type);
              } else if (onErrorCallback != null) {
                onErrorCallback(error3, result2);
              }
            }, false);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.GET_LEADERBOARD_FAILED);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Get leaderboard failed";
            error3.type = CAError.GET_LEADERBOARD_FAILED;
            onErrorCallback(error3, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.GET_LEADERBOARD_FAILED);
        } else if (onErrorCallback != null) {
          let error3 = {};
          error3.reason = "Get leaderboard failed";
          error3.type = CAError.GET_LEADERBOARD_FAILED;
          onErrorCallback(error3, result);
        }
      });
    } catch (error3) {
      if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.GET_LEADERBOARD_FAILED);
      } else if (onErrorCallback != null) {
        let error4 = {};
        error4.reason = "Get leaderboard failed";
        error4.type = CAError.GET_LEADERBOARD_FAILED;
        onErrorCallback(error4, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.CA_SDK_MISSING);
    } else if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Construct Arcade SDK missing";
      error3.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error3, null);
    }
  }
}
function getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
  if (_myDummyServer) {
    _myDummyServer.getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, caError);
  } else {
    if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Dummy server not initialized";
      error3.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error3, null);
    }
  }
}
function submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    try {
      _submitScore(leaderboardID, scoreToSubmit).then(function(result) {
        if (result.scoreSubmitted) {
          if (onDoneCallback != null) {
            onDoneCallback();
          }
        } else if (result.scoreSubmitted != null) {
          if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.USER_NOT_LOGGED_IN);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "The score can't be submitted because the user is not logged in";
            error3.type = CAError.USER_NOT_LOGGED_IN;
            onErrorCallback(error3, result);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.SUBMIT_SCORE_FAILED);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Submit score failed";
            error3.type = CAError.SUBMIT_SCORE_FAILED;
            onErrorCallback(error3, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.SUBMIT_SCORE_FAILED);
        } else if (onErrorCallback != null) {
          let error3 = {};
          error3.reason = "Submit score failed";
          error3.type = CAError.SUBMIT_SCORE_FAILED;
          onErrorCallback(error3, result);
        }
      });
    } catch (error3) {
      if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.SUBMIT_SCORE_FAILED);
      } else if (onErrorCallback != null) {
        let error4 = {};
        error4.reason = "Submit score failed";
        error4.type = CAError.SUBMIT_SCORE_FAILED;
        onErrorCallback(error4, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.CA_SDK_MISSING);
    } else if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Construct Arcade SDK missing";
      error3.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error3, null);
    }
  }
}
function submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
  if (_myDummyServer) {
    _myDummyServer.submitScore(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, caError);
  } else {
    if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Dummy server not initialized";
      error3.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error3, null);
    }
  }
}
function getUser(onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    try {
      _getUser().then(function(result) {
        if (result.user != null && result.user.displayName != null) {
          if (onDoneCallback != null) {
            onDoneCallback(result.user);
          }
        } else if (result.user != null) {
          if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.USER_NOT_LOGGED_IN);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "User not logged in";
            error3.type = CAError.USER_NOT_LOGGED_IN;
            onErrorCallback(error3, result);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.GET_USER_FAILED);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Get user failed";
            error3.type = CAError.GET_USER_FAILED;
            onErrorCallback(error3, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.GET_USER_FAILED);
        } else if (onErrorCallback != null) {
          let error3 = {};
          error3.reason = "Get user failed";
          error3.type = CAError.GET_USER_FAILED;
          onErrorCallback(error3, result);
        }
      });
    } catch (error3) {
      if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.GET_USER_FAILED);
      } else if (onErrorCallback != null) {
        let error4 = {};
        error4.reason = "Get user failed";
        error4.type = CAError.GET_USER_FAILED;
        onErrorCallback(error4, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.CA_SDK_MISSING);
    } else if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Construct Arcade SDK missing";
      error3.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error3, null);
    }
  }
}
function getUserDummy(onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
  if (_myDummyServer) {
    _myDummyServer.getUser(onDoneCallback, onErrorCallback, caError);
  } else {
    if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Dummy server not initialized";
      error3.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error3, null);
    }
  }
}
var CAUtils = {
  setUseDummyServerOnSDKMissing,
  setUseDummyServerOnError,
  setDummyServer,
  isUseDummyServerOnSDKMissing,
  isUseDummyServerOnError,
  getDummyServer,
  isSDKAvailable,
  getSDK,
  getLeaderboard,
  getLeaderboardDummy,
  submitScore,
  submitScoreDummy,
  getUser,
  getUserDummy
};
function _getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount) {
  let heyVR = CAUtils.getSDK();
  if (aroundPlayer) {
    return heyVR.leaderboard.getMy(leaderboardID, scoresAmount).then(function(result) {
      let adjustedLeaderboard = [];
      for (let leaderboardEntry of result) {
        adjustedLeaderboard.push({ rank: leaderboardEntry.rank - 1, displayName: leaderboardEntry.user, score: leaderboardEntry.score });
      }
      return { leaderboard: adjustedLeaderboard };
    }).catch(function(error3) {
      if (error3 != null && error3.status != null && error3.status.debug == "err_unauthenticated") {
        return { leaderboard: [] };
      } else {
        return { leaderboard: null };
      }
    });
  } else {
    return heyVR.leaderboard.get(leaderboardID, scoresAmount).then(function(result) {
      let adjustedLeaderboard = [];
      for (let leaderboardEntry of result) {
        adjustedLeaderboard.push({ rank: leaderboardEntry.rank - 1, displayName: leaderboardEntry.user, score: leaderboardEntry.score });
      }
      return { leaderboard: adjustedLeaderboard };
    }).catch(function() {
      return { leaderboard: null };
    });
  }
}
function _submitScore(leaderboardID, scoreToSubmit) {
  let heyVR = CAUtils.getSDK();
  return heyVR.leaderboard.postScore(leaderboardID, scoreToSubmit).then(function() {
    return { scoreSubmitted: true };
  }).catch(function(error3) {
    if (error3 != null && error3.status != null && error3.status.debug == "err_unauthenticated") {
      return { scoreSubmitted: false };
    } else {
      return { scoreSubmitted: null };
    }
  });
}
function _getUser() {
  let heyVR = CAUtils.getSDK();
  return heyVR.user.getName().then((result) => {
    return { user: { displayName: result } };
  }).catch(function(error3) {
    if (error3 != null && error3.status != null && error3.status.debug == "err_unauthenticated") {
      return { user: { displayName: null } };
    } else {
      return { user: null };
    }
  });
}

// dist/gameplay/integrations/construct_arcade/ca_dummy_server.js
var CADummyServer = class {
  constructor() {
  }
  getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
    let leaderboard = null;
    if (caError != CAError.CA_SDK_MISSING) {
      if (aroundPlayer && (caError == CAError.USER_NOT_LOGGED_IN || caError == CAError.USER_HAS_NO_SCORE)) {
        leaderboard = [
          { rank: 0, displayName: "Sign In", score: 0 },
          { rank: 1, displayName: "And", score: 0 },
          { rank: 2, displayName: "Play", score: 0 },
          { rank: 3, displayName: "On", score: 0 },
          { rank: 4, displayName: "HeyVR", score: 0 },
          { rank: 5, displayName: "To", score: 0 },
          { rank: 6, displayName: "Submit", score: 0 },
          { rank: 7, displayName: "Your", score: 0 },
          { rank: 8, displayName: "Own", score: 0 },
          { rank: 9, displayName: "Score", score: 0 }
        ];
      } else {
        leaderboard = [
          { rank: 0, displayName: "An", score: 0 },
          { rank: 1, displayName: "Error", score: 0 },
          { rank: 2, displayName: "Has", score: 0 },
          { rank: 3, displayName: "Occurred", score: 0 },
          { rank: 4, displayName: "While", score: 0 },
          { rank: 5, displayName: "Trying", score: 0 },
          { rank: 6, displayName: "To", score: 0 },
          { rank: 7, displayName: "Retrieve", score: 0 },
          { rank: 8, displayName: "The", score: 0 },
          { rank: 9, displayName: "Leaderboard", score: 0 }
        ];
      }
    } else {
      if (aroundPlayer) {
        leaderboard = [
          { rank: 0, displayName: "Sign In", score: 0 },
          { rank: 1, displayName: "And", score: 0 },
          { rank: 2, displayName: "Play", score: 0 },
          { rank: 3, displayName: "On", score: 0 },
          { rank: 4, displayName: "HeyVR", score: 0 },
          { rank: 5, displayName: "To", score: 0 },
          { rank: 6, displayName: "Submit", score: 0 },
          { rank: 7, displayName: "Your", score: 0 },
          { rank: 8, displayName: "Own", score: 0 },
          { rank: 9, displayName: "Score", score: 0 }
        ];
      } else {
        leaderboard = [
          { rank: 0, displayName: "The", score: 0 },
          { rank: 1, displayName: "Top 10", score: 0 },
          { rank: 2, displayName: "Leaderboard", score: 0 },
          { rank: 3, displayName: "Is", score: 0 },
          { rank: 4, displayName: "Available", score: 0 },
          { rank: 5, displayName: "Only", score: 0 },
          { rank: 5, displayName: "When", score: 0 },
          { rank: 7, displayName: "Playing", score: 0 },
          { rank: 8, displayName: "On", score: 0 },
          { rank: 9, displayName: "HeyVR", score: 0 }
        ];
      }
    }
    while (leaderboard.length > scoresAmount) {
      leaderboard.pop();
    }
    if (onDoneCallback != null) {
      onDoneCallback(leaderboard);
    }
  }
  submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
    if (onDoneCallback != null) {
      onDoneCallback();
    }
  }
  getUser(onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
    let user = {};
    user.displayName = "Florian";
    if (onDoneCallback != null) {
      onDoneCallback(user);
    }
  }
};

// dist/gameplay/integrations/construct_arcade/ca_display_leaderboard_component.js
import { Component as Component35, Property as Property29, TextComponent as TextComponent7 } from "@wonderlandengine/api";
var CADisplayLeaderboardComponent = class extends Component35 {
  static TypeName = "pp-ca-display-leaderboard";
  static Properties = {
    _myUsernamesTextObject: Property29.object(),
    _myScoresTextObject: Property29.object(),
    _myLeaderboardID: Property29.string(""),
    _myLocal: Property29.bool(false),
    _myAscending: Property29.bool(false),
    _myScoresAmount: Property29.int(10),
    _myScoreFormat: Property29.enum(["Value", "Hours:Minutes:Seconds", "Minutes:Seconds", "Seconds", "Hours:Minutes", "Minutes"], "Value"),
    _myPositionAndUsernameSeparator: Property29.string(" - "),
    _myNumberOfLinesBetweenScores: Property29.int(1),
    _myAddDefaultCADummyServer: Property29.bool(false)
  };
  init() {
    this._myUsernamesTextComponent = null;
    this._myScoresTextComponent = null;
    this._myStarted = false;
    this._myDestroyed = false;
  }
  start() {
    if (this._myAddDefaultCADummyServer) {
      CAUtils.setDummyServer(new CADummyServer());
      CAUtils.setUseDummyServerOnSDKMissing(true);
      CAUtils.setUseDummyServerOnError(true);
    }
  }
  update(dt) {
    if (!this._myStarted) {
      this._myStarted = true;
      if (this._myUsernamesTextObject != null) {
        this._myUsernamesTextComponent = this._myUsernamesTextObject.pp_getComponent(TextComponent7);
      }
      if (this._myScoresTextObject != null) {
        this._myScoresTextComponent = this._myScoresTextObject.pp_getComponent(TextComponent7);
      }
      this.updateLeaderboard();
    }
  }
  updateLeaderboard() {
    CAUtils.getLeaderboard(this._myLeaderboardID, this._myAscending, this._myLocal, this._myScoresAmount, this._onLeaderboardRetrieved.bind(this));
  }
  _onLeaderboardRetrieved(leaderboard) {
    if (this._myDestroyed)
      return;
    let namesText = "";
    let scoresText = "";
    let maxRankDigit = 0;
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      if (rank.toFixed(0).length > maxRankDigit) {
        maxRankDigit = rank.toFixed(0).length;
      }
    }
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      let fixedRank = rank.toFixed(0);
      while (fixedRank.length < maxRankDigit) {
        fixedRank = "0".concat(fixedRank);
      }
      let newlines = "\n";
      for (let i = 0; i < this._myNumberOfLinesBetweenScores; i++) {
        newlines = newlines + "\n";
      }
      namesText = namesText.concat(fixedRank, this._myPositionAndUsernameSeparator, value.displayName, newlines);
      let convertedScore = this._formatScore(value.score);
      scoresText = scoresText.concat(convertedScore, newlines);
    }
    if (this._myUsernamesTextComponent != null) {
      this._myUsernamesTextComponent.text = namesText;
    }
    if (this._myScoresTextComponent != null) {
      this._myScoresTextComponent.text = scoresText;
    }
  }
  _formatScore(score) {
    let convertedScore = score.toString();
    if (this._myScoreFormat == 1) {
      convertedScore = this._formatTime(score, true, true, true);
    } else if (this._myScoreFormat == 2) {
      convertedScore = this._formatTime(score, false, true, true);
    } else if (this._myScoreFormat == 3) {
      convertedScore = this._formatTime(score, false, false, true);
    } else if (this._myScoreFormat == 4) {
      convertedScore = this._formatTime(score, true, true, false);
    } else if (this._myScoreFormat == 5) {
      convertedScore = this._formatTime(score, false, true, false);
    }
    return convertedScore;
  }
  _formatTime(score, displayHours, displayMinutes, displaySeconds) {
    let time = Math.floor(score / 1e3);
    let hours = 0;
    if (displayHours) {
      hours = Math.floor(time / 3600);
      time -= hours * 3600;
    }
    let minutes = 0;
    if (displayMinutes) {
      minutes = Math.floor(time / 60);
      time -= minutes * 60;
    }
    let seconds = 0;
    if (displaySeconds) {
      seconds = Math.floor(time);
    }
    let convertedTime = "";
    if (displaySeconds) {
      convertedTime = seconds.toFixed(0).length < 2 && (displayMinutes || displayHours) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
    }
    if (displayMinutes) {
      convertedTime = (minutes.toFixed(0).length < 2 && (displaySeconds || displayHours) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0)) + (displaySeconds ? ":" + convertedTime : "");
    }
    if (displayHours) {
      convertedTime = (hours.toFixed(0).length < 2 && (displaySeconds || displayMinutes) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0)) + (displayMinutes ? ":" + convertedTime : "");
    }
    return convertedTime;
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
  onDestroy() {
    this._myDestroyed = true;
  }
};

// dist/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_utils.js
function generate360TeleportParamsFromMovementParams(movementParams, outTeleportParams = new CollisionCheckParams()) {
  outTeleportParams.copy(movementParams);
  outTeleportParams.myHalfConeAngle = 180;
  outTeleportParams.myHalfConeSliceAmount = Math.round(outTeleportParams.myHalfConeAngle / movementParams.myHalfConeAngle * movementParams.myHalfConeSliceAmount);
  outTeleportParams.myCheckHorizontalFixedForwardEnabled = true;
  outTeleportParams.myCheckHorizontalFixedForward = vec3_create(0, 0, 1);
  return outTeleportParams;
}
var CollisionCheckUtils = {
  generate360TeleportParamsFromMovementParams
};

// dist/gameplay/experimental/character_controller/collision/character_collider_setup.js
var CharacterColliderSetup = class {
  constructor() {
    this.myHeight = 0;
    this.myHorizontalCheckParams = new CharacterColliderHorizontalCheckParams();
    this.myVerticalCheckParams = new CharacterColliderVerticalCheckParams();
    this.myWallSlideParams = new CharacterColliderWallSlideParams();
    this.myGroundParams = new CharacterColliderSurfaceParams();
    this.myCeilingParams = new CharacterColliderSurfaceParams();
    this.mySplitMovementParams = new CharacterColliderSplitMovementParams();
    this.myAdditionalParams = new CharacterColliderAdditionalParams();
    this.myDebugParams = new CharacterColliderDebugParams();
  }
  copy(other) {
  }
};
var CharacterColliderHorizontalPositionVerticalCheckDirection = {
  UPWARD: 0,
  // Gives less issues with a ground based movement, but may also collide a bit more, resulting in less sliding
  DOWNWARD: 1,
  // Gives less issues with a ceiling based movement (unusual), but may also collide a bit more, resulting in less sliding and more stuck in front of a wall
  BOTH: 2
  // Check both directions, more expensive (2x checks) and better prevent collisions, sliding more, but is more expensive and gives more issues           
  //                                                                                                                                                  _
  // The issues means that a small step at the end of a slope, maybe due to 2 rectangles, one for the floor and the other for the slope like this -> /   
  // can create a small step if the floor rectangle is a bit above the end of the slope, this will make the character get stuck thinking it's a wall
  // BOTH do a more "aggressive" vertical check that makes the character get less stuck in other situations, but can get stuck in this one
  // The better solution is to properly create the level, and if possible combine the 2 rectangles by having the floor a little below the end of the slope (like this -> /-)
  // The step that is created "on the other side" in fact can easily be ignored thanks to the myHorizontalCheckFeetDistanceToIgnore param
  // If the level is properly created the best solution should be UPWARD
  // and also myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false
};
var CharacterColliderHorizontalCheckParams = class {
  constructor() {
    this.myHorizontalCheckConeRadius = 0;
    this.myHorizontalCheckConeHalfAngle = 0;
    this.myHorizontalHeightCheckEnabled = false;
    this.myHorizontalCheckFeetDistanceToIgnore = 0;
    this.myHorizontalCheckHeadDistanceToIgnore = 0;
    this.myHorizontalCheckFixedForwardEnabled = false;
    this.myHorizontalCheckFixedForward = vec3_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementCheckRadialSteps = 0;
    this.myHorizontalMovementCheckSplitMovementEnabled = false;
    this.myHorizontalMovementCheckSplitMovementMaxSteps = null;
    this.myHorizontalMovementCheckSplitMovementMaxStepLength = null;
    this.myHorizontalMovementCheckSplitMovementMinStepLength = null;
    this.myHorizontalMovementCheckGetBetterReferenceHit = false;
    this.myHorizontalMovementHorizontalRadialCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementHeightCheckSteps = 0;
    this.myHorizontalMovementHeightHorizontalCheckEnabled = false;
    this.myHorizontalMovementHeightVerticalCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHorizontalPositionCheckConeHalfSlices = 0;
    this.myHorizontalPositionHorizontalBorderCheckEnabled = false;
    this.myHorizontalPositionHorizontalRadialCheckEnabled = false;
    this.myHorizontalPositionHeightCheckSteps = 0;
    this.myHorizontalPositionHeightHorizontalCheckEnabled = false;
    this.myHorizontalPositionHeightVerticalCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalCheckGetFarthestHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = false;
    this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false;
    this.myHorizontalPositionVerticalCheckDirection = CharacterColliderHorizontalPositionVerticalCheckDirection.UPWARD;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
  }
  copy(other) {
  }
};
var CharacterColliderVerticalCheckParams = class {
  constructor() {
    this.myVerticalCheckCircumferenceRadius = 0;
    this.myVerticalCheckCircumferenceSlices = 0;
    this.myVerticalCheckCircumferenceCentralCheckEnabled = false;
    this.myVerticalCheckCircumferenceRadialSteps = 0;
    this.myVerticalCheckCircumferenceRotationPerRadialStep = 0;
    this.myVerticalCheckFixedForwardEnabled = false;
    this.myVerticalCheckFixedForward = vec3_create();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalMovementCheckReductionEnabled = false;
    this.myVerticalMovementCheckPerformCheckOnBothSides = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = false;
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
  }
  copy(other) {
  }
};
var CharacterColliderSlideFlickerPreventionMode = {
  NONE: 0,
  USE_PREVIOUS_RESULTS: 1,
  // Allow some flicker before stabilizing but avoid stopping for a 1 frame flicker only (false positive), is also less expensive
  COLLISION_ANGLE_ABOVE_90_DEGREES: 2,
  // Prevents most flicker apart those on almost flat surface, can have some false positive, always check when sliding into opposite direction
  COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES: 3,
  // Less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES but more false positive, always check when sliding into opposite direction
  ALWAYS: 4
  // Less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES but more false positive
};
var CharacterColliderWallSlideParams = class {
  constructor() {
    this.myWallSlideEnabled = false;
    this.myWallSlideMaxAttempts = 0;
    this.myCheckBothWallSlideDirections = false;
    this.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  copy(other) {
  }
};
var CharacterColliderSurfaceParams = class {
  constructor() {
    this.mySurfaceSnapEnabled = false;
    this.mySurfaceSnapMaxDistance = 0;
    this.mySurfacePopOutEnabled = false;
    this.mySurfacePopOutMaxDistance = 0;
    this.mySurfaceAngleToIgnore = 0;
    this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = null;
    this.myCollectSurfaceInfo = false;
    this.myOnSurfaceMaxOutsideDistance = 0;
    this.myOnSurfaceMaxInsideDistance = 0;
    this.myBaseInsideCollisionCheckEnabled = false;
    this.myOnSurfaceIfBaseInsideCollision = false;
    this.myCollectSurfaceNormalMaxOutsideDistance = 0;
    this.myCollectSurfaceNormalMaxInsideDistance = 0;
    this.myFindSurfaceDistanceMaxOutsideDistance = 0;
    this.myFindSurfaceDistanceMaxInsideDistance = 0;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = false;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = false;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = null;
    this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill = false;
    this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle = null;
    this.myMovementMustStayOnSurface = false;
    this.myMovementMustStayOnSurfaceHitMaxAngle = null;
    this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = false;
    this.myMovementMustStayOnSurfaceAngleDownhill = null;
    this.myTeleportMustBeOnSurface = false;
    this.myTeleportMustBeOnIgnorableSurfaceAngle = false;
    this.myTeleportMustBeOnSurfaceAngle = null;
    this.myCheckTransformMustBeOnSurface = false;
    this.myCheckTransformMustBeOnIgnorableSurfaceAngle = false;
    this.myCheckTransformMustBeOnSurfaceAngle = null;
    this.myRecollectSurfaceInfoOnSurfaceCheckFailed = false;
    this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = false;
  }
  copy(other) {
  }
};
var CharacterColliderSplitMovementParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxSteps = null;
    this.mySplitMovementMaxStepLength = null;
    this.mySplitMovementMinStepLength = null;
    this.mySplitMovementStopOnHorizontalMovementFailed = false;
    this.mySplitMovementStopOnVerticalMovementFailed = false;
    this.mySplitMovementStopReturnPreviousResults = false;
  }
  copy(other) {
  }
};
var CharacterColliderAdditionalParams = class {
  constructor() {
    this.myPositionOffsetLocal = vec3_create();
    this.myRotationOffsetLocalQuat = quat_create();
  }
  copy(other) {
  }
};
var CharacterColliderDebugParams = class {
  constructor() {
    this.myVisualDebugEnabled = false;
    this.myVisualDebugMovementEnabled = false;
    this.myVisualDebugHorizontalMovementCheckEnabled = false;
    this.myVisualDebugHorizontalPositionCheckEnabled = false;
    this.myVisualDebugVerticalMovementCheckEnabled = false;
    this.myVisualDebugVerticalPositionCheckEnabled = false;
    this.myVisualDebugSlideEnabled = false;
    this.myVisualDebugGroundInfoEnabled = false;
    this.myVisualDebugCeilingInfoEnabled = false;
    this.myVisualDebugResultsEnabled = false;
  }
  copy(other) {
  }
};
CharacterColliderSetup.prototype.copy = function copy27(other) {
  this.myHeight = other.myHeight;
  this.myHorizontalCheckParams.copy(other.myHorizontalCheckParams);
  this.myVerticalCheckParams.copy(other.myVerticalCheckParams);
  this.myWallSlideParams.copy(other.myWallSlideParams);
  this.myGroundParams.copy(other.myGroundParams);
  this.myCeilingParams.copy(other.myCeilingParams);
  this.mySplitMovementParams.copy(other.mySplitMovementParams);
  this.myAdditionalParams.copy(other.myAdditionalParams);
  this.myDebugParams.copy(other.myDebugParams);
};
CharacterColliderHorizontalCheckParams.prototype.copy = function copy28(other) {
  this.myHorizontalCheckConeRadius = other.myHorizontalCheckConeRadius;
  this.myHorizontalCheckConeHalfAngle = other.myHorizontalCheckConeHalfAngle;
  this.myHorizontalHeightCheckEnabled = other.myHorizontalHeightCheckEnabled;
  this.myHorizontalCheckFeetDistanceToIgnore = other.myHorizontalCheckFeetDistanceToIgnore;
  this.myHorizontalCheckHeadDistanceToIgnore = other.myHorizontalCheckHeadDistanceToIgnore;
  this.myHorizontalCheckFixedForwardEnabled = other.myHorizontalCheckFixedForwardEnabled;
  this.myHorizontalCheckFixedForward.vec3_copy(other.myHorizontalCheckFixedForward);
  this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
  this.myHorizontalMovementCheckRadialSteps = other.myHorizontalMovementCheckRadialSteps;
  this.myHorizontalMovementCheckSplitMovementEnabled = other.myHorizontalMovementCheckSplitMovementEnabled;
  this.myHorizontalMovementCheckSplitMovementMaxSteps = other.myHorizontalMovementCheckSplitMovementMaxSteps;
  this.myHorizontalMovementCheckSplitMovementMaxStepLength = other.myHorizontalMovementCheckSplitMovementMaxStepLength;
  this.myHorizontalMovementCheckSplitMovementMinStepLength = other.myHorizontalMovementCheckSplitMovementMinStepLength;
  this.myHorizontalMovementCheckGetBetterReferenceHit = other.myHorizontalMovementCheckGetBetterReferenceHit;
  this.myHorizontalMovementHorizontalRadialCheckEnabled = other.myHorizontalMovementHorizontalRadialCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCheckEnabled = other.myHorizontalMovementHorizontalStraightCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
  this.myHorizontalMovementHeightCheckSteps = other.myHorizontalMovementHeightCheckSteps;
  this.myHorizontalMovementHeightVerticalCheckEnabled = other.myHorizontalMovementHeightVerticalCheckEnabled;
  this.myHorizontalMovementHeightHorizontalCheckEnabled = other.myHorizontalMovementHeightHorizontalCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightCheckEnabled = other.myHorizontalMovementVerticalStraightCheckEnabled;
  this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
  this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
  this.myHorizontalPositionCheckConeHalfSlices = other.myHorizontalPositionCheckConeHalfSlices;
  this.myHorizontalPositionHorizontalBorderCheckEnabled = other.myHorizontalPositionHorizontalBorderCheckEnabled;
  this.myHorizontalPositionHorizontalRadialCheckEnabled = other.myHorizontalPositionHorizontalRadialCheckEnabled;
  this.myHorizontalPositionHeightCheckSteps = other.myHorizontalPositionHeightCheckSteps;
  this.myHorizontalPositionHeightHorizontalCheckEnabled = other.myHorizontalPositionHeightHorizontalCheckEnabled;
  this.myHorizontalPositionHeightVerticalCheckEnabled = other.myHorizontalPositionHeightVerticalCheckEnabled;
  this.myHorizontalPositionVerticalStraightCheckEnabled = other.myHorizontalPositionVerticalStraightCheckEnabled;
  this.myHorizontalPositionVerticalStraightCentralCheckEnabled = other.myHorizontalPositionVerticalStraightCentralCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalCheckGetFarthestHit = other.myHorizontalPositionVerticalCheckGetFarthestHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
  this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = other.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
  this.myHorizontalPositionVerticalCheckDirection = other.myHorizontalPositionVerticalCheckDirection;
  this.myHorizontalCheckBlockLayerFlags.setMask(other.myHorizontalCheckBlockLayerFlags.getMask());
  this.myHorizontalCheckObjectsToIgnore.pp_copy(other.myHorizontalCheckObjectsToIgnore);
};
CharacterColliderVerticalCheckParams.prototype.copy = function copy29(other) {
  this.myVerticalCheckCircumferenceRadius = other.myVerticalCheckCircumferenceRadius;
  this.myVerticalCheckCircumferenceSlices = other.myVerticalCheckCircumferenceSlices;
  this.myVerticalCheckCircumferenceCentralCheckEnabled = other.myVerticalCheckCircumferenceCentralCheckEnabled;
  this.myVerticalCheckCircumferenceRadialSteps = other.myVerticalCheckCircumferenceRadialSteps;
  this.myVerticalCheckCircumferenceRotationPerRadialStep = other.myVerticalCheckCircumferenceRotationPerRadialStep;
  this.myVerticalCheckFixedForwardEnabled = other.myVerticalCheckFixedForwardEnabled;
  this.myVerticalCheckFixedForward.vec3_copy(other.myVerticalCheckFixedForward);
  this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
  this.myVerticalMovementCheckReductionEnabled = other.myVerticalMovementCheckReductionEnabled;
  this.myVerticalMovementCheckPerformCheckOnBothSides = other.myVerticalMovementCheckPerformCheckOnBothSides;
  this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
  this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = other.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
  this.myVerticalCheckBlockLayerFlags.setMask(other.myVerticalCheckBlockLayerFlags.getMask());
  this.myVerticalCheckObjectsToIgnore.pp_copy(other.myVerticalCheckObjectsToIgnore);
};
CharacterColliderWallSlideParams.prototype.copy = function copy30(other) {
  this.myWallSlideEnabled = other.myWallSlideEnabled;
  this.myWallSlideMaxAttempts = other.myWallSlideMaxAttempts;
  this.myCheckBothWallSlideDirections = other.myCheckBothWallSlideDirections;
  this.myWallSlideFlickerPreventionMode = other.myWallSlideFlickerPreventionMode;
  this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = other.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
  this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
  this.my90DegreesWallSlideAdjustDirectionSign = other.my90DegreesWallSlideAdjustDirectionSign;
};
CharacterColliderSurfaceParams.prototype.copy = function copy31(other) {
  this.mySurfaceSnapEnabled = other.mySurfaceSnapEnabled;
  this.mySurfaceSnapMaxDistance = other.mySurfaceSnapMaxDistance;
  this.mySurfacePopOutEnabled = other.mySurfacePopOutEnabled;
  this.mySurfacePopOutMaxDistance = other.mySurfacePopOutMaxDistance;
  this.mySurfaceAngleToIgnore = other.mySurfaceAngleToIgnore;
  this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = other.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = other.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
  this.myCollectSurfaceInfo = other.myCollectSurfaceInfo;
  this.myOnSurfaceMaxOutsideDistance = other.myOnSurfaceMaxOutsideDistance;
  this.myOnSurfaceMaxInsideDistance = other.myOnSurfaceMaxInsideDistance;
  this.myBaseInsideCollisionCheckEnabled = other.myBaseInsideCollisionCheckEnabled;
  this.myOnSurfaceIfBaseInsideCollision = other.myOnSurfaceIfBaseInsideCollision;
  this.myCollectSurfaceNormalMaxOutsideDistance = other.myCollectSurfaceNormalMaxOutsideDistance;
  this.myCollectSurfaceNormalMaxInsideDistance = other.myCollectSurfaceNormalMaxInsideDistance;
  this.myFindSurfaceDistanceMaxOutsideDistance = other.myFindSurfaceDistanceMaxOutsideDistance;
  this.myFindSurfaceDistanceMaxInsideDistance = other.myFindSurfaceDistanceMaxInsideDistance;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
  this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill = other.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
  this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle = other.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
  this.myMovementMustStayOnSurface = other.myMovementMustStayOnSurface;
  this.myMovementMustStayOnSurfaceHitMaxAngle = other.myMovementMustStayOnSurfaceHitMaxAngle;
  this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = other.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
  this.myMovementMustStayOnSurfaceAngleDownhill = other.myMovementMustStayOnSurfaceAngleDownhill;
  this.myTeleportMustBeOnSurface = other.myTeleportMustBeOnSurface;
  this.myTeleportMustBeOnIgnorableSurfaceAngle = other.myTeleportMustBeOnIgnorableSurfaceAngle;
  this.myTeleportMustBeOnSurfaceAngle = other.myTeleportMustBeOnSurfaceAngle;
  this.myCheckTransformMustBeOnSurface = other.myCheckTransformMustBeOnSurface;
  this.myCheckTransformMustBeOnIgnorableSurfaceAngle = other.myCheckTransformMustBeOnIgnorableSurfaceAngle;
  this.myCheckTransformMustBeOnSurfaceAngle = other.myCheckTransformMustBeOnSurfaceAngle;
  this.myRecollectSurfaceInfoOnSurfaceCheckFailed = other.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = other.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
};
CharacterColliderSplitMovementParams.prototype.copy = function copy32(other) {
  this.mySplitMovementEnabled = other.mySplitMovementEnabled;
  this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
  this.mySplitMovementMaxStepLength = other.mySplitMovementMaxStepLength;
  this.mySplitMovementMinStepLength = other.mySplitMovementMinStepLength;
  this.mySplitMovementStopOnHorizontalMovementFailed = other.mySplitMovementStopOnHorizontalMovementFailed;
  this.mySplitMovementStopOnVerticalMovementFailed = other.mySplitMovementStopOnVerticalMovementFailed;
  this.mySplitMovementStopReturnPreviousResults = other.mySplitMovementStopReturnPreviousResults;
};
CharacterColliderAdditionalParams.prototype.copy = function copy33(other) {
  this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
  this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
};
CharacterColliderDebugParams.prototype.copy = function copy34(other) {
  this.myVisualDebugEnabled = other.myVisualDebugEnabled;
  this.myVisualDebugMovementEnabled = other.myVisualDebugMovementEnabled;
  this.myVisualDebugHorizontalMovementCheckEnabled = other.myVisualDebugHorizontalMovementCheckEnabled;
  this.myVisualDebugHorizontalPositionCheckEnabled = other.myVisualDebugHorizontalPositionCheckEnabled;
  this.myVisualDebugVerticalMovementCheckEnabled = other.myVisualDebugVerticalMovementCheckEnabled;
  this.myVisualDebugVerticalPositionCheckEnabled = other.myVisualDebugVerticalPositionCheckEnabled;
  this.myVisualDebugSlideEnabled = other.myVisualDebugSlideEnabled;
  this.myVisualDebugGroundInfoEnabled = other.myVisualDebugGroundInfoEnabled;
  this.myVisualDebugCeilingInfoEnabled = other.myVisualDebugCeilingInfoEnabled;
  this.myVisualDebugResultsEnabled = other.myVisualDebugResultsEnabled;
};

// dist/gameplay/experimental/character_controller/character_controller_utils.js
function computeGroundPerceivedAngle(surfaceNormal, direction, up) {
  return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, true);
}
function computeCeilingPerceivedAngle(surfaceNormal, direction, up) {
  return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, false);
}
var computeSurfacePerceivedAngle = function() {
  let directionOnSurface = vec3_create();
  let verticalDirection = vec3_create();
  return function computeSurfacePerceivedAngle2(surfaceNormal, direction, up, ground) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!ground) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    directionOnSurface = direction.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, directionOnSurface);
    surfacePerceivedAngle = directionOnSurface.vec3_angle(direction);
    let fartherOnUp = directionOnSurface.vec3_isFartherAlongAxis(direction, up);
    if (!fartherOnUp && ground || fartherOnUp && !ground) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();
var CharacterControllerUtils = {
  computeGroundPerceivedAngle,
  computeCeilingPerceivedAngle,
  computeSurfacePerceivedAngle
};

// dist/gameplay/experimental/character_controller/collision/character_collider_setup_utils.js
var CharacterColliderSetupSimplifiedCreationAccuracyLevel = {
  VERY_LOW: 0,
  LOW: 1,
  MEDIUM: 2,
  HIGH: 3,
  VERY_HIGH: 4
};
var CharacterColliderSetupSimplifiedCreationParams = class {
  constructor() {
    this.myHeight = 0;
    this.myRadius = 0;
    this.myAccuracyLevel = CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW;
    this.myIsPlayer = false;
    this.myCheckOnlyFeet = false;
    this.myMaxSpeed = 0;
    this.myAverageFPS = 72;
    this.myCanFly = false;
    this.myShouldSlideAlongWall = false;
    this.myCollectGroundInfo = false;
    this.myShouldSnapOnGround = false;
    this.myMaxDistanceToSnapOnGround = 0;
    this.myMaxWalkableGroundAngle = 0;
    this.myMaxWalkableGroundStepHeight = 0;
    this.myShouldNotFallFromEdges = false;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
    this.myHorizontalCheckDebugEnabled = false;
    this.myVerticalCheckDebugEnabled = false;
  }
};
function createSimplified(simplifiedCreationParams, outCharacterColliderSetup = new CharacterColliderSetup()) {
  outCharacterColliderSetup.myHeight = simplifiedCreationParams.myHeight;
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeRadius = simplifiedCreationParams.myRadius;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadius = simplifiedCreationParams.myRadius / 2;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForwardEnabled = true;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForward.vec3_set(0, 0, 1);
  if (!simplifiedCreationParams.myCheckOnlyFeet || simplifiedCreationParams.myCanFly) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalHeightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckEnabled = true;
  }
  outCharacterColliderSetup.myWallSlideParams.myWallSlideEnabled = simplifiedCreationParams.myShouldSlideAlongWall;
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore = simplifiedCreationParams.myMaxWalkableGroundStepHeight;
  outCharacterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround > 0 ? simplifiedCreationParams.myMaxDistanceToSnapOnGround : simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance = Math.max(outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance, outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore);
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = simplifiedCreationParams.myRadius * 0.75;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceInfo = simplifiedCreationParams.myCollectGroundInfo || simplifiedCreationParams.myMaxWalkableGroundAngle > 0;
  outCharacterColliderSetup.myGroundParams.mySurfaceSnapEnabled = simplifiedCreationParams.myShouldSnapOnGround;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutEnabled = true;
  outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore = simplifiedCreationParams.myMaxWalkableGroundAngle;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngle = true;
  outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance = simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = true;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = true;
  if (simplifiedCreationParams.myCanFly) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore = outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceInfo = outCharacterColliderSetup.myGroundParams.myCollectSurfaceInfo;
    outCharacterColliderSetup.myCeilingParams.mySurfacePopOutEnabled = outCharacterColliderSetup.myGroundParams.mySurfacePopOutEnabled;
    outCharacterColliderSetup.myCeilingParams.mySurfaceAngleToIgnore = outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore;
    outCharacterColliderSetup.myCeilingParams.mySurfaceSnapMaxDistance = outCharacterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance;
    outCharacterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance = outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = outCharacterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngle = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngle;
    outCharacterColliderSetup.myCeilingParams.myOnSurfaceMaxOutsideDistance = outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myOnSurfaceMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
  }
  if (simplifiedCreationParams.myShouldNotFallFromEdges) {
    outCharacterColliderSetup.myGroundParams.myMovementMustStayOnSurface = true;
    outCharacterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceAngleDownhill = Math.max(60, outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore);
  }
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckBlockLayerFlags.copy(simplifiedCreationParams.myHorizontalCheckBlockLayerFlags);
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myHorizontalCheckObjectsToIgnore);
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckBlockLayerFlags.copy(simplifiedCreationParams.myVerticalCheckBlockLayerFlags);
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myVerticalCheckObjectsToIgnore);
  if (simplifiedCreationParams.myHorizontalCheckDebugEnabled) {
    outCharacterColliderSetup.myDebugParams.myVisualDebugEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugHorizontalPositionCheckEnabled = true;
  }
  if (simplifiedCreationParams.myVerticalCheckDebugEnabled) {
    outCharacterColliderSetup.myDebugParams.myVisualDebugEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugVerticalPositionCheckEnabled = true;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle = 60;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 4;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 1;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckReductionEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckAllowHitsInsideCollisionIfOneValid = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 2;
      outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = true;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.LOW) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckRadialSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 2;
    outCharacterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections = false;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter = 0;
    outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.MEDIUM) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalBorderCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckPerformCheckOnBothSides = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 6;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 3;
    outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.USE_PREVIOUS_RESULTS;
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = true;
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter = 4;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.HIGH) {
    if (outCharacterColliderSetup.myWallSlideParams.myWallSlideEnabled) {
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckGetBetterReferenceHit = true;
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    }
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 8;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 4;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections = true;
    }
    outCharacterColliderSetup.myGroundParams.myBaseInsideCollisionCheckEnabled = true;
    outCharacterColliderSetup.myCeilingParams.myBaseInsideCollisionCheckEnabled = true;
    let safeRadius = simplifiedCreationParams.myRadius * 0.75;
    if (simplifiedCreationParams.myMaxSpeed / simplifiedCreationParams.myAverageFPS > safeRadius) {
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementEnabled = true;
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps = Math.ceil(simplifiedCreationParams.myMaxSpeed / simplifiedCreationParams.myAverageFPS / safeRadius);
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength = safeRadius;
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength = safeRadius;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_HIGH) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    outCharacterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed = true;
    outCharacterColliderSetup.myCeilingParams.myRecollectSurfaceInfoOnSurfaceCheckFailed = outCharacterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  }
  return outCharacterColliderSetup;
}
function createTeleportColliderSetupFromMovementColliderSetup(movementColliderSetup, outTeleportColliderSetup = new CharacterColliderSetup()) {
  outTeleportColliderSetup.copy(movementColliderSetup);
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle = 180;
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = Math.round(outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle / movementColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle * movementColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices);
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForwardEnabled = true;
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForward.vec3_set(0, 0, 1);
  return outTeleportColliderSetup;
}
var CharacterColliderSetupUtils = {
  createSimplified,
  createTeleportColliderSetupFromMovementColliderSetup
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_head_manager.js
var NonVRReferenceSpaceMode = {
  NO_FLOOR: 0,
  FLOOR: 1,
  NO_FLOOR_THEN_KEEP_VR: 2,
  FLOOR_THEN_KEEP_VR: 3
};
var PlayerHeadManagerParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.mySessionChangeResyncEnabled = false;
    this.myBlurEndResyncEnabled = false;
    this.myBlurEndResyncRotation = false;
    this.myResetTransformOnViewResetEnabled = true;
    this.myNextEnterSessionResyncHeight = false;
    this.myEnterSessionResyncHeight = false;
    this.myExitSessionResyncHeight = false;
    this.myExitSessionResyncVerticalAngle = false;
    this.myExitSessionRemoveRightTilt = false;
    this.myExitSessionAdjustMaxVerticalAngle = false;
    this.myExitSessionMaxVerticalAngle = 0;
    this.myExitSessionResetNonVRTransformLocal = true;
    this.myNonVRFloorBasedMode = NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR;
    this.myRotateFeetKeepUp = false;
    this.myDefaultHeightNonVR = 0;
    this.myDefaultHeightVRWithoutFloor = 0;
    this.myDefaultHeightVRWithFloor = null;
    this.myForeheadExtraHeight = 0;
    this.myEngine = engine;
    this.myDebugEnabled = false;
  }
};
var PlayerHeadManager = class {
  constructor(params = new PlayerHeadManagerParams()) {
    this._myParams = params;
    this._myCurrentHead = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._mySessionChangeResyncHeadTransform = null;
    this._myBlurRecoverHeadTransform = null;
    this._myCurrentHeadTransformLocalQuat = quat2_create();
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer = new Timer(5, false);
    this._myVisibilityHidden = false;
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    this._myIsSyncedDelayCounter = 0;
    this._myViewResetThisFrame = false;
    this._myViewResetEventListener = null;
    this._myHeightNonVR = 0;
    this._myHeightNonVROnEnterSession = 0;
    this._myHeightVRWithoutFloor = null;
    this._myHeightVRWithFloor = null;
    this._myHeightOffsetWithFloor = 0;
    this._myHeightOffsetWithoutFloor = 0;
    this._myNextEnterSessionSetHeightVRWithFloor = false;
    this._myNextEnterSessionSetHeightVRWithoutFloor = false;
    this._myDelayNextEnterSessionSetHeightVRCounter = 0;
    this._myLastReferenceSpaceIsFloorBased = null;
    this._myActive = true;
    this._myDestroyed = false;
    this._myResyncCounterFrames = 3;
    this._myIsSyncedDelayCounterFrames = 1;
  }
  start() {
    this._setHeightHeadNonVR(this._myParams.myDefaultHeightNonVR);
    this._setHeightHeadVRWithoutFloor(this._myParams.myDefaultHeightVRWithoutFloor);
    this._setHeightHeadVRWithFloor(this._myParams.myDefaultHeightVRWithFloor);
    this._updateHeightOffset();
    this._setCameraNonXRHeight(this._myHeightNonVR);
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myParams.myEngine);
  }
  setActive(active) {
    this._myActive = active;
  }
  getParams() {
    return this._myParams;
  }
  getPlayer() {
    return Globals.getPlayerObjects(this._myParams.myEngine).myPlayer;
  }
  getHead() {
    return this._myCurrentHead;
  }
  getHeightHead() {
    return this.getHeightEyes() + this._myParams.myForeheadExtraHeight;
  }
  getHeightEyes() {
  }
  getTransformFeetQuat(outTransformFeetQuat = quat2_create()) {
  }
  getTransformHeadQuat(outTransformFeetQuat = quat2_create()) {
    return this.getHead().pp_getTransformQuat(outTransformFeetQuat);
  }
  getPositionFeet(outPositionFeet = vec3_create()) {
  }
  getPositionHead(outPositionHead = vec3_create()) {
    return this._myCurrentHead.pp_getPosition(outPositionHead);
  }
  getRotationFeetQuat(outRotationFeetQuat = quat_create()) {
  }
  getRotationHeadQuat(outRotationHeadQuat = quat_create()) {
    return this.getHead().pp_getRotationQuat(outRotationHeadQuat);
  }
  isSynced() {
    return this._myIsSyncedDelayCounter == 0 && this._myDelaySessionChangeResyncCounter == 0 && this._myDelayNextEnterSessionSetHeightVRCounter == 0 && this._myDelayBlurEndResyncCounter == 0 && !this._myDelayBlurEndResyncTimer.isRunning() && !this._mySessionBlurred;
  }
  setHeightHead(height, setOnlyForActiveOne = true) {
    this._setHeightHead(height, height, height, setOnlyForActiveOne);
  }
  resetHeightHeadToDefault(resetOnlyForActiveOne = true) {
    this._setHeightHead(this._myHeightNonVR, this._myHeightVRWithoutFloor, this._myHeightVRWithFloor, resetOnlyForActiveOne);
  }
  setHeightHeadNonVR(height) {
    this._setHeightHeadNonVR(height);
    if (!this._mySessionActive) {
      this._updateHeightOffset();
      this._setCameraNonXRHeight(this._myHeightNonVR);
    }
  }
  setHeightHeadVRWithoutFloor(height) {
    this._setHeightHeadVRWithoutFloor(height);
    if (this._mySessionActive) {
      this._updateHeightOffset();
    }
  }
  resetHeightHeadVRWithFloor() {
    this.setHeightHeadVRWithFloor(null);
  }
  setHeightHeadVRWithFloor(height = null) {
    this._setHeightHeadVRWithFloor(height);
    if (this._mySessionActive) {
      this._updateHeightOffset();
    }
  }
  getDefaultHeightHeadNonVR() {
    return this._myHeightNonVR;
  }
  getDefaultHeightHeadVRWithoutFloor() {
    return this._myHeightVRWithoutFloor;
  }
  getDefaultHeightHeadVRWithFloor() {
    return this._myHeightVRWithFloor;
  }
  moveFeet(movement) {
  }
  moveHead(movement) {
    this.moveFeet(movement);
  }
  teleportPositionHead(teleportPosition) {
  }
  teleportPositionFeet(teleportPosition) {
  }
  teleportPlayerToHeadTransformQuat(headTransformQuat) {
  }
  rotateFeetQuat(rotationQuat, keepUpOverride = null) {
  }
  rotateHeadQuat(rotationQuat) {
  }
  canRotateFeet() {
    return true;
  }
  canRotateHead() {
    return !this._mySessionActive;
  }
  setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
  }
  setRotationHeadQuat() {
  }
  lookAtFeet(position, up = null, keepUpOverride = null) {
  }
  lookToFeet(direction, up = null, keepUpOverride = null) {
  }
  lookAtHead(position, up = null) {
  }
  lookToHead(direction, up = null) {
  }
  resetCameraNonXR() {
    Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_resetTransformLocal();
    this._setCameraNonXRHeight(this._myHeightNonVR);
  }
  update(dt) {
    this._myViewResetThisFrame = false;
    if (this._myIsSyncedDelayCounter != 0) {
      this._myIsSyncedDelayCounter--;
      this._myIsSyncedDelayCounter = Math.max(0, this._myIsSyncedDelayCounter);
    }
    if (this._myDelaySessionChangeResyncCounter > 0) {
      this._myDelaySessionChangeResyncCounter--;
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._sessionChangeResync();
        this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncCounter > 0 && !this._myDelayBlurEndResyncTimer.isRunning()) {
      this._myDelayBlurEndResyncCounter--;
      if (this._myDelayBlurEndResyncCounter == 0) {
        this._blurEndResync();
        this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncTimer.isRunning()) {
      if (this._myDelayBlurEndResyncCounter > 0) {
        this._myDelayBlurEndResyncCounter--;
      } else {
        this._myDelayBlurEndResyncTimer.update(dt);
        if (this._myDelayBlurEndResyncTimer.isDone()) {
          this._blurEndResync();
          this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
        }
      }
    }
    if (this._myDelayNextEnterSessionSetHeightVRCounter > 0) {
      this._myDelayNextEnterSessionSetHeightVRCounter--;
      if (this._myDelayNextEnterSessionSetHeightVRCounter == 0) {
        if (this._mySessionActive) {
          let isFloor = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine);
          if (isFloor && this._myNextEnterSessionSetHeightVRWithFloor) {
            let currentHeadPosition = this._myCurrentHead.pp_getPosition();
            let floorHeight = this._myHeightVRWithFloor - this._myParams.myForeheadExtraHeight;
            let currentHeadHeight = this._getPositionEyesHeight(currentHeadPosition);
            this._myHeightOffsetWithFloor = this._myHeightOffsetWithFloor + (floorHeight - currentHeadHeight);
            this._updateHeightOffset();
            this._myNextEnterSessionSetHeightVRWithFloor = false;
          } else if (!isFloor && this._myNextEnterSessionSetHeightVRWithoutFloor) {
            let currentHeadPosition = this._myCurrentHead.pp_getPosition();
            let floorHeight = this._myHeightVRWithoutFloor - this._myParams.myForeheadExtraHeight;
            let currentHeadHeight = this._getPositionEyesHeight(currentHeadPosition);
            this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (floorHeight - currentHeadHeight);
            this._updateHeightOffset();
            this._myNextEnterSessionSetHeightVRWithoutFloor = false;
          }
        }
      }
    }
    if (this.isSynced()) {
      this._myCurrentHead.pp_getTransformLocalQuat(this._myCurrentHeadTransformLocalQuat);
    }
    if (this._myParams.myDebugEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      this._debugUpdate(dt);
    }
  }
  _setHeightHead(heightNonVR, heightVRWithoutFloor, heightVRWithFloor, setOnlyForActiveOne = true) {
    if (!setOnlyForActiveOne || !this._mySessionActive) {
      this._setHeightHeadNonVR(heightNonVR);
    }
    if (!setOnlyForActiveOne || this._mySessionActive) {
      this._setHeightHeadVRWithoutFloor(heightVRWithoutFloor);
      this._setHeightHeadVRWithFloor(heightVRWithFloor);
    }
    this._updateHeightOffset();
    if (!this._mySessionActive) {
      this._setCameraNonXRHeight(this._myHeightNonVR);
    }
  }
  _setHeightHeadNonVR(height) {
    this._myHeightNonVR = height;
    this._myHeightNonVROnEnterSession = height;
  }
  _setHeightHeadVRWithoutFloor(heightWithoutFloor) {
    if (heightWithoutFloor != null) {
      this._myHeightVRWithoutFloor = heightWithoutFloor;
      this._myNextEnterSessionSetHeightVRWithoutFloor = false;
      if (this._mySessionActive) {
        this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (heightWithoutFloor - this.getHeightHead());
      } else {
        this._myNextEnterSessionSetHeightVRWithoutFloor = true;
      }
    } else {
      this._myHeightVRWithoutFloor = null;
      this._myHeightOffsetWithoutFloor = 0;
    }
  }
  _setHeightHeadVRWithFloor(heightWithFloor) {
    if (heightWithFloor != null) {
      this._myHeightVRWithFloor = heightWithFloor;
      this._myNextEnterSessionSetHeightVRWithFloor = false;
      if (this._mySessionActive) {
        this._myHeightOffsetWithFloor = this._myHeightOffsetWithFloor + (heightWithFloor - this.getHeightHead());
      } else {
        this._myNextEnterSessionSetHeightVRWithFloor = true;
      }
    } else {
      this._myHeightVRWithFloor = null;
      this._myHeightOffsetWithFloor = 0;
    }
  }
  _shouldNonVRUseVRWithFloor() {
    return this._myLastReferenceSpaceIsFloorBased == null && this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR || this._myLastReferenceSpaceIsFloorBased != null && this._myLastReferenceSpaceIsFloorBased && (this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.NO_FLOOR_THEN_KEEP_VR || this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR);
  }
  _shouldNonVRUseVRWithoutFloor() {
    return this._myLastReferenceSpaceIsFloorBased == null && this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.NO_FLOOR_THEN_KEEP_VR || this._myLastReferenceSpaceIsFloorBased != null && !this._myLastReferenceSpaceIsFloorBased && (this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.NO_FLOOR_THEN_KEEP_VR || this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR);
  }
  _setCameraNonXRHeight(height) {
  }
  _debugUpdate(dt) {
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this.getPositionFeet(), this.getPositionHead(), vec4_create(1, 0, 0, 1), 0.01);
    console.error(this.getHeightEyes());
  }
  _getPositionEyesHeight(position) {
  }
  _onXRSessionStart(manualCall, session) {
  }
  _onXRSessionEnd(session) {
  }
  _onXRSessionBlurStart(session) {
  }
  _onXRSessionBlurEnd(session) {
  }
  _onViewReset() {
  }
  _blurEndResync() {
  }
  _sessionChangeResync() {
  }
  _setReferenceSpaceHeightOffset(offset, amountToRemove) {
  }
  _updateHeightOffset() {
  }
  _getHeadTransformFromLocal(transformLocal) {
  }
  _resyncHeadRotationForward(resyncHeadRotation) {
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.getReferenceSpace(this._myParams.myEngine)?.removeEventListener?.("reset", this._myViewResetEventListener);
    XRUtils.getSession(this._myParams.myEngine)?.removeEventListener("visibilitychange", this._myVisibilityChangeEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerHeadManager.prototype.getHeightEyes = function() {
  let headPosition = vec3_create();
  return function getHeightEyes() {
    headPosition = this._myCurrentHead.pp_getPosition(headPosition);
    let eyesHeight = this._getPositionEyesHeight(headPosition);
    return eyesHeight;
  };
}();
PlayerHeadManager.prototype.getTransformFeetQuat = function() {
  let feetPosition = vec3_create();
  let feetRotationQuat = quat_create();
  return function getTransformFeetQuat(outTransformFeetQuat = quat2_create()) {
    outTransformFeetQuat.quat2_setPositionRotationQuat(this.getPositionFeet(feetPosition), this.getRotationFeetQuat(feetRotationQuat));
    return outTransformFeetQuat;
  };
}();
PlayerHeadManager.prototype.getRotationFeetQuat = function() {
  let playerUp = vec3_create();
  let headForward = vec3_create();
  return function getRotationFeetQuat(outRotationFeetQuat = quat_create()) {
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    headForward = this._myCurrentHead.pp_getForward(headForward);
    let angleWithUp = headForward.vec3_angle(playerUp);
    let mingAngle = 10;
    if (angleWithUp < mingAngle) {
      headForward = this._myCurrentHead.pp_getDown(headForward);
    } else if (angleWithUp > 180 - mingAngle) {
      headForward = this._myCurrentHead.pp_getUp(headForward);
    }
    headForward = headForward.vec3_removeComponentAlongAxis(playerUp, headForward);
    headForward.vec3_normalize(headForward);
    outRotationFeetQuat.quat_setUp(playerUp, headForward);
    return outRotationFeetQuat;
  };
}();
PlayerHeadManager.prototype.getPositionFeet = function() {
  let headPosition = vec3_create();
  let playerUp = vec3_create();
  return function getPositionFeet(outPositionFeet = vec3_create()) {
    headPosition = this._myCurrentHead.pp_getPosition(headPosition);
    let headHeight = this._getPositionEyesHeight(headPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    outPositionFeet = headPosition.vec3_sub(playerUp.vec3_scale(headHeight, outPositionFeet), outPositionFeet);
    return outPositionFeet;
  };
}();
PlayerHeadManager.prototype.moveFeet = function moveFeet(movement) {
  Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_translate(movement);
};
PlayerHeadManager.prototype.rotateFeetQuat = function() {
  let playerUp = vec3_create();
  let rotationAxis = vec3_create();
  let currentHeadPosition = vec3_create();
  let currentFeetRotation = quat_create();
  let newFeetRotation = quat_create();
  let fixedNewFeetRotation = quat_create();
  let newFeetForward = vec3_create();
  let fixedRotation = quat_create();
  let newHeadPosition = vec3_create();
  let headAdjustmentMovement = vec3_create();
  return function rotateFeetQuat(rotationQuat, keepUpOverride = null) {
    let angle2 = rotationQuat.quat_getAngleRadians();
    if (angle2 <= 1e-5) {
      return;
    }
    currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    rotationAxis = rotationQuat.quat_getAxis(rotationAxis);
    if (!rotationAxis.vec3_isOnAxis(playerUp) && (keepUpOverride == null && this._myParams.myFeetRotationKeepUp || keepUpOverride)) {
      currentFeetRotation = this.getRotationFeetQuat(currentFeetRotation);
      newFeetRotation = currentFeetRotation.quat_rotateQuat(rotationQuat, newFeetRotation);
      newFeetForward = newFeetRotation.quat_getForward(newFeetForward);
      fixedNewFeetRotation.quat_copy(newFeetRotation);
      fixedNewFeetRotation.quat_setUp(playerUp, newFeetForward);
      fixedRotation = currentFeetRotation.quat_rotationToQuat(fixedNewFeetRotation, fixedRotation);
    } else {
      fixedRotation.quat_copy(rotationQuat);
    }
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateAroundQuat(fixedRotation, currentHeadPosition);
    newHeadPosition = this._myCurrentHead.pp_getPosition(newHeadPosition);
    headAdjustmentMovement = currentHeadPosition.vec3_sub(newHeadPosition, headAdjustmentMovement);
    if (headAdjustmentMovement.vec3_length() > 1e-5) {
      this.moveFeet(headAdjustmentMovement);
    }
  };
}();
PlayerHeadManager.prototype.rotateHeadQuat = function() {
  let newHeadRotation = quat_create();
  let newHeadUp = vec3_create();
  return function rotateHeadQuat(rotationQuat) {
    if (this.canRotateHead()) {
      this._myCurrentHead.pp_rotateQuat(rotationQuat);
      newHeadRotation = this._myCurrentHead.pp_getRotationQuat(newHeadRotation);
      Globals.getPlayerObjects(this._myParams.myEngine).myHead.pp_setRotationQuat(newHeadRotation);
      if (!this._mySessionActive) {
        newHeadRotation = newHeadRotation.quat_rotateAxisRadians(Math.PI, newHeadRotation.quat_getUp(newHeadUp), newHeadRotation);
        Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_setRotationQuat(newHeadRotation);
      }
    }
  };
}();
PlayerHeadManager.prototype.setRotationFeetQuat = function() {
  let currentRotationQuat = quat_create();
  let rotationQuatToRotate = quat_create();
  return function setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
    currentRotationQuat = this.getRotationFeetQuat(currentRotationQuat);
    rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateFeetQuat(rotationQuatToRotate, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.setRotationHeadQuat = function() {
  let currentRotationQuat = quat_create();
  let rotationQuatToRotate = quat_create();
  return function setRotationHeadQuat(rotationQuat) {
    currentRotationQuat = this.getRotationHeadQuat(currentRotationQuat);
    rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateHeadQuat(rotationQuatToRotate);
  };
}();
PlayerHeadManager.prototype.teleportPositionHead = function() {
  let currentHeadPosition = vec3_create();
  let teleportMovementToPerform = vec3_create();
  return function teleportPositionHead(teleportPosition) {
    currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
    teleportMovementToPerform = teleportPosition.vec3_sub(currentHeadPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  };
}();
PlayerHeadManager.prototype.teleportPositionFeet = function() {
  let currentFeetPosition = vec3_create();
  let teleportMovementToPerform = vec3_create();
  return function teleportPositionFeet(teleportPosition) {
    currentFeetPosition = this.getPositionFeet(currentFeetPosition);
    teleportMovementToPerform = teleportPosition.vec3_sub(currentFeetPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  };
}();
PlayerHeadManager.prototype.teleportPlayerToHeadTransformQuat = function() {
  let headPosition = vec3_create();
  let playerUp = vec3_create();
  let flatCurrentPlayerPosition = vec3_create();
  let flatNewPlayerPosition = vec3_create();
  let teleportMovement = vec3_create();
  let playerForward = vec3_create();
  let headForward = vec3_create();
  let referenceSpaceForward = vec3_create();
  let referenceSpaceForwardNegated = vec3_create();
  let rotationToPerform = quat_create();
  return function teleportPlayerToHeadTransformQuat(headTransformQuat) {
    headPosition = headTransformQuat.quat2_getPosition(headPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    flatCurrentPlayerPosition = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getPosition(flatCurrentPlayerPosition).vec3_removeComponentAlongAxis(playerUp, flatCurrentPlayerPosition);
    flatNewPlayerPosition = headPosition.vec3_removeComponentAlongAxis(playerUp, flatNewPlayerPosition);
    teleportMovement = flatNewPlayerPosition.vec3_sub(flatCurrentPlayerPosition, teleportMovement);
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_translate(teleportMovement);
    playerForward = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward(playerForward);
    headForward = headTransformQuat.quat2_getForward(headForward);
    rotationToPerform = playerForward.vec3_rotationToPivotedQuat(headForward, playerUp, rotationToPerform);
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateQuat(rotationToPerform);
    playerForward = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward(playerForward);
    referenceSpaceForward = Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_getForward(referenceSpaceForward);
    referenceSpaceForwardNegated = referenceSpaceForward.vec3_negate(referenceSpaceForwardNegated);
    rotationToPerform = referenceSpaceForwardNegated.vec3_rotationToPivotedQuat(playerForward, playerUp, rotationToPerform);
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateQuat(rotationToPerform);
  };
}();
PlayerHeadManager.prototype.lookAtFeet = function() {
  let direction = vec3_create();
  let feetPosition = vec3_create();
  return function lookAtFeet(position, up = null, keepUpOverride = null) {
    feetPosition = this.getPositionFeet(feetPosition);
    direction = position.vec3_sub(feetPosition, direction).vec3_normalize(direction);
    this.lookToFeet(direction, up, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.lookToFeet = function() {
  let feetRotation = quat_create();
  return function lookToFeet(direction, up = null, keepUpOverride = null) {
    feetRotation = this.getRotationFeetQuat(feetRotation);
    feetRotation.quat_setForward(direction, up);
    this.setRotationFeetQuat(feetRotation, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.lookAtHead = function() {
  let direction = vec3_create();
  let headPosition = vec3_create();
  return function lookAtHead(position, up = null) {
    headPosition = this.getPositionHead(headPosition);
    direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
    this.lookToHead(direction, up);
  };
}();
PlayerHeadManager.prototype.lookToHead = function() {
  let headRotation = quat_create();
  return function lookToHead(direction, up = null) {
    headRotation = this.getRotationHeadQuat(headRotation);
    headRotation.quat_setForward(direction, up);
    this.setRotationHeadQuat(headRotation);
  };
}();
PlayerHeadManager.prototype._getPositionEyesHeight = function() {
  let playerPosition = vec3_create();
  let playerUp = vec3_create();
  let heightVector = vec3_create();
  return function _getPositionEyesHeight(position) {
    playerPosition = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getPosition(playerPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    heightVector = position.vec3_sub(playerPosition, heightVector).vec3_componentAlongAxis(playerUp, heightVector);
    let height = heightVector.vec3_length();
    if (!playerUp.vec3_isConcordant(heightVector)) {
      height = -height;
    }
    return height;
  };
}();
PlayerHeadManager.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(manualCall, session) {
    let nonVRCurrentEyesHeight = this._getPositionEyesHeight(Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_getPosition());
    this._myHeightNonVROnEnterSession = nonVRCurrentEyesHeight + this._myParams.myForeheadExtraHeight;
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._myDelayNextEnterSessionSetHeightVRCounter = 0;
    let referenceSpace = XRUtils.getReferenceSpace(this._myParams.myEngine);
    if (referenceSpace.addEventListener != null) {
      this._myViewResetEventListener = this._onViewReset.bind(this);
      referenceSpace.addEventListener("reset", this._myViewResetEventListener);
    }
    this._myLastReferenceSpaceIsFloorBased = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine);
    this._myVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState != "visible") {
        if (!this._mySessionBlurred) {
          this._onXRSessionBlurStart(event.session);
        }
        this._myVisibilityHidden = session.visibilityState == "hidden";
      } else {
        if (this._mySessionBlurred) {
          this._onXRSessionBlurEnd(event.session);
        }
        this._myVisibilityHidden = false;
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myVisibilityChangeEventListener);
    if (this._myParams.mySessionChangeResyncEnabled && !manualCall && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._mySessionChangeResyncHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
      }
      this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    if (this._myNextEnterSessionSetHeightVRWithFloor || this._myNextEnterSessionSetHeightVRWithoutFloor) {
      this._myDelayNextEnterSessionSetHeightVRCounter = this._myResyncCounterFrames;
    }
    this._mySessionActive = true;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
    }
  };
}();
PlayerHeadManager.prototype._onXRSessionEnd = function() {
  return function _onXRSessionEnd(session) {
    if (this._myParams.mySessionChangeResyncEnabled && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        let previousHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        if (this._myBlurRecoverHeadTransform != null) {
          previousHeadTransform = this._myBlurRecoverHeadTransform;
        }
        this._mySessionChangeResyncHeadTransform = previousHeadTransform;
      }
      this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    this._myDelayNextEnterSessionSetHeightVRCounter = 0;
    this._myVisibilityChangeEventListener = null;
    this._myViewResetEventListener = null;
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
      if (this._myParams.myExitSessionResetNonVRTransformLocal) {
        this.resetCameraNonXR();
      } else {
        this._setCameraNonXRHeight(this._myHeightNonVROnEnterSession);
      }
    }
  };
}();
PlayerHeadManager.prototype._onXRSessionBlurStart = function() {
  return function _onXRSessionBlurStart(session) {
    if (this._myActive) {
      if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform == null && this._mySessionActive) {
        if (this._myDelaySessionChangeResyncCounter > 0) {
          this._myBlurRecoverHeadTransform = this._mySessionChangeResyncHeadTransform;
        } else {
          this._myBlurRecoverHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        }
      } else if (!this._mySessionActive || !this._myParams.myBlurEndResyncEnabled) {
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._myDelayBlurEndResyncCounter = 0;
    this._mySessionBlurred = true;
  };
}();
PlayerHeadManager.prototype._onXRSessionBlurEnd = function() {
  return function _onXRSessionBlurEnd(session) {
    if (this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform != null && this._mySessionActive) {
          this._myDelayBlurEndResyncCounter = this._myResyncCounterFrames;
          if (this._myVisibilityHidden) {
          }
        } else {
          this._myBlurRecoverHeadTransform = null;
          this._myDelayBlurEndResyncCounter = 0;
        }
      } else {
        this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._mySessionBlurred = false;
  };
}();
PlayerHeadManager.prototype._onViewReset = function() {
  let identityTransformQuat = Quat2Utils.identity(quat2_create());
  let prevHeadPosition = vec3_create();
  let resetHeadPosition = vec3_create();
  return function _onViewReset() {
    if (this._myActive) {
      if (!this._myViewResetThisFrame && this._myParams.myResetTransformOnViewResetEnabled && this._mySessionActive && this.isSynced()) {
        this._myViewResetThisFrame = true;
        let previousHeadTransformQuat = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        this.teleportPlayerToHeadTransformQuat(previousHeadTransformQuat);
        let isFloor = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine);
        if (!isFloor) {
          let resetHeadTransformQuat = this._getHeadTransformFromLocal(identityTransformQuat);
          let prevHeadHeight = this._getPositionEyesHeight(previousHeadTransformQuat.quat2_getPosition(prevHeadPosition));
          let currentHeadHeight = this._getPositionEyesHeight(resetHeadTransformQuat.quat2_getPosition(resetHeadPosition));
          this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (prevHeadHeight - currentHeadHeight);
          this._updateHeightOffset();
        }
      }
    }
  };
}();
PlayerHeadManager.prototype._blurEndResync = function() {
  let playerUp = vec3_create();
  let currentHeadPosition = vec3_create();
  let recoverHeadPosition = vec3_create();
  let flatCurrentHeadPosition = vec3_create();
  let flatRecoverHeadPosition = vec3_create();
  let recoverMovement = vec3_create();
  let recoverHeadForward = vec3_create();
  let currentHeadForward = vec3_create();
  let rotationToPerform = quat_create();
  return function _blurEndResync() {
    if (this._myBlurRecoverHeadTransform != null) {
      if (this._mySessionChangeResyncHeadTransform != null) {
        this._myBlurRecoverHeadTransform = null;
        this._sessionChangeResync();
      } else {
        playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
        recoverHeadPosition = this._myBlurRecoverHeadTransform.quat2_getPosition(recoverHeadPosition);
        flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        flatRecoverHeadPosition = recoverHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatRecoverHeadPosition);
        recoverMovement = flatRecoverHeadPosition.vec3_sub(flatCurrentHeadPosition, recoverMovement);
        this.moveFeet(recoverMovement);
        recoverHeadForward = this._myBlurRecoverHeadTransform.quat2_getForward(recoverHeadForward);
        currentHeadForward = this._myCurrentHead.pp_getForward(currentHeadForward);
        rotationToPerform = currentHeadForward.vec3_rotationToPivotedQuat(recoverHeadForward, playerUp, rotationToPerform);
        if (this._myParams.myBlurEndResyncRotation) {
          this.rotateFeetQuat(rotationToPerform);
        }
        this._myBlurRecoverHeadTransform = null;
      }
    }
  };
}();
PlayerHeadManager.prototype._sessionChangeResync = function() {
  let currentHeadPosition = vec3_create();
  let resyncHeadPosition = vec3_create();
  let resyncHeadRotation = quat_create();
  let playerUp = vec3_create();
  let flatCurrentHeadPosition = vec3_create();
  let flatResyncHeadPosition = vec3_create();
  let resyncMovement = vec3_create();
  let resyncHeadForward = vec3_create();
  let resyncHeadUp = vec3_create();
  let resyncHeadRight = vec3_create();
  let playerPosition = vec3_create();
  let newPlayerPosition = vec3_create();
  let fixedHeadRight = vec3_create();
  let fixedHeadLeft = vec3_create();
  let fixedHeadUp = vec3_create();
  let fixedHeadForward = vec3_create();
  let fixedHeadRotation = quat_create();
  return function _sessionChangeResync() {
    if (this._myBlurRecoverHeadTransform == null && this._mySessionChangeResyncHeadTransform != null) {
      if (this._mySessionActive) {
        currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
        resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        resyncMovement = flatResyncHeadPosition.vec3_sub(flatCurrentHeadPosition, resyncMovement);
        this.moveFeet(resyncMovement);
        if (this._myParams.myEnterSessionResyncHeight || this._myParams.myNextEnterSessionResyncHeight) {
          this._myParams.myNextEnterSessionResyncHeight = false;
          let resyncHeadHeight = this._getPositionEyesHeight(resyncHeadPosition);
          let currentHeadHeight = this._getPositionEyesHeight(currentHeadPosition);
          this._myHeightVRWithoutFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          this._myHeightVRWithFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          this._myHeightOffsetWithFloor = this._myHeightOffsetWithFloor + (resyncHeadHeight - currentHeadHeight);
          this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (resyncHeadHeight - currentHeadHeight);
          this._updateHeightOffset();
          this._myNextEnterSessionSetHeightVRWithFloor = false;
          this._myNextEnterSessionSetHeightVRWithoutFloor = false;
        }
        this._resyncHeadRotationForward(resyncHeadRotation);
      } else {
        playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        playerPosition = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getPosition(playerPosition);
        newPlayerPosition = flatResyncHeadPosition.vec3_add(playerPosition.vec3_componentAlongAxis(playerUp, newPlayerPosition), newPlayerPosition);
        Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_setPosition(newPlayerPosition);
        Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_resetPositionLocal();
        if (this._myParams.myExitSessionResyncHeight) {
          let resyncHeadHeight = this._getPositionEyesHeight(resyncHeadPosition);
          this._myHeightNonVR = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
        }
        this._updateHeightOffset();
        if (this._myParams.myExitSessionResyncHeight || this._myParams.myExitSessionResetNonVRTransformLocal) {
          this._setCameraNonXRHeight(this._myHeightNonVR);
        } else {
          this._setCameraNonXRHeight(this._myHeightNonVROnEnterSession);
        }
        resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        if (this._myParams.myExitSessionRemoveRightTilt || this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          fixedHeadRight = resyncHeadForward.vec3_cross(playerUp, fixedHeadRight);
          fixedHeadRight.vec3_normalize(fixedHeadRight);
          if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
            let angleForwardUp = resyncHeadForward.vec3_angle(playerUp);
            let negateAngle = 45;
            if (angleForwardUp > 180 - negateAngle || angleForwardUp < negateAngle) {
              fixedHeadRight.vec3_negate(fixedHeadRight);
            }
          }
          if (fixedHeadRight.vec3_isZero(1e-6)) {
            fixedHeadRight = resyncHeadRotation.quat_getRight(fixedHeadRight);
          }
          fixedHeadUp = fixedHeadRight.vec3_cross(resyncHeadForward, fixedHeadUp);
          fixedHeadUp.vec3_normalize(fixedHeadUp);
          fixedHeadForward = fixedHeadUp.vec3_cross(fixedHeadRight, fixedHeadForward);
          fixedHeadForward.vec3_normalize(fixedHeadForward);
          fixedHeadRotation.quat_fromAxes(fixedHeadRight.vec3_negate(fixedHeadLeft), fixedHeadUp, fixedHeadForward);
          resyncHeadRotation.quat_copy(fixedHeadRotation);
        }
        if (this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          resyncHeadRight = resyncHeadRotation.quat_getRight(resyncHeadRight);
          let maxVerticalAngle = Math.max(0, this._myParams.myExitSessionMaxVerticalAngle - 1e-4);
          if (!this._myParams.myExitSessionResyncVerticalAngle) {
            maxVerticalAngle = 0;
          }
          let angleWithUp = Math.pp_angleClamp(resyncHeadUp.vec3_angleSigned(playerUp, resyncHeadRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            resyncHeadRotation = resyncHeadRotation.quat_rotateAxis(fixAngle, resyncHeadRight, resyncHeadRotation);
          }
        }
        this.setRotationHeadQuat(resyncHeadRotation);
      }
      this._mySessionChangeResyncHeadTransform = null;
    }
  };
}();
PlayerHeadManager.prototype._resyncHeadRotationForward = function() {
  let playerUp = vec3_create();
  let resyncHeadForward = vec3_create();
  let resyncHeadUp = vec3_create();
  let fixedResyncHeadRotation = quat_create();
  return function _resyncHeadRotationForward(resyncHeadRotation) {
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
    resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
    fixedResyncHeadRotation.quat_copy(resyncHeadRotation);
    fixedResyncHeadRotation.quat_setUp(playerUp, resyncHeadForward);
    if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
      fixedResyncHeadRotation.quat_rotateAxis(180, playerUp, fixedResyncHeadRotation);
    }
    this.setRotationFeetQuat(fixedResyncHeadRotation);
    return;
  };
}();
PlayerHeadManager.prototype._setCameraNonXRHeight = function() {
  let cameraNonVRPosition = vec3_create();
  let cameraNonVRPositionLocalToPlayer = vec3_create();
  let adjustedCameraNonVRPosition = vec3_create();
  let playerTranform = mat4_create();
  return function _setCameraNonXRHeight(height) {
    let eyeHeight = height - this._myParams.myForeheadExtraHeight;
    cameraNonVRPosition = Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_getPosition(cameraNonVRPosition);
    cameraNonVRPositionLocalToPlayer = cameraNonVRPosition.vec3_convertPositionToLocal(Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getTransform(playerTranform), cameraNonVRPositionLocalToPlayer);
    cameraNonVRPositionLocalToPlayer.vec3_set(cameraNonVRPositionLocalToPlayer[0], eyeHeight, cameraNonVRPositionLocalToPlayer[2]);
    adjustedCameraNonVRPosition = cameraNonVRPositionLocalToPlayer.vec3_convertPositionToWorld(Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getTransform(playerTranform), adjustedCameraNonVRPosition);
    Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_setPosition(adjustedCameraNonVRPosition);
  };
}();
PlayerHeadManager.prototype._updateHeightOffset = function() {
  return function _updateHeightOffset() {
    if (this._mySessionActive) {
      if (XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine)) {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithFloor, 0);
      } else {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithoutFloor, 0);
      }
    } else {
      if (this._shouldNonVRUseVRWithFloor()) {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithFloor, 0);
      } else if (this._shouldNonVRUseVRWithoutFloor()) {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithoutFloor, 0);
      } else if (this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR) {
        this._setReferenceSpaceHeightOffset(0, 0);
      } else {
        this._setReferenceSpaceHeightOffset(this._myHeightNonVR, this._myParams.myForeheadExtraHeight);
      }
    }
  };
}();
PlayerHeadManager.prototype._setReferenceSpaceHeightOffset = function() {
  let referenceSpacePosition = vec3_create();
  let referenceSpacePositionLocalToPlayer = vec3_create();
  let adjustedReferenceSpacePosition = vec3_create();
  let playerTranform = mat4_create();
  return function _setReferenceSpaceHeightOffset(offset, amountToRemove) {
    if (offset != null) {
      referenceSpacePosition = Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_getPosition(referenceSpacePosition);
      referenceSpacePositionLocalToPlayer = referenceSpacePosition.vec3_convertPositionToLocal(Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getTransform(playerTranform), referenceSpacePositionLocalToPlayer);
      referenceSpacePositionLocalToPlayer.vec3_set(referenceSpacePositionLocalToPlayer[0], offset - amountToRemove, referenceSpacePositionLocalToPlayer[2]);
      adjustedReferenceSpacePosition = referenceSpacePositionLocalToPlayer.vec3_convertPositionToWorld(Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getTransform(playerTranform), adjustedReferenceSpacePosition);
      Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_setPosition(adjustedReferenceSpacePosition);
    }
  };
}();
PlayerHeadManager.prototype._getHeadTransformFromLocal = function() {
  return function _getHeadTransformFromLocal(transformLocal) {
    return this._myCurrentHead.pp_convertTransformLocalToWorldQuat(transformLocal);
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_transform_manager.js
var PlayerTransformManagerSyncFlag = {
  BODY_COLLIDING: 0,
  HEAD_COLLIDING: 1,
  FAR: 2,
  FLOATING: 3
};
var PlayerTransformManagerParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myMovementCollisionCheckParams = null;
    this.myTeleportCollisionCheckParams = null;
    this.myTeleportCollisionCheckParamsCopyFromMovement = false;
    this.myTeleportCollisionCheckParamsCheck360 = false;
    this.myAlwaysSyncPositionWithReal = false;
    this.myAlwaysSyncHeadPositionWithReal = false;
    this.mySyncEnabledFlagMap = /* @__PURE__ */ new Map();
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
    this.mySyncPositionFlagMap = /* @__PURE__ */ new Map();
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
    this.mySyncPositionHeadFlagMap = /* @__PURE__ */ new Map();
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.mySyncRotationFlagMap = /* @__PURE__ */ new Map();
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.mySyncHeightFlagMap = /* @__PURE__ */ new Map();
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.myIsLeaningValidAboveDistance = false;
    this.myLeaningValidDistance = 0;
    this.myIsFloatingValidIfVerticalMovement = false;
    this.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
    this.myIsFloatingValidIfRealOnGround = false;
    this.myIsFloatingValidIfSteepGround = false;
    this.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
    this.myFloatingSplitCheckEnabled = false;
    this.myFloatingSplitCheckMinLength = null;
    this.myFloatingSplitCheckMaxLength = null;
    this.myFloatingSplitCheckMaxSteps = null;
    this.myFloatingSplitCheckStepEqualLength = false;
    this.myFloatingSplitCheckStepEqualLengthMinLength = 0;
    this.myMaxDistanceFromRealToSyncEnabled = false;
    this.myMaxDistanceFromRealToSync = 0;
    this.myHeadRadius = 0;
    this.myHeadCollisionBlockLayerFlags = new PhysicsLayerFlags();
    this.myHeadCollisionObjectsToIgnore = [];
    this.myHeadCollisionBlockLayerFlagsForResetToFeet = null;
    this.myRotateOnlyIfSynced = false;
    this.myResetRealResetRotationIfUpChanged = true;
    this.myResetHeadToFeetInsteadOfReal = false;
    this.myResetHeadToFeetInsteadOfRealOnlyIfRealNotReachable = false;
    this.myResetHeadToFeetMoveTowardReal = true;
    this.myResetHeadToFeetUpOffset = 0.25;
    this.myResetHeadToFeetGroudnAngleIgnoreEnabled = false;
    this.myResetHeadToRealMinDistance = 0;
    this.myRealMovementAllowVerticalAdjustments = false;
    this.myUpdatePositionValid = false;
    this.myUpdatePositionHeadValid = true;
    this.myUpdateRealPositionValid = false;
    this.myUpdateRealPositionHeadValid = false;
    this.myMinHeight = null;
    this.myMaxHeight = null;
    this.myIsBodyCollidingWhenHeightBelowValue = null;
    this.myIsBodyCollidingWhenHeightAboveValue = null;
    this.myIsBodyCollidingExtraCheckCallback = null;
    this.myIsLeaningExtraCheckCallback = null;
    this.myIsHoppingExtraCheckCallback = null;
    this.myIsFarExtraCheckCallback = null;
    this.myResetToValidOnEnterSession = false;
    this.myResetToValidOnExitSession = false;
    this.myAlwaysResetRealPositionNonVR = false;
    this.myAlwaysResetRealRotationNonVR = false;
    this.myAlwaysResetRealHeightNonVR = false;
    this.myAlwaysResetRealPositionVR = false;
    this.myAlwaysResetRealRotationVR = false;
    this.myAlwaysResetRealHeightVR = false;
    this.myNeverResetRealPositionNonVR = false;
    this.myNeverResetRealRotationNonVR = false;
    this.myNeverResetRealHeightNonVR = false;
    this.myResetRealHeightNonVROnExitSession = false;
    this.myNeverResetRealPositionVR = false;
    this.myNeverResetRealRotationVR = false;
    this.myNeverResetRealHeightVR = false;
    this.myResetRealOnMove = false;
    this.myResetRealOnTeleport = false;
    this.mySyncPositionDisabled = false;
    this.myEngine = engine;
    this.myDebugEnabled = false;
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
var PlayerTransformManager = class {
  constructor(params) {
    this._myParams = params;
    this._myRealMovementCollisionCheckParams = null;
    this._generateRealMovementParamsFromMovementParams();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myRealCollisionRuntimeParams = new CollisionRuntimeParams();
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._myHeadCollisionCheckParams = null;
    this._setupHeadCollisionCheckParams();
    this._myValidPosition = vec3_create();
    this._myValidRotationQuat = quat_create();
    this._myValidHeight = 0;
    this._myValidPositionHead = vec3_create();
    this._myValidPositionHeadBackupForResetToFeet = vec3_create();
    this._myIsBodyColliding = false;
    this._myIsHeadColliding = false;
    this._myIsLeaning = false;
    this._myIsHopping = false;
    this._myIsFar = false;
    this._myLastValidMovementDirection = vec3_create();
    this._myIsPositionValid = false;
    this._myIsPositionHeadValid = false;
    this._myIsRealPositionValid = false;
    this._myIsRealHeadositionValid = false;
    this._myResetRealOnHeadSynced = false;
    this._myResetHeadToFeetOnNextUpdateValidToReal = false;
    this._myActive = true;
    this._myDestroyed = false;
  }
  start() {
    this.resetToReal(true);
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myParams.myEngine);
  }
  getParams() {
    return this._myParams;
  }
  setActive(active) {
    this._myActive = active;
  }
  // update should be before to check the new valid transform and if the head new transform is fine
  // then update movements, so that they will use the proper transform
  // pre/post update?
  // For sliding if previous frame no horizontal movement then reset sliding on pre update
  // In generale capire come fare per risolvere i problemi quando c'è un move solo verticale che sputtana i dati dello sliding precedente
  // che servono per far slidare bene anche dopo, magari un flag per dire non aggiornare le cose relative al movimento orizzontale
  // o un move check solo verticale
  update(dt) {
  }
  move(movement, outCollisionRuntimeParams = null, forceMove = false) {
  }
  teleportPosition(position, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  teleportPositionRotationQuat(position, rotationQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  teleportTransformQuat(transformQuat2, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  // Quick way to force teleport to a position and reset the real to this
  forceTeleportAndReset(position, rotationQuat) {
    this.teleportPositionRotationQuat(position, rotationQuat, null, true);
    this._myPlayerTransformManager.resetReal(true, true, void 0, void 0, void 0, true);
  }
  rotateQuat(rotationQuat) {
  }
  setRotationQuat(rotationQuat) {
  }
  setHeight(height, forceSet = false) {
  }
  getPlayer() {
    return this._myParams.myPlayerHeadManager.getPlayer();
  }
  getHead() {
    return this._myParams.myPlayerHeadManager.getHead();
  }
  getTransformQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(this._myValidPosition), this.getRotationQuat(this._myValidRotationQuat));
  }
  getPosition(outPosition = vec3_create()) {
    return outPosition.vec3_copy(this._myValidPosition);
  }
  getRotationQuat(outRotation = quat_create()) {
    return outRotation.quat_copy(this._myValidRotationQuat);
  }
  getPositionHead(outPosition = vec3_create()) {
    return outPosition.vec3_copy(this._myValidPositionHead);
  }
  getTransformHeadQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(this._myValidPositionHead), this.getRotationQuat(this._myValidRotationQuat));
  }
  getHeight() {
    return this._myValidHeight;
  }
  getTransformRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
  }
  getTransformHeadRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
  }
  getPositionReal(outPosition = vec3_create()) {
    return this.getPlayerHeadManager().getPositionFeet(outPosition);
  }
  getPositionHeadReal(outPosition = vec3_create()) {
    return this.getPlayerHeadManager().getPositionHead(outPosition);
  }
  getRotationRealQuat(outRotation = quat_create()) {
    return this.getPlayerHeadManager().getRotationFeetQuat(outRotation);
  }
  getHeightReal() {
    return this._myParams.myPlayerHeadManager.getHeightHead();
  }
  isSynced(syncFlagMap = null) {
    let isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
    let isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
    let isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
    let isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
    return !isBodyColliding && !isHeadColliding && !isFar && !isFloating;
  }
  resetReal(resetPosition2 = true, resetRotation2 = false, resetHeight = false, resetHeadToReal = true, updateValidToReal = false, ignoreResetHeadMinDistance = false) {
  }
  updateValidToReal() {
    this._updateValidToReal(0);
  }
  updateValidHeadToRealHead() {
    this._updateValidHeadToRealHead(0);
  }
  updateValidHeadToRealHeadIfNeeded() {
    if (this._myResetHeadToFeetDirty) {
      this._updateValidHeadToRealHead(0);
    }
  }
  resetToReal(resetToPlayerInsteadOfHead = false, updateValidToReal = false) {
    if (resetToPlayerInsteadOfHead) {
      this._myValidPosition = this.getPlayerHeadManager().getPlayer().pp_getPosition(this._myValidPosition);
    } else {
      this._myValidPosition = this.getPositionReal(this._myValidPosition);
    }
    if (!this._myParams.myAlwaysSyncPositionWithReal) {
      this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
      this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
      this._myResetHeadToFeetOnNextUpdateValidToReal = false;
      this._myResetHeadToFeetDirty = false;
    }
    if (resetToPlayerInsteadOfHead) {
      this._myValidRotationQuat = this.getPlayerHeadManager().getPlayer().pp_getRotationQuat(this._myValidRotationQuat);
    } else {
      this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
    }
    this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    if (updateValidToReal) {
      this._updateValidToReal(0);
    }
  }
  resetHeadToReal() {
    if (!this._myParams.myAlwaysSyncPositionWithReal) {
      this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
      this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
      this._myResetHeadToFeetOnNextUpdateValidToReal = false;
      this._myResetHeadToFeetDirty = false;
    }
  }
  resetHeadToFeet() {
  }
  isBodyColliding() {
    return this._myIsBodyColliding;
  }
  isHeadColliding() {
    return this._myIsHeadColliding;
  }
  isFloating() {
    return this.isLeaning() || this.isHopping();
  }
  isLeaning() {
    return this._myIsLeaning;
  }
  isHopping() {
    return this._myIsHopping;
  }
  isFar() {
    return this._myIsFar;
  }
  getDistanceToReal() {
  }
  getDistanceToRealHead() {
  }
  getPlayerHeadManager() {
    return this._myParams.myPlayerHeadManager;
  }
  getMovementCollisionCheckParams() {
    return this._myParams.myMovementCollisionCheckParams;
  }
  getTeleportCollisionCheckParams() {
    return this._myParams.myTeleportCollisionCheckParams;
  }
  collisionCheckParamsUpdated() {
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._generateRealMovementParamsFromMovementParams();
  }
  isPositionValid() {
    return this._myIsPositionValid;
  }
  isPositionHeadValid() {
    return this._myIsPositionHeadValid;
  }
  isPositionRealValid() {
    return this._myIsRealPositionValid;
  }
  isPositionHeadRealValid() {
    return this._myIsRealPositionHeadValid;
  }
  getCollisionRuntimeParams() {
    return this._myCollisionRuntimeParams;
  }
  getRealCollisionRuntimeParams() {
    return this._myRealCollisionRuntimeParams;
  }
  _updateCollisionHeight() {
    let validHeight = this.getHeight();
    let realHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    this._myParams.myMovementCollisionCheckParams.myHeight = validHeight;
    this._myParams.myTeleportCollisionCheckParams.myHeight = validHeight;
    this._myRealMovementCollisionCheckParams.myHeight = realHeight;
  }
  _setupHeadCollisionCheckParams() {
    this._myHeadCollisionCheckParams = new CollisionCheckParams();
    let params = this._myHeadCollisionCheckParams;
    params.myRadius = this._myParams.myHeadRadius;
    params.myDistanceFromFeetToIgnore = 0;
    params.myDistanceFromHeadToIgnore = 0;
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLengthEnabled = true;
    params.mySplitMovementMaxLength = params.myRadius * 0.75;
    params.mySplitMovementMinLengthEnabled = true;
    params.mySplitMovementMinLength = params.mySplitMovementMaxLength;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 3;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.myHorizontalMovementCheckEnabled = true;
    params.myHorizontalMovementRadialStepAmount = 1;
    params.myHorizontalMovementCheckDiagonalOutward = true;
    params.myHorizontalMovementCheckDiagonalInward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
    params.myHorizontalPositionCheckEnabled = true;
    params.myHalfConeAngle = 180;
    params.myHalfConeSliceAmount = 3;
    params.myCheckConeBorder = true;
    params.myCheckConeRay = true;
    params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
    params.myHorizontalPositionCheckVerticalDirectionType = 0;
    params.myHeight = params.myRadius;
    params.myPositionOffsetLocal.vec3_set(0, -params.myRadius / 2, 0);
    params.myCheckHeight = true;
    params.myCheckHeightVerticalMovement = true;
    params.myCheckHeightVerticalPosition = true;
    params.myHeightCheckStepAmountMovement = 2;
    params.myHeightCheckStepAmountPosition = 2;
    params.myCheckHeightTopMovement = true;
    params.myCheckHeightTopPosition = true;
    params.myCheckVerticalStraight = true;
    params.myCheckVerticalFixedForwardEnabled = true;
    params.myCheckVerticalFixedForward = vec3_create(0, 0, 1);
    params.myCheckHorizontalFixedForwardEnabled = true;
    params.myCheckHorizontalFixedForward = vec3_create(0, 0, 1);
    params.myVerticalMovementCheckEnabled = true;
    params.myVerticalPositionCheckEnabled = true;
    params.myGroundCircumferenceAddCenter = true;
    params.myGroundCircumferenceSliceAmount = 6;
    params.myGroundCircumferenceStepAmount = 2;
    params.myGroundCircumferenceRotationPerStep = 30;
    params.myFeetRadius = params.myRadius;
    params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myDebugEnabled = false;
    params.myDebugHorizontalMovementEnabled = false;
    params.myDebugHorizontalPositionEnabled = false;
    params.myDebugVerticalMovementEnabled = false;
    params.myDebugVerticalPositionEnabled = false;
    params.myDebugSlidingEnabled = false;
    params.myDebugGroundInfoEnabled = false;
    params.myDebugCeilingInfoEnabled = false;
    params.myDebugRuntimeParamsEnabled = false;
    params.myDebugMovementEnabled = false;
  }
  _generateTeleportParamsFromMovementParams() {
    if (this._myParams.myTeleportCollisionCheckParams == null) {
      this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
    }
    if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
      this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
    } else {
      this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
    }
  }
  _generateRealMovementParamsFromMovementParams() {
    if (this._myRealMovementCollisionCheckParams == null) {
      this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
    }
    let params = this._myRealMovementCollisionCheckParams;
    params.copy(this._myParams.myMovementCollisionCheckParams);
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLengthEnabled = true;
    params.mySplitMovementMaxLength = params.myRadius * 0.75;
    params.mySplitMovementMinLengthEnabled = true;
    params.mySplitMovementMinLength = params.mySplitMovementMaxLength;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 3;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.mySlidingEnabled = false;
    if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
      params.mySnapOnGroundEnabled = false;
      params.mySnapOnCeilingEnabled = false;
      params.myGroundPopOutEnabled = false;
      params.myCeilingPopOutEnabled = false;
      params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
      params.myAdjustVerticalMovementWithGroundAngleUphill = false;
      params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
      params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
      params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
      params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
      params.myVerticalMovementReduceEnabled = false;
    }
    params.myIsOnGroundIfInsideHit = true;
    params.myDebugEnabled = false;
    params.myDebugHorizontalMovementEnabled = false;
    params.myDebugHorizontalPositionEnabled = false;
    params.myDebugVerticalMovementEnabled = false;
    params.myDebugVerticalPositionEnabled = false;
    params.myDebugSlidingEnabled = false;
    params.myDebugGroundInfoEnabled = false;
    params.myDebugCeilingInfoEnabled = false;
    params.myDebugRuntimeParamsEnabled = false;
    params.myDebugMovementEnabled = false;
  }
  _onXRSessionStart(manualCall, session) {
    if (!manualCall) {
      if (this._myActive) {
        if (this._myParams.myResetToValidOnEnterSession) {
          this._myResetRealOnHeadSynced = true;
        }
      }
    }
  }
  _onXRSessionEnd() {
    if (this._myActive) {
      if (this._myParams.myResetToValidOnExitSession) {
        this._myResetRealOnHeadSynced = true;
      }
    }
  }
  _updatePositionsValid(dt) {
  }
  _updateValidToReal(dt) {
  }
  _updateValidHeadToRealHead() {
  }
  _debugUpdate(dt) {
    Globals.getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPosition, vec4_create(1, 0, 0, 1), 0.05);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this._myValidPosition, this.getPositionReal(), vec4_create(1, 0, 0, 1), 0.05);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, vec4_create(0, 1, 0, 1), 0.025);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPositionHead, vec4_create(1, 1, 0, 1), 0.05);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerTransformManager.prototype.getDistanceToReal = function() {
  let position = vec3_create();
  let realPosition = vec3_create();
  return function getDistanceToReal() {
    realPosition = this.getPositionReal(realPosition);
    return realPosition.vec3_distance(this.getPosition(position));
  };
}();
PlayerTransformManager.prototype.getDistanceToRealHead = function() {
  let position = vec3_create();
  let realPosition = vec3_create();
  return function getDistanceToRealHead() {
    realPosition = this.getPositionHeadReal(realPosition);
    return realPosition.vec3_distance(this.getPositionHead(position));
  };
}();
PlayerTransformManager.prototype.resetReal = function() {
  let realUp = vec3_create();
  let validUp = vec3_create();
  let position = vec3_create();
  let rotationQuat = quat_create();
  let positionHeadReal = vec3_create();
  let distanceToRealHead = vec3_create();
  let validPositionHeadBackupForResetToFeet = vec3_create();
  return function resetReal(resetPosition2 = true, resetRotation2 = false, resetHeight = false, resetHeadToReal = true, updateValidToReal = false, ignoreResetHeadMinDistance = false) {
    let playerHeadManager = this.getPlayerHeadManager();
    if (resetPosition2) {
      playerHeadManager.teleportPositionFeet(this.getPosition(position));
    }
    realUp = this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
    validUp = this.getRotationQuat(rotationQuat).quat_getUp(validUp);
    if (resetRotation2 || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
      playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
    }
    if (resetHeight) {
      playerHeadManager.setHeightHead(this.getHeight(), true);
    }
    if (updateValidToReal) {
      this._updateValidToReal(0);
    }
    if (resetHeadToReal) {
      positionHeadReal = this.getPositionHeadReal(positionHeadReal);
      distanceToRealHead = this._myValidPositionHead.vec3_distance(positionHeadReal);
      if (ignoreResetHeadMinDistance || distanceToRealHead >= this._myParams.myResetHeadToRealMinDistance) {
        if (this._myParams.myResetHeadToFeetInsteadOfRealOnlyIfRealNotReachable) {
          this._myResetHeadToFeetOnNextUpdateValidToReal = true;
          validPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
          this.resetHeadToFeet();
          this._myValidPositionHeadBackupForResetToFeet.vec3_copy(validPositionHeadBackupForResetToFeet);
        } else if (this._myParams.myResetHeadToFeetInsteadOfReal) {
          this.resetHeadToFeet();
        } else {
          this.resetHeadToReal();
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.update = function() {
  return function update(dt) {
    if (this._myResetRealOnHeadSynced) {
      if (this.getPlayerHeadManager().isSynced()) {
        this._myResetRealOnHeadSynced = false;
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(!this._myParams.myNeverResetRealPositionVR, !this._myParams.myNeverResetRealRotationVR, !this._myParams.myNeverResetRealHeightVR, true, true);
        } else {
          this.resetReal(!this._myParams.myNeverResetRealPositionNonVR, !this._myParams.myNeverResetRealRotationNonVR, !this._myParams.myNeverResetRealHeightNonVR && this._myParams.myResetRealHeightNonVROnExitSession, true, true);
        }
      }
    }
    this._updateValidToReal(dt);
    this._updatePositionsValid(dt);
    if (this._myParams.myDebugEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      this._debugUpdate(dt);
    }
  };
}();
PlayerTransformManager.prototype._updateValidToReal = function() {
  let movementToCheck = vec3_create();
  let position = vec3_create();
  let positionReal = vec3_create();
  let transformQuat2 = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let newPosition = vec3_create();
  let movementStep = vec3_create();
  let currentMovementStep = vec3_create();
  let transformUp = vec3_create();
  let verticalMovement = vec3_create();
  let movementChecked = vec3_create();
  let newFeetPosition = vec3_create();
  let floatingTransformQuat = quat2_create();
  return function _updateValidToReal(dt) {
    if (this.getPlayerHeadManager().isSynced()) {
      this._updateCollisionHeight();
      this._myIsBodyColliding = false;
      this._myIsHeadColliding = false;
      this._myIsLeaning = false;
      this._myIsHopping = false;
      this._myIsFar = false;
      movementToCheck = this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
      if (movementToCheck.vec3_length() > 1e-4) {
        this._myLastValidMovementDirection = movementToCheck.vec3_normalize(this._myLastValidMovementDirection);
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
        if (this._myParams.myMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
          this._myIsFar = true;
        } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
          this._myIsFar = true;
        }
      }
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      collisionRuntimeParams.myIsOnGround = true;
      transformQuat2 = this.getTransformQuat(transformQuat2);
      newPosition.vec3_copy(this._myValidPosition);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movementToCheck, transformQuat2, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          if (Math.pp_clamp(this._myRealMovementCollisionCheckParams.myHeight, this._myParams.myIsBodyCollidingWhenHeightBelowValue, this._myParams.myIsBodyCollidingWhenHeightAboveValue) != this._myRealMovementCollisionCheckParams.myHeight) {
            this._myIsBodyColliding = true;
          } else {
            if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
              this._myIsBodyColliding = true;
            } else {
              this._myIsBodyColliding = false;
              newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
            }
          }
        } else {
          this._myIsBodyColliding = true;
        }
      }
      if (this._myParams.myAlwaysSyncPositionWithReal) {
        newPosition.vec3_copy(positionReal);
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
        if (!this._myIsBodyColliding) {
          movementToCheck = newPosition.vec3_sub(position, movementToCheck);
        } else {
          movementToCheck = positionReal.vec3_sub(position, movementToCheck);
        }
        collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
        floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (collisionRuntimeParams.myIsOnGround) {
          transformUp = transformQuat2.quat2_getUp(transformUp);
          verticalMovement = movementToCheck.vec3_componentAlongAxis(transformUp, verticalMovement);
          let isVertical = !verticalMovement.vec3_isZero(1e-5);
          if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
            let movementStepAmount = 1;
            movementStep.vec3_copy(movementToCheck);
            if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
              let minLength = this._myParams.myFloatingSplitCheckMinLength;
              let maxLength = this._myParams.myFloatingSplitCheckMaxLength;
              let maxSteps = this._myParams.myFloatingSplitCheckMaxSteps != null ? this._myParams.myFloatingSplitCheckMaxSteps : 1;
              let movementLength = movementToCheck.vec3_length();
              let equalStepLength = movementLength / maxSteps;
              let stepLength = Math.pp_clamp(equalStepLength, minLength, maxLength);
              if (stepLength != equalStepLength) {
                movementStepAmount = Math.ceil(movementLength / stepLength);
                movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(stepLength, movementStep);
                if (this._myParams.myFloatingSplitCheckMaxSteps != null) {
                  movementStepAmount = Math.min(movementStepAmount, maxSteps);
                }
              } else {
                movementStepAmount = maxSteps;
                movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
              }
              movementStepAmount = Math.max(1, movementStepAmount);
              if (movementStepAmount == 1) {
                movementStep.vec3_copy(movementToCheck);
              }
            }
            let isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
            movementChecked.vec3_zero();
            newFeetPosition.vec3_copy(this._myValidPosition);
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            let atLeastOneNotOnGround = false;
            let isOneOnGroundBetweenNoGround = false;
            let isLastOnGround = false;
            let isOneOnSteepGround = false;
            for (let i = 0; i < movementStepAmount; i++) {
              if (movementStepAmount == 1 || i != movementStepAmount - 1) {
                currentMovementStep.vec3_copy(movementStep);
              } else {
                currentMovementStep = movementToCheck.vec3_sub(movementChecked, currentMovementStep);
              }
              newFeetPosition = newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
              floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
              collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
              CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
              if (!collisionRuntimeParams.myIsOnGround) {
                atLeastOneNotOnGround = true;
              } else {
                if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                  isOneOnSteepGround = true;
                }
                if (atLeastOneNotOnGround) {
                  isOneOnGroundBetweenNoGround = true;
                }
                if (i == movementStepAmount - 1) {
                  isLastOnGround = true;
                }
              }
            }
            let isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
            if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
              if (isOneOnGroundBetweenNoGround) {
                this._myIsHopping = true;
              } else {
                this._myIsLeaning = true;
              }
            } else {
              this._myIsLeaning = false;
              this._myIsHopping = false;
              if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
                this._myIsLeaning = true;
              } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
                this._myIsHopping = true;
              }
            }
            if (this._myIsLeaning) {
              let distance2 = movementToCheck.vec3_length();
              if (this._myParams.myIsLeaningValidAboveDistance && distance2 > this._myParams.myLeaningValidDistance) {
                this._myIsLeaning = false;
              }
            }
            if (this._myIsLeaning || this._myIsHopping) {
              if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              }
            }
          }
        }
      }
      if ((this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysSyncPositionWithReal) && !this._myParams.mySyncPositionDisabled) {
        this._myValidPosition.vec3_copy(newPosition);
      }
      if (this.isSynced(this._myParams.mySyncRotationFlagMap)) {
        this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
      }
      if (this.isSynced(this._myParams.mySyncHeightFlagMap)) {
        this._myValidHeight = this._myRealMovementCollisionCheckParams.myHeight;
        this._updateCollisionHeight();
      }
      this._updateValidHeadToRealHead(dt);
    }
  };
}();
PlayerTransformManager.prototype._updateValidHeadToRealHead = function() {
  let movementToCheck = vec3_create();
  let position = vec3_create();
  let positionReal = vec3_create();
  let transformQuat2 = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let newPositionHead = vec3_create();
  let backupHorizontalBlockLayerFlags = new PhysicsLayerFlags();
  let backupVerticalBlockLayerFlags = new PhysicsLayerFlags();
  return function _updateValidHeadToRealHead(dt) {
    if (this.getPlayerHeadManager().isSynced()) {
      this._myIsHeadColliding = false;
      backupHorizontalBlockLayerFlags.copy(this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags);
      backupVerticalBlockLayerFlags.copy(this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags);
      let backupVerticalMovementReduceEnabled = this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled;
      let backupGroundAngleToIgnore = this._myHeadCollisionCheckParams.myGroundAngleToIgnore;
      let backupGroundAngleToIgnoreWithPerceivedAngle = this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle;
      let backupHorizontalMovementGroundAngleIgnoreHeight = this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight;
      let backupHorizontalPositionGroundAngleIgnoreHeight = this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
      let backupHorizontalMovementGroundAngleIgnoreMaxMovementLeft = this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      let headReducedVerticalMovementFeetAdjustment = false;
      let firstHeadCollidingCheckDone = false;
      do {
        if (firstHeadCollidingCheckDone && this._myResetHeadToFeetOnNextUpdateValidToReal) {
          this._myResetHeadToFeetOnNextUpdateValidToReal = false;
          this.resetHeadToFeet();
        }
        if (this._myResetHeadToFeetOnNextUpdateValidToReal) {
          this._myValidPositionHead.vec3_copy(this._myValidPositionHeadBackupForResetToFeet);
          this._myResetHeadToFeetDirty = false;
        }
        if (this._myResetHeadToFeetDirty) {
          if (this._myParams.myHeadCollisionBlockLayerFlagsForResetToFeet != null) {
            this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlagsForResetToFeet);
            this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlagsForResetToFeet);
          }
          if (this._myParams.myResetHeadToFeetMoveTowardReal) {
            this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled = true;
          }
          if (this._myParams.myResetHeadToFeetGroudnAngleIgnoreEnabled) {
            this._myHeadCollisionCheckParams.myGroundAngleToIgnore = this._myParams.myMovementCollisionCheckParams.myGroundAngleToIgnore;
            this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = this._myParams.myMovementCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle;
            this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = this._myParams.myMovementCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight;
            this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = this._myParams.myMovementCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
            this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = this._myParams.myMovementCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
          }
          this._myResetHeadToFeetDirty = false;
        } else {
          this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags.copy(backupHorizontalBlockLayerFlags);
          this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags.copy(backupVerticalBlockLayerFlags);
          this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled = backupVerticalMovementReduceEnabled;
          this._myHeadCollisionCheckParams.myGroundAngleToIgnore = backupGroundAngleToIgnore;
          this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = backupGroundAngleToIgnoreWithPerceivedAngle;
          this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = backupHorizontalMovementGroundAngleIgnoreHeight;
          this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = backupHorizontalPositionGroundAngleIgnoreHeight;
          this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = backupHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
        }
        movementToCheck = this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
        collisionRuntimeParams.reset();
        transformQuat2 = this.getTransformHeadQuat(transformQuat2);
        newPositionHead.vec3_copy(this._myValidPositionHead);
        if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
          CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movementToCheck, transformQuat2, this._myHeadCollisionCheckParams, collisionRuntimeParams);
          if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
            if (!backupVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
              this._myIsHeadColliding = true;
              headReducedVerticalMovementFeetAdjustment = true;
            } else {
              this._myIsHeadColliding = false;
            }
            newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
          } else {
            this._myIsHeadColliding = true;
          }
        }
        firstHeadCollidingCheckDone = true;
      } while (this._myIsHeadColliding && this._myResetHeadToFeetOnNextUpdateValidToReal);
      {
        this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags.copy(backupHorizontalBlockLayerFlags);
        this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags.copy(backupVerticalBlockLayerFlags);
        this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled = backupVerticalMovementReduceEnabled;
        this._myHeadCollisionCheckParams.myGroundAngleToIgnore = backupGroundAngleToIgnore;
        this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = backupGroundAngleToIgnoreWithPerceivedAngle;
        this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = backupHorizontalMovementGroundAngleIgnoreHeight;
        this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = backupHorizontalPositionGroundAngleIgnoreHeight;
        this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = backupHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      }
      this._myResetHeadToFeetOnNextUpdateValidToReal = false;
      this._myResetHeadToFeetDirty = false;
      if (this._myParams.myAlwaysSyncHeadPositionWithReal) {
        newPositionHead.vec3_copy(positionReal);
      }
      let backupIsHeadColliding = this._myIsHeadColliding;
      if (headReducedVerticalMovementFeetAdjustment) {
        this._myIsHeadColliding = false;
      }
      if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap) || this._myParams.myAlwaysSyncHeadPositionWithReal || this.isSynced(this._myParams.mySyncPositionFlagMap) && this._myParams.myAlwaysSyncPositionWithReal) {
        this._myValidPositionHead.vec3_copy(newPositionHead);
        this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
      }
      if (headReducedVerticalMovementFeetAdjustment) {
        this._myIsHeadColliding = backupIsHeadColliding;
      }
    }
  };
}();
PlayerTransformManager.prototype._updatePositionsValid = function() {
  let transformQuat2 = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let headCollisionRuntimeParams = new CollisionRuntimeParams();
  let transformUp = vec3_create();
  let horizontalDirection = vec3_create();
  let rotationQuat = quat_create();
  return function _updatePositionsValid(dt) {
    if (this._myParams.myUpdatePositionValid) {
      transformQuat2 = this.getTransformQuat(transformQuat2);
      transformUp = transformQuat2.quat2_getUp(transformUp);
      rotationQuat = transformQuat2.quat2_getRotationQuat(rotationQuat);
      horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setForward(horizontalDirection);
        transformQuat2.quat2_setRotationQuat(rotationQuat);
      }
      let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
    } else {
      this._myIsPositionValid = true;
    }
    if (this._myParams.myUpdatePositionHeadValid) {
      transformQuat2 = this.getTransformHeadQuat(transformQuat2);
      let debugBackup = this._myHeadCollisionCheckParams.myDebugEnabled;
      this._myHeadCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myHeadCollisionCheckParams, headCollisionRuntimeParams);
      this._myHeadCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsPositionHeadValid = headCollisionRuntimeParams.myIsPositionOk;
    } else {
      this._myIsPositionHeadValid = true;
    }
    if (this._myParams.myUpdateRealPositionValid) {
      transformQuat2 = this.getTransformRealQuat(transformQuat2);
      transformUp = transformQuat2.quat2_getUp(transformUp);
      rotationQuat = transformQuat2.quat2_getRotationQuat(rotationQuat);
      horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setForward(horizontalDirection);
        transformQuat2.quat2_setRotationQuat(rotationQuat);
      }
      let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myParams.myMovementCollisionCheckParams, this._myRealCollisionRuntimeParams);
      this._myIsRealPositionValid = this._myRealCollisionRuntimeParams.myIsPositionOk;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
    } else {
      this._myIsRealPositionValid = true;
    }
    if (this._myParams.myUpdateRealPositionHeadValid) {
      transformQuat2 = this.getTransformHeadRealQuat(transformQuat2);
      let debugBackup = this._myHeadCollisionCheckParams.myDebugEnabled;
      this._myHeadCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myHeadCollisionCheckParams, headCollisionRuntimeParams);
      this._myHeadCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsRealPositionHeadValid = headCollisionRuntimeParams.myIsPositionOk;
    } else {
      this._myIsRealPositionHeadValid = true;
    }
  };
}();
PlayerTransformManager.prototype.move = function() {
  let transformQuat2 = quat2_create();
  let fixedMovement = vec3_create();
  return function move(movement, outCollisionRuntimeParams = null, forceMove = false) {
    transformQuat2 = this.getTransformQuat(transformQuat2);
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movement, transformQuat2, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    if (!forceMove) {
      fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
    } else {
      fixedMovement.vec3_copy(movement);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnMove) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(!this._myParams.myNeverResetRealPositionVR, !this._myParams.myNeverResetRealRotationVR, !this._myParams.myNeverResetRealHeightVR, true);
        } else {
          this.resetReal(!this._myParams.myNeverResetRealPositionNonVR, !this._myParams.myNeverResetRealRotationNonVR, !this._myParams.myNeverResetRealHeightNonVR, true);
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.teleportPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function teleportPosition(teleportPosition, outCollisionRuntimeParams = null, forceTeleport = false) {
    teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
  };
}();
PlayerTransformManager.prototype.teleportPositionRotationQuat = function() {
  let teleportTransformQuat = quat2_create();
  return function teleportPositionRotationQuat(teleportPosition, teleportRotationQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
    teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPositionRotationQuat(teleportPosition, teleportRotationQuat);
    this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
  };
}();
PlayerTransformManager.prototype.teleportTransformQuat = function() {
  let currentPosition = vec3_create();
  let teleportPositionVec = vec3_create();
  let teleportRotation = quat_create();
  let rotatedTransformQuat = quat2_create();
  let fixedMovement = vec3_create();
  return function teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
    currentPosition = this.getPosition(currentPosition);
    teleportPositionVec = teleportTransformQuat.quat2_getPosition(teleportPositionVec);
    teleportRotation = teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
    rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).teleport(teleportPositionVec, rotatedTransformQuat, this._myParams.myTeleportCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    fixedMovement.vec3_zero();
    if (!forceTeleport) {
      if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
        fixedMovement = this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
      }
    } else {
      fixedMovement = teleportPositionVec.vec3_sub(currentPosition, fixedMovement);
    }
    if (!this._myCollisionRuntimeParams.myTeleportCanceled || forceTeleport) {
      this._myValidRotationQuat.quat_copy(teleportRotation);
      this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnTeleport) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(!this._myParams.myNeverResetRealPositionVR, !this._myParams.myNeverResetRealRotationVR, !this._myParams.myNeverResetRealHeightVR, true);
        } else {
          this.resetReal(!this._myParams.myNeverResetRealPositionNonVR, !this._myParams.myNeverResetRealRotationNonVR, !this._myParams.myNeverResetRealHeightNonVR, true);
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.rotateQuat = function() {
  return function rotateQuat4(rotationQuat) {
    this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
    this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
  };
}();
PlayerTransformManager.prototype.setRotationQuat = function() {
  let rotationToPerform = quat_create();
  return function setRotationQuat4(rotationQuat) {
    rotationToPerform = this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
    this.rotateQuat(rotationToPerform);
  };
}();
PlayerTransformManager.prototype.setHeight = function() {
  let transformQuat2 = quat2_create();
  return function setHeight(height, forceSet = false) {
    let fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight, this._myParams.myMaxHeight);
    let previousHeight = this.getHeight();
    this._myValidHeight = fixedHeight;
    this._updateCollisionHeight();
    transformQuat2 = this.getTransformQuat(transformQuat2);
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (this._myCollisionRuntimeParams.myIsPositionOk || forceSet) {
      this.getPlayerHeadManager().setHeightHead(this.getHeight(), true);
    } else {
      this._myValidHeight = previousHeight;
    }
    this._updateCollisionHeight();
  };
}();
PlayerTransformManager.prototype.resetHeadToFeet = function() {
  let transformQuat2 = quat2_create();
  let headUp = vec3_create();
  return function resetHeadToFeet() {
    this._myValidPositionHead = this.getPosition(this._myValidPositionHead);
    transformQuat2 = this.getTransformHeadQuat(transformQuat2);
    headUp = transformQuat2.quat2_getUp(headUp);
    this._myValidPositionHead.vec3_add(headUp.vec3_scale(this._myHeadCollisionCheckParams.myHeight / 2 + 1e-5 + this._myParams.myResetHeadToFeetUpOffset, headUp), this._myValidPositionHead);
    this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
    this._myResetHeadToFeetDirty = true;
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_rotate.js
var PlayerLocomotionRotateParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myHorizontalRotationEnabled = true;
    this.myVerticalRotationEnabled = true;
    this.myMaxRotationSpeed = 0;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySmoothSnapEnabled = true;
    this.mySmoothSnapSpeedDegrees = 240;
    this.myRotationMinStickIntensityThreshold = 0;
    this.mySnapTurnActivateThreshold = 0;
    this.mySnapTurnResetThreshold = 0;
    this.myClampVerticalAngle = true;
    this.myMaxVerticalAngle = 89;
    this.myHandedness = Handedness.RIGHT;
    this.myEngine = engine;
  }
};
var PlayerLocomotionRotate = class {
  constructor(params) {
    this._myParams = params;
    this._mySnapCharge = false;
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  start() {
  }
  stop() {
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  getParams() {
    return this._myParams;
  }
  update(dt) {
    if (this._myParams.myHorizontalRotationEnabled) {
      this._rotateHeadHorizontally(dt);
    }
    if (this._myParams.myVerticalRotationEnabled && this._myParams.myPlayerHeadManager.canRotateHead()) {
      this._rotateHeadVertically(dt);
    }
  }
  _rotateHeadHorizontally(dt) {
  }
  _rotateHeadVertically(dt) {
  }
};
PlayerLocomotionRotate.prototype._rotateHeadHorizontally = function() {
  let playerUp = vec3_create();
  let headRotation = quat_create();
  return function _rotateHeadHorizontally(dt) {
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headRotation.quat_identity();
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[0]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = -axes[0];
        let speed = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity);
        headRotation.quat_fromAxis(speed * dt, playerUp);
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapHorizontalRunning) {
        if (Math.abs(axes[0]) > this._myParams.mySnapTurnActivateThreshold) {
          let angleToRotate = -Math.pp_sign(axes[0]) * this._myParams.mySnapTurnAngle;
          if (!this._myParams.mySmoothSnapEnabled) {
            headRotation.quat_fromAxis(angleToRotate, playerUp);
          } else {
            this._mySmoothSnapHorizontalRunning = true;
            this._mySmoothSnapHorizontalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapHorizontalRunning) {
      let angleToRotate = Math.pp_sign(this._mySmoothSnapHorizontalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapHorizontalAngleToPerform) - Math.PP_EPSILON) {
        angleToRotate = this._mySmoothSnapHorizontalAngleToPerform;
      }
      headRotation.quat_fromAxis(angleToRotate, playerUp);
      this._mySmoothSnapHorizontalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapHorizontalAngleToPerform) < Math.PP_EPSILON) {
        this._mySmoothSnapHorizontalRunning = false;
        this._mySmoothSnapHorizontalAngleToPerform = 0;
      }
    }
    if (headRotation.quat_getAngle() > Math.PP_EPSILON_DEGREES) {
      this._myParams.myPlayerTransformManager.rotateQuat(headRotation);
    }
  };
}();
PlayerLocomotionRotate.prototype._rotateHeadVertically = function() {
  let headForward = vec3_create();
  let headUp = vec3_create();
  let referenceUp = vec3_create();
  let referenceUpNegate = vec3_create();
  let referenceRight = vec3_create();
  let newUp = vec3_create();
  let headRotation = quat_create();
  return function _rotateHeadVertically(dt) {
    let head = this._myParams.myPlayerHeadManager.getHead();
    headForward = head.pp_getForward(headForward);
    headUp = head.pp_getUp(headUp);
    referenceUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(referenceUp);
    referenceUpNegate = referenceUp.vec3_negate(referenceUpNegate);
    referenceRight = headForward.vec3_cross(referenceUp, referenceRight);
    let minAngle = 1;
    if (headForward.vec3_angle(referenceUp) < minAngle) {
      referenceRight = headUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
    } else if (headForward.vec3_angle(referenceUpNegate) < minAngle) {
      referenceRight = headUp.vec3_cross(referenceUp, referenceRight);
    } else if (!headUp.vec3_isConcordant(referenceUp)) {
      referenceRight.vec3_negate(referenceRight);
    }
    referenceRight.vec3_normalize(referenceRight);
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    let angleToRotate = 0;
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[1]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = axes[1];
        angleToRotate = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity) * dt;
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapVerticalRunning) {
        if (Math.abs(axes[1]) > this._myParams.mySnapTurnActivateThreshold) {
          angleToRotate = Math.pp_sign(axes[1]) * this._myParams.mySnapTurnAngle;
          let angleWithUp = Math.pp_angleClamp(headUp.vec3_angleSigned(referenceUp, referenceRight));
          let snapStep = Math.round(angleWithUp / this._myParams.mySnapTurnAngle);
          let snapAngle = Math.pp_angleClamp(snapStep * this._myParams.mySnapTurnAngle);
          let angleToAlign = -Math.pp_angleDistanceSigned(angleWithUp, snapAngle);
          if (Math.abs(angleToAlign) > 1) {
            if (Math.pp_sign(angleToRotate) == Math.pp_sign(angleToAlign)) {
              angleToRotate = angleToAlign;
            } else {
              angleToRotate = -Math.pp_sign(angleToAlign) * this._myParams.mySnapTurnAngle + angleToAlign;
            }
          } else if (Math.abs(angleToAlign) > Math.PP_EPSILON_DEGREES) {
            angleToRotate += angleToAlign;
          }
          if (this._myParams.mySmoothSnapEnabled) {
            this._mySmoothSnapVerticalRunning = true;
            this._mySmoothSnapVerticalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapVerticalRunning) {
      angleToRotate = Math.pp_sign(this._mySmoothSnapVerticalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapVerticalAngleToPerform) - Math.PP_EPSILON) {
        angleToRotate = this._mySmoothSnapVerticalAngleToPerform;
      }
      this._mySmoothSnapVerticalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapVerticalAngleToPerform) < Math.PP_EPSILON) {
        this._mySmoothSnapVerticalRunning = false;
        this._mySmoothSnapVerticalAngleToPerform = 0;
      }
    }
    if (angleToRotate != 0) {
      headRotation.quat_fromAxis(angleToRotate, referenceRight);
      this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
      if (this._myParams.myClampVerticalAngle) {
        let maxVerticalAngle = Math.max(0, this._myParams.myMaxVerticalAngle - 1e-4);
        newUp = head.pp_getUp(newUp);
        let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
        if (Math.abs(angleWithUp) > maxVerticalAngle) {
          let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
          headRotation.quat_fromAxis(fixAngle, referenceRight);
          this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
        }
      }
    }
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_movement.js
var PlayerLocomotionMovementRuntimeParams = class {
  constructor() {
    this.myIsFlying = false;
    this.myGravitySpeed = 0;
    this.myCollisionRuntimeParams = null;
    this.myIsTeleportDetecting = false;
    this.myIsTeleporting = false;
    this.myTeleportJustPerformed = false;
  }
};
var PlayerLocomotionMovement = class {
  constructor(locomotionRuntimeParams) {
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
  }
  getRuntimeParams() {
    return this._myLocomotionRuntimeParams;
  }
  start() {
  }
  stop() {
  }
  canStop() {
    return true;
  }
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
import { Emitter as Emitter12, PhysXComponent as PhysXComponent8 } from "@wonderlandengine/api";

// dist/input/gamepad/cauldron/gamepad_utils.js
var _mySimultaneousPressMaxDelay = 0.15;
var _mySimultaneousTouchMaxDelay = 0.15;
function setSimultaneousPressMaxDelay(simultaneousPressMaxDelay) {
  _mySimultaneousPressMaxDelay = simultaneousPressMaxDelay;
}
function setSimultaneousTouchMaxDelay(simultaneousTouchMaxDelay) {
  _mySimultaneousTouchMaxDelay = simultaneousTouchMaxDelay;
}
function getSimultaneousPressMaxDelay() {
  return _mySimultaneousPressMaxDelay;
}
function getSimultaneousTouchMaxDelay() {
  return _mySimultaneousTouchMaxDelay;
}
function isAnyButtonPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonPressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressStart(multiplePressCount)) {
        atLeastOneButtonPressStart = true;
        break;
      }
    }
    if (atLeastOneButtonPressStart) {
      break;
    }
  }
  return atLeastOneButtonPressStart;
}
function areButtonsPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonPressedRecently = true;
  let atLeastOneButtonPressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myPressed && (multiplePressCount == null || button.myMultiplePressStartCount == multiplePressCount) && button.myTimePressed < _mySimultaneousPressMaxDelay)) {
        areButtonPressedRecently = false;
        break;
      }
      if (button.isPressStart(multiplePressCount)) {
        atLeastOneButtonPressStart = true;
      }
    }
    if (!areButtonPressedRecently) {
      break;
    }
  }
  return areButtonPressedRecently && atLeastOneButtonPressStart;
}
function isAnyButtonPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonPressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressEnd(multiplePressCount)) {
        atLeastOneButtonPressEnd = true;
        break;
      }
    }
    if (atLeastOneButtonPressEnd) {
      break;
    }
  }
  return atLeastOneButtonPressEnd;
}
function areButtonsPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotPressedRecently = true;
  let atLeastOneButtonPressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myPressed && (multiplePressCount == null || button.myMultiplePressEndCount == multiplePressCount) && button.myTimeNotPressed < _mySimultaneousPressMaxDelay)) {
        areButtonNotPressedRecently = false;
        break;
      }
      if (button.isPressEnd(multiplePressCount)) {
        atLeastOneButtonPressEnd = true;
      }
    }
    if (!areButtonNotPressedRecently) {
      break;
    }
  }
  return areButtonNotPressedRecently && atLeastOneButtonPressEnd;
}
function isAnyButtonTouchStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchStart(multiplePressCount)) {
        atLeastOneButtonTouchStart = true;
        break;
      }
    }
    if (atLeastOneButtonTouchStart) {
      break;
    }
  }
  return atLeastOneButtonTouchStart;
}
function areButtonsTouchStart(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonTouchedRecently = true;
  let atLeastOneButtonTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myTouched && (multipleTouchCount == null || button.myMultipleTouchStartCount == multipleTouchCount) && button.myTimeTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonTouchedRecently = false;
        break;
      }
      if (button.isTouchStart(multipleTouchCount)) {
        atLeastOneButtonTouchStart = true;
      }
    }
    if (!areButtonTouchedRecently) {
      break;
    }
  }
  return areButtonTouchedRecently && atLeastOneButtonTouchStart;
}
function isAnyButtonTouchEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchEnd(multiplePressCount)) {
        atLeastOneButtonTouchEnd = true;
        break;
      }
    }
    if (atLeastOneButtonTouchEnd) {
      break;
    }
  }
  return atLeastOneButtonTouchEnd;
}
function areButtonsTouchEnd(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotTouchedRecently = true;
  let atLeastOneButtonTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myTouched && (multipleTouchCount == null || button.myMultipleTouchEndCount == multipleTouchCount) && button.myTimeNotTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonNotTouchedRecently = false;
        break;
      }
      if (button.isTouchEnd(multipleTouchCount)) {
        atLeastOneButtonTouchEnd = true;
      }
    }
    if (!areButtonNotTouchedRecently) {
      break;
    }
  }
  return areButtonNotTouchedRecently && atLeastOneButtonTouchEnd;
}
var GamepadUtils = {
  setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay,
  getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay,
  isAnyButtonPressStart,
  areButtonsPressStart,
  isAnyButtonPressEnd,
  areButtonsPressEnd,
  isAnyButtonTouchStart,
  areButtonsTouchStart,
  isAnyButtonTouchEnd,
  areButtonsTouchEnd
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_obscure_manager.js
var PlayerObscureManagerParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerTransformManager = null;
    this.myPlayerLocomotionTeleport = null;
    this.myEnabled = true;
    this.myObscureObject = null;
    this.myObscureMaterial = null;
    this.myObscureRadius = 0;
    this.myObscureFadeOutSeconds = 0.1;
    this.myObscureFadeInSeconds = 0.1;
    this.myObscureFadeEasingFunction = EasingFunction.linear;
    this.myDistanceToStartObscureWhenHeadColliding = 0;
    this.myDistanceToStartObscureWhenBodyColliding = 0;
    this.myDistanceToStartObscureWhenFloating = 0;
    this.myDistanceToStartObscureWhenFar = 0;
    this.myRelativeDistanceToMaxObscureWhenHeadColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenBodyColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenFloating = 0;
    this.myRelativeDistanceToMaxObscureWhenFar = 0;
    this.myObscureLevelRelativeDistanceEasingFunction = EasingFunction.linear;
    this.myDisableObscureWhileTeleporting = true;
    this.myDisableObscureWhileTeleportingDuration = 0.5;
    this.myEngine = engine;
  }
};
var PlayerObscureManager = class {
  constructor(params) {
    this._myParams = params;
    this._myObscureMaterial = null;
    this._myObscureParentObject = null;
    this._myCurrentObscureLevel = 0;
    this._myTargetObscureLevel = 0;
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
    this._myInstantObscureFramesCount = 0;
    this._myFadeTimer = new Timer(0, false);
    this._myDisableObscureWhileTeleportingTimer = null;
    if (this._myParams.myDisableObscureWhileTeleportingDuration != null) {
      this._myDisableObscureWhileTeleportingTimer = new Timer(this._myParams.myDisableObscureWhileTeleportingDuration);
    } else {
      this._myDisableObscureWhileTeleportingTimer = new Timer(0, false);
    }
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("inactive");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("fading", this._fadingUpdate.bind(this));
    this._myFSM.addTransition("init", "inactive", "end", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("inactive", "idle", "start");
    this._myFSM.addTransition("idle", "fading", "fade", this._startFading.bind(this));
    this._myFSM.addTransition("fading", "idle", "done", this._fadingDone.bind(this));
    this._myFSM.addTransition("inactive", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("idle", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("fading", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.init("init");
    this._setupVisuals();
    this._myFSM.perform("end");
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), false, false, this._myParams.myEngine);
    this._myDestroyed = false;
  }
  start() {
    this._myFSM.perform("start");
  }
  stop() {
    this._myFSM.perform("stop");
  }
  getParams() {
    return this._myParams;
  }
  update(dt) {
    if (!this._myParams.myPlayerLocomotionTeleport.isTeleporting()) {
      if (this._myParams.myDisableObscureWhileTeleportingDuration != null) {
        this._myDisableObscureWhileTeleportingTimer.start();
      } else {
        this._myDisableObscureWhileTeleportingTimer.reset();
      }
    } else {
      this._myDisableObscureWhileTeleportingTimer.update(dt);
    }
    this._myObscureParentObject.pp_resetTransformLocal();
    this._updateObscured();
    this._myFSM.update(dt);
    this._setObscureVisible(this.isObscured());
    if (this._myInstantObscureFramesCount > 0) {
      this._myInstantObscureFramesCount--;
    }
  }
  isStarted() {
    return !this._myFSM.isInState("inactive");
  }
  isObscured() {
    return this._myCurrentObscureLevel > 0;
  }
  isFading() {
    return this._myFSM.isInState("fading");
  }
  isFadingIn() {
    return this.isFading() && this._myCurrentObscureLevel > this._myTargetObscureLevel;
  }
  isFadingOut() {
    return this.isFading() && this._myCurrentObscureLevel <= this._myTargetObscureLevel;
  }
  getObscureLevel() {
    return this._myCurrentObscureLevel;
  }
  getTargetObscureLevel() {
    return this._myTargetObscureLevel;
  }
  getCurrentObscureLevel() {
    this._myCurrentObscureLevel;
  }
  overrideObscureLevel(obscureLevel, instantFade = false) {
    this._myObscureLevelOverride = obscureLevel;
    if (instantFade && this.isStarted()) {
      this._setObscureLevel(obscureLevel);
    }
  }
  resetObscureLevelOverride() {
    this._myObscureLevelOverride = null;
  }
  _idleUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) > Math.PP_EPSILON) {
      if (this._myInstantObscureFramesCount > 0) {
        this._setObscureAlpha(this._myTargetObscureLevel);
        this._myCurrentObscureLevel = this._myTargetObscureLevel;
      } else {
        this._myFSM.perform("fade");
      }
    }
  }
  _fadingUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON) {
      this._myFSM.perform("done");
      return;
    }
    if (this._myLastTargetObscureLevel != this._myTargetObscureLevel) {
      this._refreshFadeTimer();
      this._myLastTargetObscureLevel = this._myTargetObscureLevel;
    }
    this._myFadeTimer.update(dt);
    if (this._myInstantObscureFramesCount > 0) {
      this._myFadeTimer.end();
    }
    let newObscureLevel = this._myParams.myObscureFadeEasingFunction(this._myFadeTimer.getPercentage());
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (!isFadingIn) {
      newObscureLevel = Math.min(newObscureLevel, this._myTargetObscureLevel);
    } else {
      newObscureLevel = Math.pp_clamp(1 - newObscureLevel, 0, 1);
      newObscureLevel = Math.max(newObscureLevel, this._myTargetObscureLevel);
    }
    this._setObscureAlpha(newObscureLevel);
    this._myCurrentObscureLevel = newObscureLevel;
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON || this._myFadeTimer.isDone()) {
      this._myFSM.perform("done");
    }
  }
  _startFading() {
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
  }
  _fadingDone() {
    this._setObscureLevel(this._myTargetObscureLevel);
  }
  _refreshFadeTimer() {
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (this._myLastIsFadingIn != isFadingIn) {
      this._setFadeTimerToObscureLevel(isFadingIn);
    }
    this._myLastIsFadingIn = isFadingIn;
  }
  _setFadeTimerToObscureLevel(isFadingIn) {
    let percentage = 0;
    let closestPercentage = 0;
    let steps = 1e3;
    let increment = 1 / steps;
    while (percentage < 1) {
      if (Math.abs(this._myParams.myObscureFadeEasingFunction(percentage) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
        closestPercentage = percentage;
      }
      percentage += increment;
    }
    if (Math.abs(this._myParams.myObscureFadeEasingFunction(1) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
      closestPercentage = 1;
    }
    if (isFadingIn) {
      this._myFadeTimer.start(this._myParams.myObscureFadeInSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(1 - closestPercentage, 0, 1));
    } else {
      this._myFadeTimer.start(this._myParams.myObscureFadeOutSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(closestPercentage, 0, 1));
    }
  }
  _setObscureLevel(obscureLevel) {
    this._myTargetObscureLevel = obscureLevel;
    this._myCurrentObscureLevel = obscureLevel;
    this._setObscureAlpha(obscureLevel);
    this._setObscureVisible(this.isObscured());
  }
  _setObscureAlpha(alpha) {
    if (this._myParams.myObscureObject == null) {
      MaterialUtils.setAlpha(this._myObscureMaterial, alpha);
    } else {
      MaterialUtils.setObjectAlpha(this._myParams.myObscureObject, alpha);
    }
  }
  _updateObscured() {
    this._myTargetObscureLevel = 0;
    if (this._myParams.myEnabled) {
      if (this._myObscureLevelOverride != null) {
        this._myTargetObscureLevel = this._myObscureLevelOverride;
      } else if (!this._myParams.myPlayerLocomotionTeleport.isTeleporting() || !this._myParams.myDisableObscureWhileTeleporting || this._myDisableObscureWhileTeleportingTimer.isDone()) {
        if (this._myParams.myPlayerTransformManager.isHeadColliding() || !this._myParams.myPlayerTransformManager.isPositionHeadValid()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToRealHead();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenHeadColliding;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenHeadColliding, 0, 1);
            if (isNaN(relativeDistancePercentage) || !this._myParams.myPlayerTransformManager.isPositionHeadValid()) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isBodyColliding()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenBodyColliding;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenBodyColliding, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isFloating()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenFloating;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFloating, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isFar()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenFar;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFar, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
      }
    }
  }
  _setupVisuals() {
    this._myObscureMaterial = null;
    if (this._myParams.myObscureMaterial != null) {
      this._myObscureMaterial = this._myParams.myObscureMaterial;
    } else {
      this._myObscureMaterial = Globals.getDefaultMaterials(this._myParams.myEngine).myFlatTransparentNoDepth.clone();
      this._myObscureMaterial.color = vec4_create(0, 0, 0, 1);
    }
    this._myObscureParentObject = Globals.getPlayerObjects(this._myParams.myEngine).myCauldron.pp_addObject();
    let obscureVisualParams = new VisualMeshParams(this._myParams.myEngine);
    obscureVisualParams.myMesh = Globals.getDefaultMeshes(this._myParams.myEngine).myInvertedSphere;
    obscureVisualParams.myMaterial = this._myParams.myObscureMaterial != null ? this._myParams.myObscureMaterial : this._myObscureMaterial;
    obscureVisualParams.myParent = this._myObscureParentObject;
    obscureVisualParams.myLocal = true;
    obscureVisualParams.myTransform.mat4_setScale(vec3_create(this._myParams.myObscureRadius, this._myParams.myObscureRadius, this._myParams.myObscureRadius));
    this._myObscureVisual = new VisualMesh(obscureVisualParams);
    if (this._myParams.myObscureObject != null) {
      this._myParams.myObscureObject.pp_setParent(this._myObscureParentObject, false);
      this._myParams.myObscureObject.pp_resetTransformLocal();
    }
    this._setObscureVisible(false);
  }
  _setObscureVisible(visible) {
    if (this._myParams.myObscureObject == null) {
      this._myObscureVisual.setVisible(visible);
    } else {
      this._myObscureVisual.setVisible(false);
      this._myParams.myObscureObject.pp_setActive(visible);
    }
    if (visible) {
      this._myObscureParentObject.pp_setParent(this._myParams.myPlayerTransformManager.getHead(), false);
    } else {
      this._myObscureParentObject.pp_setParent(Globals.getPlayerObjects(this._myParams.myEngine)?.myCauldron, false);
    }
  }
  _onXRSessionStart() {
    this._myInstantObscureFramesCount = 5;
  }
  _onXRSessionEnd() {
    this._myInstantObscureFramesCount = 5;
  }
  destroy() {
    this._myDestroyed = true;
    this._myObscureVisual.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_visualizer.js
var PlayerLocomotionTeleportDetectionVisualizerParams = class {
  constructor() {
    this.myTeleportValidMaterial = null;
    this.myTeleportInvalidMaterial = null;
    this.myTeleportPositionObject = null;
    this.myTeleportPositionObjectRotateWithHead = true;
    this.myTeleportParableLineEndOffset = 0.05;
    this.myTeleportParableMinVerticalDistanceToShowVerticalLine = 0.8;
    this.myTeleportParableShowVerticalLineMaxLength = 0.3;
    this.myTeleportParablePositionUpOffset = 0.05;
    this.myTeleportParablePositionVisualAlignOnSurface = true;
    this.myVisualTeleportPositionLerpEnabled = true;
    this.myVisualTeleportPositionLerpFactor = 10;
    this.myVisualTeleportPositionMinDistanceToResetLerp = 5e-3;
    this.myVisualTeleportPositionMinDistanceToLerp = 0.15;
    this.myVisualTeleportPositionMaxDistanceToLerp = 5;
    this.myVisualTeleportPositionMinDistanceToCloseLerpFactor = 0.02;
    this.myVisualTeleportPositionCloseLerpFactor = 30;
    this.myVisualTeleportPositionMinAngleDistanceToResetLerp = 0.1;
    this.myVisualTeleportPositionMinAngleDistanceToLerp = 1;
    this.myVisualTeleportPositionMaxAngleDistanceToLerp = 180;
  }
};
var PlayerLocomotionTeleportDetectionVisualizer = class {
  constructor(teleportParams, teleportRuntimeParams, detectionRuntimeParams) {
    this._myDetectionRuntimeParams = detectionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformQuat = quat2_create();
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._setupVisuals();
    this._myDestroyed = false;
  }
  start() {
  }
  end() {
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._hideTeleportPosition();
  }
  update(dt) {
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._showTeleportPosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
      this._hideTeleportPosition();
    }
  }
  _showTeleportPosition(dt) {
    this._hideTeleportPosition();
    this._showTeleportParable(dt);
  }
  _hideTeleportPosition() {
    for (let visualLine of this._myValidVisualLines) {
      visualLine.setVisible(false);
    }
    for (let visualLine of this._myInvalidVisualLines) {
      visualLine.setVisible(false);
    }
    this._myValidVisualPoint.setVisible(false);
    this._myInvalidVisualPoint.setVisible(false);
    this._myValidVisualVerticalArrow.setVisible(false);
    this._myValidVisualTeleportPositionTorus.setVisible(false);
    this._myValidVisualTeleportPositionTorusInner.setVisible(false);
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
  }
  _addVisualLines(amount) {
    for (let i = 0; i < amount; i++) {
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportValidMaterial;
        }
        this._myValidVisualLines.push(new VisualLine(visualParams));
      }
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportInvalidMaterial;
        }
        this._myInvalidVisualLines.push(new VisualLine(visualParams));
      }
    }
  }
  _showTeleportParablePosition(dt) {
  }
  _showTeleportParable(dt) {
  }
  _setupVisuals() {
  }
  destroy() {
    this._myDestroyed = true;
    for (let visual of this._myValidVisualLines) {
      visual.destroy();
    }
    for (let visual of this._myInvalidVisualLines) {
      visual.destroy();
    }
    this._myValidVisualPoint.destroy();
    this._myInvalidVisualPoint.destroy();
    this._myValidVisualVerticalArrow.destroy();
    this._myValidVisualTeleportPositionTorus.destroy();
    this._myValidVisualTeleportPositionTorusInner.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleportDetectionVisualizer.prototype._setupVisuals = function() {
  let innerTorusPosition = vec3_create();
  return function _setupVisuals() {
    this._myTeleportValidMaterial = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatOpaque.clone();
    this._myTeleportValidMaterial.color = vec4_create(0, 0.5, 1, 1);
    this._myTeleportInvalidMaterial = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatOpaque.clone();
    this._myTeleportInvalidMaterial.color = vec4_create(0.75, 0.05, 0, 1);
    this._myValidVisualLines = [];
    this._myInvalidVisualLines = [];
    this._addVisualLines(30);
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      this._myValidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportInvalidMaterial;
      }
      this._myInvalidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualArrowParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      this._myValidVisualVerticalArrow = new VisualArrow(visualParams);
    }
    this._myVisualTeleportPositionObject = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron.pp_addObject();
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myLocal = true;
      this._myValidVisualTeleportPositionTorus = new VisualTorus(visualParams);
    }
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myLocal = true;
      let visualTorusParams = this._myValidVisualTeleportPositionTorus.getParams();
      let innerTorusCenter = (visualTorusParams.myRadius - visualTorusParams.mySegmentThickness / 2) / 2;
      innerTorusPosition.vec3_set(0, 0, innerTorusCenter);
      visualParams.myTransform.mat4_setPosition(innerTorusPosition);
      this._myValidVisualTeleportPositionTorusInner = new VisualTorus(visualParams);
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setParent(this._myVisualTeleportPositionObject);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_resetTransformLocal();
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
    this._hideTeleportPosition();
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParable = function() {
  let currentPosition = vec3_create();
  let nextPosition = vec3_create();
  let playerUp = vec3_create();
  let upDifference = vec3_create();
  return function _showTeleportParable(dt) {
    let showParableDistance = Math.max(this._myDetectionRuntimeParams.myParableDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableLineEndOffset);
    let lastParableIndex = this._myDetectionRuntimeParams.myParable.getPositionIndexByDistance(showParableDistance);
    let lastParableIndexDistance = this._myDetectionRuntimeParams.myParable.getDistance(lastParableIndex);
    if (lastParableIndex + 1 > this._myValidVisualLines.length) {
      this._addVisualLines(lastParableIndex + 1, this._myValidVisualLines.length);
    }
    for (let i = 0; i <= lastParableIndex; i++) {
      currentPosition = this._myDetectionRuntimeParams.myParable.getPosition(i, currentPosition);
      nextPosition = this._myDetectionRuntimeParams.myParable.getPosition(i + 1, nextPosition);
      let visuaLine = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualLines[i] : this._myInvalidVisualLines[i];
      let currentVisualLineParams = visuaLine.getParams();
      if (i == lastParableIndex) {
        let stepLength = Math.max(0, showParableDistance - lastParableIndexDistance);
        nextPosition = nextPosition.vec3_sub(currentPosition, nextPosition).vec3_normalize(nextPosition);
        nextPosition = currentPosition.vec3_add(nextPosition.vec3_scale(stepLength, nextPosition), nextPosition);
      }
      currentVisualLineParams.setStartEnd(currentPosition, nextPosition);
      currentVisualLineParams.myThickness = 5e-3;
      visuaLine.paramsUpdated();
      visuaLine.setVisible(true);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugShowEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, currentPosition, vec4_create(1, 0, 0, 1), 0.01);
      }
    }
    let visualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualPoint : this._myInvalidVisualPoint;
    let visualPointParams = visualPoint.getParams();
    visualPointParams.myPosition.vec3_copy(nextPosition);
    visualPointParams.myRadius = 0.01;
    visualPoint.paramsUpdated();
    visualPoint.setVisible(true);
    if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      upDifference = nextPosition.vec3_sub(this._myTeleportRuntimeParams.myTeleportPosition, upDifference).vec3_componentAlongAxis(playerUp, upDifference);
      let upDistance = upDifference.vec3_length();
      if (upDistance >= this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine) {
        let lineLength = Math.min(upDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine, this._myTeleportParams.myVisualizerParams.myTeleportParableShowVerticalLineMaxLength);
        let visualArrowParams = this._myValidVisualVerticalArrow.getParams();
        visualArrowParams.myStart.vec3_copy(nextPosition);
        visualArrowParams.myDirection = playerUp.vec3_negate(visualArrowParams.myDirection);
        visualArrowParams.myLength = lineLength;
        visualArrowParams.myThickness = 5e-3;
        visualArrowParams.myArrowThickness = visualPointParams.myRadius;
        visualArrowParams.myArrowLength = visualArrowParams.myArrowThickness * 3.5 / 1.5;
        this._myValidVisualVerticalArrow.paramsUpdated();
        this._myValidVisualVerticalArrow.setVisible(true);
      }
      this._showTeleportParablePosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
    }
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParablePosition = function() {
  let playerUp = vec3_create();
  let feetTransformQuat = quat2_create();
  let feetRotationQuat = quat_create();
  let parableFirstPosition = vec3_create();
  let parableSecondPosition = vec3_create();
  let parableDirection = vec3_create();
  let visualPosition = vec3_create();
  let visualForward = vec3_create();
  let visualRotationQuat = quat_create();
  let currentVisualTeleportTransformQuat = quat2_create();
  let currentVisualTeleportPosition = vec3_create();
  let currentVisualTeleportRotationQuat = quat_create();
  let differenceRotationQuat = quat_create();
  return function _showTeleportParablePosition(dt) {
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
    feetRotationQuat = feetRotationQuat.quat_rotateAxis(this._myTeleportRuntimeParams.myTeleportRotationOnUp, playerUp, feetRotationQuat);
    visualPosition = this._myTeleportRuntimeParams.myTeleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myVisualizerParams.myTeleportParablePositionUpOffset, visualPosition), visualPosition);
    visualForward = feetRotationQuat.quat_getForward(visualForward);
    if (!this._myTeleportParams.myVisualizerParams.myTeleportPositionObjectRotateWithHead) {
      parableFirstPosition = this._myDetectionRuntimeParams.myParable.getPosition(0, parableFirstPosition);
      parableSecondPosition = this._myDetectionRuntimeParams.myParable.getPosition(1, parableSecondPosition);
      parableDirection = parableSecondPosition.vec3_sub(parableFirstPosition, parableDirection).vec3_removeComponentAlongAxis(playerUp, parableDirection);
      if (parableDirection.vec3_length() > Math.PP_EPSILON) {
        visualForward = parableDirection.vec3_normalize(visualForward);
      }
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportParablePositionVisualAlignOnSurface) {
      visualRotationQuat.quat_setUp(this._myDetectionRuntimeParams.myTeleportSurfaceNormal, visualForward);
    } else {
      visualRotationQuat.quat_setUp(playerUp, visualForward);
    }
    this._myVisualTeleportTransformQuat.quat2_setPositionRotationQuat(visualPosition, visualRotationQuat);
    if (this._myVisualTeleportTransformQuatReset || !this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpEnabled) {
      this._myVisualTeleportPositionObject.pp_setTransformQuat(this._myVisualTeleportTransformQuat);
      this._myVisualTeleportTransformQuatReset = false;
    } else {
      currentVisualTeleportTransformQuat = this._myVisualTeleportPositionObject.pp_getTransformQuat(currentVisualTeleportTransformQuat);
      currentVisualTeleportPosition = currentVisualTeleportTransformQuat.quat2_getPosition(currentVisualTeleportPosition);
      currentVisualTeleportRotationQuat = currentVisualTeleportTransformQuat.quat2_getRotationQuat(currentVisualTeleportRotationQuat);
      currentVisualTeleportRotationQuat.quat_rotationToQuat(visualRotationQuat, differenceRotationQuat);
      let positionDistance = currentVisualTeleportPosition.vec3_distance(visualPosition);
      let rotationAngleDistance = differenceRotationQuat.quat_getAngle();
      if ((!this._myVisualTeleportTransformPositionLerping || positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToResetLerp) && (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp)) {
        this._myVisualTeleportTransformPositionLerping = false;
        currentVisualTeleportPosition.vec3_copy(visualPosition);
      } else {
        this._myVisualTeleportTransformPositionLerping = true;
        let interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        if (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToCloseLerpFactor) {
          interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionCloseLerpFactor * dt;
        }
        currentVisualTeleportPosition.vec3_lerp(visualPosition, interpolationFactor, currentVisualTeleportPosition);
      }
      if ((!this._myVisualTeleportTransformRotationLerping || rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToResetLerp) && (rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp)) {
        this._myVisualTeleportTransformRotationLerping = false;
        currentVisualTeleportRotationQuat.quat_copy(visualRotationQuat);
      } else {
        let interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        this._myVisualTeleportTransformRotationLerping = true;
        currentVisualTeleportRotationQuat.quat_slerp(visualRotationQuat, interpolationFactor, currentVisualTeleportRotationQuat);
      }
      currentVisualTeleportTransformQuat.quat2_setPositionRotationQuat(currentVisualTeleportPosition, currentVisualTeleportRotationQuat);
      this._myVisualTeleportPositionObject.pp_setTransformQuat(currentVisualTeleportTransformQuat);
    }
    {
      let visualParams = this._myValidVisualTeleportPositionTorus.getParams();
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      this._myValidVisualTeleportPositionTorus.paramsUpdated();
    }
    {
      let visualParams = this._myValidVisualTeleportPositionTorusInner.getParams();
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      this._myValidVisualTeleportPositionTorusInner.paramsUpdated();
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject == null) {
      this._myValidVisualTeleportPositionTorus.setVisible(true);
      this._myValidVisualTeleportPositionTorusInner.setVisible(true);
    } else {
      this._myValidVisualTeleportPositionTorus.setVisible(false);
      this._myValidVisualTeleportPositionTorusInner.setVisible(false);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(true);
    }
    if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugShowEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
      Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, this._myTeleportRuntimeParams.myTeleportPosition, vec4_create(0, 0, 1, 1), 0.02);
    }
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_parable.js
var PlayerLocomotionTeleportParable = class {
  constructor() {
    this._myStartPosition = vec3_create();
    this._myForward = vec3_create();
    this._myUp = vec3_create();
    this._mySpeed = 0;
    this._myGravity = 0;
    this._myStepLength = 0;
  }
  setStartPosition(startPosition) {
    this._myStartPosition.vec3_copy(startPosition);
  }
  setForward(forward) {
    this._myForward.vec3_copy(forward);
  }
  setUp(up) {
    this._myUp.vec3_copy(up);
  }
  setSpeed(speed) {
    this._mySpeed = speed;
  }
  setGravity(gravity) {
    this._myGravity = gravity;
  }
  setStepLength(stepLength) {
    this._myStepLength = stepLength;
  }
  getPosition(positionIndex, outPosition = vec3_create()) {
  }
  getDistance(positionIndex) {
  }
  getPositionIndexByDistance(distance2) {
  }
  getPositionByDistance(distance2, outPosition = vec3_create()) {
  }
  getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
  }
  getFlatDistanceOverDistance(distance2) {
  }
};
PlayerLocomotionTeleportParable.prototype.getPosition = function() {
  let forwardPosition = vec3_create();
  let upPosition = vec3_create();
  return function getPosition4(positionIndex, outPosition = vec3_create()) {
    let deltaTimePerStep = this._myStepLength / this._mySpeed;
    let elapsedTime = deltaTimePerStep * positionIndex;
    forwardPosition = this._myForward.vec3_scale(this._mySpeed * elapsedTime, forwardPosition);
    forwardPosition = forwardPosition.vec3_add(this._myStartPosition, forwardPosition);
    upPosition = this._myUp.vec3_scale(this._myGravity * elapsedTime * elapsedTime / 2, upPosition);
    outPosition = forwardPosition.vec3_add(upPosition, outPosition);
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  return function getDistance(positionIndex) {
    let distance2 = 0;
    prevPosition.vec3_copy(this._myStartPosition);
    for (let i = 1; i <= positionIndex; i++) {
      currentPosition = this.getPosition(i, currentPosition);
      distance2 += currentPosition.vec3_distance(prevPosition);
      prevPosition.vec3_copy(currentPosition);
    }
    return distance2;
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionIndexByDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  return function getPositionIndexByDistance(distance2) {
    let currentDistance = 0;
    let currentIndex = 0;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (currentDistance < distance2) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.max(0, currentIndex - 1);
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionByDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  let prevToCurrent = vec3_create();
  return function getPositionByDistance(distance2, outPosition = vec3_create()) {
    let currentDistance = 0;
    let currentIndex = 0;
    let found = false;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (!found) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      if (currentDistance > distance2) {
        let lengthToRemove = currentDistance - distance2;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let lengthToAdd = prevToCurrent.vec3_length() - lengthToRemove;
        prevToCurrent.vec3_normalize(prevToCurrent);
        outPosition = prevPosition.vec3_add(prevToCurrent.vec3_scale(lengthToAdd, outPosition), outPosition);
        found = true;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistanceOverFlatDistance = function() {
  let currentPosition = vec3_create();
  let flatCurrentPosition = vec3_create();
  let flatStartPosition = vec3_create();
  let prevPosition = vec3_create();
  let prevToCurrent = vec3_create();
  let startToCurrentFlat = vec3_create();
  return function getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
    if (flatDistance < 1e-5) {
      return 0;
    }
    let currentDistance = 0;
    let currentIndex = 0;
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    prevPosition = this.getPosition(currentIndex, prevPosition);
    let distanceOverFlatDistance = 0;
    while (currentDistance <= maxParableDistance) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      flatCurrentPosition = currentPosition.vec3_removeComponentAlongAxis(this._myUp, flatCurrentPosition);
      startToCurrentFlat = flatCurrentPosition.vec3_sub(flatStartPosition, startToCurrentFlat);
      let currentFlatDistance = startToCurrentFlat.vec3_length();
      if (currentFlatDistance >= flatDistance) {
        let flatDifference = currentFlatDistance - flatDistance;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let angleWithFlat = prevToCurrent.vec3_angleRadians(startToCurrentFlat);
        let cos = Math.cos(angleWithFlat);
        let lengthToRemove = prevToCurrent.vec3_length();
        if (cos != 0) {
          lengthToRemove = flatDifference / Math.cos(angleWithFlat);
        }
        distanceOverFlatDistance = currentDistance - lengthToRemove;
        break;
      } else {
        distanceOverFlatDistance = currentDistance;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.min(maxParableDistance, distanceOverFlatDistance);
  };
}();
PlayerLocomotionTeleportParable.prototype.getFlatDistanceOverDistance = function() {
  let positionByDistance = vec3_create();
  let flatPositionByDistance = vec3_create();
  let flatStartPosition = vec3_create();
  return function getFlatDistanceOverDistance(distance2) {
    positionByDistance = this.getPositionByDistance(distance2, positionByDistance);
    flatPositionByDistance = positionByDistance.vec3_removeComponentAlongAxis(this._myUp, flatPositionByDistance);
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    return flatStartPosition.vec3_distance(flatPositionByDistance);
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_state.js
var PlayerLocomotionTeleportState = class extends State {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super();
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myTeleportAsMovementFailed = false;
  }
  _checkTeleport(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
  }
  _checkTeleportAsMovement(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
  }
  _teleportToPosition(teleportPosition, rotationOnUp, collisionRuntimeParams, forceTeleport = false) {
  }
};
PlayerLocomotionTeleportState.prototype._checkTeleport = function() {
  return function _checkTeleport(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
    CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).teleport(teleportPosition, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
    if (checkTeleportCollisionRuntimeParams != null) {
      checkTeleportCollisionRuntimeParams.copy(collisionRuntimeParams);
    }
  };
}();
PlayerLocomotionTeleportState.prototype._checkTeleportAsMovement = function() {
  let checkTeleportMovementCollisionRuntimeParams = new CollisionRuntimeParams();
  let feetRotationQuat = quat_create();
  let feetPosition = vec3_create();
  let feetUp = vec3_create();
  let teleportFeetForward = vec3_create();
  let teleportFeetRotationQuat = quat_create();
  let teleportFeetTransformQuat = quat2_create();
  let currentFeetPosition = vec3_create();
  let fixedTeleportPosition = vec3_create();
  let teleportMovement = vec3_create();
  let extraVerticalMovement = vec3_create();
  let movementToTeleportPosition = vec3_create();
  let movementFeetTransformQuat = quat2_create();
  return function _checkTeleportAsMovement(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
    feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
    feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
    feetUp = feetRotationQuat.quat_getUp(feetUp);
    teleportFeetForward = teleportPosition.vec3_sub(feetPosition, teleportFeetForward).vec3_removeComponentAlongAxis(feetUp, teleportFeetForward);
    teleportFeetForward.vec3_normalize(teleportFeetForward);
    if (teleportFeetForward.vec3_isZero(1e-5)) {
      teleportFeetForward = feetRotationQuat.quat_getForward(teleportFeetForward);
    }
    teleportFeetRotationQuat.quat_setUp(feetUp, teleportFeetForward);
    teleportFeetTransformQuat.quat2_setPositionRotationQuat(feetPosition, teleportFeetRotationQuat);
    this._checkTeleport(teleportPosition, teleportFeetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      let teleportMovementValid = false;
      checkTeleportMovementCollisionRuntimeParams.copy(collisionRuntimeParams);
      fixedTeleportPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
      currentFeetPosition.vec3_copy(feetPosition);
      for (let i = 0; i < this._myTeleportParams.myTeleportAsMovementMaxSteps; i++) {
        teleportMovement = fixedTeleportPosition.vec3_sub(currentFeetPosition, teleportMovement);
        if (this._myTeleportParams.myTeleportAsMovementRemoveVerticalMovement) {
          teleportMovement = teleportMovement.vec3_removeComponentAlongAxis(feetUp, teleportMovement);
        }
        if (this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter != 0) {
          let meters = teleportMovement.vec3_length();
          let extraVerticalMovementValue = meters * this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter;
          extraVerticalMovement = feetUp.vec3_scale(extraVerticalMovementValue, extraVerticalMovement);
          teleportMovement = teleportMovement.vec3_add(extraVerticalMovement, teleportMovement);
        }
        movementFeetTransformQuat.quat2_setPositionRotationQuat(currentFeetPosition, feetRotationQuat);
        CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).move(teleportMovement, movementFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, checkTeleportMovementCollisionRuntimeParams);
        if (!checkTeleportMovementCollisionRuntimeParams.myHorizontalMovementCanceled && !checkTeleportMovementCollisionRuntimeParams.myVerticalMovementCanceled) {
          movementToTeleportPosition = fixedTeleportPosition.vec3_sub(checkTeleportMovementCollisionRuntimeParams.myNewPosition, movementToTeleportPosition);
          if (movementToTeleportPosition.vec3_length() < this._myTeleportParams.myTeleportAsMovementMaxDistanceFromTeleportPosition + 1e-5) {
            teleportMovementValid = true;
            break;
          } else {
            teleportMovement.vec3_copy(movementToTeleportPosition);
            currentFeetPosition.vec3_copy(checkTeleportMovementCollisionRuntimeParams.myNewPosition);
          }
        } else {
          break;
        }
      }
      if (!teleportMovementValid) {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
      this._myTeleportAsMovementFailed = !teleportMovementValid;
    }
  };
}();
PlayerLocomotionTeleportState.prototype._teleportToPosition = function() {
  let playerUp = vec3_create();
  let feetTransformQuat = quat2_create();
  let newFeetTransformQuat = quat2_create();
  let newFeetRotationQuat = quat_create();
  let teleportRotation = quat_create();
  return function _teleportToPosition(teleportPosition, rotationOnUp, collisionRuntimeParams, forceTeleport = false) {
    this._myTeleportAsMovementFailed = false;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    newFeetRotationQuat = feetTransformQuat.quat2_getRotationQuat(newFeetRotationQuat);
    if (rotationOnUp != 0) {
      newFeetRotationQuat = newFeetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, newFeetRotationQuat);
    }
    newFeetTransformQuat.quat2_setPositionRotationQuat(teleportPosition, newFeetRotationQuat);
    if (Globals.getGamepads(this._myTeleportParams.myEngine)[InputUtils.getOppositeHandedness(this._myTeleportParams.myHandedness)].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
      CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).positionCheck(true, newFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
      this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(teleportPosition);
      if (rotationOnUp != 0) {
        teleportRotation.quat_fromAxis(rotationOnUp, playerUp);
        this._myTeleportParams.myPlayerHeadManager.rotateFeetQuat(teleportRotation);
      }
    } else {
      this._myTeleportParams.myPlayerTransformManager.teleportTransformQuat(newFeetTransformQuat, collisionRuntimeParams, forceTeleport);
    }
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state.js
var PlayerLocomotionTeleportDetectionParams = class {
  constructor() {
    this.myMaxDistance = 0;
    this.myMaxHeightDifference = 0;
    this.myGroundAngleToIgnoreUpward = 0;
    this.myMustBeOnGround = false;
    this.myTeleportBlockLayerFlags = new PhysicsLayerFlags();
    this.myTeleportFloorLayerFlags = new PhysicsLayerFlags();
    this.myParableForwardMinAngleToBeValidUp = 30;
    this.myParableForwardMinAngleToBeValidDown = 0;
    this.myTeleportParableStartReferenceObject = null;
    this.myTeleportParableStartPositionOffset = vec3_create(0, -0.04, 0.08);
    this.myTeleportParableStartRotationOffset = vec3_create(30, 0, 0);
    this.myTeleportParableSpeed = 15;
    this.myTeleportParableGravity = -30;
    this.myTeleportParableStepLength = 0.25;
    this.myRotationOnUpMinStickIntensity = 0.5;
    this.myRotationOnUpEnabled = false;
    this.myTeleportFeetPositionMustBeVisible = false;
    this.myTeleportHeadPositionMustBeVisible = false;
    this.myTeleportHeadOrFeetPositionMustBeVisible = false;
    this.myVisibilityCheckRadius = 0.05;
    this.myVisibilityCheckFeetPositionVerticalOffset = 0.1;
    this.myVisibilityCheckDistanceFromHitThreshold = 0.1;
    this.myVisibilityCheckCircumferenceSliceAmount = 6;
    this.myVisibilityCheckCircumferenceStepAmount = 1;
    this.myVisibilityCheckCircumferenceRotationPerStep = 30;
    this.myVisibilityBlockLayerFlags = new PhysicsLayerFlags();
  }
};
var PlayerLocomotionTeleportDetectionRuntimeParams = class {
  constructor() {
    this.myTeleportDetectionValid = false;
    this.myTeleportPositionValid = false;
    this.myTeleportSurfaceNormal = vec3_create();
    this.myParable = new PlayerLocomotionTeleportParable();
  }
};
var PlayerLocomotionTeleportDetectionState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myDetectionRuntimeParams = new PlayerLocomotionTeleportDetectionRuntimeParams();
    this._myVisualizer = new PlayerLocomotionTeleportDetectionVisualizer(this._myTeleportParams, this._myTeleportRuntimeParams, this._myDetectionRuntimeParams);
    this._myTeleportRotationOnUpNext = 0;
    this._myDestroyed = false;
  }
  start() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = true;
    this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
    this._myTeleportRotationOnUpNext = 0;
    this._myDetectionRuntimeParams.myParable.setSpeed(this._myTeleportParams.myDetectionParams.myTeleportParableSpeed);
    this._myDetectionRuntimeParams.myParable.setGravity(this._myTeleportParams.myDetectionParams.myTeleportParableGravity);
    this._myDetectionRuntimeParams.myParable.setStepLength(this._myTeleportParams.myDetectionParams.myTeleportParableStepLength);
    this._myTeleportParams.myPlayerTransformManager.resetReal();
    this._myVisualizer.start();
  }
  end() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = false;
    this._myVisualizer.end();
  }
  update(dt, fsm) {
    this._detectTeleportPosition();
    this._myVisualizer.update(dt);
    if (this._confirmTeleport()) {
      if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
        fsm.perform("teleport");
      } else {
        fsm.perform("cancel");
      }
    } else if (this._cancelTeleport()) {
      fsm.perform("cancel");
    }
  }
  _confirmTeleport() {
    let confirmTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      if (Globals.getMouse(this._myTeleportParams.myEngine).isInsideView()) {
        confirmTeleport = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.MIDDLE);
      }
    } else {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        confirmTeleport = true;
      }
    }
    return confirmTeleport;
  }
  _cancelTeleport() {
    let cancelTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      cancelTeleport = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.RIGHT) || !Globals.getMouse(this._myTeleportParams.myEngine).isInsideView();
    } else {
      cancelTeleport = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed();
    }
    return cancelTeleport;
  }
  _detectTeleportPosition() {
    if (XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      this._detectTeleportRotationVR();
      this._detectTeleportPositionVR();
    } else {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
      this._myTeleportRotationOnUpNext = 0;
      this._detectTeleportPositionNonVR();
    }
  }
  _isTeleportPositionValid(teleportPosition, rotationOnUp, checkTeleportCollisionRuntimeParams) {
  }
  _isTeleportHitValid(hit, rotationOnUp, checkTeleportCollisionRuntimeParams) {
  }
  _detectTeleportRotationVR(dt) {
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualizer.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionNonVR = function() {
  let mousePosition = vec3_create();
  let mouseDirection = vec3_create();
  let playerUp = vec3_create();
  return function _detectTeleportPositionNonVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    Globals.getMouse(this._myTeleportParams.myEngine).getOriginWorld(mousePosition);
    Globals.getMouse(this._myTeleportParams.myEngine).getDirectionWorld(mouseDirection);
    this._detectTeleportPositionParable(mousePosition, mouseDirection, playerUp);
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionVR = function() {
  let teleportStartTransformLocal = quat2_create();
  let teleportStartTransformWorld = quat2_create();
  let teleportStartPosition = vec3_create();
  let teleportDirection = vec3_create();
  let playerUp = vec3_create();
  let playerUpNegate = vec3_create();
  return function _detectTeleportPositionVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = false;
    if (this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject == null) {
      let referenceObject = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myHands[this._myTeleportParams.myHandedness];
      teleportStartTransformLocal.quat2_setPositionRotationDegrees(this._myTeleportParams.myDetectionParams.myTeleportParableStartPositionOffset, this._myTeleportParams.myDetectionParams.myTeleportParableStartRotationOffset);
      teleportStartTransformWorld = referenceObject.pp_convertTransformObjectToWorldQuat(teleportStartTransformLocal, teleportStartTransformWorld);
    } else {
      let referenceObject = this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject;
      referenceObject.pp_getTransformQuat(teleportStartTransformWorld);
    }
    teleportStartPosition = teleportStartTransformWorld.quat2_getPosition(teleportStartPosition);
    teleportDirection = teleportStartTransformWorld.quat2_getForward(teleportDirection);
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    playerUpNegate = playerUp.vec3_negate(playerUpNegate);
    if (teleportDirection.vec3_angle(playerUp) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidUp && teleportDirection.vec3_angle(playerUpNegate) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidDown) {
      this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    }
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._detectTeleportPositionParable(teleportStartPosition, teleportDirection, playerUp);
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionParable = function() {
  let parablePosition = vec3_create();
  let prevParablePosition = vec3_create();
  let parableFinalPosition = vec3_create();
  let raycastParams = new RaycastParams();
  let raycastResult = new RaycastResults();
  let parableHitPosition = vec3_create();
  let parableHitNormal = vec3_create();
  let verticalHitOrigin = vec3_create();
  let verticalHitDirection = vec3_create();
  let flatTeleportHorizontalHitNormal = vec3_create();
  let flatParableHitNormal = vec3_create();
  let flatParableDirectionNegate = vec3_create();
  let teleportCollisionRuntimeParams = new CollisionRuntimeParams();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function _detectTeleportPositionParable(startPosition, direction, up) {
    this._myDetectionRuntimeParams.myParable.setStartPosition(startPosition);
    this._myDetectionRuntimeParams.myParable.setForward(direction);
    this._myDetectionRuntimeParams.myParable.setUp(up);
    let currentPositionIndex = 1;
    let positionFlatDistance = 0;
    let positionParableDistance = 0;
    prevParablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex - 1, prevParablePosition);
    raycastParams.myIgnoreHitsInsideCollision = true;
    raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportBlockLayerFlags.getMask());
    raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
    raycastParams.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
    for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
      raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
    }
    let maxParableDistance = this._myTeleportParams.myDetectionParams.myMaxDistance * 2;
    do {
      parablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex, parablePosition);
      raycastParams.myOrigin.vec3_copy(prevParablePosition);
      raycastParams.myDirection = parablePosition.vec3_sub(prevParablePosition, raycastParams.myDirection);
      raycastParams.myDistance = raycastParams.myDirection.vec3_length();
      raycastParams.myDirection.vec3_normalize(raycastParams.myDirection);
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      prevParablePosition.vec3_copy(parablePosition);
      positionFlatDistance = parablePosition.vec3_sub(startPosition, parablePosition).vec3_removeComponentAlongAxis(up, parablePosition).vec3_length();
      positionParableDistance = this._myDetectionRuntimeParams.myParable.getDistance(currentPositionIndex);
      currentPositionIndex++;
    } while (positionFlatDistance <= this._myTeleportParams.myDetectionParams.myMaxDistance && positionParableDistance <= maxParableDistance && !raycastResult.isColliding());
    let maxParableDistanceOverFlatDistance = this._myDetectionRuntimeParams.myParable.getDistanceOverFlatDistance(this._myTeleportParams.myDetectionParams.myMaxDistance, maxParableDistance);
    let fixedPositionParableDistance = positionParableDistance;
    if (positionParableDistance > maxParableDistanceOverFlatDistance || positionParableDistance > maxParableDistance) {
      fixedPositionParableDistance = Math.min(maxParableDistanceOverFlatDistance, maxParableDistance);
    }
    this._myDetectionRuntimeParams.myParableDistance = fixedPositionParableDistance;
    let hitCollisionValid = false;
    let bottomCheckMaxLength = 100;
    if (raycastResult.isColliding()) {
      let hit = raycastResult.myHits.pp_first();
      let hitParableDistance = positionParableDistance - (raycastParams.myDistance - hit.myDistance);
      if (hitParableDistance <= fixedPositionParableDistance) {
        hitCollisionValid = true;
        this._myDetectionRuntimeParams.myParableDistance = hitParableDistance;
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        parableHitPosition.vec3_copy(hit.myPosition);
        parableHitNormal.vec3_copy(hit.myNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          verticalHitOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(0.01, verticalHitOrigin), verticalHitOrigin);
          verticalHitDirection = up.vec3_negate(verticalHitDirection);
          raycastParams.myOrigin.vec3_copy(verticalHitOrigin);
          raycastParams.myDirection.vec3_copy(verticalHitDirection);
          raycastParams.myDistance = bottomCheckMaxLength;
          raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
          if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
            Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
          }
          if (raycastResult.isColliding()) {
            let hit2 = raycastResult.myHits.pp_first();
            teleportCollisionRuntimeParams.reset();
            this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
            this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
            this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
              flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
              if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
                flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                raycastParams.myDirection.vec3_copy(verticalHitDirection);
                raycastParams.myDistance = bottomCheckMaxLength;
                raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit3 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
              flatParableHitNormal = parableHitNormal.vec3_removeComponentAlongAxis(up, flatParableHitNormal);
              if (!flatParableHitNormal.vec3_isZero(1e-5)) {
                flatParableHitNormal.vec3_normalize(flatParableHitNormal);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                raycastParams.myDirection.vec3_copy(verticalHitDirection);
                raycastParams.myDistance = bottomCheckMaxLength;
                raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit3 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
              flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
              if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
                flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                raycastParams.myDirection.vec3_copy(verticalHitDirection);
                raycastParams.myDistance = bottomCheckMaxLength;
                raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit3 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
          }
        } else {
        }
      }
    }
    if (!hitCollisionValid) {
      parableFinalPosition = this._myDetectionRuntimeParams.myParable.getPositionByDistance(this._myDetectionRuntimeParams.myParableDistance, parableFinalPosition);
      verticalHitOrigin.vec3_copy(parableFinalPosition);
      verticalHitDirection = up.vec3_negate(verticalHitDirection);
      raycastParams.myOrigin.vec3_copy(verticalHitOrigin);
      raycastParams.myDirection.vec3_copy(verticalHitDirection);
      raycastParams.myDistance = bottomCheckMaxLength;
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      if (raycastResult.isColliding()) {
        let hit = raycastResult.myHits.pp_first();
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
          flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
          if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
            flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
            let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
            raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
            raycastParams.myDirection.vec3_copy(verticalHitDirection);
            raycastParams.myDistance = bottomCheckMaxLength;
            raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
            if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
            }
            if (raycastResult.isColliding()) {
              let hit2 = raycastResult.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            }
          }
        }
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
          if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
            flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
            let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
            raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
            raycastParams.myDirection.vec3_copy(verticalHitDirection);
            raycastParams.myDistance = bottomCheckMaxLength;
            raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
            if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
            }
            if (raycastResult.isColliding()) {
              let hit2 = raycastResult.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            }
          }
        }
      }
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportRotationVR = function() {
  let axesVec3 = vec3_create();
  let axesForward = vec3_create(0, 0, 1);
  let axesUp = vec3_create(0, 1, 0);
  return function _detectTeleportRotationVR(dt) {
    let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (axes.vec2_length() > this._myTeleportParams.myDetectionParams.myRotationOnUpMinStickIntensity) {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = this._myTeleportRotationOnUpNext;
      axesVec3.vec3_set(axes[0], 0, axes[1]);
      this._myTeleportRotationOnUpNext = axesVec3.vec3_angleSigned(axesForward, axesUp);
    }
    if (!this._myTeleportParams.myDetectionParams.myRotationOnUpEnabled) {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
      this._myTeleportRotationOnUpNext = 0;
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportHitValid = function() {
  let raycastParams = new RaycastParams();
  let raycastResult = new RaycastResults();
  let playerUp = vec3_create();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function _isTeleportHitValid(hit, rotationOnUp, checkTeleportCollisionRuntimeParams) {
    let isValid = false;
    this._myTeleportAsMovementFailed = false;
    if (hit.isValid() && !hit.myInsideCollision) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      let hitValidEvenWhenNotConcordant = true;
      if (hit.myNormal.vec3_isConcordant(playerUp) || hitValidEvenWhenNotConcordant) {
        raycastParams.myIgnoreHitsInsideCollision = true;
        raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportFloorLayerFlags.getMask());
        raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
        raycastParams.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
        for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
          raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
        }
        let distanceToCheck = 0.01;
        raycastParams.myOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(distanceToCheck, raycastParams.myOrigin), raycastParams.myOrigin);
        raycastParams.myDirection = hit.myNormal.vec3_negate(raycastParams.myDirection);
        raycastParams.myDistance = distanceToCheck * 1.25;
        raycastParams.myDirection.vec3_normalize(raycastParams.myDirection);
        raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
        if (raycastResult.isColliding()) {
          let floorHit = raycastResult.myHits.pp_first();
          if (floorHit.myObject.pp_equals(hit.myObject)) {
            isValid = this._isTeleportPositionValid(hit.myPosition, rotationOnUp, checkTeleportCollisionRuntimeParams);
          }
        }
      }
    }
    return isValid;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionValid = function() {
  let playerUp = vec3_create();
  let feetTransformQuat = quat2_create();
  let feetRotationQuat = quat_create();
  let feetPosition = vec3_create();
  let differenceOnUpVector = vec3_create();
  let teleportCheckCollisionRuntimeParams = new CollisionRuntimeParams();
  return function _isTeleportPositionValid(teleportPosition, rotationOnUp, checkTeleportCollisionRuntimeParams) {
    let isValid = false;
    let positionVisible = this._isTeleportPositionVisible(teleportPosition);
    if (positionVisible) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
      feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
      if (rotationOnUp != 0) {
        feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
        feetRotationQuat = feetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, feetRotationQuat);
        feetTransformQuat.quat2_setPositionRotationQuat(feetPosition, feetRotationQuat);
      }
      let differenceOnUp = teleportPosition.vec3_sub(feetPosition, differenceOnUpVector).vec3_componentAlongAxis(playerUp, differenceOnUpVector).vec3_length();
      if (differenceOnUp < this._myTeleportParams.myDetectionParams.myMaxHeightDifference + 1e-5) {
        let teleportCheckValid = false;
        teleportCheckCollisionRuntimeParams.copy(this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        if (!this._myTeleportParams.myPerformTeleportAsMovement) {
          this._checkTeleport(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        } else {
          this._checkTeleportAsMovement(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        }
        if (!teleportCheckCollisionRuntimeParams.myTeleportCanceled) {
          teleportCheckValid = true;
        }
        if (teleportCheckValid && (!this._myTeleportParams.myDetectionParams.myMustBeOnGround || teleportCheckCollisionRuntimeParams.myIsOnGround)) {
          let groundAngleValid = true;
          let isTeleportingUpward = teleportCheckCollisionRuntimeParams.myNewPosition.vec3_isFartherAlongAxis(feetPosition, playerUp);
          if (isTeleportingUpward) {
            groundAngleValid = teleportCheckCollisionRuntimeParams.myGroundAngle < this._myTeleportParams.myDetectionParams.myGroundAngleToIgnoreUpward + 1e-4;
          }
          if (groundAngleValid) {
            isValid = true;
          }
        }
      }
    }
    return isValid;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionVisible = function() {
  let playerUp = vec3_create();
  let offsetFeetTeleportPosition = vec3_create();
  let headTeleportPosition = vec3_create();
  return function _isTeleportPositionVisible(teleportPosition) {
    let isVisible = true;
    if (this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      let isHeadVisible = false;
      let isFeetVisible = false;
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible) {
        let headheight = this._myTeleportParams.myPlayerHeadManager.getHeightHead();
        headTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(headheight, headTeleportPosition), headTeleportPosition);
        isHeadVisible = this._isPositionVisible(headTeleportPosition);
      } else {
        isHeadVisible = true;
      }
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible && isHeadVisible) {
        isFeetVisible = true;
      } else {
        if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible && isHeadVisible) {
          offsetFeetTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myDetectionParams.myVisibilityCheckFeetPositionVerticalOffset, offsetFeetTeleportPosition), offsetFeetTeleportPosition);
          isFeetVisible = this._isPositionVisible(offsetFeetTeleportPosition);
        } else {
          isFeetVisible = true;
        }
      }
      isVisible = isHeadVisible && isFeetVisible;
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isPositionVisible = function() {
  let playerUp = vec3_create();
  let standardUp = vec3_create(0, 1, 0);
  let standardUpNegated = vec3_create(0, -1, 0);
  let standardForward = vec3_create(0, 0, 1);
  let referenceUp = vec3_create();
  let headPosition = vec3_create();
  let direction = vec3_create();
  let fixedRight = vec3_create();
  let fixedForward = vec3_create();
  let fixedUp = vec3_create();
  let raycastEndPosition = vec3_create();
  let raycastParams = new RaycastParams();
  let raycastResult = new RaycastResults();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function _isPositionVisible(position) {
    let isVisible = true;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    let currentHead = this._myTeleportParams.myPlayerHeadManager.getHead();
    headPosition = currentHead.pp_getPosition(headPosition);
    direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
    referenceUp.vec3_copy(standardUp);
    if (direction.vec3_angle(standardUp) < 1e-4 || direction.vec3_angle(standardUpNegated) < 1e-4) {
      referenceUp.vec3_copy(standardForward);
    }
    fixedRight = direction.vec3_cross(referenceUp, fixedRight);
    fixedUp = fixedRight.vec3_cross(direction, fixedUp);
    fixedForward.vec3_copy(direction);
    fixedUp.vec3_normalize(fixedUp);
    fixedForward.vec3_normalize(fixedForward);
    let checkPositions = this._getVisibilityCheckPositions(headPosition, fixedUp, fixedForward);
    let distance2 = headPosition.vec3_distance(position);
    for (let checkPosition of checkPositions) {
      raycastParams.myOrigin.vec3_copy(checkPosition);
      raycastParams.myDirection.vec3_copy(fixedForward);
      raycastParams.myDistance = distance2;
      raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
      raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myVisibilityBlockLayerFlags.getMask());
      raycastParams.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
      for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
        raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      raycastParams.myIgnoreHitsInsideCollision = true;
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugVisibilityEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      if (raycastResult.isColliding()) {
        raycastEndPosition = checkPosition.vec3_add(fixedForward.vec3_scale(distance2, raycastEndPosition), raycastEndPosition);
        let hit = raycastResult.myHits.pp_first();
        if (this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold == 0 || hit.myPosition.vec3_distance(raycastEndPosition) > this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold + 1e-5) {
          isVisible = false;
          break;
        }
      }
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._getVisibilityCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create();
  return function _getVisibilityCheckPositions(position, up, forward) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(position);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = this._myTeleportParams.myDetectionParams.myVisibilityCheckRadius / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount;
    let sliceAngle = 360 / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = up.vec3_rotateAxis(currentStepRotation, forward, currentDirection);
      for (let j = 0; j < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, forward, tempCheckPosition);
        checkPositions.push(position.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_blink_state.js
import { MeshComponent as MeshComponent10 } from "@wonderlandengine/api";
var PlayerLocomotionTeleportTeleportBlinkState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myBlinkSphere = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron.pp_addObject();
    this._myBlinkSphereMeshComponent = this._myBlinkSphere.pp_addComponent(MeshComponent10);
    this._myBlinkSphereMeshComponent.mesh = Globals.getDefaultMeshes(this._myTeleportParams.myEngine).myInvertedSphere;
    this._myBlinkSphereMeshComponent.material = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatTransparentNoDepth.clone();
    this._myBlinkSphereMaterialColor = vec4_create(this._myTeleportParams.myTeleportParams.myBlinkSphereColor[0] / 255, this._myTeleportParams.myTeleportParams.myBlinkSphereColor[1] / 255, this._myTeleportParams.myTeleportParams.myBlinkSphereColor[2] / 255, 0);
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myBlinkSphere.pp_setScaleLocal(this._myTeleportParams.myTeleportParams.myBlinkSphereScale);
    this._myBlinkSphere.pp_setActive(false);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("fade_out", this._fadeOutUpdate.bind(this));
    this._myFSM.addState("wait", new TimerState(this._myTeleportParams.myTeleportParams.myBlinkWaitSeconds, "done"));
    this._myFSM.addState("fade_in", this._fadeInUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "fade_out", "teleport", this._startFadeOut.bind(this));
    this._myFSM.addTransition("fade_out", "wait", "done", this._teleport.bind(this));
    this._myFSM.addTransition("wait", "fade_in", "done", this._startFadeIn.bind(this));
    this._myFSM.addTransition("fade_in", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("fade_out", "idle", "stop", this._stop.bind(this, true));
    this._myFSM.addTransition("wait", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.addTransition("fade_in", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myFadeInTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeInSeconds);
    this._myFadeOutTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeOutSeconds);
    this._myFadeOutAlphaOverTime = new NumberOverFactor(0, 1, 0, 1);
    this._myFadeInAlphaOverTime = new NumberOverFactor(1, 0, 0, 1);
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myBlinkSphere.pp_setActive(false);
    this._myBlinkSphere.pp_setParent(Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron, false);
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myBlinkSphere.pp_setParent(this._myTeleportParams.myPlayerHeadManager.getHead(), false);
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myFSM.update(dt);
  }
  _startFadeOut() {
    this._myFadeOutTimer.start();
    this._myBlinkSphereMaterialColor[3] = 0;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_setActive(true);
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
  }
  _startFadeIn() {
    this._myFadeInTimer.start();
  }
  _fadeOutUpdate(dt, fsm) {
    this._myFadeOutTimer.update(dt);
    let alpha = this._myFadeOutAlphaOverTime.get(this._myFadeOutTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeOutTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _fadeInUpdate(dt, fsm) {
    this._myFadeInTimer.update(dt);
    let alpha = this._myFadeInAlphaOverTime.get(this._myFadeInTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeInTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _teleportDone() {
    this._myBlinkSphere.pp_setActive(false);
    this._myParentFSM.performDelayed("done");
  }
  _stop(teleport) {
    this._myBlinkSphere.pp_setActive(false);
    if (teleport) {
      this._teleport();
    }
  }
  _teleport() {
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_shift_state.js
var PlayerLocomotionTeleportTeleportShiftState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("shifting", this._shiftingUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "shifting", "teleport", this._startShifting.bind(this));
    this._myFSM.addTransition("shifting", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("shifting", "idle", "stop", this._stop.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myShiftMovementTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    this._myShiftRotateTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds, false);
    this._myFeetStartPosition = vec3_create();
    this._myCurrentRotationOnUp = 0;
    this._myStartRotationOnUp = 0;
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  _startShifting() {
    this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = true;
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
    this._myFeetStartPosition = this._myTeleportParams.myPlayerHeadManager.getPositionFeet(this._myFeetStartPosition);
    this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction) {
      let distance2 = this._myTeleportRuntimeParams.myTeleportPosition.vec3_distance(this._myFeetStartPosition);
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction(distance2);
      this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds * multiplier);
    }
    this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction) {
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction(Math.abs(this._myTeleportRuntimeParams.myTeleportRotationOnUp));
      this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds * multiplier);
    }
    this._myStartRotationOnUp = this._myTeleportRuntimeParams.myTeleportRotationOnUp;
    this._myCurrentRotationOnUp = 0;
  }
  _stop() {
    this._teleport();
  }
  _teleportDone() {
    this._teleport();
    this._myParentFSM.performDelayed("done");
  }
  _teleport() {
    this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = false;
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myStartRotationOnUp - this._myCurrentRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
  _shiftingUpdate(dt, fsm) {
  }
};
PlayerLocomotionTeleportTeleportShiftState.prototype._shiftingUpdate = function() {
  let movementToTeleportFeet = vec3_create();
  let newFeetPosition = vec3_create();
  return function _shiftingUpdate(dt, fsm) {
    this._myShiftMovementTimer.update(dt);
    this._myShiftRotateTimer.update(dt);
    if (this._myShiftRotateTimer.isDone() && this._myShiftMovementTimer.isDone()) {
      fsm.perform("done");
    } else {
      newFeetPosition.vec3_copy(this._myTeleportRuntimeParams.myTeleportPosition);
      if (this._myShiftMovementTimer.isStarted() || this._myShiftMovementTimer.isJustDone()) {
        let interpolationFactor = this._myTeleportParams.myTeleportParams.myShiftMovementEasingFunction(this._myShiftMovementTimer.getPercentage());
        if (interpolationFactor >= this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage && !this._myShiftRotateTimer.isStarted()) {
          this._myShiftRotateTimer.start();
          this._myShiftRotateTimer.update(dt);
        }
        movementToTeleportFeet = this._myTeleportRuntimeParams.myTeleportPosition.vec3_sub(this._myFeetStartPosition, movementToTeleportFeet);
        movementToTeleportFeet.vec3_scale(interpolationFactor, movementToTeleportFeet);
        newFeetPosition = this._myFeetStartPosition.vec3_add(movementToTeleportFeet, newFeetPosition);
      }
      let rotationOnUp = 0;
      if (this._myShiftRotateTimer.isRunning() || this._myShiftRotateTimer.isJustDone()) {
        let interpolationFactor = this._myTeleportParams.myTeleportParams.myShiftRotateEasingFunction(this._myShiftRotateTimer.getPercentage());
        let newCurrentRotationOnUp = this._myStartRotationOnUp * interpolationFactor;
        rotationOnUp = newCurrentRotationOnUp - this._myCurrentRotationOnUp;
        this._myCurrentRotationOnUp = newCurrentRotationOnUp;
      }
      this._teleportToPosition(newFeetPosition, rotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
    }
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_state.js
var PlayerLocomotionTeleportTeleportType = {
  INSTANT: 0,
  BLINK: 1,
  SHIFT: 2
};
var PlayerLocomotionTeleportTeleportParams = class {
  constructor() {
    this.myTeleportType = PlayerLocomotionTeleportTeleportType.SHIFT;
    this.myBlinkFadeOutSeconds = 0.1;
    this.myBlinkFadeInSeconds = 0.1;
    this.myBlinkWaitSeconds = 0.1;
    this.myBlinkSphereColor = vec3_create();
    this.myBlinkSphereScale = 0.1;
    this.myShiftMovementSeconds = 0.15;
    this.myShiftMovementSecondsMultiplierOverDistanceFunction = null;
    this.myShiftMovementEasingFunction = EasingFunction.easeInOut;
    this.myShiftRotateSeconds = 1;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = null;
    this.myShiftRotateEasingFunction = EasingFunction.easeOut;
    this.myShiftRotateStartAfterMovementPercentage = 0.7;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = function(angle2) {
      return EasingFunction.easeOut(angle2 / 180);
    };
  }
};
var PlayerLocomotionTeleportTeleportState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myBlinkState = new PlayerLocomotionTeleportTeleportBlinkState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myShiftState = new PlayerLocomotionTeleportTeleportShiftState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM.addState("instant_teleport", this._instantUpdate.bind(this));
    this._myFSM.addState("blink_teleport", this._myBlinkState);
    this._myFSM.addState("shift_teleport", this._myShiftState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "instant_teleport", "start_instant");
    this._myFSM.addTransition("idle", "blink_teleport", "start_blink");
    this._myFSM.addTransition("idle", "shift_teleport", "start_shift");
    this._myFSM.addTransition("instant_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("shift_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("instant_teleport", "idle", "stop", this._instantStop.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "stop");
    this._myFSM.addTransition("shift_teleport", "idle", "stop");
    this._myFSM.init("init");
    this._myFSM.perform("start");
  }
  start(fsm) {
    this._myParentFSM = fsm;
    switch (this._myTeleportParams.myTeleportParams.myTeleportType) {
      case PlayerLocomotionTeleportTeleportType.INSTANT:
        this._myFSM.perform("start_instant");
        break;
      case PlayerLocomotionTeleportTeleportType.BLINK:
        this._myFSM.perform("start_blink");
        break;
      case PlayerLocomotionTeleportTeleportType.SHIFT:
        this._myFSM.perform("start_shift");
        break;
      default:
        this._myFSM.perform("start_instant");
    }
  }
  end() {
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  completeTeleport() {
    this._myFSM.perform("stop");
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
  _instantUpdate(dt, fsm) {
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    fsm.perform("done");
  }
  _instantStop(fsm) {
    this._instantUpdate(0, fsm);
  }
  _teleportDone() {
    this._myTeleportParams.myPlayerTransformManager.resetReal();
    this._myParentFSM.performDelayed("done");
  }
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport.js
var PlayerLocomotionTeleportParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myCollisionCheckParams = null;
    this.myDetectionParams = new PlayerLocomotionTeleportDetectionParams();
    this.myVisualizerParams = new PlayerLocomotionTeleportDetectionVisualizerParams();
    this.myTeleportParams = new PlayerLocomotionTeleportTeleportParams();
    this.myHandedness = Handedness.LEFT;
    this.myPerformTeleportAsMovement = false;
    this.myTeleportAsMovementMaxDistanceFromTeleportPosition = 1e-3;
    this.myTeleportAsMovementMaxSteps = 2;
    this.myTeleportAsMovementRemoveVerticalMovement = true;
    this.myTeleportAsMovementExtraVerticalMovementPerMeter = 1;
    this.myStickIdleThreshold = 0.1;
    this.myAdjustPositionEveryFrame = false;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myEngine = engine;
    this.myDebugEnabled = false;
    this.myDebugDetectEnabled = false;
    this.myDebugShowEnabled = false;
    this.myDebugVisibilityEnabled = false;
  }
};
var PlayerLocomotionTeleportRuntimeParams = class {
  constructor() {
    this.myTeleportPosition = vec3_create();
    this.myTeleportRotationOnUp = 0;
  }
};
var PlayerLocomotionTeleport = class extends PlayerLocomotionMovement {
  constructor(teleportParams, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = new PlayerLocomotionTeleportRuntimeParams();
    this._myStickIdleCharge = true;
    this._myDetectionState = new PlayerLocomotionTeleportDetectionState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myTeleportState = new PlayerLocomotionTeleportTeleportState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("detect", this._myDetectionState);
    this._myFSM.addState("teleport", this._myTeleportState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "detect", "detect");
    this._myFSM.addTransition("detect", "teleport", "teleport");
    this._myFSM.addTransition("detect", "idle", "cancel");
    this._myFSM.addTransition("teleport", "idle", "done");
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("detect", "idle", "stop");
    this._myFSM.addTransition("teleport", "idle", "stop", this._completeTeleport.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myDestroyed = false;
  }
  start() {
  }
  stop() {
    this._myFSM.perform("stop");
  }
  canStop() {
    return this._myFSM.isInState("idle");
  }
  isTeleporting() {
    return this._myFSM.isInState("teleport");
  }
  getParams() {
    return this._myTeleportParams;
  }
  getTeleportRuntimeParams() {
    return this._myTeleportRuntimeParams;
  }
  update(dt) {
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = false;
    this._myFSM.update(dt);
    if (!this._myLocomotionRuntimeParams.myIsTeleporting && (this._myTeleportParams.myAdjustPositionEveryFrame || this._myTeleportParams.myGravityAcceleration != 0)) {
      this._applyGravity(dt);
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
    }
  }
  _idleUpdate(dt) {
    if (this._startDetecting()) {
      this._myFSM.perform("detect");
    }
  }
  _startDetecting() {
    let startDetecting = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      startDetecting = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressStart(MouseButtonID.MIDDLE) && Globals.getMouse(this._myTeleportParams.myEngine).isTargetingRenderCanvas();
    } else {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        this._myStickIdleCharge = true;
      }
      if (this._myStickIdleCharge && axes[1] >= 0.75) {
        this._myStickIdleCharge = false;
        startDetecting = true;
      }
    }
    return startDetecting;
  }
  _completeTeleport() {
    this._myTeleportState.completeTeleport();
  }
  destroy() {
    this._myDestroyed = true;
    this._myDetectionState.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleport.prototype._applyGravity = function() {
  let playerUp = vec3_create();
  let gravityMovement = vec3_create();
  let feetTransformQuat = quat2_create();
  return function _applyGravity(dt) {
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    gravityMovement.vec3_zero();
    if (!this._myLocomotionRuntimeParams.myIsFlying && !this._myLocomotionRuntimeParams.myIsTeleporting) {
      this._myLocomotionRuntimeParams.myGravitySpeed += this._myTeleportParams.myGravityAcceleration * dt;
      if (Math.abs(this._myLocomotionRuntimeParams.myGravitySpeed) > Math.abs(this._myTeleportParams.myMaxGravitySpeed)) {
        this._myLocomotionRuntimeParams.myGravitySpeed = Math.pp_sign(this._myTeleportParams.myGravityAcceleration) * Math.abs(this._myTeleportParams.myMaxGravitySpeed);
      }
      gravityMovement = playerUp.vec3_scale(this._myLocomotionRuntimeParams.myGravitySpeed * dt, gravityMovement);
    } else {
      this._myLocomotionRuntimeParams.myGravitySpeed = 0;
    }
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).move(gravityMovement, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
    if (!this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myVerticalMovementCanceled) {
      this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myNewPosition);
    }
    if (this._myLocomotionRuntimeParams.myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myLocomotionRuntimeParams.myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myGravitySpeed = 0;
    }
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
var PlayerLocomotionDirectionReferenceType = {
  HEAD: 0,
  HAND: 1,
  CUSTOM_OBJECT: 2
};
var PlayerLocomotionType = {
  SMOOTH: 0,
  TELEPORT: 1
};
var PlayerLocomotionParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myDefaultLocomotionType = PlayerLocomotionType.SMOOTH;
    this.myAlwaysSmoothForNonVR = true;
    this.mySwitchLocomotionTypeShortcutEnabled = true;
    this.myDefaultHeight = 0;
    this.myMaxSpeed = 0;
    this.myMaxRotationSpeed = 0;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myCharacterRadius = 0;
    this.mySpeedSlowDownPercentageOnWallSlid = 1;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySnapTurnAngle = 0;
    this.mySnapTurnSpeedDegrees = 0;
    this.myFlyEnabled = false;
    this.myStartFlying = false;
    this.myFlyWithButtonsEnabled = false;
    this.myFlyWithViewAngleEnabled = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myMainHand = Handedness.LEFT;
    this.myDirectionInvertForwardWhenUpsideDown = true;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myForeheadExtraHeight = 0;
    this.myTeleportType = PlayerLocomotionTeleportTeleportType.INSTANT;
    this.myTeleportMaxDistance = 0;
    this.myTeleportMaxHeightDifference = 0;
    this.myTeleportRotationOnUpEnabled = null;
    this.myTeleportValidMaterial = null;
    this.myTeleportInvalidMaterial = null;
    this.myTeleportPositionObject = null;
    this.myTeleportPositionObjectRotateWithHead = null;
    this.myTeleportParableStartReferenceObject = null;
    this.myResetRealOnStart = true;
    this.myResetRealOnStartFramesAmount = 1;
    this.myResetHeadToFeetInsteadOfReal = false;
    this.myResetHeadToRealMinDistance = 0;
    this.mySyncWithRealWorldPositionOnlyIfValid = true;
    this.myViewOcclusionInsideWallsEnabled = true;
    this.mySyncNonVRHeightWithVROnExitSession = false;
    this.mySyncNonVRVerticalAngleWithVROnExitSession = false;
    this.mySyncHeadWithRealAfterLocomotionUpdateIfNeeded = false;
    this.myColliderAccuracy = null;
    this.myColliderCheckOnlyFeet = false;
    this.myColliderSlideAlongWall = false;
    this.myColliderMaxWalkableGroundAngle = 0;
    this.myColliderSnapOnGround = false;
    this.myColliderMaxDistanceToSnapOnGround = 0;
    this.myColliderMaxWalkableGroundStepHeight = 0;
    this.myColliderPreventFallingFromEdges = false;
    this.myDebugFlyShortcutEnabled = false;
    this.myDebugFlyMaxSpeedMultiplier = 5;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myTripleSpeedShortcutEnabled = false;
    this.myDebugHorizontalEnabled = false;
    this.myDebugVerticalEnabled = false;
    this.myCollisionCheckDisabled = false;
    this.myPhysicsBlockLayerFlags = new PhysicsLayerFlags();
    this.myEngine = engine;
  }
};
var PlayerLocomotion = class {
  constructor(params) {
    this._myParams = params;
    this._myCollisionCheckParamsMovement = new CollisionCheckParams();
    this._setupCollisionCheckParamsMovement();
    this._myCollisionCheckParamsTeleport = null;
    this._setupCollisionCheckParamsTeleport();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myMovementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
    this._myMovementRuntimeParams.myIsFlying = this._myParams.myStartFlying;
    this._myMovementRuntimeParams.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
    {
      let params2 = new PlayerHeadManagerParams(this._myParams.myEngine);
      params2.mySessionChangeResyncEnabled = true;
      params2.myBlurEndResyncEnabled = true;
      params2.myBlurEndResyncRotation = true;
      params2.myEnterSessionResyncHeight = false;
      params2.myExitSessionResyncHeight = this._myParams.mySyncNonVRHeightWithVROnExitSession;
      params2.myExitSessionResyncVerticalAngle = this._myParams.mySyncNonVRVerticalAngleWithVROnExitSession;
      params2.myExitSessionRemoveRightTilt = true;
      params2.myExitSessionAdjustMaxVerticalAngle = true;
      params2.myExitSessionMaxVerticalAngle = 90;
      params2.myNonVRFloorBasedMode = NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR;
      params2.myDefaultHeightNonVR = this._myParams.myDefaultHeight;
      params2.myDefaultHeightVRWithoutFloor = this._myParams.myDefaultHeight;
      params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
      params2.myFeetRotationKeepUp = true;
      params2.myDebugEnabled = false;
      this._myPlayerHeadManager = new PlayerHeadManager(params2);
    }
    {
      let params2 = new PlayerTransformManagerParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myMovementCollisionCheckParams = this._myCollisionCheckParamsMovement;
      params2.myTeleportCollisionCheckParams = null;
      params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
      params2.myTeleportCollisionCheckParamsCheck360 = true;
      params2.myHeadCollisionBlockLayerFlags.copy(params2.myMovementCollisionCheckParams.myHorizontalBlockLayerFlags);
      params2.myHeadCollisionBlockLayerFlags.add(params2.myMovementCollisionCheckParams.myVerticalBlockLayerFlags);
      params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
      let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
      for (let objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
        params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      params2.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
      params2.myHeadRadius = 0.2;
      params2.myAlwaysSyncPositionWithReal = !this._myParams.mySyncWithRealWorldPositionOnlyIfValid;
      params2.myAlwaysSyncHeadPositionWithReal = false;
      if (!this._myParams.myViewOcclusionInsideWallsEnabled && !this._myParams.mySyncWithRealWorldPositionOnlyIfValid) {
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
        params2.myAlwaysSyncHeadPositionWithReal = !this._myParams.mySyncWithRealWorldPositionOnlyIfValid;
      }
      params2.myMaxDistanceFromRealToSyncEnabled = true;
      params2.myMaxDistanceFromRealToSync = 0.5;
      params2.myIsFloatingValidIfVerticalMovement = false;
      params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
      params2.myIsFloatingValidIfSteepGround = false;
      params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
      params2.myIsFloatingValidIfRealOnGround = false;
      params2.myFloatingSplitCheckEnabled = true;
      params2.myFloatingSplitCheckMinLength = this._myCollisionCheckParamsMovement.myFeetRadius * 1.5;
      params2.myFloatingSplitCheckMaxLength = this._myCollisionCheckParamsMovement.myFeetRadius * 1.5;
      params2.myFloatingSplitCheckMaxSteps = 3;
      params2.myRealMovementAllowVerticalAdjustments = false;
      params2.myUpdateRealPositionValid = false;
      params2.myUpdatePositionValid = false;
      params2.myIsBodyCollidingWhenHeightBelowValue = null;
      params2.myIsBodyCollidingWhenHeightAboveValue = null;
      params2.myResetToValidOnEnterSession = true;
      params2.myResetToValidOnExitSession = true;
      params2.myAlwaysResetRealPositionNonVR = true;
      params2.myAlwaysResetRealRotationNonVR = true;
      params2.myAlwaysResetRealHeightNonVR = true;
      params2.myAlwaysResetRealPositionVR = false;
      params2.myAlwaysResetRealRotationVR = false;
      params2.myAlwaysResetRealHeightVR = false;
      params2.myNeverResetRealPositionNonVR = false;
      params2.myNeverResetRealRotationNonVR = true;
      params2.myNeverResetRealHeightNonVR = false;
      params2.myResetRealHeightNonVROnExitSession = this._myParams.mySyncNonVRHeightWithVROnExitSession;
      params2.myResetHeadToFeetInsteadOfRealOnlyIfRealNotReachable = this._myParams.myResetHeadToFeetInsteadOfReal;
      params2.myResetHeadToRealMinDistance = this._myParams.myResetHeadToRealMinDistance;
      params2.myNeverResetRealPositionVR = false;
      params2.myNeverResetRealRotationVR = false;
      params2.myNeverResetRealHeightVR = true;
      params2.myDebugEnabled = false;
      this._myPlayerTransformManager = new PlayerTransformManager(params2);
    }
    {
      let params2 = new PlayerLocomotionRotateParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
      params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
      params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
      params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
      if (this._myParams.mySnapTurnSpeedDegrees > Math.PP_EPSILON) {
        params2.mySmoothSnapEnabled = true;
        params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
      } else {
        params2.mySmoothSnapEnabled = false;
      }
      params2.myRotationMinStickIntensityThreshold = 0.1;
      params2.mySnapTurnActivateThreshold = 0.5;
      params2.mySnapTurnResetThreshold = 0.4;
      params2.myClampVerticalAngle = true;
      params2.myMaxVerticalAngle = 89;
      this._myPlayerLocomotionRotate = new PlayerLocomotionRotate(params2);
      params2.myHandedness = InputUtils.getOppositeHandedness(this._myParams.myMainHand);
    }
    {
      {
        let params2 = new PlayerLocomotionSmoothParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsMovement;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myMaxSpeed = this._myParams.myMaxSpeed;
        params2.mySpeedSlowDownPercentageOnWallSlid = this._myParams.mySpeedSlowDownPercentageOnWallSlid;
        params2.myMovementMinStickIntensityThreshold = 0.1;
        params2.myFlyEnabled = this._myParams.myFlyEnabled;
        params2.myFlyWithButtonsEnabled = this._myParams.myFlyWithButtonsEnabled;
        params2.myFlyWithViewAngleEnabled = this._myParams.myFlyWithViewAngleEnabled;
        params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
        params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
        params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
        params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
        params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
        params2.myGravityAcceleration = this._myParams.myGravityAcceleration;
        params2.myMaxGravitySpeed = this._myParams.myMaxGravitySpeed;
        params2.myDirectionInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
        params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
        params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
        params2.myDebugFlyMaxSpeedMultiplier = this._myParams.myDebugFlyMaxSpeedMultiplier;
        params2.myMoveThroughCollisionShortcutEnabled = this._myParams.myMoveThroughCollisionShortcutEnabled;
        params2.myMoveHeadShortcutEnabled = this._myParams.myMoveHeadShortcutEnabled;
        params2.myTripleSpeedShortcutEnabled = this._myParams.myTripleSpeedShortcutEnabled;
        this._myPlayerLocomotionSmooth = new PlayerLocomotionSmooth(params2, this._myMovementRuntimeParams);
      }
      {
        let params2 = new PlayerLocomotionTeleportParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsTeleport;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myDetectionParams.myMaxDistance = this._myParams.myTeleportMaxDistance;
        params2.myDetectionParams.myMaxHeightDifference = this._myParams.myTeleportMaxHeightDifference;
        params2.myDetectionParams.myGroundAngleToIgnoreUpward = this._myCollisionCheckParamsMovement.myGroundAngleToIgnore;
        params2.myDetectionParams.myRotationOnUpEnabled = this._myParams.myTeleportRotationOnUpEnabled;
        params2.myDetectionParams.myMustBeOnGround = true;
        params2.myDetectionParams.myTeleportBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFloorLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
        params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
        params2.myDetectionParams.myVisibilityBlockLayerFlags.copy(params2.myDetectionParams.myTeleportBlockLayerFlags);
        params2.myTeleportParams.myTeleportType = this._myParams.myTeleportType;
        params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
        params2.myVisualizerParams.myTeleportValidMaterial = this._myParams.myTeleportValidMaterial;
        params2.myVisualizerParams.myTeleportInvalidMaterial = this._myParams.myTeleportInvalidMaterial;
        params2.myVisualizerParams.myTeleportPositionObjectRotateWithHead = this._myParams.myTeleportPositionObjectRotateWithHead;
        params2.myPerformTeleportAsMovement = false;
        params2.myTeleportAsMovementRemoveVerticalMovement = true;
        params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
        params2.myGravityAcceleration = this._myParams.myGravityAcceleration;
        params2.myMaxGravitySpeed = this._myParams.myMaxGravitySpeed;
        params2.myDebugEnabled = false;
        params2.myDebugDetectEnabled = true;
        params2.myDebugShowEnabled = true;
        params2.myDebugVisibilityEnabled = false;
        this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport(params2, this._myMovementRuntimeParams);
      }
      {
        let params2 = new PlayerObscureManagerParams(this._myParams.myEngine);
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myPlayerLocomotionTeleport = this._myPlayerLocomotionTeleport;
        params2.myEnabled = this._myParams.myViewOcclusionInsideWallsEnabled;
        params2.myObscureObject = null;
        params2.myObscureMaterial = null;
        params2.myObscureRadius = 0.5;
        params2.myObscureFadeOutSeconds = 0;
        params2.myObscureFadeInSeconds = 0.25;
        params2.myObscureFadeEasingFunction = EasingFunction.linear;
        params2.myObscureLevelRelativeDistanceEasingFunction = EasingFunction.linear;
        params2.myDistanceToStartObscureWhenBodyColliding = 0.75;
        params2.myDistanceToStartObscureWhenHeadColliding = 0;
        params2.myDistanceToStartObscureWhenFloating = 0.75;
        params2.myDistanceToStartObscureWhenFar = 0.75;
        params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
        params2.myRelativeDistanceToMaxObscureWhenHeadColliding = 0.05;
        params2.myRelativeDistanceToMaxObscureWhenFloating = 0.5;
        params2.myRelativeDistanceToMaxObscureWhenFar = 0.5;
        this._myPlayerObscureManager = new PlayerObscureManager(params2);
      }
    }
    this._setupLocomotionMovementFSM();
    this._mySwitchToTeleportOnEnterSession = false;
    this._myIdle = false;
    this._myActive = true;
    this._myStarted = false;
    this._myResetRealOnStartCounter = this._myParams.myResetRealOnStartFramesAmount;
    this._myPreUpdateEmitter = new Emitter12();
    this._myPostUpdateEmitter = new Emitter12();
    this._myDestroyed = false;
  }
  start() {
    this._fixAlmostUp();
    this._myPlayerHeadManager.start();
    this._myPlayerTransformManager.start();
    this._myPlayerObscureManager.start();
    this._myPlayerLocomotionRotate.start();
    if (this._myParams.myDefaultLocomotionType == PlayerLocomotionType.SMOOTH) {
      this._myLocomotionMovementFSM.perform("startSmooth");
    } else {
      this._myLocomotionMovementFSM.perform("startTeleport");
    }
    this._myStarted = true;
    let currentActive = this._myActive;
    this._myActive = !this._myActive;
    this.setActive(currentActive);
  }
  // #WARN Only a few params are actually used by this class after the setup phase, like @myCollisionCheckDisabled
  // Params like @myMaxSpeed must be edited directly on the PlayerLocomotionSmooth object
  getParams() {
    return this._myParams;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myStarted) {
        if (this._myActive) {
          this._myPlayerObscureManager.start();
          if (!this._myIdle) {
            this._myLocomotionMovementFSM.perform("resume");
          }
        } else {
          this._myLocomotionMovementFSM.perform("idle");
          this._myPlayerObscureManager.stop();
        }
      }
      this._myPlayerHeadManager.setActive(this._myActive);
      this._myPlayerTransformManager.setActive(this._myActive);
    }
  }
  isStarted() {
    return this._myStarted;
  }
  canStop() {
    let canStop = false;
    if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
      canStop = true;
    } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
      canStop = true;
    }
    return canStop;
  }
  update(dt) {
    this._myPreUpdateEmitter.notify(dt, this);
    let collisionCheckEnabledBackup = false;
    let maxGravitySpeedBackup = 0;
    if (this._myParams.myCollisionCheckDisabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      collisionCheckEnabledBackup = CollisionCheckBridge.isCollisionCheckDisabled();
      maxGravitySpeedBackup = this.getPlayerLocomotionSmooth().getParams().myMaxGravitySpeed;
      CollisionCheckBridge.setCollisionCheckDisabled(true);
      this.getPlayerLocomotionSmooth().getParams().myMaxGravitySpeed = 0;
    }
    this._myPlayerHeadManager.update(dt);
    if (this._myParams.myResetRealOnStart && this._myResetRealOnStartCounter > 0) {
      this._myResetRealOnStartCounter--;
      this._myPlayerTransformManager.resetReal(true, true, void 0, void 0, void 0, true);
      this._myPlayerTransformManager.update(dt);
      if (this._myPlayerHeadManager.isSynced()) {
        this._updateCollisionHeight();
      }
    } else {
      this._myPlayerTransformManager.update(dt);
      if (!this._myPlayerLocomotionSmooth.isDebugFlyEnabled() || !Globals.isDebugEnabled(this._myParams.myEngine)) {
        if (!this._myParams.myAlwaysSmoothForNonVR || XRUtils.isSessionActive()) {
          if (this._myParams.mySwitchLocomotionTypeShortcutEnabled && this._getMainHandGamepad().getButtonInfo(GamepadButtonID.THUMBSTICK).isPressEnd(2)) {
            if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
              this._myLocomotionMovementFSM.perform("next");
            } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
              this._myLocomotionMovementFSM.perform("next");
            }
          }
        }
        if (this._myParams.myAlwaysSmoothForNonVR && !XRUtils.isSessionActive()) {
          if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
            this._mySwitchToTeleportOnEnterSession = true;
            this._myLocomotionMovementFSM.perform("next");
          }
        } else if (this._mySwitchToTeleportOnEnterSession && XRUtils.isSessionActive()) {
          if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
            this._mySwitchToTeleportOnEnterSession = false;
            this._myLocomotionMovementFSM.perform("next");
          }
        }
      }
      if (this._myParams.myDebugFlyShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
        if (GamepadUtils.areButtonsPressEnd([this._getMainHandGamepad(), GamepadButtonID.SELECT, GamepadButtonID.THUMBSTICK])) {
          if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
            this._myLocomotionMovementFSM.perform("next");
          }
          if (this._myLocomotionMovementFSM.isInState("smooth")) {
            this._myPlayerLocomotionSmooth.setDebugFlyEnabled(!this._myPlayerLocomotionSmooth.isDebugFlyEnabled());
            this._mySwitchToTeleportOnEnterSession = false;
          }
        }
      }
      if (this._myPlayerHeadManager.isSynced()) {
        this._updateCollisionHeight();
        if (!this._myIdle) {
          this._myPlayerLocomotionRotate.update(dt);
          this._myLocomotionMovementFSM.update(dt);
        }
      }
    }
    if (this._myParams.mySyncHeadWithRealAfterLocomotionUpdateIfNeeded) {
      this._myPlayerTransformManager.updateValidHeadToRealHeadIfNeeded();
    }
    this._myPlayerObscureManager.update(dt);
    if (this._myParams.myCollisionCheckDisabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      CollisionCheckBridge.setCollisionCheckDisabled(collisionCheckEnabledBackup);
      this.getPlayerLocomotionSmooth().getParams().myMaxGravitySpeed = maxGravitySpeedBackup;
    }
    this._myPostUpdateEmitter.notify(dt, this);
  }
  setIdle(idle) {
    this._myIdle = idle;
    if (idle) {
      this._myLocomotionMovementFSM.perform("idle");
    } else {
      this._myLocomotionMovementFSM.perform("resume");
    }
  }
  getPlayerLocomotionSmooth() {
    return this._myPlayerLocomotionSmooth;
  }
  getPlayerLocomotionTeleport() {
    return this._myPlayerLocomotionTeleport;
  }
  getPlayerTransformManager() {
    return this._myPlayerTransformManager;
  }
  getPlayerLocomotionRotate() {
    return this._myPlayerLocomotionRotate;
  }
  getPlayerHeadManager() {
    return this._myPlayerHeadManager;
  }
  getPlayerObscureManager() {
    return this._myPlayerObscureManager;
  }
  registerPreUpdateCallback(id, callback) {
    this._myPreUpdateEmitter.add(callback, { id });
  }
  unregisterPreUpdateCallback(id) {
    this._myPreUpdateEmitter.remove(id);
  }
  registerPostUpdateCallback(id, callback) {
    this._myPostUpdateEmitter.add(callback, { id });
  }
  unregisterPostUpdateCallback(id) {
    this._myPostUpdateEmitter.remove(id);
  }
  _updateCollisionHeight() {
    this._myCollisionCheckParamsMovement.myHeight = this._myPlayerHeadManager.getHeightHead();
    if (this._myCollisionCheckParamsMovement.myHeight <= 1e-6) {
      this._myCollisionCheckParamsMovement.myHeight = 0;
    }
    this._myCollisionCheckParamsTeleport.myHeight = this._myCollisionCheckParamsMovement.myHeight;
  }
  _setupCollisionCheckParamsMovement() {
    let simplifiedParams = new CharacterColliderSetupSimplifiedCreationParams();
    simplifiedParams.myHeight = this._myParams.myDefaultHeight;
    simplifiedParams.myRadius = this._myParams.myCharacterRadius;
    simplifiedParams.myAccuracyLevel = this._myParams.myColliderAccuracy;
    simplifiedParams.myIsPlayer = true;
    simplifiedParams.myCheckOnlyFeet = this._myParams.myColliderCheckOnlyFeet;
    simplifiedParams.myMaxSpeed = this._myParams.myMaxSpeed;
    simplifiedParams.myCanFly = this._myParams.myFlyEnabled;
    simplifiedParams.myShouldSlideAlongWall = this._myParams.myColliderSlideAlongWall;
    simplifiedParams.myCollectGroundInfo = true;
    simplifiedParams.myMaxWalkableGroundAngle = this._myParams.myColliderMaxWalkableGroundAngle;
    simplifiedParams.myShouldSnapOnGround = this._myParams.myColliderSnapOnGround;
    simplifiedParams.myMaxDistanceToSnapOnGround = this._myParams.myColliderMaxDistanceToSnapOnGround;
    simplifiedParams.myMaxWalkableGroundStepHeight = this._myParams.myColliderMaxWalkableGroundStepHeight;
    simplifiedParams.myShouldNotFallFromEdges = this._myParams.myColliderPreventFallingFromEdges;
    simplifiedParams.myHorizontalCheckBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
    let physXComponents = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getComponents(PhysXComponent8);
    for (let physXComponent of physXComponents) {
      simplifiedParams.myHorizontalCheckObjectsToIgnore.pp_pushUnique(physXComponent.object, (first2, second) => first2.pp_equals(second));
    }
    simplifiedParams.myVerticalCheckBlockLayerFlags.copy(simplifiedParams.myHorizontalCheckBlockLayerFlags);
    simplifiedParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedParams.myHorizontalCheckObjectsToIgnore);
    simplifiedParams.myHorizontalCheckDebugEnabled = this._myParams.myDebugHorizontalEnabled && Globals.isDebugEnabled(this._myParams.myEngine);
    simplifiedParams.myVerticalCheckDebugEnabled = this._myParams.myDebugVerticalEnabled && Globals.isDebugEnabled(this._myParams.myEngine);
    let colliderSetup = CharacterColliderSetupUtils.createSimplified(simplifiedParams);
    this._myCollisionCheckParamsMovement = CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(colliderSetup, this._myCollisionCheckParamsMovement, this._myParams.myEngine);
  }
  _setupCollisionCheckParamsTeleport() {
    this._myCollisionCheckParamsTeleport = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myCollisionCheckParamsMovement);
    this._myCollisionCheckParamsTeleport.myGroundAngleToIgnore = 61;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnIgnorableGroundAngle = true;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnGround = true;
  }
  _fixAlmostUp() {
    let defaultUp = vec3_create(0, 1, 0);
    let angleWithDefaultUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp().vec3_angle(defaultUp);
    if (angleWithDefaultUp < 1) {
      let forward = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward();
      let flatForward = forward.vec3_clone();
      flatForward[1] = 0;
      let defaultForward = vec3_create(0, 0, 1);
      let angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
      Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_resetRotation();
      Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
    }
  }
  _setupLocomotionMovementFSM() {
    this._myLocomotionMovementFSM = new FSM();
    this._myLocomotionMovementFSM.addState("init");
    this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
    this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
    this._myLocomotionMovementFSM.addState("idleSmooth");
    this._myLocomotionMovementFSM.addState("idleTeleport");
    this._myLocomotionMovementFSM.addTransition("init", "smooth", "startSmooth", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("init", "teleport", "startTeleport", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "next", function() {
      this._myPlayerLocomotionSmooth.stop();
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "next", function() {
      this._myPlayerLocomotionTeleport.stop();
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
      this._myPlayerLocomotionSmooth.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
      this._myPlayerLocomotionTeleport.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "resume", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "resume", function() {
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.init("init");
  }
  _getMainHandGamepad() {
    return Globals.getGamepads(this._myParams.myEngine)[this._myParams.myMainHand];
  }
  destroy() {
    this._myDestroyed = true;
    this._myPlayerHeadManager.destroy();
    this._myPlayerLocomotionSmooth.destroy();
    this._myPlayerTransformManager.destroy();
    this._myPlayerObscureManager.destroy();
    this._myPlayerLocomotionTeleport.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_smooth.js
var PlayerLocomotionSmoothParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myPlayerTransformManager = null;
    this.myCollisionCheckParams = null;
    this.myMaxSpeed = 0;
    this.mySpeedSlowDownPercentageOnWallSlid = 1;
    this.myMovementMinStickIntensityThreshold = 0;
    this.myFlyEnabled = false;
    this.myFlyWithButtonsEnabled = false;
    this.myFlyWithViewAngleEnabled = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myHandedness = Handedness.LEFT;
    this.myDebugFlyMaxSpeedMultiplier = 5;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myTripleSpeedShortcutEnabled = false;
    this.myEngine = engine;
  }
};
var PlayerLocomotionSmooth = class extends PlayerLocomotionMovement {
  constructor(params, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myParams = params;
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement = vec3_create();
    this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._myStickIdleTimer = new Timer(0.25, false);
    let directionConverterNonVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
    directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
    directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
    let directionConverterVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
    directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
    directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
    this._myDirectionConverterNonVR = new Direction2DTo3DConverter(directionConverterNonVRParams);
    this._myDirectionConverterVR = new Direction2DTo3DConverter(directionConverterVRParams);
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myDebugFlyEnabled = false;
    this._myDestroyed = false;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  start() {
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement.vec3_zero();
  }
  getParams() {
    return this._myParams;
  }
  getCurrentSpeed() {
    return this._myCurrentSpeed;
  }
  getLastHorizontalSpeed() {
    return this._myLastHorizontalMovement;
  }
  update(dt) {
  }
  setDebugFlyEnabled(enabled) {
    if (this._myDebugFlyEnabled != enabled) {
      if (!enabled) {
        this._myLocomotionRuntimeParams.myIsFlying = false;
        this._myCurrentDirectionConverter.resetFly();
      }
    }
    this._myDebugFlyEnabled = enabled;
  }
  isDebugFlyEnabled() {
    return this._myDebugFlyEnabled;
  }
  _onXRSessionStart(session) {
  }
  _onXRSessionEnd(session) {
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionSmooth.prototype.update = function() {
  let playerUp = vec3_create();
  let headMovement = vec3_create();
  let direction = vec3_create();
  let directionOnUp = vec3_create();
  let verticalMovement = vec3_create();
  let feetTransformQuat = quat2_create();
  let directionReferenceTransformQuat = quat2_create();
  return function update(dt) {
    let debugFlyEnabled = this._myDebugFlyEnabled && Globals.isDebugEnabled(this._myParams.myEngine);
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement.vec3_zero();
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headMovement.vec3_zero();
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
    axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
    let isManuallyMoving = false;
    let maxSpeed = this._myParams.myMaxSpeed;
    if (debugFlyEnabled) {
      maxSpeed = maxSpeed * this._myParams.myDebugFlyMaxSpeedMultiplier;
    }
    if (this._myParams.myTripleSpeedShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) || debugFlyEnabled) {
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SELECT).isPressed()) {
        maxSpeed *= 3;
      }
    }
    if (debugFlyEnabled && Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.SELECT).isPressed()) {
      maxSpeed = this._myParams.myMaxSpeed;
    }
    if (!axes.vec2_isZero()) {
      this._myStickIdleTimer.start();
      direction = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction);
      if (!direction.vec3_isZero()) {
        this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          direction = direction.vec3_removeComponentAlongAxis(playerUp, direction);
        }
        let movementIntensity = axes.vec2_length();
        this._myCurrentSpeed = Math.pp_lerp(0, maxSpeed, movementIntensity);
        if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsSliding && this._myParams.mySpeedSlowDownPercentageOnWallSlid != 1) {
          let slowPercentage = this._myParams.mySpeedSlowDownPercentageOnWallSlid;
          let slidStrength = Math.pp_mapToRange(Math.abs(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.mySlidingMovementAngle), 0, 90, 0, 1);
          slowPercentage = Math.pp_lerp(1, slowPercentage, slidStrength);
          this._myCurrentSpeed = this._myCurrentSpeed * slowPercentage;
        }
        headMovement = direction.vec3_scale(this._myCurrentSpeed * dt, headMovement);
        isManuallyMoving = true;
      }
    } else {
      if (this._myStickIdleTimer.isRunning()) {
        this._myStickIdleTimer.update(dt);
        if (this._myStickIdleTimer.isDone()) {
          this._myCurrentDirectionConverter.resetFly();
        }
      }
    }
    if (this._myParams.myFlyEnabled && this._myParams.myFlyWithButtonsEnabled || debugFlyEnabled) {
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(maxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
        isManuallyMoving = true;
      } else if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(-maxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
        isManuallyMoving = true;
      }
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
        this._myLocomotionRuntimeParams.myIsFlying = false;
      }
    }
    if (this._myParams.myMoveHeadShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) && Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
      this._myParams.myPlayerTransformManager.getPlayerHeadManager().moveFeet(headMovement);
    } else if (this._myParams.myMoveThroughCollisionShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) && Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed() || debugFlyEnabled) {
      this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
      if (isManuallyMoving) {
        this._myParams.myPlayerTransformManager.resetReal();
      }
    } else {
      if (!this._myLocomotionRuntimeParams.myIsFlying) {
        this._myLocomotionRuntimeParams.myGravitySpeed += this._myParams.myGravityAcceleration * dt;
        if (Math.abs(this._myLocomotionRuntimeParams.myGravitySpeed) > Math.abs(this._myParams.myMaxGravitySpeed)) {
          this._myLocomotionRuntimeParams.myGravitySpeed = Math.pp_sign(this._myParams.myGravityAcceleration) * Math.abs(this._myParams.myMaxGravitySpeed);
        }
        verticalMovement = playerUp.vec3_scale(this._myLocomotionRuntimeParams.myGravitySpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
      } else {
        this._myLocomotionRuntimeParams.myGravitySpeed = 0;
      }
      feetTransformQuat = this._myParams.myPlayerTransformManager.getTransformQuat(feetTransformQuat);
      this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
      if (isManuallyMoving) {
        this._myParams.myPlayerTransformManager.resetReal();
        this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myOriginalUp, this._myLastHorizontalMovement);
      }
      if (this._myLocomotionRuntimeParams.myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myLocomotionRuntimeParams.myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
        this._myLocomotionRuntimeParams.myGravitySpeed = 0;
      }
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
      this._myCurrentDirectionConverter.resetFly();
    }
  };
}();
PlayerLocomotionSmooth.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(session) {
    switch (this._myParams.myVRDirectionReferenceType) {
      case 0:
        this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
        break;
      case 1:
        this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHands[this._myParams.myHandedness];
        break;
      case 2:
        this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
        break;
    }
    this._myCurrentDirectionConverter = this._myDirectionConverterVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
PlayerLocomotionSmooth.prototype._onXRSessionEnd = function() {
  return function _onXRSessionEnd(session) {
    this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();

// dist/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_component.js
import { Component as Component36, Property as Property30 } from "@wonderlandengine/api";
var PlayerLocomotionComponent = class extends Component36 {
  static TypeName = "pp-player-locomotion";
  static Properties = {
    _myDefaultLocomotionType: Property30.enum(["Smooth", "Teleport"], "Smooth"),
    _myAlwaysSmoothForNonVR: Property30.bool(true),
    _mySwitchLocomotionTypeShortcutEnabled: Property30.bool(true),
    // Double press main hand (default left) thumbstick to switch
    _myPhysicsBlockLayerFlags: Property30.string("0, 0, 0, 0, 0, 0, 0, 0"),
    _myDefaultHeight: Property30.float(1.7),
    _myCharacterRadius: Property30.float(0.3),
    _myMaxSpeed: Property30.float(2),
    _myMaxRotationSpeed: Property30.float(100),
    _myGravityAcceleration: Property30.float(-20),
    _myMaxGravitySpeed: Property30.float(-15),
    _mySpeedSlowDownPercentageOnWallSlid: Property30.float(1),
    _myIsSnapTurn: Property30.bool(true),
    _mySnapTurnOnlyVR: Property30.bool(true),
    _mySnapTurnAngle: Property30.float(30),
    _mySnapTurnSpeedDegrees: Property30.float(0),
    _myFlyEnabled: Property30.bool(false),
    _myStartFlying: Property30.bool(false),
    _myFlyWithButtonsEnabled: Property30.bool(true),
    _myFlyWithViewAngleEnabled: Property30.bool(true),
    _myMinAngleToFlyUpNonVR: Property30.float(30),
    _myMinAngleToFlyDownNonVR: Property30.float(50),
    _myMinAngleToFlyUpVR: Property30.float(60),
    _myMinAngleToFlyDownVR: Property30.float(1),
    _myMinAngleToFlyRight: Property30.float(60),
    _myMainHand: Property30.enum(["Left", "Right"], "Left"),
    _myDirectionInvertForwardWhenUpsideDown: Property30.bool(true),
    _myVRDirectionReferenceType: Property30.enum(["Head", "Hand", "Custom Object"], "Head"),
    _myVRDirectionReferenceObject: Property30.object(),
    _myTeleportType: Property30.enum(["Instant", "Blink", "Shift"], "Shift"),
    _myTeleportMaxDistance: Property30.float(3),
    _myTeleportMaxHeightDifference: Property30.float(1.25),
    _myTeleportRotationOnUpEnabled: Property30.bool(false),
    _myTeleportValidMaterial: Property30.material(),
    _myTeleportInvalidMaterial: Property30.material(),
    _myTeleportPositionObject: Property30.object(),
    _myTeleportPositionObjectRotateWithHead: Property30.bool(true),
    _myTeleportParableStartReferenceObject: Property30.object(),
    _myResetRealOnStart: Property30.bool(true),
    // #WARN With @myResetRealOnStartFramesAmount at 1 it can happen that you enter the session like 1 frame before the game load
    // and the head pose might have not been properly initialized yet in the WebXR API, so the reset real will not happen has expected
    // Since this is a sort of edge case (either u enter after the load, or you were already in for more than 2-3 frames), and that
    // setting this to more than 1 can cause a visible (even if very short) stutter after the load (due to resetting the head multiple times),
    // it's better to keep this value at 1
    // A possible effect of the edge case is the view being obscured on start because it thinks you are colliding
    //
    // A value of 3 will make u sure that the head pose will be initialized and the reset real will happen as expected in any case
    // For example, if u have a total fade at start and nothing can be seen aside the clear color for at least, let's say, 10 frames, 
    // you can set this to 3 safely, since there will be no visible stutter to be seen (beside the clear color)
    _myResetRealOnStartFramesAmount: Property30.int(1),
    // Can fix some head through floor issues, when you can move your head completely to the other side of the floor
    // If the floors are thick enough that this can't happen, you can leave this to false
    _myResetHeadToFeetInsteadOfReal: Property30.bool(true),
    _myResetHeadToRealMinDistance: Property30.float(0.25),
    // these 2 flags works 100% properly only if both true or false
    _mySyncWithRealWorldPositionOnlyIfValid: Property30.bool(true),
    // valid means the real player has not moved inside walls
    _myViewOcclusionInsideWallsEnabled: Property30.bool(true),
    _mySyncNonVRHeightWithVROnExitSession: Property30.bool(false),
    _mySyncNonVRVerticalAngleWithVROnExitSession: Property30.bool(false),
    _mySyncHeadWithRealAfterLocomotionUpdateIfNeeded: Property30.bool(true),
    _myColliderAccuracy: Property30.enum(["Very Low", "Low", "Medium", "High", "Very High"], "High"),
    _myColliderCheckOnlyFeet: Property30.bool(false),
    _myColliderSlideAlongWall: Property30.bool(true),
    _myColliderMaxWalkableGroundAngle: Property30.float(30),
    _myColliderSnapOnGround: Property30.bool(true),
    _myColliderMaxDistanceToSnapOnGround: Property30.float(0.1),
    _myColliderMaxWalkableGroundStepHeight: Property30.float(0.1),
    _myColliderPreventFallingFromEdges: Property30.bool(false),
    _myDebugFlyShortcutEnabled: Property30.bool(false),
    // main hand (default left) select + thumbstick press, auto switch to smooth
    _myDebugFlyMaxSpeedMultiplier: Property30.float(5),
    _myMoveThroughCollisionShortcutEnabled: Property30.bool(false),
    // main hand (default left) thumbstick pressed while moving
    _myMoveHeadShortcutEnabled: Property30.bool(false),
    // non main hand (default right) thumbstick pressed while moving
    _myTripleSpeedShortcutEnabled: Property30.bool(false),
    // main hand (default left) select pressed while moving
    _myDebugHorizontalEnabled: Property30.bool(false),
    _myDebugVerticalEnabled: Property30.bool(false),
    _myCollisionCheckDisabled: Property30.bool(false),
    _myRaycastCountLogEnabled: Property30.bool(false),
    _myRaycastVisualDebugEnabled: Property30.bool(false),
    _myPerformanceLogEnabled: Property30.bool(false)
  };
  start() {
    let params = new PlayerLocomotionParams(this.engine);
    params.myDefaultLocomotionType = this._myDefaultLocomotionType;
    params.myAlwaysSmoothForNonVR = this._myAlwaysSmoothForNonVR;
    params.mySwitchLocomotionTypeShortcutEnabled = this._mySwitchLocomotionTypeShortcutEnabled;
    params.myDefaultHeight = this._myDefaultHeight;
    params.myMaxSpeed = this._myMaxSpeed;
    params.myMaxRotationSpeed = this._myMaxRotationSpeed;
    params.myGravityAcceleration = this._myGravityAcceleration;
    params.myMaxGravitySpeed = this._myMaxGravitySpeed;
    params.myCharacterRadius = this._myCharacterRadius;
    params.mySpeedSlowDownPercentageOnWallSlid = this._mySpeedSlowDownPercentageOnWallSlid;
    params.myIsSnapTurn = this._myIsSnapTurn;
    params.mySnapTurnOnlyVR = this._mySnapTurnOnlyVR;
    params.mySnapTurnAngle = this._mySnapTurnAngle;
    params.mySnapTurnSpeedDegrees = this._mySnapTurnSpeedDegrees;
    params.myFlyEnabled = this._myFlyEnabled;
    params.myStartFlying = this._myStartFlying;
    params.myFlyWithButtonsEnabled = this._myFlyWithButtonsEnabled;
    params.myFlyWithViewAngleEnabled = this._myFlyWithViewAngleEnabled;
    params.myMinAngleToFlyUpNonVR = this._myMinAngleToFlyUpNonVR;
    params.myMinAngleToFlyDownNonVR = this._myMinAngleToFlyDownNonVR;
    params.myMinAngleToFlyUpVR = this._myMinAngleToFlyUpVR;
    params.myMinAngleToFlyDownVR = this._myMinAngleToFlyDownVR;
    params.myMinAngleToFlyRight = this._myMinAngleToFlyRight;
    params.myMainHand = InputUtils.getHandednessByIndex(this._myMainHand);
    params.myDirectionInvertForwardWhenUpsideDown = this._myDirectionInvertForwardWhenUpsideDown;
    params.myVRDirectionReferenceType = this._myVRDirectionReferenceType;
    params.myVRDirectionReferenceObject = this._myVRDirectionReferenceObject;
    params.myForeheadExtraHeight = 0.1;
    params.myTeleportType = this._myTeleportType;
    params.myTeleportMaxDistance = this._myTeleportMaxDistance;
    params.myTeleportMaxHeightDifference = this._myTeleportMaxHeightDifference;
    params.myTeleportRotationOnUpEnabled = this._myTeleportRotationOnUpEnabled;
    params.myTeleportValidMaterial = this._myTeleportValidMaterial;
    params.myTeleportInvalidMaterial = this._myTeleportInvalidMaterial;
    params.myTeleportPositionObject = this._myTeleportPositionObject;
    params.myTeleportPositionObjectRotateWithHead = this._myTeleportPositionObjectRotateWithHead;
    params.myTeleportParableStartReferenceObject = this._myTeleportParableStartReferenceObject;
    params.myResetRealOnStart = this._myResetRealOnStart;
    params.myResetRealOnStartFramesAmount = this._myResetRealOnStartFramesAmount;
    params.myResetHeadToFeetInsteadOfReal = this._myResetHeadToFeetInsteadOfReal;
    params.myResetHeadToRealMinDistance = this._myResetHeadToRealMinDistance;
    params.mySyncWithRealWorldPositionOnlyIfValid = this._mySyncWithRealWorldPositionOnlyIfValid;
    params.myViewOcclusionInsideWallsEnabled = this._myViewOcclusionInsideWallsEnabled;
    params.mySyncNonVRHeightWithVROnExitSession = this._mySyncNonVRHeightWithVROnExitSession;
    params.mySyncNonVRVerticalAngleWithVROnExitSession = this._mySyncNonVRVerticalAngleWithVROnExitSession;
    params.mySyncHeadWithRealAfterLocomotionUpdateIfNeeded = this._mySyncHeadWithRealAfterLocomotionUpdateIfNeeded;
    params.myColliderAccuracy = this._myColliderAccuracy;
    params.myColliderCheckOnlyFeet = this._myColliderCheckOnlyFeet;
    params.myColliderSlideAlongWall = this._myColliderSlideAlongWall;
    params.myColliderMaxWalkableGroundAngle = this._myColliderMaxWalkableGroundAngle;
    params.myColliderSnapOnGround = this._myColliderSnapOnGround;
    params.myColliderMaxDistanceToSnapOnGround = this._myColliderMaxDistanceToSnapOnGround;
    params.myColliderMaxWalkableGroundStepHeight = this._myColliderMaxWalkableGroundStepHeight;
    params.myColliderPreventFallingFromEdges = this._myColliderPreventFallingFromEdges;
    params.myDebugFlyShortcutEnabled = this._myDebugFlyShortcutEnabled;
    params.myDebugFlyMaxSpeedMultiplier = this._myDebugFlyMaxSpeedMultiplier;
    params.myMoveThroughCollisionShortcutEnabled = this._myMoveThroughCollisionShortcutEnabled;
    params.myMoveHeadShortcutEnabled = this._myMoveHeadShortcutEnabled;
    params.myTripleSpeedShortcutEnabled = this._myTripleSpeedShortcutEnabled;
    params.myDebugHorizontalEnabled = this._myDebugHorizontalEnabled;
    params.myDebugVerticalEnabled = this._myDebugVerticalEnabled;
    params.myCollisionCheckDisabled = this._myCollisionCheckDisabled;
    params.myPhysicsBlockLayerFlags.copy(this._getPhysicsBlockLayersFlags());
    this._myPlayerLocomotion = new PlayerLocomotion(params);
    this._myLocomotionStarted = false;
    this._myResetReal = true;
    this._myDebugPerformanceLogTimer = new Timer(0.5);
    this._myDebugPerformanceLogTotalTime = 0;
    this._myDebugPerformanceLogFrameCount = 0;
    Globals.getHeadPose(this.engine).registerPostPoseUpdatedEventEventListener(this, this.onPostPoseUpdatedEvent.bind(this));
  }
  onPostPoseUpdatedEvent(dt, pose, manualUpdate) {
    if (manualUpdate)
      return;
    let startTime = 0;
    if (this._myPerformanceLogEnabled && Globals.isDebugEnabled(this.engine)) {
      startTime = window.performance.now();
    }
    let raycastVisualDebugEnabledBackup = false;
    if (this._myRaycastVisualDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      raycastVisualDebugEnabledBackup = PhysicsUtils.isRaycastVisualDebugEnabled(this.engine.physics);
      PhysicsUtils.setRaycastVisualDebugEnabled(true, this.engine.physics);
    }
    if (this._myRaycastCountLogEnabled && Globals.isDebugEnabled(this.engine)) {
      PhysicsUtils.resetRaycastCount(this.engine.physics);
    }
    if (!this._myLocomotionStarted) {
      this._myLocomotionStarted = true;
      this._myPlayerLocomotion.start();
    }
    this._myPlayerLocomotion.update(dt);
    if (this._myPerformanceLogEnabled && Globals.isDebugEnabled(this.engine)) {
      let endTime = window.performance.now();
      this._myDebugPerformanceLogTotalTime += endTime - startTime;
      this._myDebugPerformanceLogFrameCount++;
      this._myDebugPerformanceLogTimer.update(dt);
      if (this._myDebugPerformanceLogTimer.isDone()) {
        this._myDebugPerformanceLogTimer.start();
        let averageTime = this._myDebugPerformanceLogTotalTime / this._myDebugPerformanceLogFrameCount;
        console.log("Locomotion ms: " + averageTime.toFixed(3));
        this._myDebugPerformanceLogTotalTime = 0;
        this._myDebugPerformanceLogFrameCount = 0;
      }
    }
    if (this._myRaycastVisualDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      PhysicsUtils.setRaycastVisualDebugEnabled(raycastVisualDebugEnabledBackup, this.engine.physics);
    }
    if (this._myRaycastCountLogEnabled && Globals.isDebugEnabled(this.engine)) {
      console.log("Raycast count: " + PhysicsUtils.getRaycastCount(this.engine.physics));
      PhysicsUtils.resetRaycastCount(this.engine.physics);
    }
  }
  getPlayerLocomotion() {
    return this._myPlayerLocomotion;
  }
  onActivate() {
    if (this._myPlayerLocomotion != null) {
      this._myPlayerLocomotion.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myPlayerLocomotion != null) {
      this._myPlayerLocomotion.setActive(false);
    }
  }
  _getPhysicsBlockLayersFlags() {
    let physicsFlags = new PhysicsLayerFlags();
    let flags = [...this._myPhysicsBlockLayerFlags.split(",")];
    for (let i = 0; i < flags.length; i++) {
      physicsFlags.setFlagActive(i, flags[i].trim() == "1");
    }
    return physicsFlags;
  }
  onDestroy() {
    this._myPlayerLocomotion?.destroy();
  }
};

// dist/input/cauldron/components/finger_cursor_component.js
import { Collider, CollisionComponent as CollisionComponent3, Component as Component37, Property as Property31 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget5 } from "@wonderlandengine/components";
var FingerCursorComponent = class extends Component37 {
  static TypeName = "pp-finger-cursor";
  static Properties = {
    _myHandedness: Property31.enum(["Left", "Right"], "Left"),
    _myMultipleClicksEnabled: Property31.bool(true),
    _myCollisionGroup: Property31.int(1),
    _myCollisionSize: Property31.float(0.0125),
    _myCursorObject: Property31.object(null)
  };
  init() {
    this._myLastTarget = null;
    this._myHandInputSource = null;
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myDoubleClickTimer = 0;
    this._myTripleClickTimer = 0;
    this._myMultipleClickObject = null;
    this._myMultipleClickDelay = 0.3;
  }
  start() {
    this._myCursorParentObject = this.object.pp_addObject();
    if (this._myCursorObject == null) {
      this._myCursorObject = this._myCursorParentObject.pp_addObject();
    } else {
      this._myCursorObject.pp_setParent(this._myCursorParentObject);
    }
    this._myCollisionComponent = this._myCursorObject.pp_addComponent(CollisionComponent3);
    this._myCollisionComponent.collider = Collider.Sphere;
    this._myCollisionComponent.group = 1 << this._myCollisionGroup;
    this._myCollisionComponent.extents = vec3_create(this._myCollisionSize, this._myCollisionSize, this._myCollisionSize);
  }
  update(dt) {
    if (this._myDoubleClickTimer > 0) {
      this._myDoubleClickTimer -= dt;
    }
    if (this._myTripleClickTimer > 0) {
      this._myTripleClickTimer -= dt;
    }
    this._myCursorParentObject.pp_setTransformQuat(Globals.getPlayerObjects(this.engine).myReferenceSpace.pp_getTransformQuat());
    this._updateHand();
    if (this._myHandInputSource) {
      let overlaps = this._myCollisionComponent.queryOverlaps();
      let overlapTarget = null;
      for (let i = 0; i < overlaps.length; ++i) {
        let collision = overlaps[i];
        if (collision.group & this._myCollisionComponent.group) {
          let object = collision.object;
          let target = object.pp_getComponent(CursorTarget5);
          if (target && (overlapTarget == null || !target.isSurface)) {
            overlapTarget = target;
            if (!target.isSurface) {
              break;
            }
          }
        }
      }
      if (!overlapTarget) {
        this._targetTouchEnd();
      } else if (!overlapTarget.equals(this._myLastTarget)) {
        this._targetTouchEnd();
        this._myLastTarget = overlapTarget;
        this._targetTouchStart();
      }
    } else {
      this._targetTouchEnd();
    }
  }
  _targetTouchStart() {
    this._myLastTarget.onHover.notify(this._myLastTarget.object, this);
    this._myLastTarget.onDown.notify(this._myLastTarget.object, this);
  }
  _targetTouchEnd() {
    if (this._myLastTarget) {
      this._myLastTarget.onClick.notify(this._myLastTarget.object, this);
      if (this._myMultipleClicksEnabled && this._myTripleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.pp_equals(this._myLastTarget.object)) {
        this._myLastTarget.onTripleClick.notify(this._myLastTarget.object, this);
        this._myTripleClickTimer = 0;
      } else if (this._myMultipleClicksEnabled && this._myDoubleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.pp_equals(this._myLastTarget.object)) {
        this._myLastTarget.onDoubleClick.notify(this._myLastTarget.object, this);
        this._myTripleClickTimer = this._myMultipleClickDelay;
        this._myDoubleClickTimer = 0;
      } else {
        this._myLastTarget.onSingleClick.notify(this._myLastTarget.object, this);
        this._myTripleClickTimer = 0;
        this._myDoubleClickTimer = this._myMultipleClickDelay;
        this._myMultipleClickObject = this._myLastTarget.object;
      }
      this._myLastTarget.onUp.notify(this._myLastTarget.object, this);
      this._myLastTarget.onUpWithDown.notify(this._myLastTarget.object, this);
      this._myLastTarget.onUnhover.notify(this._myLastTarget.object, this);
      this._myLastTarget = null;
    }
  }
  onActivate() {
    this._myCursorParentObject.pp_setActive(true);
  }
  onDeactivate() {
    if (this._myCursorParentObject != null) {
      this._myCursorParentObject.pp_setActive(false);
    }
  }
  _updateHand() {
    this._myHandInputSource = InputUtils.getInputSource(this._myHandednessType, InputSourceType.TRACKED_HAND, this.engine);
    if (this._myHandInputSource) {
      let tip = null;
      try {
        tip = XRUtils.getFrame(this.engine).getJointPose(this._myHandInputSource.hand.get(TrackedHandJointID.INDEX_FINGER_TIP), XRUtils.getReferenceSpace(this.engine));
      } catch (error3) {
      }
      if (tip) {
        this._myCursorObject.pp_setRotationLocalQuat([
          tip.transform.orientation.x,
          tip.transform.orientation.y,
          tip.transform.orientation.z,
          tip.transform.orientation.w
        ]);
        this._myCursorObject.pp_setPositionLocal([
          tip.transform.position.x,
          tip.transform.position.y,
          tip.transform.position.z
        ]);
      }
    }
  }
};

// dist/input/cauldron/components/switch_hand_object_component.js
import { Component as Component38, Property as Property32 } from "@wonderlandengine/api";
var SwitchHandObjectComponent = class extends Component38 {
  static TypeName = "pp-switch-hand-object";
  static Properties = {
    _myHandedness: Property32.enum(["Left", "Right"], "Left"),
    _myGamepad: Property32.object(),
    _myTrackedHand: Property32.object(),
    _myDisableHandsWhenNonXR: Property32.bool(true)
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myFirstUpdate = true;
    this._myCurrentInputSourceType = null;
  }
  onActivate() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      this._start();
    }
    if (this._myDisableHandsWhenNonXR && !XRUtils.isSessionActive()) {
      if (this._myCurrentInputSourceType != null) {
        this._myCurrentInputSourceType = null;
        this._myGamepad.pp_setActive(false);
        this._myTrackedHand.pp_setActive(false);
      }
    } else {
      let inputSourceType = InputUtils.getInputSourceTypeByHandedness(this._myHandednessType, this.engine);
      if (inputSourceType != null && this._myCurrentInputSourceType != inputSourceType) {
        this._myCurrentInputSourceType = inputSourceType;
        if (inputSourceType == InputSourceType.TRACKED_HAND) {
          if (this._myGamepad != null) {
            this._myGamepad.pp_setActive(false);
          }
          if (this._myTrackedHand != null) {
            this._myTrackedHand.pp_setActive(true);
          }
        } else if (inputSourceType == InputSourceType.GAMEPAD) {
          if (this._myTrackedHand != null) {
            this._myTrackedHand.pp_setActive(false);
          }
          if (this._myGamepad != null) {
            this._myGamepad.pp_setActive(true);
          }
        }
      }
    }
  }
  _start() {
    if (this._myGamepad != null) {
      this._myGamepad.pp_setActive(false);
    }
    if (this._myTrackedHand != null) {
      this._myTrackedHand.pp_setActive(false);
    }
    this._myCurrentInputSourceType = null;
  }
};

// dist/input/cauldron/components/tracked_hand_draw_joint_component.js
import { Component as Component39, MeshComponent as MeshComponent11, Property as Property33 } from "@wonderlandengine/api";
var TrackedHandDrawJointComponent = class extends Component39 {
  static TypeName = "pp-tracked-hand-draw-joint";
  static Properties = {
    _myHandedness: Property33.enum(["Left", "Right"], "Left"),
    _myJointID: Property33.enum([
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ], "Wrist"),
    _myJointMesh: Property33.mesh(),
    _myJointMaterial: Property33.material()
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDType = InputUtils.getJointIDByIndex(this._myJointID);
    this._buildTrackedHandHierarchy();
  }
  update(dt) {
  }
  _buildTrackedHandHierarchy() {
    this._myJointMeshObject = this.object.pp_addObject();
    let mesh = this._myJointMeshObject.pp_addComponent(MeshComponent11);
    mesh.mesh = this._myJointMesh;
    mesh.material = this._myJointMaterial;
    this._myJointMeshObject.pp_setScaleLocal(0);
  }
};
TrackedHandDrawJointComponent.prototype.update = function() {
  let transformQuat2 = quat2_create();
  return function update(dt) {
    let jointPose = Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(this._myJointIDType);
    this._myJointMeshObject.pp_setTransformLocalQuat(jointPose.getTransformQuat(transformQuat2, null));
    this._myJointMeshObject.pp_setScaleLocal(jointPose.getJointRadius());
  };
}();

// dist/input/cauldron/components/tracked_hand_draw_all_joints_component.js
import { Component as Component40, Property as Property34 } from "@wonderlandengine/api";
var TrackedHandDrawAllJointsComponent = class extends Component40 {
  static TypeName = "pp-tracked-hand-draw-all-joints";
  static Properties = {
    _myHandedness: Property34.enum(["Left", "Right"], "Left"),
    _myHideMetacarpals: Property34.bool(true),
    _myJointMesh: Property34.mesh(),
    _myJointMaterial: Property34.material()
  };
  start() {
    this._buildTrackedHandHierarchy();
  }
  _buildTrackedHandHierarchy() {
    this._myTrackedHandMeshObject = this.object.pp_addObject();
    this._myJointMeshObjectList = [];
    for (let jointIDKey in TrackedHandJointID) {
      let jointID = TrackedHandJointID[jointIDKey];
      if (!this._myHideMetacarpals || jointID != TrackedHandJointID.THUMB_METACARPAL && jointID != TrackedHandJointID.INDEX_FINGER_METACARPAL && jointID != TrackedHandJointID.MIDDLE_FINGER_METACARPAL && jointID != TrackedHandJointID.RING_FINGER_METACARPAL && jointID != TrackedHandJointID.PINKY_FINGER_METACARPAL) {
        let jointObject = this._myTrackedHandMeshObject.pp_addObject();
        this._myJointMeshObjectList[jointID] = jointObject;
        jointObject.pp_addComponent(TrackedHandDrawJointComponent, {
          "_myHandedness": this._myHandedness,
          "_myJointID": TrackedHandJointIDIndex[jointIDKey],
          "_myJointMesh": this._myJointMesh,
          "_myJointMaterial": this._myJointMaterial
        });
      }
    }
  }
};

// dist/input/cauldron/components/tracked_hand_draw_skin_component.js
import { Component as Component41, Property as Property35 } from "@wonderlandengine/api";
var TrackedHandDrawSkinComponent = class extends Component41 {
  static TypeName = "pp-tracked-hand-draw-skin";
  static Properties = {
    _myHandedness: Property35.enum(["Left", "Right"], "Left"),
    _myHandSkin: Property35.skin(null)
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._prepareJoints();
  }
  update(dt) {
  }
  _prepareJoints() {
    this._myJoints = [];
    let skinJointIDs = this._myHandSkin.jointIds;
    for (let i = 0; i < skinJointIDs.length; i++) {
      this._myJoints[i] = ObjectUtils.wrapObject(skinJointIDs[i]);
    }
  }
};
TrackedHandDrawSkinComponent.prototype.update = function() {
  let transformQuat2 = quat2_create();
  return function update(dt) {
    for (let i = 0; i < this._myJoints.length; i++) {
      let jointObject = this._myJoints[i];
      let jointID = jointObject.pp_getName();
      let jointPose = Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(jointID);
      jointObject.pp_setTransformLocalQuat(jointPose.getTransformQuat(transformQuat2, null));
    }
  };
}();

// dist/input/gamepad/cauldron/gamepad_mesh_animator_component.js
import { Component as Component42, Property as Property36 } from "@wonderlandengine/api";
var GamepadMeshAnimatorComponent = class extends Component42 {
  static TypeName = "pp-gamepad-mesh-animator";
  static Properties = {
    _myHandedness: Property36.enum(["Left", "Right"], "Left"),
    _mySelect: Property36.object(null),
    _mySqueeze: Property36.object(null),
    _myThumbstick: Property36.object(null),
    _myTopButton: Property36.object(null),
    _myBottomButton: Property36.object(null),
    _mySelectRotateAngle: Property36.float(15),
    _mySqueezeRotateAngle: Property36.float(11),
    _myThumbstickRotateAngle: Property36.float(15),
    _myThumbstickPressOffset: Property36.float(625e-6),
    _myTopButtonPressOffset: Property36.float(15e-4),
    _myBottomButtonPressOffset: Property36.float(15e-4),
    _myUsePressForSqueeze: Property36.bool(false),
    _mySqueezePressOffset: Property36.float(15e-4)
  };
  start() {
    let gamepad = null;
    if (this._myHandedness == HandednessIndex.LEFT) {
      gamepad = Globals.getLeftGamepad(this.engine);
    } else {
      gamepad = Globals.getRightGamepad(this.engine);
    }
    if (this._mySelect != null) {
      this._mySelectOriginalRotation = this._mySelect.pp_getRotationLocalQuat();
      this._mySelectOriginalLeft = this._mySelect.pp_getLeftLocal();
    }
    if (this._mySqueeze != null) {
      this._mySqueezeOriginalPosition = this._mySqueeze.pp_getPositionLocal();
      this._mySqueezeOriginalRotation = this._mySqueeze.pp_getRotationLocalQuat();
      this._mySqueezeOriginalLeft = this._mySqueeze.pp_getLeftLocal();
      this._mySqueezeOriginalForward = this._mySqueeze.pp_getForwardLocal();
    }
    if (this._myThumbstick != null) {
      this._myThumbstickOriginalPosition = this._myThumbstick.pp_getPositionLocal();
      this._myThumbstickOriginalRotation = this._myThumbstick.pp_getRotationLocalQuat();
      this._myThumbstickOriginalLeft = this._myThumbstick.pp_getLeftLocal();
      this._myThumbstickOriginalUp = this._myThumbstick.pp_getUpLocal();
      this._myThumbstickOriginalForward = this._myThumbstick.pp_getForwardLocal();
    }
    if (this._myTopButton != null) {
      this._myTopButtonOriginalPosition = this._myTopButton.pp_getPositionLocal();
      this._myTopButtonOriginalUp = this._myTopButton.pp_getUpLocal();
    }
    if (this._myBottomButton != null) {
      this._myBottomButtonOriginalPosition = this._myBottomButton.pp_getPositionLocal();
      this._myBottomButtonOriginalUp = this._myBottomButton.pp_getUpLocal();
    }
    if (this._myThumbstick != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_START, this, this._thumbstickPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_END, this, this._thumbstickPressedEnd.bind(this));
    }
    if (this._myTopButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_START, this, this._topButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_END, this, this._topButtonPressedEnd.bind(this));
    }
    if (this._myBottomButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_START, this, this._bottomButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_END, this, this._bottomButtonPressedEnd.bind(this));
    }
    if (this._mySelect != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.VALUE_CHANGED, this, this._selectValueChanged.bind(this));
    }
    if (this._mySqueeze != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.VALUE_CHANGED, this, this._squeezeValueChanged.bind(this));
    }
    if (this._myThumbstick != null) {
      gamepad.registerAxesEventListener(GamepadAxesID.THUMBSTICK, GamepadAxesEvent.AXES_CHANGED, this, this._thumbstickValueChanged.bind(this));
    }
  }
  _thumbstickPressedStart() {
  }
  _thumbstickPressedEnd(buttonInfo, gamepad) {
    this._myThumbstick.pp_setPositionLocal(this._myThumbstickOriginalPosition);
  }
  _topButtonPressedStart(buttonInfo, gamepad) {
    this._myTopButton.pp_translateAxisLocal(-this._myTopButtonPressOffset, this._myTopButtonOriginalUp);
  }
  _topButtonPressedEnd(buttonInfo, gamepad) {
    this._myTopButton.pp_setPositionLocal(this._myTopButtonOriginalPosition);
  }
  _bottomButtonPressedStart(buttonInfo, gamepad) {
    this._myBottomButton.pp_translateAxisLocal(-this._myBottomButtonPressOffset, this._myBottomButtonOriginalUp);
  }
  _bottomButtonPressedEnd(buttonInfo, gamepad) {
    this._myBottomButton.pp_setPositionLocal(this._myBottomButtonOriginalPosition);
  }
  _selectValueChanged(buttonInfo, gamepad) {
    this._mySelect.pp_setRotationLocalQuat(this._mySelectOriginalRotation);
    if (buttonInfo.getValue() > 1e-5) {
      this._mySelect.pp_rotateAxisLocal(this._mySelectRotateAngle * buttonInfo.getValue(), this._mySelectOriginalLeft);
    }
  }
  _squeezeValueChanged(buttonInfo, gamepad) {
    this._mySqueeze.pp_setPositionLocal(this._mySqueezeOriginalPosition);
    this._mySqueeze.pp_setRotationLocalQuat(this._mySqueezeOriginalRotation);
    if (buttonInfo.getValue() > 1e-5) {
      if (this._myUsePressForSqueeze) {
        let translation = this._mySqueezePressOffset;
        if (this._myHandedness == 1) {
          translation *= -1;
        }
        this._mySqueeze.pp_translateAxisLocal(translation * buttonInfo.getValue(), this._mySqueezeOriginalLeft);
      } else {
        let rotation = -this._mySqueezeRotateAngle;
        if (this._myHandedness == 1) {
          rotation *= -1;
        }
        this._mySqueeze.pp_rotateAxisLocal(rotation * buttonInfo.getValue(), this._mySqueezeOriginalForward);
      }
    }
  }
  _thumbstickValueChanged(axesInfo, gamepad) {
    this._myThumbstick.pp_setRotationLocalQuat(this._myThumbstickOriginalRotation);
    let leftRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[1];
    let forwardRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[0];
    if (Math.abs(leftRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(leftRotation, this._myThumbstickOriginalLeft);
    }
    if (Math.abs(forwardRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(forwardRotation, this._myThumbstickOriginalForward);
    }
  }
};
GamepadMeshAnimatorComponent.prototype._thumbstickPressedStart = function() {
  let upTranslation = vec3_create();
  return function _thumbstickPressedStart(buttonInfo, gamepad) {
    this._myThumbstickOriginalUp.vec3_scale(-this._myThumbstickPressOffset, upTranslation);
    this._myThumbstick.pp_translateLocal(upTranslation);
  };
}();

// dist/input/gamepad/cauldron/gamepad_control_scheme_component.js
import { Alignment as Alignment5, Component as Component43, Justification as Justification5, MeshComponent as MeshComponent12, Property as Property37, TextComponent as TextComponent8 } from "@wonderlandengine/api";
var GamepadControlSchemeComponent = class extends Component43 {
  static TypeName = "pp-gamepad-control-scheme";
  static Properties = {
    _myShowOnStart: Property37.bool(true),
    _myHandedness: Property37.enum(["Left", "Right"], "Left"),
    _mySelectText: Property37.string(""),
    _mySqueezeText: Property37.string(""),
    _myThumbstickText: Property37.string(""),
    _myBottomButtonText: Property37.string(""),
    _myTopButtonText: Property37.string(""),
    _mySelect: Property37.object(null),
    _mySqueeze: Property37.object(null),
    _myThumbstick: Property37.object(null),
    _myBottomButton: Property37.object(null),
    _myTopButton: Property37.object(null),
    _myTextScaleMultiplier: Property37.float(1),
    _myTextOffsetMultiplier: Property37.float(1),
    _myLineLengthMultiplier: Property37.float(1),
    _myLineThicknessMultiplier: Property37.float(1),
    _myDistanceFromButtonsMultiplier: Property37.float(1),
    _myTextMaterial: Property37.material(),
    _myLineMaterial: Property37.material()
  };
  start() {
    this._myTextMaterialFinal = this._myTextMaterial != null ? this._myTextMaterial : Globals.getDefaultMaterials(this.engine).myText.clone();
    this._myLineMaterialFinal = this._myLineMaterial != null ? this._myLineMaterial : Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myControlSchemeDirection = this._myHandednessType == Handedness.LEFT ? 1 : -1;
    this._myVisible = false;
    this._mySetVisibleNextUpdate = false;
    this._createControlScheme();
    this.setVisible(this._myShowOnStart);
    this._myVisibleBackup = this._myVisible;
  }
  update(dt) {
    if (this._mySetVisibleNextUpdate) {
      this._mySetVisibleNextUpdate = false;
      this.setVisible(false);
      this.setVisible(this._myVisibleBackup);
    }
  }
  onActivate() {
    this._mySetVisibleNextUpdate = true;
  }
  onDeactivate() {
    if (this._myVisible != null) {
      this._myVisibleBackup = this._myVisible;
      this.setVisible(false);
    }
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    this._myVisible = visible;
    if (this._myParentObject != null) {
      this._myParentObject.pp_setActive(this._myVisible);
      if (this._myVisible) {
        this._hideEmptySchemes();
      }
    }
  }
  setSelectText(text) {
    this._mySelectText = text;
    this._mySelectTextComponent.text = this._mySelectText;
    this.setVisible(this._myVisible);
  }
  setSqueezeText(text) {
    this._mySqueezeText = text;
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this.setVisible(this._myVisible);
  }
  setThumbstickText(text) {
    this._myThumbstickText = text;
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    this.setVisible(this._myVisible);
  }
  setBottomButtonText(text) {
    this._myBottomButtonText = text;
    this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    this.setVisible(this._myVisible);
  }
  setTopButtonText(text) {
    this._myTopButtonText = text;
    this._myTopButtonTextComponent.text = this._myTopButtonText;
    this.setVisible(this._myVisible);
  }
  _createControlScheme() {
    this._myParentObject = this.object.pp_addObject();
    let distanceFromButton = 0.02 * this._myDistanceFromButtonsMultiplier;
    let lineLength = 0.0935 * this._myLineLengthMultiplier;
    let referenceObject = this._myThumbstick;
    this._mySelectObject = this._myParentObject.pp_addObject();
    this._mySelectTextComponent = this._addScheme(this._mySelect, referenceObject, vec3_create(0, 0, distanceFromButton), vec3_create(lineLength * this._myControlSchemeDirection, 0, 0), this._mySelectObject);
    this._mySelectTextComponent.text = this._mySelectText;
    this._mySqueezeObject = this._myParentObject.pp_addObject();
    this._mySqueezeTextComponent = this._addScheme(this._mySqueeze, referenceObject, vec3_create(distanceFromButton * this._myControlSchemeDirection, 0, 0), vec3_create(lineLength * this._myControlSchemeDirection, 0, 0), this._mySqueezeObject);
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this._myThumbstickObject = this._myParentObject.pp_addObject();
    this._myThumbstickTextComponent = this._addScheme(this._myThumbstick, referenceObject, vec3_create(0, distanceFromButton, 0), vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0), this._myThumbstickObject);
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    let thumbstickPositionLocal = this._myThumbstick.pp_getPositionLocal();
    let thumbstickUpLocal = this._myThumbstick.pp_getUpLocal();
    {
      let bottomButtonPositionLocal = this._myBottomButton.pp_getPositionLocal();
      let difference = bottomButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myBottomButtonObject = this._myParentObject.pp_addObject();
      this._myBottomButtonTextComponent = this._addScheme(this._myBottomButton, referenceObject, vec3_create(0, distanceFromButton - differenceOnUp, 0), vec3_create(0, 0, -lineLength), this._myBottomButtonObject);
      this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    }
    {
      let topButtonPositionLocal = this._myTopButton.pp_getPositionLocal();
      let difference = topButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myTopButtonObject = this._myParentObject.pp_addObject();
      this._myTopButtonTextComponent = this._addScheme(this._myTopButton, referenceObject, vec3_create(0, distanceFromButton - differenceOnUp, 0), vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0).vec3_rotateAxis(-45 * this._myControlSchemeDirection, vec3_create(0, 1, 0)), this._myTopButtonObject);
      this._myTopButtonTextComponent.text = this._myTopButtonText;
    }
  }
  _addScheme(buttonObject, referenceObject, startOffset, endOffset, parentObject) {
    let buttonPosition = buttonObject.pp_getPositionLocal();
    let referenceForward = referenceObject.pp_getForwardLocal();
    let referenceRight = referenceObject.pp_getRightLocal();
    let referenceUp = referenceObject.pp_getUpLocal();
    let lineStart = buttonPosition.vec3_add(referenceRight.vec3_scale(startOffset[0]));
    lineStart.vec3_add(referenceUp.vec3_scale(startOffset[1]), lineStart);
    lineStart.vec3_add(referenceForward.vec3_scale(startOffset[2]), lineStart);
    let lineEnd = lineStart.vec3_add(referenceRight.vec3_scale(endOffset[0]));
    lineEnd.vec3_add(referenceUp.vec3_scale(endOffset[1]), lineEnd);
    lineEnd.vec3_add(referenceForward.vec3_scale(endOffset[2]), lineEnd);
    let textOffset = 0.01 * this._myTextOffsetMultiplier;
    let textPosition = lineEnd.vec3_add(referenceForward.vec3_scale(-textOffset));
    this._addLine(lineStart, lineEnd, parentObject);
    let textComponent = this._addText(textPosition, referenceForward, referenceUp, parentObject);
    return textComponent;
  }
  _addLine(start, end, parentObject) {
    let lineDirection = end.vec3_sub(start);
    let length5 = lineDirection.vec3_length();
    lineDirection.vec3_normalize(lineDirection);
    let lineParentObject = parentObject.pp_addObject();
    let lineObject = lineParentObject.pp_addObject();
    let lineMesh = lineObject.pp_addComponent(MeshComponent12);
    lineMesh.mesh = Globals.getDefaultMeshes(this.engine).myCylinder;
    lineMesh.material = this._myLineMaterialFinal;
    lineParentObject.pp_setPositionLocal(start);
    let thickness = 1e-3 * this._myLineThicknessMultiplier;
    lineObject.pp_scaleObject(vec3_create(thickness / 2, length5 / 2, thickness / 2));
    lineObject.pp_setUpLocal(lineDirection);
    lineObject.pp_translateObject(vec3_create(0, length5 / 2, 0));
  }
  _addText(position, forward, up, parentObject) {
    let textObject = parentObject.pp_addObject();
    textObject.pp_setPositionLocal(position);
    textObject.pp_lookToLocal(up, forward);
    textObject.pp_scaleObject(0.0935 * this._myTextScaleMultiplier);
    let textComponent = textObject.pp_addComponent(TextComponent8);
    textComponent.alignment = Alignment5.Center;
    textComponent.justification = Justification5.Top;
    textComponent.material = this._myTextMaterialFinal;
    return textComponent;
  }
  _hideEmptySchemes() {
    if (this._mySelectText.length == 0) {
      this._mySelectObject.pp_setActive(false);
    }
    if (this._mySqueezeText.length == 0) {
      this._mySqueezeObject.pp_setActive(false);
    }
    if (this._myThumbstickText.length == 0) {
      this._myThumbstickObject.pp_setActive(false);
    }
    if (this._myBottomButtonText.length == 0) {
      this._myBottomButtonObject.pp_setActive(false);
    }
    if (this._myTopButtonText.length == 0) {
      this._myTopButtonObject.pp_setActive(false);
    }
  }
};

// dist/input/gamepad/gamepad_cores/virtual_gamepad_gamepad_core.js
var VirtualGamepadGamepadCore = class extends GamepadCore {
  constructor(virtualGamepad, handPose) {
    super(handPose);
    this._myVirtualGamepad = virtualGamepad;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this._myVirtualGamepad.isVisible();
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    if (this.isGamepadCoreActive()) {
      if (this._myVirtualGamepad.isButtonPressed(this.getHandedness(), buttonID)) {
        this._myButtonData.myPressed = true;
        this._myButtonData.myTouched = true;
        this._myButtonData.myValue = 1;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    if (this.isGamepadCoreActive()) {
      this._myVirtualGamepad.getAxes(this.getHandedness(), axesID, this._myAxesData);
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// dist/input/gamepad/virtual_gamepad/virtual_gamepad_icon.js
var VirtualGamepadIconType = {
  NONE: 0,
  LABEL: 1,
  IMAGE: 2,
  DOT: 3,
  CIRCLE: 4,
  SQUARE: 5,
  RING: 6,
  FRAME: 7
};
var VirtualGamepadIconParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myBackgroundPressedColor = "";
    this.myIconColor = "";
    this.myIconPressedColor = "";
    this.myIconType = VirtualGamepadIconType.NONE;
    this.myOverallHoveredBrightness = 1;
    this.myLabel = "";
    this.myLabelFontSize = 0;
    this.myLabelFontFamily = "";
    this.myLabelFontWeight = "";
    this.myImageURL = "";
    this.myImagePressedBrightness = 1;
  }
};
var VirtualGamepadIcon = class {
  constructor(iconElementParent, iconParams, minSizeMultiplier, scale4, engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myParams = iconParams;
    this._myIconContainerElement = null;
    this._myBackgroundElement = null;
    this._myIconElement = null;
    this._myPressed = false;
    this._myMouseHover = false;
    this._myMouseHoverEnabled = true;
    this._myDestroyed = false;
    this._build(iconElementParent, minSizeMultiplier, scale4);
  }
  update(dt) {
    if (this._myPressed || !this._myMouseHover || !this._myMouseHoverEnabled) {
      this._myIconContainerElement.style.filter = "none";
    } else {
      this._myIconContainerElement.style.filter = "brightness(" + this._myParams.myOverallHoveredBrightness + ")";
    }
  }
  reset() {
    this.setPressed(false);
    this._myMouseHover = false;
    this._myIconContainerElement.style.filter = "none";
  }
  setPressed(pressed) {
    if (this._myPressed != pressed) {
      this._myPressed = pressed;
      if (this._myPressed) {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundPressedColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconPressedColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconPressedColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "brightness(" + this._myParams.myImagePressedBrightness + ")";
          }
        }
      } else {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "none";
          }
        }
      }
    }
  }
  onMouseEnter() {
    this._myMouseHover = true;
  }
  onMouseLeave() {
    this._myMouseHover = false;
  }
  setMouseHoverEnabled(enabled) {
    this._myMouseHoverEnabled = enabled;
  }
  _build(iconElementParent, minSizeMultiplier, scale4) {
    this._myIconContainerElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
    this._myIconContainerElement.style.position = "absolute";
    this._myIconContainerElement.style.width = "100%";
    this._myIconContainerElement.style.height = "100%";
    iconElementParent.appendChild(this._myIconContainerElement);
    this._myBackgroundElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myBackgroundElement.setAttributeNS(null, "cx", "50%");
    this._myBackgroundElement.setAttributeNS(null, "cy", "50%");
    this._myBackgroundElement.setAttributeNS(null, "r", "50%");
    this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
    this._myIconContainerElement.appendChild(this._myBackgroundElement);
    switch (this._myParams.myIconType) {
      case VirtualGamepadIconType.NONE:
        break;
      case VirtualGamepadIconType.LABEL:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "text");
        this._myIconElement.setAttributeNS(null, "x", "50%");
        this._myIconElement.setAttributeNS(null, "y", "50%");
        this._myIconElement.style.textAlign = "center";
        this._myIconElement.style.textAnchor = "middle";
        this._myIconElement.style.dominantBaseline = "central";
        this._myIconElement.style.alignmentBaseline = "central";
        this._myIconElement.style.fontFamily = this._myParams.myLabelFontFamily;
        this._myIconElement.style.fontWeight = this._myParams.myLabelFontWeight;
        this._myIconElement.style.fontSize = this._createSizeValue(this._myParams.myLabelFontSize * scale4, minSizeMultiplier);
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.textContent = this._myParams.myLabel;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.IMAGE:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "image");
        this._myIconElement.setAttributeNS(null, "x", "0%");
        this._myIconElement.setAttributeNS(null, "y", "0%");
        this._myIconElement.setAttribute("href", this._myParams.myImageURL);
        this._myIconElement.style.width = "100%";
        this._myIconElement.style.height = "100%";
        this._myIconElement.style.filter = "none";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.DOT:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "17.5%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.CIRCLE:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "24%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.SQUARE:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "28%");
        this._myIconElement.setAttributeNS(null, "y", "28%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "44%");
        this._myIconElement.setAttributeNS(null, "height", "44%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.RING:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "20%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.FRAME:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "31.5%");
        this._myIconElement.setAttributeNS(null, "y", "31.5%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "37%");
        this._myIconElement.setAttributeNS(null, "height", "37%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _invertColors() {
    if (this._myIconElement.style.strokeWidth.length > 0) {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.stroke = this._myParams.myBackgroundColor;
    } else {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myBackgroundColor;
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myIconContainerElement.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/virtual_gamepad/virtual_gamepad_params.js
var VirtualGamepadButtonParams = class {
  constructor() {
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadThumbstickParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myMaxDistanceFromCenterMultiplier = 1;
    this.myReleaseTransitionSeconds = 0.2;
    this.myMoveTransitionSeconds = 0;
    this.myIncludeBackgroundToDetection = false;
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myShowOnDesktop = false;
    this.myShowOnMobile = false;
    this.myShowOnHeadset = false;
    this.myAutoUpdateVisibility = false;
    this.myOpacity = 1;
    this.myInterfaceScale = 1;
    this.myMarginScale = 1;
    this.myReleaseOnPointerLeave = true;
    this.myStopPropagatingMouseDownEvents = true;
    this.myButtonParams = [];
    this.myButtonParams[Handedness.LEFT] = [];
    this.myButtonParams[Handedness.RIGHT] = [];
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON] = new VirtualGamepadButtonParams();
    this.myThumbstickParams = [];
    this.myThumbstickParams[Handedness.LEFT] = [];
    this.myThumbstickParams[Handedness.RIGHT] = [];
    this.myThumbstickParams[Handedness.LEFT][GamepadAxesID.THUMBSTICK] = new VirtualGamepadThumbstickParams();
    this.myThumbstickParams[Handedness.RIGHT][GamepadAxesID.THUMBSTICK] = new VirtualGamepadThumbstickParams();
    this.myButtonsOrder = [];
    this.myButtonsOrder[Handedness.LEFT] = [null, null, null, null, null];
    this.myButtonsOrder[Handedness.RIGHT] = [null, null, null, null, null];
    this.myThumbsticksOrder = [];
    this.myThumbsticksOrder[Handedness.LEFT] = [null];
    this.myThumbsticksOrder[Handedness.RIGHT] = [null];
    this.myValidPointerButtons = [];
    this.myMarginLeft = 0;
    this.myMarginRight = 0;
    this.myMarginBottom = 0;
    this.myThumbstickSize = 0;
    this.myButtonSize = 0;
    this.myButtonsRingRadius = 0;
    this.myButtonsRingStartAngle = 0;
    this.myButtonsRingEndAngle = 0;
    this.myFontSize = 0;
    this.myMinSizeMultiplier = 0;
    this.myDisableMouseHoverWhenPressed = false;
    this.myEngine = engine;
  }
  defaultConfig() {
    this.myShowOnMobile = true;
    this.myAutoUpdateVisibility = true;
    this.myOpacity = 0.5;
    let backgroundColor = "#616161";
    let iconColor = "#e0e0e0";
    let buttonHoveredBrightness = 0.75;
    let thumbstickHoveredBrightness = 0.75;
    let thumbstickIncludeBackgroundToDetection = true;
    for (let handedness in this.myButtonParams) {
      for (let gamepadButtonID in this.myButtonParams[handedness]) {
        let buttonParams = this.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = backgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = iconColor;
        buttonParams.myIconParams.myIconColor = iconColor;
        buttonParams.myIconParams.myIconPressedColor = backgroundColor;
        buttonParams.myIconParams.myOverallHoveredBrightness = buttonHoveredBrightness;
      }
    }
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    for (let handedness in this.myThumbstickParams) {
      for (let gamepadAxesID in this.myThumbstickParams[handedness]) {
        let thumbstickParams = this.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = backgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = iconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = iconColor;
        thumbstickParams.myIconParams.myIconColor = backgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = backgroundColor;
        thumbstickParams.myIconParams.myOverallHoveredBrightness = thumbstickHoveredBrightness;
        thumbstickParams.myIncludeBackgroundToDetection = thumbstickIncludeBackgroundToDetection;
      }
    }
    this.myButtonsOrder[Handedness.LEFT][0] = [Handedness.LEFT, GamepadButtonID.SQUEEZE];
    this.myButtonsOrder[Handedness.LEFT][1] = [Handedness.LEFT, GamepadButtonID.SELECT];
    this.myButtonsOrder[Handedness.LEFT][2] = [Handedness.LEFT, GamepadButtonID.TOP_BUTTON];
    this.myButtonsOrder[Handedness.LEFT][3] = [Handedness.LEFT, GamepadButtonID.BOTTOM_BUTTON];
    this.myButtonsOrder[Handedness.LEFT][4] = [Handedness.LEFT, GamepadButtonID.THUMBSTICK];
    this.myButtonsOrder[Handedness.RIGHT][0] = [Handedness.RIGHT, GamepadButtonID.SQUEEZE];
    this.myButtonsOrder[Handedness.RIGHT][1] = [Handedness.RIGHT, GamepadButtonID.SELECT];
    this.myButtonsOrder[Handedness.RIGHT][2] = [Handedness.RIGHT, GamepadButtonID.TOP_BUTTON];
    this.myButtonsOrder[Handedness.RIGHT][3] = [Handedness.RIGHT, GamepadButtonID.BOTTOM_BUTTON];
    this.myButtonsOrder[Handedness.RIGHT][4] = [Handedness.RIGHT, GamepadButtonID.THUMBSTICK];
    this.myThumbsticksOrder[Handedness.LEFT][0] = [Handedness.LEFT, GamepadAxesID.THUMBSTICK];
    this.myThumbsticksOrder[Handedness.RIGHT][0] = [Handedness.RIGHT, GamepadAxesID.THUMBSTICK];
    this.myMarginLeft = 3;
    this.myMarginRight = 3;
    this.myMarginBottom = 3;
    this.myThumbstickSize = 15;
    this.myButtonSize = 5;
    this.myButtonsRingRadius = 12;
    this.myButtonsRingStartAngle = 385;
    this.myButtonsRingEndAngle = 245;
    this.myMinSizeMultiplier = 5 / 3;
    this.myDisableMouseHoverWhenPressed = true;
    this.myValidPointerButtons = [0];
  }
};

// dist/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_button.js
var VirtualGamepadVirtualButton = class {
  constructor(buttonElementParent, virtualGamepadParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
    this._myButtonElement = null;
    this._myButtonIcon = null;
    this._myButtonDetectionElement = null;
    this._myActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myButtonParams[gamepadButtonHandedness][gamepadButtonID];
    this._build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex);
    this._myPointerDownEventListener = this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents);
    this._myPointerUpEventListener = this._onPointerUp.bind(this);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    this._myMouseEnterEventListener = this._onButtonEnter.bind(this);
    this._myMouseLeaveEventListener = this._onButtonLeave.bind(this);
    this._myButtonDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerup", this._myPointerUpEventListener);
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerleave", this._myPointerLeaveEventListener);
    }
    this._myButtonDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myButtonDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
    this._myDestroyed = false;
  }
  isPressed() {
    return this._myActive && this._myPressed;
  }
  setActive(active) {
    if (this._myActive != active) {
      this.reset();
      this._myButtonIcon.reset();
    }
    this._myActive = active;
  }
  setMouseHoverEnabled(hoverActive) {
    this._myButtonIcon.setMouseHoverEnabled(hoverActive);
  }
  reset() {
    this._myButtonIcon.setPressed(false);
    this._myPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
  }
  update(dt) {
    this._myButtonIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myActive)
      return;
    if (this._myPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myButtonIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onButtonEnter(event) {
    if (!this._myActive)
      return;
    this._myButtonIcon.onMouseEnter(event);
  }
  _onButtonLeave(event) {
    if (!this._myActive)
      return;
    this._myButtonIcon.onMouseLeave(event);
  }
  _build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex) {
    let buttonSize = this._myVirtualGamepadParams.myButtonSize * this._myVirtualGamepadParams.myInterfaceScale;
    let buttonsRingRadius = this._myVirtualGamepadParams.myButtonsRingRadius * this._myVirtualGamepadParams.myInterfaceScale;
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let buttonRingStartAngle = this._myVirtualGamepadParams.myButtonsRingStartAngle;
    let buttonRingEndAngle = this._myVirtualGamepadParams.myButtonsRingEndAngle;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    let buttonsAmount = this._myVirtualGamepadParams.myButtonsOrder[Handedness.LEFT].length;
    let angleStep = (buttonRingEndAngle - buttonRingStartAngle) / (buttonsAmount - 1);
    let currentAngle = Math.pp_angleClamp(buttonRingStartAngle + angleStep * virtualButtonIndex);
    if (virtualButtonHandedness == Handedness.RIGHT) {
      currentAngle = 270 + (270 - currentAngle);
      currentAngle = Math.pp_angleClamp(currentAngle, true);
    }
    let counterAngle = 360 - currentAngle;
    this._myButtonContainer = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myButtonContainer.style.position = "absolute";
    this._myButtonContainer.style.width = this._createSizeValue(buttonSize, minSizeMultiplier);
    this._myButtonContainer.style.height = this._createSizeValue(buttonSize, minSizeMultiplier);
    let centerOnThumbstickBottom = marginBottom + thumbstickSize / 2 - buttonSize / 2;
    this._myButtonContainer.style.bottom = this._createSizeValue(centerOnThumbstickBottom, minSizeMultiplier);
    if (virtualButtonHandedness == Handedness.LEFT) {
      let centerOnThumbstickLeft = marginLeft + thumbstickSize / 2 - buttonSize / 2;
      this._myButtonContainer.style.left = this._createSizeValue(centerOnThumbstickLeft, minSizeMultiplier);
    } else {
      let centerOnThumbstickRight = marginRight + thumbstickSize / 2 - buttonSize / 2;
      this._myButtonContainer.style.right = this._createSizeValue(centerOnThumbstickRight, minSizeMultiplier);
    }
    this._myButtonContainer.style.transform = "rotate(" + currentAngle + "deg) translateX(" + this._createSizeValue(buttonsRingRadius, minSizeMultiplier) + ")";
    buttonElementParent.appendChild(this._myButtonContainer);
    this._myButtonElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myButtonElement.style.position = "absolute";
    this._myButtonElement.style.width = "100%";
    this._myButtonElement.style.height = "100%";
    this._myButtonElement.style.transform = "rotate(" + counterAngle + "deg)";
    this._myButtonContainer.appendChild(this._myButtonElement);
    this._myButtonIcon = new VirtualGamepadIcon(this._myButtonElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myInterfaceScale, this._myVirtualGamepadParams.myEngine);
    let buttonElementStill = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    buttonElementStill.style.position = "absolute";
    buttonElementStill.style.width = "100%";
    buttonElementStill.style.height = "100%";
    buttonElementStill.style.transform = "rotate(" + counterAngle + "deg)";
    this._myButtonContainer.appendChild(buttonElementStill);
    let buttonDetectionElementSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
    buttonDetectionElementSVG.style.position = "absolute";
    buttonDetectionElementSVG.style.width = "100%";
    buttonDetectionElementSVG.style.height = "100%";
    buttonElementStill.appendChild(buttonDetectionElementSVG);
    let buttonDetectionElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
    buttonDetectionElement.setAttributeNS(null, "cx", "50%");
    buttonDetectionElement.setAttributeNS(null, "cy", "50%");
    buttonDetectionElement.setAttributeNS(null, "r", "50%");
    buttonDetectionElement.style.fill = "#00000000";
    buttonDetectionElementSVG.appendChild(buttonDetectionElement);
    this._myButtonDetectionElement = buttonDetectionElement;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  destroy() {
    this._myDestroyed = true;
    this._myButtonDetectionElement.removeEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerleave", this._myPointerLeaveEventListener);
    this._myButtonDetectionElement.removeEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myButtonDetectionElement.removeEventListener("mouseleave", this._myPointerUpEventLis_myMouseLeaveEventListenertener);
    this._myButtonIcon.destroy();
    this._myButtonContainer.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_thumbstick.js
var VirtualGamepadVirtualThumbstick = class {
  constructor(thumbstickElementParent, virtualGamepadParams, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID) {
    this._myThumbstickElement = null;
    this._myThumbstickIcon = null;
    this._myThumbstickBackground = null;
    this._myThumbstickDetectionElement = null;
    this._myActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickDragStartPosition = vec2_create();
    this._myAxes = vec2_create();
    this._myPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myThumbstickParams[gamepadThumbstickHandedness][gamepadAxesID];
    this._build(thumbstickElementParent, virtualThumbstickHandedness);
    this._myPointerDownEventListener = this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents);
    this._myPointerUpEventListener = this._onPointerUp.bind(this);
    this._myPointerMoveEventListener = this._onPointerMove.bind(this);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    this._myMouseEnterEventListener = this._onThumbstickEnter.bind(this);
    this._myMouseLeaveEventListener = this._onThumbstickLeave.bind(this);
    this._myThumbstickDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointermove", this._myPointerMoveEventListener);
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerleave", this._myPointerLeaveEventListener);
    }
    this._myThumbstickDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myThumbstickDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
    this._myDestroyed = false;
  }
  isPressed() {
    return this._myActive && this._myPressed;
  }
  getAxes() {
    return this._myAxes;
  }
  setActive(active) {
    if (this._myActive != active) {
      this.reset();
      this._myThumbstickIcon.reset();
    }
    this._myActive = active;
  }
  setMouseHoverEnabled(hoverActive) {
    this._myThumbstickIcon.setMouseHoverEnabled(hoverActive);
  }
  reset() {
    this._myThumbstickIcon.setPressed(false);
    this._myAxes[0] = 0;
    this._myAxes[1] = 0;
    this._myPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickElement.style.transition = "all " + this._myParams.myReleaseTransitionSeconds + "s ease 0s";
    this._myThumbstickElement.style.transform = "translate(0px, 0px)";
  }
  update(dt) {
    this._myThumbstickIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myActive)
      return;
    if (this._myPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myThumbstickIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myThumbstickDragStartPosition[0] = event.clientX;
    this._myThumbstickDragStartPosition[1] = event.clientY;
    this._myPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onThumbstickEnter(event) {
    this._myThumbstickIcon.onMouseEnter(event);
  }
  _onThumbstickLeave(event) {
    this._myThumbstickIcon.onMouseLeave(event);
  }
  _onPointerMove(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (event.pointerId != this._myPointerID)
      return;
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let backgroundRect = this._myThumbstickBackground.getBoundingClientRect();
    let maxDistanceFromCenter = backgroundRect.width / 2 * this._myParams.myMaxDistanceFromCenterMultiplier;
    let xDiff = mouseX - this._myThumbstickDragStartPosition[0];
    let yDiff = mouseY - this._myThumbstickDragStartPosition[1];
    let angle2 = Math.atan2(yDiff, xDiff);
    let distanceFromDragStart = Math.min(maxDistanceFromCenter, Math.hypot(xDiff, yDiff));
    let translateThumbstickX = distanceFromDragStart * Math.cos(angle2);
    let translateThumbstickY = distanceFromDragStart * Math.sin(angle2);
    this._myThumbstickElement.style.transition = "all " + this._myParams.myMoveTransitionSeconds + "s ease-out 0s";
    this._myThumbstickElement.style.transform = "translate(" + translateThumbstickX + "px, " + translateThumbstickY + "px)";
    this._myAxes[0] = translateThumbstickX / maxDistanceFromCenter;
    this._myAxes[1] = -(translateThumbstickY / maxDistanceFromCenter);
  }
  _build(thumbstickElementParent, virtualThumbstickHandedness) {
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    this._myThumbstickContainer = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myThumbstickContainer.style.position = "absolute";
    this._myThumbstickContainer.style.width = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    this._myThumbstickContainer.style.height = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    this._myThumbstickContainer.style.bottom = this._createSizeValue(marginBottom, minSizeMultiplier);
    if (virtualThumbstickHandedness == Handedness.LEFT) {
      this._myThumbstickContainer.style.left = this._createSizeValue(marginLeft, minSizeMultiplier);
    } else {
      this._myThumbstickContainer.style.right = this._createSizeValue(marginRight, minSizeMultiplier);
    }
    thumbstickElementParent.appendChild(this._myThumbstickContainer);
    let thumbstickContainerSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
    thumbstickContainerSVG.style.position = "absolute";
    thumbstickContainerSVG.style.width = "100%";
    thumbstickContainerSVG.style.height = "100%";
    this._myThumbstickContainer.appendChild(thumbstickContainerSVG);
    this._myThumbstickBackground = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myThumbstickBackground.setAttributeNS(null, "cx", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "cy", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "r", "48%");
    this._myThumbstickBackground.style.fill = this._myParams.myBackgroundColor;
    thumbstickContainerSVG.appendChild(this._myThumbstickBackground);
    this._myThumbstickElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myThumbstickElement.style.position = "absolute";
    this._myThumbstickElement.style.width = "34%";
    this._myThumbstickElement.style.height = "34%";
    this._myThumbstickElement.style.top = "33%";
    this._myThumbstickElement.style.left = "33%";
    this._myThumbstickContainer.appendChild(this._myThumbstickElement);
    this._myThumbstickIcon = new VirtualGamepadIcon(this._myThumbstickElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myScale, this._myVirtualGamepadParams.myEngine);
    if (this._myParams.myIncludeBackgroundToDetection) {
      let thumbstickBackgroundDetectionElementSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickBackgroundDetectionElementSVG.style.position = "absolute";
      thumbstickBackgroundDetectionElementSVG.style.width = "100%";
      thumbstickBackgroundDetectionElementSVG.style.height = "100%";
      this._myThumbstickContainer.appendChild(thumbstickBackgroundDetectionElementSVG);
      let thumbstickBackgroundDetectionElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "r", "48%");
      thumbstickBackgroundDetectionElement.style.fill = "#00000000";
      thumbstickBackgroundDetectionElementSVG.appendChild(thumbstickBackgroundDetectionElement);
      this._myThumbstickDetectionElement = thumbstickBackgroundDetectionElement;
    } else {
      let thumbstickElementStill = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
      thumbstickElementStill.style.position = "absolute";
      thumbstickElementStill.style.width = "34%";
      thumbstickElementStill.style.height = "34%";
      thumbstickElementStill.style.top = "33%";
      thumbstickElementStill.style.left = "33%";
      this._myThumbstickContainer.appendChild(thumbstickElementStill);
      let thumbstickDetectionElementSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickDetectionElementSVG.style.position = "absolute";
      thumbstickDetectionElementSVG.style.width = "100%";
      thumbstickDetectionElementSVG.style.height = "100%";
      thumbstickElementStill.appendChild(thumbstickDetectionElementSVG);
      let thumbstickDetectionElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "r", "50%");
      thumbstickDetectionElement.style.fill = "#00000000";
      thumbstickDetectionElementSVG.appendChild(thumbstickDetectionElement);
      this._myThumbstickDetectionElement = thumbstickDetectionElement;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  destroy() {
    this._myDestroyed = true;
    this._myThumbstickDetectionElement.removeEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointermove", this._myPointerMoveEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerleave", this._myPointerLeaveEventListener);
    this._myThumbstickDetectionElement.removeEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myThumbstickDetectionElement.removeEventListener("mouseleave", this._myPointerUpEventLis_myMouseLeaveEventListenertener);
    this._myThumbstickIcon.destroy();
    this._myThumbstickContainer.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/virtual_gamepad/virtual_gamepad.js
var VirtualGamepad = class {
  constructor(params = new VirtualGamepadParams()) {
    this._myParams = params;
    this._myVisible = true;
    this._myVirtualGamepadContainer = null;
    this._myVirtualGamepadVirtualButtons = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.SELECT] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.SQUEEZE] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.TOP_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.SELECT] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.SQUEEZE] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON] = null;
    this._myButtonsAmount = this._myVirtualGamepadVirtualButtons[Handedness.LEFT].length;
    this._myVirtualGamepadVirtualThumbsticks = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT][GamepadAxesID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT][GamepadAxesID.THUMBSTICK] = null;
    this._myGestureStartEventListener = null;
    this._myDestroyed = false;
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVirtualGamepadContainer != null) {
        if (this._myVisible) {
          this._myVirtualGamepadContainer.style.display = "block";
        } else {
          this._myVirtualGamepadContainer.style.display = "none";
        }
        for (let handedness in this._myVirtualGamepadVirtualButtons) {
          for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
            let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
            if (button != null) {
              button.setActive(this._myVisible);
            }
          }
        }
        for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
          for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
            let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
            if (thumbstick != null) {
              thumbstick.setActive(this._myVisible);
            }
          }
        }
      }
    }
  }
  isButtonPressed(handedness, gamepadButtonID) {
    if (!this._myVisible)
      return false;
    let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
    if (button != null) {
      return button.isPressed();
    }
    return false;
  }
  getAxes(handedness, gamepadAxesID, outAxes = vec2_create(0, 0)) {
    if (!this._myVisible)
      return outAxes;
    let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
    if (thumbstick != null) {
      outAxes.vec2_copy(thumbstick.getAxes());
    }
    return outAxes;
  }
  start() {
    this._buildVirtualGamepad();
    let currentVisible = this._myVisible;
    this._myVisible = !this._myVisible;
    this.setVisible(currentVisible);
  }
  update(dt) {
    if (this._myParams.myAutoUpdateVisibility) {
      if (XRUtils.isSessionActive(this._myParams.myEngine) && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(false);
      } else if (this._myParams.myShowOnDesktop && BrowserUtils.isDesktop() && !XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnHeadset && BrowserUtils.isDesktop() && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnMobile && BrowserUtils.isMobile()) {
        this.setVisible(true);
      } else {
        this.setVisible(false);
      }
    }
    if (this._myVisible) {
      for (let handedness in this._myVirtualGamepadVirtualButtons) {
        for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
          let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
          if (button != null) {
            button.update(dt);
          }
        }
      }
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
          if (thumbstick != null) {
            thumbstick.update(dt);
          }
        }
      }
      this._setMouseHoverEnabled(!(this._myParams.myDisableMouseHoverWhenPressed && this._isAnyElementPressed()));
    }
  }
  _buildVirtualGamepad() {
    this._setupDocumentBody();
    this._myVirtualGamepadContainer = Globals.getDocument(this._myParams.myEngine).createElement("div");
    this._myVirtualGamepadContainer.style.display = "block";
    this._myVirtualGamepadContainer.style.opacity = this._myParams.myOpacity.toString();
    Globals.getBody(this._myParams.myEngine).appendChild(this._myVirtualGamepadContainer);
    let leftDiv = Globals.getDocument(this._myParams.myEngine).createElement("div");
    this._myVirtualGamepadContainer.appendChild(leftDiv);
    let rightDiv = Globals.getDocument(this._myParams.myEngine).createElement("div");
    this._myVirtualGamepadContainer.appendChild(rightDiv);
    let buttonsAmount = this._myParams.myButtonsOrder[Handedness.LEFT].length;
    for (let i = 0; i < buttonsAmount; i++) {
      if (this._myParams.myButtonsOrder[Handedness.LEFT][i] != null) {
        let gamepadButtonHandedness = this._myParams.myButtonsOrder[Handedness.LEFT][i][0];
        let gamepadButtonID = this._myParams.myButtonsOrder[Handedness.LEFT][i][1];
        this._buildButton(leftDiv, Handedness.LEFT, i, gamepadButtonHandedness, gamepadButtonID);
      }
      if (this._myParams.myButtonsOrder[Handedness.RIGHT][i] != null) {
        let gamepadButtonHandedness = this._myParams.myButtonsOrder[Handedness.RIGHT][i][0];
        let gamepadButtonID = this._myParams.myButtonsOrder[Handedness.RIGHT][i][1];
        this._buildButton(rightDiv, Handedness.RIGHT, i, gamepadButtonHandedness, gamepadButtonID);
      }
    }
    let thumbsticksAmount = this._myParams.myThumbsticksOrder[Handedness.LEFT].length;
    for (let i = 0; i < thumbsticksAmount; i++) {
      if (this._myParams.myThumbsticksOrder[Handedness.LEFT][i] != null) {
        let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[Handedness.LEFT][i][0];
        let gamepadAxesID = this._myParams.myThumbsticksOrder[Handedness.LEFT][i][1];
        this._buildThumbstick(leftDiv, Handedness.LEFT, gamepadThumbstickHandedness, gamepadAxesID);
      }
      if (this._myParams.myThumbsticksOrder[Handedness.RIGHT][i] != null) {
        let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[Handedness.RIGHT][i][0];
        let gamepadAxesID = this._myParams.myThumbsticksOrder[Handedness.RIGHT][i][1];
        this._buildThumbstick(rightDiv, Handedness.RIGHT, gamepadThumbstickHandedness, gamepadAxesID);
      }
    }
  }
  _setupDocumentBody() {
    Globals.getBody(this._myParams.myEngine).style.overflow = "hidden";
    Globals.getBody(this._myParams.myEngine).style.userSelect = "none";
    Globals.getBody(this._myParams.myEngine).style.webkitUserSelect = "none";
    Globals.getBody(this._myParams.myEngine).style.webkitTapHighlightColor = "transparent";
    Globals.getBody(this._myParams.myEngine).style.touchAction = "none";
    this._myGestureStartEventListener = function(e) {
      e.preventDefault();
    };
    Globals.getDocument(this._myParams.myEngine).addEventListener("gesturestart", this._myGestureStartEventListener);
  }
  _buildButton(buttonElementParent, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
    let virtualGamepadVirtualButton = new VirtualGamepadVirtualButton(buttonElementParent, this._myParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID);
    this._myVirtualGamepadVirtualButtons[gamepadButtonHandedness][gamepadButtonID] = virtualGamepadVirtualButton;
  }
  _buildThumbstick(thumbstickElementParent, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID) {
    let virtualGamepadVirtualThumbstick = new VirtualGamepadVirtualThumbstick(thumbstickElementParent, this._myParams, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID);
    this._myVirtualGamepadVirtualThumbsticks[gamepadThumbstickHandedness][gamepadAxesID] = virtualGamepadVirtualThumbstick;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _isAnyElementPressed() {
    let anyElementPressed = false;
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null && button.isPressed()) {
          anyElementPressed = true;
          break;
        }
      }
    }
    if (!anyElementPressed) {
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
          if (thumbstick != null && thumbstick.isPressed()) {
            anyElementPressed = true;
            break;
          }
        }
      }
    }
    return anyElementPressed;
  }
  _setMouseHoverEnabled(hoverActive) {
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null) {
          button.setMouseHoverEnabled(hoverActive);
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
        if (thumbstick != null) {
          thumbstick.setMouseHoverEnabled(hoverActive);
        }
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getDocument(this._myParams.myEngine).removeEventListener("gesturestart", this._myGestureStartEventListener);
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null) {
          button.destroy();
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
        if (thumbstick != null) {
          thumbstick.destroy();
        }
      }
    }
    this._myVirtualGamepadContainer.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/input/gamepad/virtual_gamepad/virtual_gamepad_component.js
import { Component as Component44, Property as Property38 } from "@wonderlandengine/api";
var VirtualGamepadComponent = class extends Component44 {
  static TypeName = "pp-virtual-gamepad";
  static Properties = {
    _myShowOnDesktop: Property38.bool(false),
    // You may have to enable headset too
    _myShowOnMobile: Property38.bool(true),
    _myShowOnHeadset: Property38.bool(false),
    // Not 100% reliable, this is true if the device supports XR and it is Desktop
    _myAddToUniversalGamepad: Property38.bool(true),
    _myOpacity: Property38.float(0.5),
    _myIconColor: Property38.string("#e0e0e0"),
    _myBackgroundColor: Property38.string("#616161"),
    _myInterfaceScale: Property38.float(1),
    _myMarginScale: Property38.float(1),
    ADVANCED_PARAMS_BELOW: Property38.string(""),
    _myLabelFontSize: Property38.float(2),
    _myLabelFontFamily: Property38.string("sans-serif"),
    _myLabelFontWeight: Property38.string("bold"),
    _myImagePressedBrightness: Property38.float(0.5),
    _myLeftSelectButtonVisible: Property38.bool(true),
    _myLeftSelectButtonOrderIndex: Property38.int(1),
    _myLeftSelectButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
    _myLeftSelectButtonIconLabelOrImageUrl: Property38.string(""),
    _myLeftSqueezeButtonVisible: Property38.bool(true),
    _myLeftSqueezeButtonOrderIndex: Property38.int(0),
    _myLeftSqueezeButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
    _myLeftSqueezeButtonIconLabelOrImageUrl: Property38.string(""),
    _myLeftThumbstickButtonVisible: Property38.bool(true),
    _myLeftThumbstickButtonOrderIndex: Property38.int(4),
    _myLeftThumbstickButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
    _myLeftThumbstickButtonIconLabelOrImageUrl: Property38.string(""),
    _myLeftTopButtonVisible: Property38.bool(true),
    _myLeftTopButtonOrderIndex: Property38.int(2),
    _myLeftTopButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
    _myLeftTopButtonIconLabelOrImageUrl: Property38.string(""),
    _myLeftBottomButtonVisible: Property38.bool(true),
    _myLeftBottomButtonOrderIndex: Property38.int(3),
    _myLeftBottomButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
    _myLeftBottomButtonIconLabelOrImageUrl: Property38.string(""),
    _myRightSelectButtonVisible: Property38.bool(true),
    _myRightSelectButtonOrderIndex: Property38.int(1),
    _myRightSelectButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
    _myRightSelectButtonIconLabelOrImageUrl: Property38.string(""),
    _myRightSqueezeButtonVisible: Property38.bool(true),
    _myRightSqueezeButtonOrderIndex: Property38.int(0),
    _myRightSqueezeButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
    _myRightSqueezeButtonIconLabelOrImageUrl: Property38.string(""),
    _myRightThumbstickButtonVisible: Property38.bool(true),
    _myRightThumbstickButtonOrderIndex: Property38.int(4),
    _myRightThumbstickButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
    _myRightThumbstickButtonIconLabelOrImageUrl: Property38.string(""),
    _myRightTopButtonVisible: Property38.bool(true),
    _myRightTopButtonOrderIndex: Property38.int(2),
    _myRightTopButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
    _myRightTopButtonIconLabelOrImageUrl: Property38.string(""),
    _myRightBottomButtonVisible: Property38.bool(true),
    _myRightBottomButtonOrderIndex: Property38.int(3),
    _myRightBottomButtonIconType: Property38.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
    _myRightBottomButtonIconLabelOrImageUrl: Property38.string("")
  };
  start() {
    let params = new VirtualGamepadParams(this.engine);
    params.defaultConfig();
    for (let handedness in params.myButtonParams) {
      for (let gamepadButtonID in params.myButtonParams[handedness]) {
        let buttonParams = params.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = this._myBackgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        buttonParams.myIconParams.myIconColor = this._myIconColor;
        buttonParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    for (let handedness in params.myThumbstickParams) {
      for (let gamepadAxesID in params.myThumbstickParams[handedness]) {
        let thumbstickParams = params.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = this._myIconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        thumbstickParams.myIconParams.myIconColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    params.myOpacity = this._myOpacity;
    params.myInterfaceScale = this._myInterfaceScale;
    params.myMarginScale = this._myMarginScale;
    params.myShowOnDesktop = this._myShowOnDesktop;
    params.myShowOnMobile = this._myShowOnMobile;
    params.myShowOnHeadset = this._myShowOnHeadset;
    if (params.myShowOnDesktop || params.myShowOnMobile || params.myShowOnHeadset) {
      params.myAutoUpdateVisibility = true;
    } else {
      params.myAutoUpdateVisibility = false;
    }
    this._advancedConfig(params);
    this._myVirtualGamepad = new VirtualGamepad(params);
    this._myVirtualGamepad.setVisible(false);
    this._myVirtualGamepad.start();
    this._myFirstUpdate = true;
    this._myLeftVirtualGamepadGamepadCore = null;
    this._myRightVirtualGamepadGamepadCore = null;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      if (this._myAddToUniversalGamepad) {
        this._myLeftVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, Globals.getLeftGamepad(this.engine).getGamepadCore("pp_left_xr_gamepad").getHandPose());
        this._myRightVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, Globals.getRightGamepad(this.engine).getGamepadCore("pp_right_xr_gamepad").getHandPose());
        Globals.getLeftGamepad(this.engine).addGamepadCore("pp_left_virtual_gamepad", this._myLeftVirtualGamepadGamepadCore);
        Globals.getRightGamepad(this.engine).addGamepadCore("pp_right_virtual_gamepad", this._myRightVirtualGamepadGamepadCore);
      }
    }
    this._myVirtualGamepad.update(dt);
  }
  _advancedConfig(params) {
    params.myButtonsOrder[Handedness.LEFT] = [null, null, null, null, null];
    params.myButtonsOrder[Handedness.RIGHT] = [null, null, null, null, null];
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT];
      buttonParams.myIconParams.myIconType = this._myLeftSelectButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSelectButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSelectButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftSelectButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftSelectButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.SELECT];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE];
      buttonParams.myIconParams.myIconType = this._myLeftSqueezeButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSqueezeButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSqueezeButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftSqueezeButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftSqueezeButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.SQUEEZE];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK];
      buttonParams.myIconParams.myIconType = this._myLeftThumbstickButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftThumbstickButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftThumbstickButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.THUMBSTICK];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftTopButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftTopButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftTopButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.TOP_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftBottomButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftBottomButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftBottomButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.BOTTOM_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT];
      buttonParams.myIconParams.myIconType = this._myRightSelectButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSelectButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSelectButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightSelectButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightSelectButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.SELECT];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE];
      buttonParams.myIconParams.myIconType = this._myRightSqueezeButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSqueezeButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSqueezeButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightSqueezeButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightSqueezeButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.SQUEEZE];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK];
      buttonParams.myIconParams.myIconType = this._myRightThumbstickButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightThumbstickButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightThumbstickButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.THUMBSTICK];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightTopButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightTopButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightTopButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.TOP_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightBottomButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightBottomButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightBottomButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.BOTTOM_BUTTON];
      }
    }
  }
  onDestroy() {
    Globals.getLeftGamepad(this.engine)?.removeGamepadCore("pp_left_virtual_gamepad");
    Globals.getRightGamepad(this.engine)?.removeGamepadCore("pp_right_virtual_gamepad");
    this._myLeftVirtualGamepadGamepadCore.destroy();
    this._myRightVirtualGamepadGamepadCore.destroy();
    this._myVirtualGamepad.destroy();
  }
};

// dist/input/pose/components/set_player_height_component.js
import { Component as Component45, Property as Property39 } from "@wonderlandengine/api";
var SetPlayerHeightComponent = class extends Component45 {
  static TypeName = "pp-set-player-height";
  static Properties = {
    _myEyesHeight: Property39.float(1.65),
    _mySetOnlyOnStart: Property39.bool(false)
  };
  start() {
    let localPosition = this.object.pp_getPositionLocal();
    this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
    this._myHeightSetOnce = false;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.engine);
  }
  _onXRSessionStart() {
    if (this.active && (!this._mySetOnlyOnStart || !this._myHeightSetOnce)) {
      let localPosition = this.object.pp_getPositionLocal();
      if (XRUtils.isReferenceSpaceFloorBased(this.engine)) {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], 0, localPosition[2]));
      } else {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
      }
      this._myHeightSetOnce = true;
    }
  }
  _onXRSessionEnd() {
    if (this.active && !this._mySetOnlyOnStart) {
      let localPosition = this.object.pp_getPositionLocal();
      this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
    }
  }
};

// dist/input/pose/components/set_hand_local_transform_component.js
import { Component as Component46, Property as Property40 } from "@wonderlandengine/api";
var SetHandLocalTransformComponent = class extends Component46 {
  static TypeName = "pp-set-hand-local-transform";
  static Properties = {
    _myHandedness: Property40.enum(["Left", "Right"], "Left")
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    Globals.getHandPose(this._myHandednessType, this.engine).registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  onPoseUpdated(dt, pose) {
  }
  onDestroy() {
    Globals.getHandPose(this._myHandednessType, this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};
SetHandLocalTransformComponent.prototype.onPoseUpdated = function() {
  let handPoseTransform = quat2_create();
  return function onPoseUpdated(dt, pose) {
    if (this.active) {
      if (XRUtils.isSessionActive(this.engine)) {
        if (pose.isValid()) {
          this.object.pp_setTransformLocalQuat(pose.getTransformQuat(handPoseTransform, null));
        }
      }
    }
  };
}();

// dist/input/pose/components/set_head_local_transform_component.js
import { Component as Component47 } from "@wonderlandengine/api";
var SetHeadLocalTransformComponent = class extends Component47 {
  static TypeName = "pp-set-head-local-transform";
  static Properties = {};
  start() {
    Globals.getHeadPose(this.engine).registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  onPoseUpdated(dt, pose) {
  }
  onDestroy() {
    Globals.getHeadPose(this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};
SetHeadLocalTransformComponent.prototype.onPoseUpdated = function() {
  let cameraNonXRRotation = quat_create();
  let cameraNonXRUp = vec3_create();
  let cameraNonXRPosition = vec3_create();
  let headPoseTransform = quat2_create();
  return function onPoseUpdated(dt, pose) {
    if (this.active) {
      if (!XRUtils.isSessionActive(this.engine)) {
        let cameraNonXR = Globals.getPlayerObjects(this.engine).myCameraNonXR;
        cameraNonXRRotation = cameraNonXR.pp_getRotationLocalQuat(cameraNonXRRotation);
        if (Globals.isPoseForwardFixed(this.engine)) {
          cameraNonXRRotation.quat_rotateAxisRadians(Math.PI, cameraNonXRRotation.quat_getUp(cameraNonXRUp), cameraNonXRRotation);
        }
        this.object.pp_setPositionLocal(cameraNonXR.pp_getPositionLocal(cameraNonXRPosition));
        this.object.pp_setRotationLocalQuat(cameraNonXRRotation);
      } else {
        if (pose.isValid()) {
          this.object.pp_setTransformLocalQuat(pose.getTransformQuat(headPoseTransform, null));
        }
      }
    }
  };
}();

// dist/input/pose/components/set_tracked_hand_joint_local_transform_component.js
import { Component as Component48, Property as Property41 } from "@wonderlandengine/api";
var SetTrackedHandJointLocalTransformComponent = class extends Component48 {
  static TypeName = "pp-set-tracked-hand-joint-local-transform";
  static Properties = {
    _myHandedness: Property41.enum(["Left", "Right"], "Left"),
    _mySetLocalScaleAsJointRadius: Property41.bool(false),
    _myJointID: Property41.enum([
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ], "Wrist")
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDType = InputUtils.getJointIDByIndex(this._myJointID);
    Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(this._myJointIDType).registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  onPoseUpdated(dt, pose) {
  }
  onDestroy() {
    Globals.getTrackedHandPose(this._myHandednessType, this.engine)?.getJointPose(this._myJointIDType)?.unregisterPoseUpdatedEventListener(this);
  }
};
SetTrackedHandJointLocalTransformComponent.prototype.onPoseUpdated = function() {
  let jointPoseTransform = quat2_create();
  return function onPoseUpdated(dt, pose) {
    if (this.active) {
      if (XRUtils.isSessionActive(this.engine)) {
        if (pose.isValid()) {
          this.object.pp_setTransformLocalQuat(pose.getTransformQuat(jointPoseTransform, null));
          if (this._mySetLocalScaleAsJointRadius) {
            this.object.pp_setScaleLocal(pose.getJointRadius());
          }
        }
      }
    }
  };
}();

// dist/input/pose/components/copy_hand_transform_component.js
import { Component as Component49, Property as Property42 } from "@wonderlandengine/api";
var CopyHandTransformComponent = class extends Component49 {
  static TypeName = "pp-copy-hand-transform";
  static Properties = {
    _myHandedness: Property42.enum(["Left", "Right"], "Left")
  };
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
  }
  update(dt) {
    let hand = Globals.getPlayerObjects(this.engine).myHands[this._myHandednessType];
    this.object.pp_setTransformQuat(hand.pp_getTransformQuat());
    this.object.pp_setScale(hand.pp_getScale());
  }
};

// dist/input/pose/components/copy_head_transform_component.js
import { Component as Component50 } from "@wonderlandengine/api";
var CopyHeadTransformComponent = class extends Component50 {
  static TypeName = "pp-copy-head-transform";
  static Properties = {};
  update(dt) {
    let head = Globals.getPlayerObjects(this.engine).myHead;
    this.object.pp_setTransformQuat(head.pp_getTransformQuat());
    this.object.pp_setScale(head.pp_getScale());
  }
};

// dist/input/pose/components/copy_player_transform_component.js
import { Component as Component51 } from "@wonderlandengine/api";
var CopyPlayerTransformComponent = class extends Component51 {
  static TypeName = "pp-copy-player-transform";
  static Properties = {};
  update(dt) {
    let player = Globals.getPlayerObjects(this.engine).myPlayer;
    this.object.pp_setTransformQuat(player.pp_getTransformQuat());
    this.object.pp_setScale(player.pp_getScale());
  }
};

// dist/input/pose/components/copy_reference_space_transform_component.js
import { Component as Component52 } from "@wonderlandengine/api";
var CopyReferenceSpaceTransformComponent = class extends Component52 {
  static TypeName = "pp-copy-reference-space-transform";
  static Properties = {};
  update(dt) {
    let referenceSpace = Globals.getPlayerObjects(this.engine).myReferenceSpace;
    this.object.pp_setTransformQuat(referenceSpace.pp_getTransformQuat());
    this.object.pp_setScale(referenceSpace.pp_getScale());
  }
};

// dist/tool/cauldron/tool_types.js
var ToolHandedness = {
  NONE: null,
  LEFT: "left",
  RIGHT: "right"
};
var ToolInputSourceType = {
  NONE: null,
  GAMEPAD: 0,
  TRACKED_HAND: 1
};

// dist/tool/cauldron/components/tool_cursor_component.js
import { Component as Component53, MeshComponent as MeshComponent13, Property as Property43, ViewComponent as ViewComponent5 } from "@wonderlandengine/api";
import { Cursor as Cursor4, CursorTarget as CursorTarget6 } from "@wonderlandengine/components";
var ToolCursorComponent = class extends Component53 {
  static TypeName = "pp-tool-cursor";
  static Properties = {
    _myHandedness: Property43.enum(["Left", "Right"], "Left"),
    _myApplyDefaultCursorOffset: Property43.bool(true),
    _myPulseOnHover: Property43.bool(false),
    _myShowFingerCursor: Property43.bool(false),
    _myUpdatePointerCursorStyle: Property43.bool(true)
  };
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myCursorPositionDefaultOffset = vec3_create(0, -0.035, 0.05);
    this._myCursorRotationDefaultOffset = vec3_create(30, 0, 0);
    this._myCursorMeshScale = vec3_create(25e-4, 25e-4, 25e-4);
    this._myCursorColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this._myCursorTargetCollisionGroup = 7;
    this._myStarted = false;
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      this._myToolCursorObject = this.object.pp_addObject();
      this._myCursorObjectXR = this._myToolCursorObject.pp_addObject();
      if (this._myApplyDefaultCursorOffset) {
        this._myCursorObjectXR.pp_setPositionLocal(this._myCursorPositionDefaultOffset);
        this._myCursorObjectXR.pp_rotateObject(this._myCursorRotationDefaultOffset);
      }
      {
        this._myCursorMeshobject = this._myCursorObjectXR.pp_addObject();
        this._myCursorMeshobject.pp_setScale(this._myCursorMeshScale);
        let cursorMeshComponent = this._myCursorMeshobject.pp_addComponent(MeshComponent13);
        cursorMeshComponent.mesh = Globals.getDefaultMeshes(this.engine).mySphere;
        cursorMeshComponent.material = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
        cursorMeshComponent.material.color = this._myCursorColor;
        this._myCursorComponentXR = this._myCursorObjectXR.pp_addComponent(Cursor4, {
          "collisionGroup": this._myCursorTargetCollisionGroup,
          "handedness": this._myHandedness + 1,
          "cursorObject": this._myCursorMeshobject,
          "styleCursor": false
        });
        this._myCursorComponentXR.rayCastMode = 0;
        if (this._myPulseOnHover) {
          this._myCursorComponentXR.globalTarget.onHover.add(this._pulseOnHover.bind(this), { id: this });
        }
      }
      this._myCursorObjectNonXR = this._myToolCursorObject.pp_addObject();
      {
        this._myCursorComponentNonXR = this._myCursorObjectNonXR.pp_addComponent(Cursor4, {
          "collisionGroup": this._myCursorTargetCollisionGroup,
          "handedness": this._myHandedness + 1,
          "styleCursor": this._myUpdatePointerCursorStyle
        });
        this._myCursorComponentNonXR.rayCastMode = 0;
        if (this._myPulseOnHover) {
          this._myCursorComponentNonXR.globalTarget.onHover.add(this._pulseOnHover.bind(this), { id: this });
        }
        this._myCursorComponentNonXR.pp_setViewComponent(Globals.getPlayerObjects(this.engine).myCameraNonXR.pp_getComponent(ViewComponent5));
      }
      let fingerCursorMeshObject = null;
      let fingerCollisionSize = 0.0125;
      if (this._myShowFingerCursor) {
        fingerCursorMeshObject = this._myToolCursorObject.pp_addObject();
        let meshComponent = fingerCursorMeshObject.pp_addComponent(MeshComponent13);
        meshComponent.mesh = Globals.getDefaultMeshes(this.engine).mySphere;
        meshComponent.material = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
        meshComponent.material.color = this._myCursorColor;
        fingerCursorMeshObject.pp_setScale(fingerCollisionSize);
      }
      this._myFingerCursorObject = this._myToolCursorObject.pp_addObject();
      this._myFingerCursorComponent = this._myFingerCursorObject.pp_addComponent(FingerCursorComponent, {
        "_myHandedness": this._myHandedness,
        "_myMultipleClicksEnabled": true,
        "_myCollisionGroup": this._myCursorTargetCollisionGroup,
        "_myCollisionSize": fingerCollisionSize,
        "_myCursorObject": fingerCursorMeshObject
      });
      this._myCursorComponentXR.active = false;
      this._myCursorComponentNonXR.active = false;
      this._myFingerCursorComponent.active = false;
      this._myStarted = true;
    }
  }
  update(dt) {
  }
  _isUsingHand() {
    let usingHand = false;
    if (XRUtils.getSession(this.engine) && XRUtils.getSession(this.engine).inputSources != null) {
      for (let i = 0; i < XRUtils.getSession(this.engine).inputSources.length; i++) {
        let input = XRUtils.getSession(this.engine).inputSources[i];
        if (input.hand && input.handedness == this._myHandednessType) {
          usingHand = true;
          break;
        }
      }
    }
    return usingHand;
  }
  _pulseOnHover(object) {
    let targetComponent = object.pp_getComponent(CursorTarget6);
    if (targetComponent && !targetComponent.isSurface) {
      if (this._myHandedness == 0) {
        if (Globals.getLeftGamepad(this.engine) != null) {
          Globals.getLeftGamepad(this.engine).pulse(0.4, 0);
        }
      } else {
        if (Globals.getRightGamepad(this.engine) != null) {
          Globals.getRightGamepad(this.engine).pulse(0.4, 0);
        }
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myCursorComponentXR.globalTarget.onHover.remove(this);
      this._myCursorComponentNonXR.globalTarget.onHover.remove(this);
    }
  }
};
ToolCursorComponent.prototype.update = function() {
  let transformQuat2 = quat2_create();
  return function update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        let usingHand = this._isUsingHand();
        this._myFingerCursorComponent.active = usingHand;
        if (usingHand) {
          this._myCursorComponentXR.active = false;
          this._myCursorComponentNonXR.active = false;
        } else {
          if (XRUtils.isSessionActive(this.engine)) {
            this._myCursorComponentXR.active = !usingHand;
            this._myCursorComponentNonXR.active = false;
          } else {
            this._myCursorComponentNonXR.active = !usingHand;
            this._myCursorComponentXR.active = false;
            this._myCursorObjectNonXR.pp_setTransformQuat(Globals.getPlayerObjects(this.engine).myCameraNonXR.pp_getTransformQuat(transformQuat2));
          }
        }
      }
    }
  };
}();

// dist/tool/console_vr/console_vr_widget_config.js
import { Alignment as Alignment6, Collider as Collider2, Justification as Justification6 } from "@wonderlandengine/api";

// dist/tool/console_vr/console_vr_types.js
var ConsoleVRWidgetConsoleFunction = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3,
  INFO: 4,
  ASSERT: 5
};
var ConsoleVRWidgetSender = {
  BROWSER_CONSOLE: 0,
  CONSOLE_VR: 1,
  WINDOW: 2
};
var ConsoleVRWidgetPulseOnNewMessage = {
  NEVER: 0,
  ALWAYS: 1,
  WHEN_HIDDEN: 2
};
var ConsoleVRWidgetMessageType = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3
};
var OverrideBrowserConsoleFunctions = {
  NONE: 0,
  ALL: 1,
  ERRORS_AND_WARNS: 2
};

// dist/tool/console_vr/console_vr_widget_config.js
var ConsoleVRWidgetConfig = class {
  constructor() {
    this._setupBuildConfig();
    this._setupRuntimeConfig();
  }
  _setupBuildConfig() {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider2.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment6.Center;
    this.myTextJustification = Justification6.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myMessageTypeColors = [];
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG] = this.myDefaultTextColor;
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR] = vec4_create(255 / 255, 40 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN] = vec4_create(250 / 255, 220 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG] = vec4_create(60 / 255, 200 / 255, 255 / 255, 1);
    this.myMessagesPanelPosition = vec3_create(0, 0.075, 0);
    this.myMessagesBackgroundScale = vec3_create(0.34, 0.15, 1);
    {
      let xPaddingPercentage = 0.03;
      let yPaddingPercentage = xPaddingPercentage * this.myMessagesBackgroundScale[0] / this.myMessagesBackgroundScale[1] * 0.8;
      let xPosition = -this.myMessagesBackgroundScale[0] + this.myMessagesBackgroundScale[0] * xPaddingPercentage;
      let yPosition = this.myMessagesBackgroundScale[1] - this.myMessagesBackgroundScale[1] * yPaddingPercentage;
      this.myMessagesTextsPanelPosition = vec3_create(xPosition, yPosition, 7e-3);
    }
    this.myMessagesTextsPanelScale = vec3_create(0.1, 0.1, 0.1);
    this.myMessagesTextStartString = ".\n";
    this.myMessagesTextAlignment = Alignment6.Left;
    this.myMessagesTextJustification = Justification6.Top;
    this.myMessagesTextPositions = [];
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.LOG] = vec3_create(0, 0, 2e-4);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.ERROR] = vec3_create(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.WARN] = vec3_create(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.DEBUG] = vec3_create(0, 0, 0);
    this.myMessagesTextColors = [];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myButtonsPanelPosition = vec3_create(0, -0.11, 0.015);
    this.myButtonBackgroundScale = vec3_create(0.04, 0.02, 1);
    this.myButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myButtonCursorTargetPosition[2] = this.myButtonTextPosition[2];
    this.myButtonsCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myButtonsCollisionGroup = this.myCursorTargetCollisionGroup;
    this.myButtonsCollisionExtents = this.myButtonBackgroundScale.pp_clone();
    this.myButtonsCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myClearButtonTextLabel = "clear";
    this.myUpButtonTextLabel = "up";
    this.myDownButtonTextLabel = "down";
    this.myFilterButtonsTextColors = [];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myFilterButtonsTextLabel = [];
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.LOG] = "log";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.ERROR] = "error";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.WARN] = "warn";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.DEBUG] = "debug";
    {
      let numberOfButtons = 7;
      let buttonsHorizontalSpace = Math.max(0.68, this.myButtonBackgroundScale[0] * numberOfButtons);
      let numberOfSpacesBetweenButtons = 2 + 3 + 4 + 4 + 1 + 2;
      let spaceWidth = Math.max((buttonsHorizontalSpace - numberOfButtons * this.myButtonBackgroundScale[0] * 2) / numberOfSpacesBetweenButtons, 0);
      let halfButtonWidth = this.myButtonBackgroundScale[0];
      let initialPosition = -buttonsHorizontalSpace / 2;
      this.myFilterButtonsPositions = [];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG] = [initialPosition + spaceWidth * 2 + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myClearButtonPosition = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG][0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myUpButtonPosition = [this.myClearButtonPosition[0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myDownButtonPosition = [this.myUpButtonPosition[0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
    }
    this.myNotifyIconBackgroundScale = vec3_create(0.01, 0.01, 1);
    this.myNotifyIconPanelPositions = [];
    this.myNotifyIconPanelPositions[ToolHandedness.NONE] = vec3_create(0, 0, 0);
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][0] = -this.myMessagesBackgroundScale[0] + this.myNotifyIconBackgroundScale[0] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][1] = -this.myMessagesBackgroundScale[1] + this.myNotifyIconBackgroundScale[1] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][2] = this.myMessagesTextsPanelPosition[2] - 1e-5;
    this.myNotifyIconPanelPositions[ToolHandedness.LEFT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconPanelPositions[ToolHandedness.RIGHT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconCursorTargetPosition = vec3_create(0, 0, 0);
    this.myNotifyIconCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - this.myMessagesTextsPanelPosition[2];
    this.myNotifyIconCollisionExtents = this.myNotifyIconBackgroundScale.pp_clone();
    this.myNotifyIconCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNotifyIconColor = vec4_create(210 / 255, 210 / 255, 210 / 255, 1);
    this.myPointerCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myPointerCollisionGroup = this.myCursorTargetCollisionGroup;
    {
      let spaceBetweenMessagesAndButtons = Math.abs(this.myMessagesPanelPosition[1] - this.myMessagesBackgroundScale[1] - (this.myButtonsPanelPosition[1] + this.myButtonBackgroundScale[1]));
      let pointerCollisionHalfHeight = this.myMessagesBackgroundScale[1] + this.myButtonBackgroundScale[1] + spaceBetweenMessagesAndButtons / 2;
      this.myPointerCollisionExtents = vec3_create(this.myMessagesBackgroundScale[0], pointerCollisionHalfHeight, this.myCursorTargetCollisionThickness);
    }
    this.myPointerCursorTargetPosition = vec3_create(0, 0, 0);
    this.myPointerCursorTargetPosition[1] = this.myMessagesPanelPosition[1] + this.myMessagesBackgroundScale[1] - this.myPointerCollisionExtents[1];
    this.myPointerCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - 1e-4;
  }
  _setupRuntimeConfig() {
    this.myTabString = "     ";
    this.myAssertStartString = "Assertion failed:";
    this.myMaxCharactersPerLine = 100;
    this.myMaxLineSplits = 500;
    this.myMaxLines = 22;
    this.myMaxMessages = 2e3;
    this.myMaxMessagesDeletePad = 2e3;
    this.myLinesBetweenMessages = 1;
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create(110 / 255, 110 / 255, 110 / 255, 1);
    this.myFilterButtonDisabledTextColor = this.myButtonDisabledTextColor;
    this.myFilterButtonDisabledBackgroundColor = this.myButtonDisabledBackgroundColor;
    this.myScrollDelay = 0.1;
    this.myScrollAmount = 1;
    this.myScrollThumbstickHandedness = ToolHandedness.RIGHT;
    this.myScrollThumbstickDelay = 0.1;
    this.myScrollThumbstickMinThreshold = 0.2;
    this.myScrollThumbstickAmount = 3;
    this.myPulseDelay = 5;
    this.myPulseIntensity = 0.3;
    this.myPulseDuration = 0.085;
    this.myClearBrowserConsoleWhenClearPressed = false;
    this.myGamepadScrollOnlyOnHover = true;
  }
};

// dist/tool/console_vr/console_vr_widget_ui.js
import { CollisionComponent as CollisionComponent4, MeshComponent as MeshComponent14, TextComponent as TextComponent9 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget7 } from "@wonderlandengine/components";
var ConsoleVRWidgetUI = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
  }
  // Skeleton
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addObject();
    this._createMessagesSkeleton();
    this._createButtonsSkeleton();
    this._createPointerSkeleton();
  }
  _createMessagesSkeleton() {
    this.myMessagesPanel = this.myPivotObject.pp_addObject();
    this.myMessagesBackground = this.myMessagesPanel.pp_addObject();
    this.myMessagesTextsPanel = this.myMessagesPanel.pp_addObject();
    this.myMessagesTexts = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]] = this.myMessagesTextsPanel.pp_addObject();
    }
    this.myNotifyIconPanel = this.myMessagesPanel.pp_addObject();
    this.myNotifyIconBackground = this.myNotifyIconPanel.pp_addObject();
    this.myNotifyIconCursorTarget = this.myNotifyIconPanel.pp_addObject();
  }
  _createButtonsSkeleton() {
    this.myButtonsPanel = this.myPivotObject.pp_addObject();
    this.myFilterButtonsPanels = [];
    this.myFilterButtonsBackgrounds = [];
    this.myFilterButtonsTexts = [];
    this.myFilterButtonsCursorTargets = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]] = this.myButtonsPanel.pp_addObject();
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
    }
    this.myClearButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myClearButtonBackground = this.myClearButtonPanel.pp_addObject();
    this.myClearButtonText = this.myClearButtonPanel.pp_addObject();
    this.myClearButtonCursorTarget = this.myClearButtonPanel.pp_addObject();
    this.myUpButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myUpButtonBackground = this.myUpButtonPanel.pp_addObject();
    this.myUpButtonText = this.myUpButtonPanel.pp_addObject();
    this.myUpButtonCursorTarget = this.myUpButtonPanel.pp_addObject();
    this.myDownButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myDownButtonBackground = this.myDownButtonPanel.pp_addObject();
    this.myDownButtonText = this.myDownButtonPanel.pp_addObject();
    this.myDownButtonCursorTarget = this.myDownButtonPanel.pp_addObject();
  }
  _createPointerSkeleton() {
    this.myPointerCursorTarget = this.myPivotObject.pp_addObject();
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this._setMessagesTransforms();
    this._setButtonsTransforms();
    this._setPointerTransform();
  }
  _setMessagesTransforms() {
    this.myMessagesPanel.pp_setPositionLocal(this._myConfig.myMessagesPanelPosition);
    this.myMessagesBackground.pp_scaleObject(this._myConfig.myMessagesBackgroundScale);
    this.myMessagesTextsPanel.pp_setPositionLocal(this._myConfig.myMessagesTextsPanelPosition);
    this.myMessagesTextsPanel.pp_scaleObject(this._myConfig.myMessagesTextsPanelScale);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myMessagesTextPositions[ConsoleVRWidgetMessageType[key]]);
    }
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[this._myParams.myHandedness]);
    this.myNotifyIconBackground.pp_scaleObject(this._myConfig.myNotifyIconBackgroundScale);
    this.myNotifyIconCursorTarget.pp_setPositionLocal(this._myConfig.myNotifyIconCursorTargetPosition);
  }
  _setButtonsTransforms() {
    this.myButtonsPanel.pp_setPositionLocal(this._myConfig.myButtonsPanelPosition);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myFilterButtonsPositions[ConsoleVRWidgetMessageType[key]]);
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myClearButtonPanel.pp_setPositionLocal(this._myConfig.myClearButtonPosition);
      this.myClearButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myClearButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myClearButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myClearButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myUpButtonPanel.pp_setPositionLocal(this._myConfig.myUpButtonPosition);
      this.myUpButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myUpButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myUpButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myUpButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myDownButtonPanel.pp_setPositionLocal(this._myConfig.myDownButtonPosition);
      this.myDownButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myDownButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myDownButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myDownButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
  }
  _setPointerTransform() {
    this.myPointerCursorTarget.pp_setPositionLocal(this._myConfig.myPointerCursorTargetPosition);
  }
  // Components
  _addComponents() {
    this._addMessagesComponents();
    this._addButtonsComponents();
    this._addPointerComponents();
  }
  _addMessagesComponents() {
    let messagesBackgroundMeshComp = this.myMessagesBackground.pp_addComponent(MeshComponent14);
    messagesBackgroundMeshComp.mesh = this._myPlaneMesh;
    messagesBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
    messagesBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
    this.myMessagesTextComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let textComp = this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent9);
      textComp.alignment = this._myConfig.myMessagesTextAlignment;
      textComp.justification = this._myConfig.myMessagesTextJustification;
      textComp.material = this._myParams.myTextMaterial.clone();
      textComp.material.color = this._myConfig.myMessagesTextColors[ConsoleVRWidgetMessageType[key]];
      textComp.lineSpacing = 1.2;
      textComp.text = this._myConfig.myMessagesTextStartString;
      this.myMessagesTextComponents[ConsoleVRWidgetMessageType[key]] = textComp;
    }
    this.myNotifyIconBackgroundComponent = this.myNotifyIconBackground.pp_addComponent(MeshComponent14);
    this.myNotifyIconBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNotifyIconBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myNotifyIconBackgroundComponent.material.color = this._myConfig.myNotifyIconColor;
    this.myNotifyIconCursorTargetComponent = this.myNotifyIconCursorTarget.pp_addComponent(CursorTarget7);
    this.myNotifyIconCollisionComponent = this.myNotifyIconCursorTarget.pp_addComponent(CollisionComponent4);
    this.myNotifyIconCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myNotifyIconCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myNotifyIconCollisionComponent.extents = this._myConfig.myNotifyIconCollisionExtents;
  }
  _addButtonsComponents() {
    this.myFilterButtonsBackgroundComponents = [];
    this.myFilterButtonsTextComponents = [];
    this.myFilterButtonsCursorTargetComponents = [];
    this.myFilterButtonsCollisionComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let buttonBackgroundMeshComp = this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.material.color = this._myConfig.myFilterButtonsTextColors[ConsoleVRWidgetMessageType[key]];
      buttonTextComp.text = this._myConfig.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType[key]];
      let buttonCursorTargetComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CursorTarget7);
      let buttonCollisionComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]] = buttonBackgroundMeshComp;
      this.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]] = buttonTextComp;
      this.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]] = buttonCursorTargetComp;
      this.myFilterButtonsCollisionComponents[ConsoleVRWidgetMessageType[key]] = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myClearButtonBackground.pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myClearButtonText.pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myClearButtonTextLabel;
      let buttonCursorTargetComp = this.myClearButtonCursorTarget.pp_addComponent(CursorTarget7);
      let buttonCollisionComp = this.myClearButtonCursorTarget.pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myClearButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myClearButtonTextComponent = buttonTextComp;
      this.myClearButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myClearButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myUpButtonBackground.pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myUpButtonText.pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myUpButtonTextLabel;
      let buttonCursorTargetComp = this.myUpButtonCursorTarget.pp_addComponent(CursorTarget7);
      let buttonCollisionComp = this.myUpButtonCursorTarget.pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myUpButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myUpButtonTextComponent = buttonTextComp;
      this.myUpButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myUpButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myDownButtonBackground.pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myDownButtonText.pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myDownButtonTextLabel;
      let buttonCursorTargetComp = this.myDownButtonCursorTarget.pp_addComponent(CursorTarget7);
      let buttonCollisionComp = this.myDownButtonCursorTarget.pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myDownButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myDownButtonTextComponent = buttonTextComp;
      this.myDownButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myDownButtonCollisionComponent = buttonCollisionComp;
    }
  }
  _addPointerComponents() {
    this.myPointerCursorTargetComponent = this.myPointerCursorTarget.pp_addComponent(CursorTarget7);
    this.myPointerCursorTargetComponent.isSurface = true;
    let collisionComp = this.myPointerCursorTarget.pp_addComponent(CollisionComponent4);
    collisionComp.collider = this._myConfig.myPointerCollisionCollider;
    collisionComp.group = 1 << this._myConfig.myPointerCollisionGroup;
    collisionComp.extents = this._myConfig.myPointerCollisionExtents;
    this.myPointerCollisionComponent = collisionComp;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.justification = this._myConfig.myTextJustification;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[this._myParams.myHandedness]);
  }
  _setTransformForNonXR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[ToolHandedness.NONE]);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/widget_frame/widget_frame.js
import { Emitter as Emitter13 } from "@wonderlandengine/api";

// dist/tool/widget_frame/widget_frame_config.js
import { Alignment as Alignment7, Collider as Collider3, Justification as Justification7 } from "@wonderlandengine/api";
var WidgetFrameConfig = class {
  constructor(widgetLetterID, buttonsColumnIndex) {
    this._setupBuildConfig(widgetLetterID, buttonsColumnIndex);
    this._setupRuntimeConfig();
  }
  _setupBuildConfig(widgetLetterID, buttonsColumnIndex) {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider3.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment7.Center;
    this.myTextJustification = Justification7.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myVisibilityButtonBackgroundScale = vec3_create(0.015, 0.015, 1);
    this.myVisibilityButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myVisibilityButtonTextScale = this.myButtonTextScale;
    let distanceBetweenToolsVisibilityButtons = 0.01;
    let buttonXOffset = this.myVisibilityButtonBackgroundScale[0] * (2 * buttonsColumnIndex) + distanceBetweenToolsVisibilityButtons * buttonsColumnIndex;
    this.myVisibilityButtonPosition = [];
    this.myVisibilityButtonPosition[ToolHandedness.NONE] = {};
    this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition = vec3_create(-0.3 + buttonXOffset, -0.205, 0.035);
    this.myVisibilityButtonPosition[ToolHandedness.LEFT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition = vec3_create(-0.2 + buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition = vec3_create(0.2 - buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonText = widgetLetterID;
    this.myVisibilityButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myVisibilityButtonCursorTargetPosition[2] = this.myVisibilityButtonTextPosition[2];
    this.myVisibilityButtonCollisionExtents = this.myVisibilityButtonBackgroundScale.pp_clone();
    this.myVisibilityButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myFlagButtonBackgroundScale = vec3_create(0.0125, 0.0125, 1);
    this.myFlagButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myFlagButtonTextScale = vec3_create(0.15, 0.15, 0.15);
    let distanceBetweenFlagButtons = 75e-4;
    let pinFlagIndex = 0;
    let pinButtonYOffset = this.myVisibilityButtonBackgroundScale[1] + this.myFlagButtonBackgroundScale[1] + distanceBetweenFlagButtons + this.myFlagButtonBackgroundScale[1] * (2 * pinFlagIndex) + distanceBetweenFlagButtons * pinFlagIndex;
    this.myPinButtonPosition = [];
    this.myPinButtonPosition[ToolHandedness.NONE] = {};
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition = this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.LEFT] = {};
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.RIGHT] = {};
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonText = "P";
    this.myPinButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myPinButtonCursorTargetPosition[2] = this.myFlagButtonTextPosition[2];
    this.myPinButtonCollisionExtents = this.myFlagButtonBackgroundScale.pp_clone();
    this.myPinButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfig() {
    this._initializeObjectsTransforms();
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create(110 / 255, 110 / 255, 110 / 255, 1);
  }
  _initializeObjectsTransforms() {
    this.myPivotObjectTransforms = this._createDefaultObjectTransforms();
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myWidgetObjectTransforms = this._createDefaultObjectTransforms();
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myPosition = vec3_create(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myPosition = vec3_create(0.07, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myPosition = vec3_create(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myPosition = vec3_create(0.07, 0.23, -0.02);
    this._myPivotObjectDistanceFromHeadNonXR = 0.6;
  }
  _createDefaultObjectTransforms() {
    let defaultObjectTransforms = [];
    for (let inputSourceTypeKey in ToolInputSourceType) {
      let inputSourceType = ToolInputSourceType[inputSourceTypeKey];
      defaultObjectTransforms[inputSourceType] = [];
      for (let handednessKey in ToolHandedness) {
        let handedness = ToolHandedness[handednessKey];
        defaultObjectTransforms[inputSourceType][handedness] = {};
        defaultObjectTransforms[inputSourceType][handedness].myPosition = vec3_create(0, 0, 0);
        defaultObjectTransforms[inputSourceType][handedness].myRotation = quat_create(0, 0, 0, 1);
      }
    }
    return defaultObjectTransforms;
  }
};

// dist/tool/widget_frame/widget_frame_ui.js
import { CollisionComponent as CollisionComponent5, MeshComponent as MeshComponent15, TextComponent as TextComponent10 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget8 } from "@wonderlandengine/components";
var WidgetFrameUI = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myInputSourceType = null;
    this._myParentObject = null;
    this._myPinned = false;
    this._myWidgetVisible = true;
    this._myVisibilityButtonVisible = true;
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setWidgetVisible(visible) {
    this._myWidgetVisible = visible;
    this.myFlagsButtonPanel.pp_setActive(visible);
    if (visible) {
      this._updateObjectsTransforms(true);
    }
  }
  setVisibilityButtonVisible(visible) {
    this._myVisibilityButtonVisible = visible;
    this.myVisibilityButtonPanel.pp_setActive(visible);
  }
  setPinned(pinned) {
    if (pinned != this._myPinned) {
      this._myPinned = pinned;
      if (this._myPinned) {
        this.myPivotObject.pp_setParent(Globals.getSceneObjects(this._myEngine).myTools);
      } else {
        this.myPivotObject.pp_setParent(this.myFixForwardObject);
        if (!XRUtils.isSessionActive(this._myEngine)) {
          this._setTransformForNonXR();
        }
        this._updateObjectsTransforms(true);
      }
    }
  }
  update(dt) {
    this._updateObjectsTransforms(false);
  }
  _updateObjectsTransforms(forceRefreshObjectsTransforms) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      let inputSourceType = InputUtils.getInputSourceTypeByHandedness(this._myParams.myHandedness, this._myEngine);
      if (inputSourceType != this._myInputSourceType || forceRefreshObjectsTransforms) {
        this._myInputSourceType = inputSourceType;
        if (!this._myPinned) {
          this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myPosition);
          this.myPivotObject.pp_resetRotationLocal();
          this.myPivotObject.pp_rotateObjectQuat(this._myConfig.myPivotObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myRotation);
          this.myWidgetObject.pp_setPositionLocal(this._myConfig.myWidgetObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myPosition);
          this.myWidgetObject.pp_resetRotationLocal();
          this.myWidgetObject.pp_rotateObjectQuat(this._myConfig.myWidgetObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myRotation);
          this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[this._myParams.myHandedness].myPosition);
          this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[this._myParams.myHandedness].myPosition);
        }
      }
    } else {
      this.myVisibilityButtonPanel.pp_setActive(this._myWidgetVisible || this._myVisibilityButtonVisible);
    }
  }
  // Skeleton
  _createSkeleton() {
    this.myFixForwardObject = this._myParentObject.pp_addObject();
    if (Globals.isPoseForwardFixed(this._myEngine)) {
      this.myFixForwardObject.pp_rotateObject(vec3_create(0, 180, 0));
    }
    this.myPivotObject = this.myFixForwardObject.pp_addObject();
    this.myWidgetObject = this.myPivotObject.pp_addObject();
    this.myVisibilityButtonPanel = this.myPivotObject.pp_addObject();
    this.myVisibilityButtonBackground = this.myVisibilityButtonPanel.pp_addObject();
    this.myVisibilityButtonText = this.myVisibilityButtonPanel.pp_addObject();
    this.myVisibilityButtonCursorTarget = this.myVisibilityButtonPanel.pp_addObject();
    this.myFlagsButtonPanel = this.myPivotObject.pp_addObject();
    this.myPinButtonPanel = this.myFlagsButtonPanel.pp_addObject();
    this.myPinButtonBackground = this.myPinButtonPanel.pp_addObject();
    this.myPinButtonText = this.myPinButtonPanel.pp_addObject();
    this.myPinButtonCursorTarget = this.myPinButtonPanel.pp_addObject();
    this.myNonXRParentObject = Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_addObject();
    this.myNonXRParentObject.pp_translateLocal(vec3_create(0, 0, -this._myConfig._myPivotObjectDistanceFromHeadNonXR));
    this.myNonXRParentObject.pp_lookToLocal(vec3_create(0, 0, 1), vec3_create(0, 1, 0));
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[this._myParams.myHandedness].myPosition);
    this.myVisibilityButtonBackground.pp_scaleObject(this._myConfig.myVisibilityButtonBackgroundScale);
    this.myVisibilityButtonText.pp_setPositionLocal(this._myConfig.myVisibilityButtonTextPosition);
    this.myVisibilityButtonText.pp_scaleObject(this._myConfig.myVisibilityButtonTextScale);
    this.myVisibilityButtonCursorTarget.pp_setPositionLocal(this._myConfig.myVisibilityButtonCursorTargetPosition);
    this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[this._myParams.myHandedness].myPosition);
    this.myPinButtonBackground.pp_scaleObject(this._myConfig.myFlagButtonBackgroundScale);
    this.myPinButtonText.pp_setPositionLocal(this._myConfig.myFlagButtonTextPosition);
    this.myPinButtonText.pp_scaleObject(this._myConfig.myFlagButtonTextScale);
    this.myPinButtonCursorTarget.pp_setPositionLocal(this._myConfig.myPinButtonCursorTargetPosition);
  }
  // Components
  _addComponents() {
    this.myVisibilityButtonBackgroundComponent = this.myVisibilityButtonBackground.pp_addComponent(MeshComponent15);
    this.myVisibilityButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myVisibilityButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myVisibilityButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myVisibilityButtonTextComponent = this.myVisibilityButtonText.pp_addComponent(TextComponent10);
    this._setupButtonTextComponent(this.myVisibilityButtonTextComponent);
    this.myVisibilityButtonTextComponent.text = this._myConfig.myVisibilityButtonText;
    this.myVisibilityButtonCursorTargetComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CursorTarget8);
    this.myVisibilityButtonCollisionComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CollisionComponent5);
    this.myVisibilityButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myVisibilityButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myVisibilityButtonCollisionComponent.extents = this._myConfig.myVisibilityButtonCollisionExtents;
    this.myPinButtonBackgroundComponent = this.myPinButtonBackground.pp_addComponent(MeshComponent15);
    this.myPinButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPinButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPinButtonBackgroundComponent.material.color = this._myConfig.myButtonDisabledBackgroundColor;
    this.myPinButtonTextComponent = this.myPinButtonText.pp_addComponent(TextComponent10);
    this._setupButtonTextComponent(this.myPinButtonTextComponent);
    this.myPinButtonTextComponent.material.color = this._myConfig.myButtonDisabledTextColor;
    this.myPinButtonTextComponent.text = this._myConfig.myPinButtonText;
    this.myPinButtonCursorTargetComponent = this.myPinButtonCursorTarget.pp_addComponent(CursorTarget8);
    this.myPinButtonCollisionComponent = this.myPinButtonCursorTarget.pp_addComponent(CollisionComponent5);
    this.myPinButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPinButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPinButtonCollisionComponent.extents = this._myConfig.myPinButtonCollisionExtents;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.justification = this._myConfig.myTextJustification;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this.myVisibilityButtonPanel.pp_setActive(this._myVisibilityButtonVisible);
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myFixForwardObject.pp_setParent(this._myParentObject);
    this.myFixForwardObject.pp_resetTransformLocal();
    if (Globals.isPoseForwardFixed(this._myEngine)) {
      this.myFixForwardObject.pp_rotateObject(vec3_create(0, 180, 0));
    }
    this._updateObjectsTransforms(true);
  }
  _setTransformForNonXR() {
    if (!this._myPinned) {
      this.myFixForwardObject.pp_setParent(this.myNonXRParentObject);
      this.myFixForwardObject.pp_resetTransformLocal();
      this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myPivotObject.pp_resetRotationLocal();
      this.myPivotObject.pp_rotateObjectQuat(this._myConfig.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myWidgetObject.pp_setPositionLocal(this._myConfig.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myWidgetObject.pp_resetRotationLocal();
      this.myWidgetObject.pp_rotateObjectQuat(this._myConfig.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition);
      this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[ToolHandedness.NONE].myPosition);
    }
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/widget_frame/widget_frame.js
var WidgetParams = class {
  constructor() {
    this.myHandedness = ToolHandedness.NONE;
    this.myPlaneMaterial = null;
    this.myTextMaterial = null;
  }
};
var WidgetFrame = class {
  constructor(widgetLetterID, buttonsColumnIndex, engine = Globals.getMainEngine()) {
    this._myWidgetVisible = true;
    this._myPinned = false;
    this._myConfig = new WidgetFrameConfig(widgetLetterID, buttonsColumnIndex);
    this._myParams = null;
    this._myUI = new WidgetFrameUI(engine);
    this._myShowVisibilityButton = false;
    this._myWidgetVisibleChangedEmitter = new Emitter13();
    this._myPinChangedEmitter = new Emitter13();
    this._myDestroyed = true;
  }
  getWidgetObject() {
    return this._myUI.myWidgetObject;
  }
  setVisible(visible) {
    this._myWidgetVisible = !visible;
    this._toggleVisibility(false, true);
  }
  isVisible() {
    return this._myWidgetVisible;
  }
  toggleVisibility() {
    this._toggleVisibility(false, true);
  }
  togglePin() {
    this._togglePin(false);
  }
  registerWidgetVisibleChangedEventListener(id, listener) {
    this._myWidgetVisibleChangedEmitter.add(listener, { id });
  }
  unregisterWidgetVisibleChangedEventListener(id) {
    this._myWidgetVisibleChangedEmitter.remove(id);
  }
  registerPinChangedEventListener(id, listener) {
    this._myPinChangedEmitter.add(listener, { id });
  }
  unregisterPinChangedEventListener(id) {
    this._myPinChangedEmitter.remove(id);
  }
  start(parentObject, params) {
    this._myParams = params;
    this._myUI.build(parentObject, this._myConfig, params);
    this._myUI.setVisibilityButtonVisible(params.myShowVisibilityButton);
    this._myShowVisibilityButton = params.myShowVisibilityButton;
    if (!params.myShowOnStart) {
      this._toggleVisibility(false, false);
    }
    this._addListeners();
  }
  update(dt) {
    this._myUI.update(dt);
  }
  _addListeners() {
    let ui = this._myUI;
    ui.myPinButtonCursorTargetComponent.onClick.add(this._togglePin.bind(this, true));
    ui.myPinButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myPinButtonCursorTargetComponent.onUnhover.add(this._pinUnhover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.onClick.add(this._toggleVisibility.bind(this, true, true));
    ui.myVisibilityButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.onUnhover.add(this._visibilityUnhover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
  }
  _toggleVisibility(isButton, notify) {
    this._myWidgetVisible = !this._myWidgetVisible;
    this._myUI.setWidgetVisible(this._myWidgetVisible);
    let textMaterial = this._myUI.myVisibilityButtonTextComponent.material;
    let backgroundMaterial = this._myUI.myVisibilityButtonBackgroundComponent.material;
    if (this._myWidgetVisible) {
      textMaterial.color = this._myConfig.myDefaultTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._myConfig.myBackgroundColor;
      }
    } else {
      textMaterial.color = this._myConfig.myButtonDisabledTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._myConfig.myButtonDisabledBackgroundColor;
      }
    }
    if (notify) {
      this._myWidgetVisibleChangedEmitter.notify(this._myWidgetVisible);
    }
    this._myUI.setVisibilityButtonVisible(this._myShowVisibilityButton);
  }
  _togglePin(isButton) {
    if (this._myWidgetVisible) {
      this._myPinned = !this._myPinned;
      this._myUI.setPinned(this._myPinned);
      let textMaterial = this._myUI.myPinButtonTextComponent.material;
      let backgroundMaterial = this._myUI.myPinButtonBackgroundComponent.material;
      if (this._myPinned) {
        textMaterial.color = this._myConfig.myDefaultTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._myConfig.myBackgroundColor;
        }
      } else {
        textMaterial.color = this._myConfig.myButtonDisabledTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._myConfig.myButtonDisabledBackgroundColor;
        }
      }
      this._myPinChangedEmitter.notify(this._myPinned);
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _visibilityUnhover(material) {
    if (this._myWidgetVisible) {
      material.color = this._myConfig.myBackgroundColor;
    } else {
      material.color = this._myConfig.myButtonDisabledBackgroundColor;
    }
  }
  _pinUnhover(material) {
    if (this._myPinned) {
      material.color = this._myConfig.myBackgroundColor;
    } else {
      material.color = this._myConfig.myButtonDisabledBackgroundColor;
    }
  }
  destroy() {
    this._myDestroyed = true;
    if (this._myUI != null) {
      this._myUI.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/console_vr/console_vr_widget.js
var ConsoleVRWidgetParams = class extends WidgetParams {
  constructor() {
    super();
    this.myOverrideBrowserConsoleFunctions = false;
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myPulseOnNewMessage = ConsoleVRWidgetPulseOnNewMessage.NEVER;
    this.myResetBrowserConsoleOriginalFunctionsOnDestroy = true;
  }
};
var ConsoleVRWidgetMessage = class {
  constructor(messageType, messageLines) {
    this.myType = messageType;
    this.myLines = messageLines;
    this._myOriginalText = messageLines.join("\n");
    this._myMessagesCount = 1;
  }
  hasSameInfo(message) {
    return this._myOriginalText == message._myOriginalText && this.myType == message.myType;
  }
  increaseCount() {
    this._myMessagesCount += 1;
    let countString = "(x".concat(this._myMessagesCount).concat(") ");
    let text = this._myOriginalText;
    text = countString.concat(text);
    this.myLines = text.split("\n");
  }
};
var ConsoleVRWidget = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myWidgetFrame = new WidgetFrame("C", 0, engine);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._myConfig = new ConsoleVRWidgetConfig();
    this._myParams = null;
    this._myUI = new ConsoleVRWidgetUI(engine);
    this._myMessages = [];
    this._myOldBrowserConsole = [];
    this._myOldConsoleVR = [];
    this._myTypeFilters = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
    }
    this._myScrollUp = false;
    this._myScrollDown = false;
    this._myScrollOffset = 0;
    this._myScrollTimer = 0;
    this._myScrollThumbstickTimer = 0;
    this._myPulseTimer = 0;
    this._myGamepadScrollEnabled = true;
    if (this._myConfig.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollEnabled = false;
    }
    this._myErrorEventListener = null;
    this._myUnhandledRejectionEventListener = null;
    this._myConsolePrintAddMessageEnabled = true;
    this._myConsolePrintAddMessageEnabledReset = false;
    this._myTextDirty = false;
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  setVisible(visible) {
    this._myWidgetFrame.setVisible(visible);
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, params) {
    this._myLeftGamepad = Globals.getLeftGamepad(this._myEngine);
    this._myRightGamepad = Globals.getRightGamepad(this._myEngine);
    this._myParams = params;
    this._myWidgetFrame.start(parentObject, params);
    this._myUI.build(this._myWidgetFrame.getWidgetObject(), this._myConfig, params);
    this._myUI.setVisible(this._myWidgetFrame.isVisible());
    this._setNotifyIconActive(false);
    this._addListeners();
    this._overrideConsolesFunctions();
  }
  update(dt) {
    if (this._myConsolePrintAddMessageEnabledReset) {
      this._myConsolePrintAddMessageEnabledReset = false;
      this._myConsolePrintAddMessageEnabled = true;
    }
    this._myWidgetFrame.update(dt);
    if (this._myWidgetFrame.isVisible()) {
      if (this._myTextDirty) {
        this._updateAllTexts();
      }
      this._updateScroll(dt);
    }
    this._updateGamepadsExtraActions(dt);
  }
  // This must be done only when all the setup is complete, to avoid issues with other part of the code calling the console and then triggering the console vr while not ready yet
  _overrideConsolesFunctions() {
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG] = console.log;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR] = console.error;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN] = console.warn;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO] = console.info;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG] = console.debug;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT] = console.assert;
    this._myOldBrowserConsoleClear = console.clear;
    if (this._myParams.myOverrideBrowserConsoleFunctions != OverrideBrowserConsoleFunctions.NONE) {
      if (this._myParams.myOverrideBrowserConsoleFunctions == OverrideBrowserConsoleFunctions.ALL) {
        console.log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      }
      console.error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      if (this._myParams.myOverrideBrowserConsoleFunctions == OverrideBrowserConsoleFunctions.ALL) {
        console.info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.BROWSER_CONSOLE);
        console.debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      }
      console.assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      this._myErrorEventListener = function(errorEvent) {
        if (errorEvent.error != null) {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.error.stack);
        } else {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.message);
        }
      }.bind(this);
      this._myUnhandledRejectionEventListener = function(errorEvent) {
        this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught (in promise)", errorEvent.reason);
      }.bind(this);
      Globals.getWindow(this._myEngine).addEventListener("error", this._myErrorEventListener);
      Globals.getWindow(this._myEngine).addEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
    }
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG] = Globals.getConsoleVR(this._myEngine).log;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR] = Globals.getConsoleVR(this._myEngine).error;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN] = Globals.getConsoleVR(this._myEngine).warn;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO] = Globals.getConsoleVR(this._myEngine).info;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG] = Globals.getConsoleVR(this._myEngine).debug;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT] = Globals.getConsoleVR(this._myEngine).assert;
    this._myOldConsoleVRClear = Globals.getConsoleVR(this._myEngine).clear;
    Globals.getConsoleVR(this._myEngine).log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.CONSOLE_VR);
  }
  // Text section
  _updateText(messageType) {
    let consoleText = "";
    if (!this._myTypeFilters[messageType]) {
      let linesCount = 0;
      let i = this._myMessages.length - 1;
      let scrollLinesToSkip = Math.round(this._myScrollOffset);
      while (i >= 0 && linesCount < this._myConfig.myMaxLines) {
        let message = this._myMessages[i];
        if (this._myTypeFilters[message.myType]) {
          i -= 1;
          continue;
        }
        let messageLines = message.myLines.length;
        let linesToSkip = 0;
        if (scrollLinesToSkip > 0) {
          let additionalEmptyLines = 0;
          if (i != this._myMessages.length - 1) {
            additionalEmptyLines = this._myConfig.myLinesBetweenMessages;
          }
          if (scrollLinesToSkip >= messageLines + additionalEmptyLines) {
            scrollLinesToSkip -= messageLines + additionalEmptyLines;
            linesToSkip = messageLines + additionalEmptyLines;
          } else {
            linesToSkip = scrollLinesToSkip;
            scrollLinesToSkip = 0;
          }
        }
        if (i != this._myMessages.length - 1) {
          let emptyLinesToSkip = this._myConfig.myLinesBetweenMessages - Math.max(this._myConfig.myLinesBetweenMessages - linesToSkip, 0);
          let emptyLinesToShow = this._myConfig.myLinesBetweenMessages - emptyLinesToSkip;
          if (linesCount + emptyLinesToShow > this._myConfig.myMaxLines) {
            emptyLinesToShow = this._myMaxLines - linesCount;
          }
          for (let j = 0; j < emptyLinesToShow; j++) {
            consoleText = "\n".concat(consoleText);
          }
          linesCount += emptyLinesToShow;
          linesToSkip -= emptyLinesToSkip;
        }
        let linesToShow = messageLines - linesToSkip;
        if (linesCount + linesToShow > this._myConfig.myMaxLines) {
          linesToShow = this._myConfig.myMaxLines - linesCount;
        }
        if (linesToShow > 0) {
          if (message.myType == messageType) {
            let linesToPrint = message.myLines.slice(messageLines - linesToShow - linesToSkip, messageLines - linesToSkip);
            let text = linesToPrint.join("\n");
            consoleText = text.concat("\n").concat(consoleText);
            linesCount += linesToShow;
          } else {
            for (let j = 0; j < linesToShow; j++) {
              consoleText = "\n".concat(consoleText);
            }
            linesCount += linesToShow;
          }
        }
        i -= 1;
      }
    }
    consoleText = this._myConfig.myMessagesTextStartString.concat(consoleText);
    this._myUI.myMessagesTextComponents[messageType].text = consoleText;
  }
  _consolePrint(consoleFunction, sender, ...args) {
    switch (sender) {
      case ConsoleVRWidgetSender.BROWSER_CONSOLE:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
      case ConsoleVRWidgetSender.CONSOLE_VR:
        this._myOldConsoleVR[consoleFunction].apply(Globals.getConsoleVR(this._myEngine), args);
        break;
      default:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
    }
    if (this._myConsolePrintAddMessageEnabled && (consoleFunction != ConsoleVRWidgetConsoleFunction.ASSERT || args.length > 0 && !args[0])) {
      this._myTextDirty = true;
      this._pulseGamepad();
      try {
        let message = this._argsToMessage(consoleFunction, ...args);
        this._addMessage(message);
        if (this._myMessages.length >= this._myConfig.myMaxMessages + this._myConfig.myMaxMessagesDeletePad) {
          this._myMessages = this._myMessages.slice(this._myMessages.length - this._myConfig.myMaxMessages);
          this._clampScrollOffset();
        }
      } catch (error3) {
        this._myConsolePrintAddMessageEnabled = false;
        this._myConsolePrintAddMessageEnabledReset = true;
        try {
          let errorMessage = "An error occurred while trying to add a new message to the Console VR Widget";
          let message = new ConsoleVRWidgetMessage(ConsoleVRWidgetMessageType.ERROR, [errorMessage]);
          this._myMessages.push(message);
          ConsoleOriginalFunctions.error(this._myEngine, errorMessage);
        } catch (anotherError) {
        }
        throw error3;
      }
    }
  }
  _argsToMessage(consoleFunction, ...args) {
    if (consoleFunction == ConsoleVRWidgetConsoleFunction.ASSERT) {
      args = args.slice(1);
      args.splice(0, 0, this._myConfig.myAssertStartString);
    }
    let messageType = this._consoleFunctionToMessageType(consoleFunction);
    let formattedText = this._formatArgs(...args);
    let lines = this._splitLongLines(formattedText);
    if (messageType == ConsoleVRWidgetMessageType.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else if (messageType == ConsoleVRWidgetMessageType.EXCEPTION || messageType == ConsoleVRWidgetMessageType.ASSERT) {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    let message = new ConsoleVRWidgetMessage(messageType, lines);
    return message;
  }
  _consoleFunctionToMessageType(consoleFunction) {
    let messageType = ConsoleVRWidgetMessageType.LOG;
    if (consoleFunction < ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = consoleFunction;
    } else if (consoleFunction == ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    return messageType;
  }
  // Here the formatting using placeholder like %d could be implemented in the future
  _formatArgs(...args) {
    let stringifiedArgs = [];
    for (let i = 0; i < args.length; i++) {
      if (args[i] === void 0) {
        stringifiedArgs.push("undefined");
      } else {
        stringifiedArgs.push(this._stringifyItem(args[i]));
      }
    }
    let formattedString = stringifiedArgs.join(" ");
    return formattedString;
  }
  _stringifyItem(item) {
    let stringifiedItem = null;
    if (item instanceof Error) {
      stringifiedItem = item.stack;
    } else if (typeof item === "object") {
      let linesBetweenItems = 2;
      try {
        stringifiedItem = JSON.stringify(item, this._jsonReplacer.bind(this), linesBetweenItems);
      } catch (error3) {
        let cache = /* @__PURE__ */ new WeakSet();
        stringifiedItem = JSON.stringify(item, function(key, value) {
          if (typeof value === "object" && value !== null) {
            if (cache.has(value)) {
              return "<stringify error: object already stringified>";
            }
            cache.add(value);
          }
          return this._jsonReplacer(key, value);
        }.bind(this), linesBetweenItems);
      }
      stringifiedItem = stringifiedItem.replaceAll('"[', "[");
      stringifiedItem = stringifiedItem.replaceAll("'[", "[");
      stringifiedItem = stringifiedItem.replaceAll(']"', "]");
      stringifiedItem = stringifiedItem.replaceAll("]'", "]");
    } else {
      stringifiedItem = item;
    }
    return stringifiedItem;
  }
  _splitLongLines(messageText) {
    let linesToSplit = messageText.split("\n");
    let lines = [];
    for (let i = 0; i < linesToSplit.length; i++) {
      let lineToSplit = linesToSplit[i];
      if (lineToSplit.length > this._myConfig.myMaxCharactersPerLine) {
        let spacesAtStart = this._getSpacesAtStart(lineToSplit);
        let spaceToAdd = this._myConfig.myTabString.concat(spacesAtStart);
        let lineSplits = 0;
        while (lineToSplit.length > this._myConfig.myMaxCharactersPerLine && lineSplits < this._myConfig.myMaxLineSplits) {
          let firstSub = lineToSplit.substr(0, this._myConfig.myMaxCharactersPerLine - 1);
          let secondSub = lineToSplit.substr(this._myConfig.myMaxCharactersPerLine - 1);
          secondSub = spaceToAdd.concat(secondSub);
          lines.push(firstSub);
          lineToSplit = secondSub;
          lineSplits++;
        }
        lines.push(lineToSplit);
      } else {
        lines.push(lineToSplit);
      }
    }
    return lines;
  }
  _getSpacesAtStart(text) {
    let spaces = "";
    let i = 0;
    while (i < text.length && text[i] == " ") {
      spaces = spaces.concat(" ");
      i++;
    }
    return spaces;
  }
  _addMessage(message) {
    let hasSameInfoAsPrev = false;
    if (this._myMessages.length > 0) {
      let lastMessage = this._myMessages[this._myMessages.length - 1];
      if (lastMessage.hasSameInfo(message)) {
        lastMessage.increaseCount();
        hasSameInfoAsPrev = true;
      }
    }
    if (!hasSameInfoAsPrev) {
      this._myMessages.push(message);
    }
    this._adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev);
    this._updateNotifyIcon(message);
  }
  // If you have scrolled, new messages does not move the scroll position
  _adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev) {
    if (!hasSameInfoAsPrev && !this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._myScrollOffset += message.myLines.length + this._myConfig.myLinesBetweenMessages;
    }
  }
  _updateAllTexts() {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        this._updateText(ConsoleVRWidgetMessageType[key]);
      }
      this._myTextDirty = false;
    }
  }
  _updateNotifyIcon(message) {
    if (!this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._setNotifyIconActive(true);
    }
  }
  _updateScroll(dt) {
    if (this._myScrollUp) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._myConfig.myScrollDelay) {
        this._myScrollTimer -= this._myConfig.myScrollDelay;
        this._myScrollOffset += this._myConfig.myScrollAmount;
      }
    } else if (this._myScrollDown) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._myConfig.myScrollDelay) {
        this._myScrollTimer -= this._myConfig.myScrollDelay;
        this._myScrollOffset -= this._myConfig.myScrollAmount;
      }
    }
    this._clampScrollOffset();
    if (this._myScrollUp || this._myScrollDown) {
      this._updateAllTexts();
    }
    if (this._myScrollOffset == 0) {
      this._setNotifyIconActive(false);
    }
  }
  _clampScrollOffset() {
    let maxScroll = this._getMaxScrollOffset();
    this._myScrollOffset = Math.pp_clamp(this._myScrollOffset, 0, maxScroll);
  }
  _getMaxScrollOffset() {
    return Math.max(this._getLinesCount() - this._myConfig.myMaxLines, 0);
  }
  _getLinesCount() {
    let linesCount = 0;
    for (let message of this._myMessages) {
      if (!this._myTypeFilters[message.myType]) {
        linesCount += message.myLines.length + this._myConfig.myLinesBetweenMessages;
      }
    }
    linesCount -= this._myConfig.myLinesBetweenMessages;
    linesCount = Math.max(linesCount, 0);
    return linesCount;
  }
  // Listener section
  _addListeners() {
    let ui = this._myUI;
    for (let key in ConsoleVRWidgetMessageType) {
      let cursorTarget = ui.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]];
      let backgroundMaterial = ui.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
      let textMaterial = ui.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
      cursorTarget.onSingleClick.add(this._toggleFilter.bind(this, ConsoleVRWidgetMessageType[key], textMaterial));
      cursorTarget.onDoubleClick.add(this._filterAllButOne.bind(this, ConsoleVRWidgetMessageType[key], textMaterial));
      cursorTarget.onTripleClick.add(this._resetFilters.bind(this, ConsoleVRWidgetMessageType[key]));
      cursorTarget.onHover.add(this._filterHover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
      cursorTarget.onUnhover.add(this._filterUnhover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
    }
    {
      let cursorTarget = ui.myClearButtonCursorTargetComponent;
      let backgroundMaterial = ui.myClearButtonBackgroundComponent.material;
      cursorTarget.onClick.add(this._clearConsole.bind(this, false, null));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myUpButtonCursorTargetComponent;
      let backgroundMaterial = ui.myUpButtonBackgroundComponent.material;
      cursorTarget.onDoubleClick.add(this._instantScrollUp.bind(this, true));
      cursorTarget.onDown.add(this._setScrollUp.bind(this, true));
      cursorTarget.onDownOnHover.add(this._setScrollUp.bind(this, true));
      cursorTarget.onUp.add(this._setScrollUp.bind(this, false));
      cursorTarget.onUnhover.add(this._setScrollUp.bind(this, false));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myDownButtonCursorTargetComponent;
      let backgroundMaterial = ui.myDownButtonBackgroundComponent.material;
      cursorTarget.onDoubleClick.add(this._instantScrollDown.bind(this));
      cursorTarget.onDown.add(this._setScrollDown.bind(this, true));
      cursorTarget.onDownOnHover.add(this._setScrollDown.bind(this, true));
      cursorTarget.onUp.add(this._setScrollDown.bind(this, false));
      cursorTarget.onUnhover.add(this._setScrollDown.bind(this, false));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myNotifyIconCursorTargetComponent;
      let backgroundMaterial = ui.myNotifyIconBackgroundComponent.material;
      cursorTarget.onClick.add(this._instantScrollDown.bind(this));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._notifyIconUnhover.bind(this));
    }
    ui.myPointerCursorTargetComponent.onHover.add(this._setGamepadScrollEnabled.bind(this, true));
    ui.myPointerCursorTargetComponent.onUnhover.add(this._setGamepadScrollEnabled.bind(this, false));
  }
  _resetFilters(messageType) {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
        filterTextMaterial.color = this._myConfig.myMessageTypeColors[ConsoleVRWidgetMessageType[key]];
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          backgroundMaterial.color = this._myConfig.myBackgroundColor;
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _filterAllButOne(messageType) {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = true;
          backgroundMaterial.color = this._myConfig.myFilterButtonDisabledBackgroundColor;
          filterTextMaterial.color = this._myConfig.myFilterButtonDisabledTextColor;
        } else {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
          filterTextMaterial.color = this._myConfig.myMessageTypeColors[messageType];
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _toggleFilter(messageType, textMaterial) {
    if (this._myWidgetFrame.isVisible()) {
      this._myTypeFilters[messageType] = !this._myTypeFilters[messageType];
      if (this._myTypeFilters[messageType]) {
        textMaterial.color = this._myConfig.myFilterButtonDisabledTextColor;
      } else {
        textMaterial.color = this._myConfig.myMessageTypeColors[messageType];
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _clearConsole(codeDrivenClear = false, sender = null) {
    if (this._myWidgetFrame.isVisible() || codeDrivenClear) {
      this._myMessages = [];
      this._clampScrollOffset();
      this._updateAllTexts();
      if (codeDrivenClear) {
        switch (sender) {
          case ConsoleVRWidgetSender.BROWSER_CONSOLE:
            this._myOldBrowserConsoleClear.apply(console);
            break;
          case ConsoleVRWidgetSender.CONSOLE_VR:
            this._myOldConsoleVRClear.apply(Globals.getConsoleVR(this._myEngine));
            break;
          default:
            break;
        }
      } else if (this._myConfig.myClearBrowserConsoleWhenClearPressed) {
        ConsoleOriginalFunctions.clear(this._myEngine);
      }
    }
  }
  _setScrollUp(value) {
    if (this._myWidgetFrame.isVisible() || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollUp = value;
    }
  }
  _setScrollDown(value) {
    if (this._myWidgetFrame.isVisible() || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollDown = value;
    }
  }
  _instantScrollUp() {
    if (this._myWidgetFrame.isVisible()) {
      this._myScrollOffset = this._getMaxScrollOffset();
      this._updateAllTexts();
    }
  }
  _instantScrollDown() {
    if (this._myWidgetFrame.isVisible()) {
      this._myScrollOffset = 0;
      this._setNotifyIconActive(false);
      this._updateAllTexts();
    }
  }
  _setNotifyIconActive(active) {
    this._myUI.myNotifyIconPanel.pp_setActive(active && this._myWidgetFrame.isVisible());
  }
  _notifyIconUnhover() {
    let material = this._myUI.myNotifyIconBackgroundComponent.material;
    material.color = this._myConfig.myNotifyIconColor;
  }
  _filterHover(messageType, material) {
    this._genericHover(material);
  }
  _filterUnhover(messageType, material) {
    if (this._myTypeFilters[messageType]) {
      material.color = this._myConfig.myFilterButtonDisabledBackgroundColor;
    } else {
      material.color = this._myConfig.myBackgroundColor;
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _genericUnhover(material) {
    material.color = this._myConfig.myBackgroundColor;
  }
  // Gamepad section
  _updateGamepadsExtraActions(dt) {
    if (this._myLeftGamepad && this._myRightGamepad) {
      if (this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed() || this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
        this._toggleVisibility();
      }
      this._myPulseTimer = Math.max(this._myPulseTimer - dt, 0);
      this._updateScrollWithThumbstick(dt);
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    this._myUI.setVisible(visible);
    if (visible) {
      this._updateAllTexts();
    }
  }
  _updateScrollWithThumbstick(dt) {
    if (this._myWidgetFrame.isVisible() && this._myGamepadScrollEnabled) {
      let axes = vec2_create(0, 0);
      if (this._myConfig.myScrollThumbstickHandedness == ToolHandedness.LEFT) {
        axes = this._myLeftGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      } else if (this._myConfig.myScrollThumbstickHandedness == ToolHandedness.RIGHT) {
        axes = this._myRightGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      }
      if (Math.abs(axes[1]) > this._myConfig.myScrollThumbstickMinThreshold) {
        this._myScrollThumbstickTimer += dt;
        while (this._myScrollThumbstickTimer > this._myConfig.myScrollThumbstickDelay) {
          this._myScrollThumbstickTimer -= this._myConfig.myScrollThumbstickDelay;
          let normalizedScrollAmount = (Math.abs(axes[1]) - this._myConfig.myScrollThumbstickMinThreshold) / (1 - this._myConfig.myScrollThumbstickMinThreshold);
          this._myScrollOffset += Math.sign(axes[1]) * normalizedScrollAmount * this._myConfig.myScrollThumbstickAmount;
        }
        this._clampScrollOffset();
        this._updateAllTexts();
      } else {
        this._myScrollThumbstickTimer = 0;
      }
    }
  }
  _pulseGamepad() {
    if (this._myLeftGamepad && this._myRightGamepad) {
      let pulseType = this._myParams.myPulseOnNewMessage;
      let pulseEnabled = pulseType == ConsoleVRWidgetPulseOnNewMessage.ALWAYS || !this._myWidgetFrame.isVisible() && pulseType == ConsoleVRWidgetPulseOnNewMessage.WHEN_HIDDEN;
      if (pulseEnabled && this._myPulseTimer == 0) {
        if (this._myParams.myHandedness == ToolHandedness.RIGHT) {
          this._myRightGamepad.pulse(this._myConfig.myPulseIntensity, this._myConfig.myPulseDuration);
        } else {
          this._myLeftGamepad.pulse(this._myConfig.myPulseIntensity, this._myConfig.myPulseDuration);
        }
        this._myPulseTimer = this._myConfig.myPulseDelay;
      }
    }
  }
  _isSimpleArray(array) {
    if (this._isSpecialSimpleArray(array)) {
      return true;
    } else if (Array.isArray(array)) {
      let builtInArray = true;
      for (let element of array) {
        if (element instanceof Object) {
          builtInArray = false;
          break;
        }
      }
      return builtInArray;
    }
    return false;
  }
  _isSpecialSimpleArray(item) {
    return item && item.constructor && (item.constructor.name == "Uint8ClampedArray" || item.constructor.name == "Uint8Array" || item.constructor.name == "Uint16Array" || item.constructor.name == "Uint32Array" || item.constructor.name == "Int8Array" || item.constructor.name == "Int16Array" || item.constructor.name == "Int32Array" || item.constructor.name == "Float32Array" || item.constructor.name == "Float64Array");
  }
  _setGamepadScrollEnabled(enabled) {
    this._myGamepadScrollEnabled = enabled;
    if (!this._myConfig.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollEnabled = true;
    }
  }
  _jsonReplacer(key, value) {
    if (value instanceof Map) {
      return Array.from(value.entries());
    } else if (this._isSimpleArray(value)) {
      let array = value;
      if (this._isSpecialSimpleArray(array)) {
        let arrayCopy = [];
        for (let i = 0; i < array.length; i++) {
          arrayCopy[i] = array[i];
        }
        array = arrayCopy;
      }
      let stringifiedArray = JSON.stringify(array);
      stringifiedArray = stringifiedArray.split(",").join(", ");
      return stringifiedArray;
    } else {
      return value;
    }
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getWindow(this._myEngine).removeEventListener("error", this._myErrorEventListener);
    Globals.getWindow(this._myEngine).removeEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
    this._myUI.destroy();
    this._myWidgetFrame.destroy();
    if (this._myParams.myResetBrowserConsoleOriginalFunctionsOnDestroy) {
      console.log = ConsoleOriginalFunctions.getLog(this._myEngine);
      console.error = ConsoleOriginalFunctions.getError(this._myEngine);
      console.warn = ConsoleOriginalFunctions.getWarn(this._myEngine);
      console.info = ConsoleOriginalFunctions.getInfo(this._myEngine);
      console.debug = ConsoleOriginalFunctions.getDebug(this._myEngine);
      console.assert = ConsoleOriginalFunctions.getAssert(this._myEngine);
      console.clear = ConsoleOriginalFunctions.getClear(this._myEngine);
    } else {
      console.log = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG];
      console.error = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR];
      console.warn = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN];
      console.info = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO];
      console.debug = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG];
      console.assert = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT];
      console.clear = this._myOldBrowserConsoleClear;
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/console_vr/components/console_vr_tool_component.js
import { Component as Component54, Property as Property44 } from "@wonderlandengine/api";
var ConsoleVRToolComponent = class extends Component54 {
  static TypeName = "pp-console-vr-tool";
  static Properties = {
    _myHandedness: Property44.enum(["None", "Left", "Right"], "None"),
    _myOverrideBrowserConsoleFunctions: Property44.enum(["None", "All", "Errors & Warns"], "All"),
    _myShowOnStart: Property44.bool(false),
    _myShowVisibilityButton: Property44.bool(false),
    _myPulseOnNewMessage: Property44.enum(["Never", "Always", "When Hidden"], "Never")
  };
  start() {
    this._myStarted = false;
    if (Globals.isToolEnabled(this.engine)) {
      this.object.pp_addComponent(InitConsoleVRComponent);
      this._myWidget = new ConsoleVRWidget(this.engine);
      let params = new ConsoleVRWidgetParams(this.engine);
      params.myHandedness = [null, "left", "right"][this._myHandedness];
      params.myOverrideBrowserConsoleFunctions = this._myOverrideBrowserConsoleFunctions;
      params.myShowOnStart = this._myShowOnStart;
      params.myShowVisibilityButton = this._myShowVisibilityButton;
      params.myPulseOnNewMessage = this._myPulseOnNewMessage;
      params.myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      params.myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
      this._myWidget.start(this.object, params);
      this._myWidgetVisibleBackup = null;
      this._myStarted = true;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        if (this._myWidgetVisibleBackup != null) {
          this._myWidget.setVisible(false);
          this._myWidget.setVisible(this._myWidgetVisibleBackup);
          this._myWidgetVisibleBackup = null;
        }
        this._myWidget.update(dt);
      }
    } else if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myWidget.destroy();
    }
  }
};

// dist/tool/easy_tune/easy_tune_variable_types.js
import { Emitter as Emitter14 } from "@wonderlandengine/api";

// dist/tool/easy_tune/easy_tune_utils.js
var _mySetWidgetCurrentVariableCallbacks = /* @__PURE__ */ new WeakMap();
var _myRefreshWidgetCallbacks = /* @__PURE__ */ new WeakMap();
var _myAutoImportEnabledDefaultValues = /* @__PURE__ */ new WeakMap();
var _myManualImportEnabledDefaultValues = /* @__PURE__ */ new WeakMap();
var _myExportEnabledDefaultValues = /* @__PURE__ */ new WeakMap();
function setWidgetCurrentVariable(variableName, engine = Globals.getMainEngine()) {
  if (_mySetWidgetCurrentVariableCallbacks.has(engine)) {
    for (let callback of _mySetWidgetCurrentVariableCallbacks.get(engine).values()) {
      callback(variableName);
    }
  }
}
function refreshWidget(engine = Globals.getMainEngine()) {
  if (_myRefreshWidgetCallbacks.has(engine)) {
    for (let callback of _myRefreshWidgetCallbacks.get(engine).values()) {
      callback();
    }
  }
}
function importVariables(fileURL = null, resetVariablesDefaultValueOnImport = false, manualImport = false, onSuccessCallback = null, onFailureCallback = null, engine = Globals.getMainEngine()) {
  if (fileURL == null || fileURL.length == 0) {
    if (Globals.getNavigator(engine).clipboard) {
      Globals.getNavigator(engine).clipboard.readText().then(function(clipboard) {
        Globals.getEasyTuneVariables(engine).fromJSON(clipboard, resetVariablesDefaultValueOnImport, manualImport);
        EasyTuneUtils.refreshWidget(engine);
        if (onSuccessCallback != null) {
          onSuccessCallback();
        }
        console.log("Easy Tune Variables Imported from: clipboard");
        console.log(clipboard);
      }, function() {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from: clipboard");
      }).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from: clipboard");
        console.error(reason);
      });
    }
  } else {
    let replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL, engine);
    fetch(replacedFileURL).then(function(response) {
      if (response.ok) {
        response.text().then(function(text) {
          Globals.getEasyTuneVariables(engine).fromJSON(text, resetVariablesDefaultValueOnImport, manualImport);
          EasyTuneUtils.refreshWidget(engine);
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Imported from:", replacedFileURL);
          console.log(text);
        }, function(response2) {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
          console.error(response2);
        });
      } else {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
        console.error(response);
      }
    }, function(response) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
      console.error(response);
    }).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
      console.error(reason);
    });
  }
  EasyTuneUtils.refreshWidget(engine);
}
function exportVariables(fileURL = null, onSuccessCallback = null, onFailureCallback = null, engine = Globals.getMainEngine()) {
  let jsonVariables = Globals.getEasyTuneVariables(engine).toJSON();
  if (fileURL == null || fileURL.length == 0) {
    if (Globals.getNavigator(engine).clipboard) {
      Globals.getNavigator(engine).clipboard.writeText(jsonVariables).then(function() {
        if (onSuccessCallback != null) {
          onSuccessCallback();
        }
        console.log("Easy Tune Variables Exported to: clipboard");
        console.log(jsonVariables);
      }, function() {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to: clipboard");
      }).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to: clipboard");
        console.error(reason);
      });
    }
  } else {
    let replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL, engine);
    fetch(replacedFileURL, {
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: jsonVariables
    }).then(function(response) {
      if (response.ok) {
        if (onSuccessCallback != null) {
          onSuccessCallback();
        }
        console.log("Easy Tune Variables Exported to:", replacedFileURL);
        console.log(jsonVariables);
      } else {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
        console.error(response);
      }
    }, function(response) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
      console.error(response);
    }).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
      console.error(reason);
    });
  }
}
function setAutoImportEnabledDefaultValue(defaultValue, engine = Globals.getMainEngine()) {
  _myAutoImportEnabledDefaultValues.set(engine, defaultValue);
}
function setManualImportEnabledDefaultValue(defaultValue, engine = Globals.getMainEngine()) {
  _myManualImportEnabledDefaultValues.set(engine, defaultValue);
}
function setExportEnabledDefaultValue(defaultValue, engine = Globals.getMainEngine()) {
  _myExportEnabledDefaultValues.set(engine, defaultValue);
}
function getAutoImportEnabledDefaultValue(engine = Globals.getMainEngine()) {
  let defaultValue = true;
  if (_myAutoImportEnabledDefaultValues.has(engine)) {
    defaultValue = _myAutoImportEnabledDefaultValues.get(engine);
  }
  return defaultValue;
}
function getManualImportEnabledDefaultValue(engine = Globals.getMainEngine()) {
  let defaultValue = true;
  if (_myManualImportEnabledDefaultValues.has(engine)) {
    defaultValue = _myManualImportEnabledDefaultValues.get(engine);
  }
  return defaultValue;
}
function getExportEnabledDefaultValue(engine = Globals.getMainEngine()) {
  let defaultValue = true;
  if (_myExportEnabledDefaultValues.has(engine)) {
    defaultValue = _myExportEnabledDefaultValues.get(engine);
  }
  return defaultValue;
}
function addSetWidgetCurrentVariableCallback(id, callback, engine = Globals.getMainEngine()) {
  if (!_mySetWidgetCurrentVariableCallbacks.has(engine)) {
    _mySetWidgetCurrentVariableCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _mySetWidgetCurrentVariableCallbacks.get(engine).set(id, callback);
}
function removeSetWidgetCurrentVariableCallback(id, engine = Globals.getMainEngine()) {
  if (_mySetWidgetCurrentVariableCallbacks.has(engine)) {
    _mySetWidgetCurrentVariableCallbacks.get(engine).delete(id);
  }
}
function addRefreshWidgetCallback(id, callback, engine = Globals.getMainEngine()) {
  if (!_myRefreshWidgetCallbacks.has(engine)) {
    _myRefreshWidgetCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _myRefreshWidgetCallbacks.get(engine).set(id, callback);
}
function removeRefreshWidgetCallback(id, engine = Globals.getMainEngine()) {
  if (_myRefreshWidgetCallbacks.has(engine)) {
    _myRefreshWidgetCallbacks.get(engine).delete(id);
  }
}
var EasyTuneUtils = {
  setWidgetCurrentVariable,
  refreshWidget,
  importVariables,
  exportVariables,
  setAutoImportEnabledDefaultValue,
  setManualImportEnabledDefaultValue,
  setExportEnabledDefaultValue,
  getAutoImportEnabledDefaultValue,
  getManualImportEnabledDefaultValue,
  getExportEnabledDefaultValue,
  addSetWidgetCurrentVariableCallback,
  removeSetWidgetCurrentVariableCallback,
  addRefreshWidgetCallback,
  removeRefreshWidgetCallback
};
var _importExportVariablesReplaceFileURLParams = function() {
  let matchEasyTuneURLParamsRegex = new RegExp("\\{.+?\\}", "g");
  return function _importExportVariablesReplaceFileURLParams2(fileURL, engine = Globals.getMainEngine()) {
    let params = fileURL.match(matchEasyTuneURLParamsRegex);
    if (params == null || params.length == 0) {
      return fileURL;
    }
    for (let i = 0; i < params.length; i++) {
      params[i] = params[i].replace("{", "");
      params[i] = params[i].replace("}", "");
    }
    let urlSearchParams = new URL(Globals.getDocument(engine).location).searchParams;
    let replacedFileURL = fileURL;
    for (let param of params) {
      let searchParamValue = urlSearchParams.get(param);
      if (searchParamValue != null) {
        replacedFileURL = replacedFileURL.replace("{" + param + "}", searchParamValue);
      }
    }
    return replacedFileURL;
  };
}();

// dist/tool/easy_tune/easy_tune_variable_types.js
var EasyTuneVariableType = {
  NONE: 0,
  NUMBER: 1,
  BOOL: 2,
  TRANSFORM: 3
};
var EasyTuneVariableExtraParams = class {
  constructor(autoimportEnabled = null, manualImportEnabled = null, exportEnabled = null) {
    this.myAutoImportEnabled = autoimportEnabled;
    this.myManualImportEnabled = manualImportEnabled;
    this.myExportEnabled = exportEnabled;
  }
};
var EasyTuneVariable = class _EasyTuneVariable {
  constructor(name, type, onValueChangedEventListener = null, showOnWidget = true, extraParams = new EasyTuneVariableExtraParams(), engine = Globals.getMainEngine()) {
    this._myName = name;
    this._myType = type;
    this._myValue = null;
    this._myDefaultValue = null;
    this._myShowOnWidget = showOnWidget;
    this._myAutoImportEnabled = extraParams.myAutoImportEnabled != null ? extraParams.myAutoImportEnabled : EasyTuneUtils.getAutoImportEnabledDefaultValue(engine);
    this._myManualImportEnabled = extraParams.myManualImportEnabled != null ? extraParams.myManualImportEnabled : EasyTuneUtils.getManualImportEnabledDefaultValue(engine);
    this._myExportEnabled = extraParams.myExportEnabled != null ? extraParams.myExportEnabled : EasyTuneUtils.getExportEnabledDefaultValue(engine);
    this._myWidgetCurrentVariable = false;
    this._myValueChangedEmitter = new Emitter14();
    this._myEngine = engine;
    if (onValueChangedEventListener != null) {
      this.registerValueChangedEventListener(this, onValueChangedEventListener);
    }
  }
  getName() {
    return this._myName;
  }
  getType() {
    return this._myType;
  }
  isWidgetCurrentVariable() {
    return this._myWidgetCurrentVariable;
  }
  setWidgetCurrentVariable(widgetCurrentVariable) {
    this._myWidgetCurrentVariable = widgetCurrentVariable;
    return this;
  }
  getValue() {
    return this._myValue;
  }
  setValue(value, resetDefaultValue = false) {
    let valueChanged = this._myValue != value;
    this._myValue = value;
    if (resetDefaultValue) {
      _EasyTuneVariable.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged) {
      this._myValueChangedEmitter.notify(this.getValue(), this);
    }
    return this;
  }
  getDefaultValue() {
    return this._myDefaultValue;
  }
  setDefaultValue(value) {
    this._myDefaultValue = value;
    return this;
  }
  isShownOnWidget() {
    return this._myShowOnWidget;
  }
  setShowOnWidget(showOnWidget) {
    this._myShowOnWidget = showOnWidget;
    return this;
  }
  isManualImportEnabled() {
    return this._myManualImportEnabled;
  }
  isAutoImportEnabled() {
    return this._myAutoImportEnabled;
  }
  isExportEnabled() {
    return this._myExportEnabled;
  }
  setManualImportEnabled(enabled) {
    this._myManualImportEnabled = enabled;
    return this;
  }
  setAutoImportEnabled(enabled) {
    this._myAutoImportEnabled = enabled;
    return this;
  }
  setExportEnabled(enabled) {
    this._myExportEnabled = enabled;
    return this;
  }
  fromJSON(valueJSON, resetDefaultValue = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue);
  }
  toJSON() {
    return JSON.stringify(this.getValue());
  }
  registerValueChangedEventListener(id, listener) {
    this._myValueChangedEmitter.add(listener, { id });
  }
  unregisterValueChangedEventListener(id) {
    this._myValueChangedEmitter.remove(id);
  }
};
var EasyTuneVariableArray = class _EasyTuneVariableArray extends EasyTuneVariable {
  constructor(name, type, value, onValueChangedEventListener, showOnWidget, extraParams, engine) {
    super(name, type, onValueChangedEventListener, showOnWidget, extraParams, engine);
    _EasyTuneVariableArray.prototype.setValue.call(this, value, true);
  }
  setValue(value, resetDefaultValue = false) {
    let valueChanged = this._myValue != null && !this._myValue.pp_equals(value);
    if (this._myValue == null) {
      this._myValue = value.pp_clone();
    } else {
      this._myValue.pp_copy(value);
    }
    if (resetDefaultValue) {
      _EasyTuneVariableArray.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged) {
      this._myValueChangedEmitter.notify(this.getValue(), this);
    }
    return this;
  }
  setDefaultValue(value) {
    if (this._myDefaultValue == null) {
      this._myDefaultValue = value.pp_clone();
    } else {
      this._myDefaultValue.pp_copy(value);
    }
    return this;
  }
};
var EasyTuneNumberArray = class extends EasyTuneVariableArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, decimalPlaces = 3, stepPerSecond = 1, min = null, max = null, editAllValuesTogether = false, extraParams, engine) {
    super(name, EasyTuneVariableType.NUMBER, value, onValueChangedEventListener, showOnWidget, extraParams, engine);
    this._myDecimalPlaces = decimalPlaces;
    this._myStepPerSecond = stepPerSecond;
    this._myDefaultStepPerSecond = this._myStepPerSecond;
    this._myMin = min;
    this._myMax = max;
    this._myEditAllValuesTogether = editAllValuesTogether;
    this._clampValue(true);
  }
  setMax(max) {
    this._myMax = max;
    this._clampValue(false);
  }
  setMin(min) {
    this._myMin = min;
    this._clampValue(false);
  }
  _clampValue(resetDefaultValue) {
    let clampedValue = this._myValue.vec_clamp(this._myMin, this._myMax);
    if (!resetDefaultValue) {
      let clampedDefaultValue = this.getDefaultValue().vec_clamp(this._myMin, this._myMax);
      let defaultValueChanged = !clampedDefaultValue.vec_equals(this.getDefaultValue(), 1e-5);
      if (defaultValueChanged) {
        EasyTuneVariableArray.prototype.setDefaultValue.call(this, clampedDefaultValue);
      }
    }
    EasyTuneVariableArray.prototype.setValue.call(this, clampedValue, resetDefaultValue);
  }
};
var EasyTuneNumber = class extends EasyTuneNumberArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, decimalPlaces, stepPerSecond, min, max, extraParams, engine) {
    super(name, [value], onValueChangedEventListener, showOnWidget, decimalPlaces, stepPerSecond, min, max, void 0, extraParams, engine);
    this._myTempValue = [0];
    this._myTempDefaultValue = [0];
  }
  getValue() {
    return super.getValue()[0];
  }
  setValue(value, resetDefaultValue = false) {
    this._myTempValue[0] = value;
    return super.setValue(this._myTempValue, resetDefaultValue);
  }
  getDefaultValue() {
    return super.getDefaultValue()[0];
  }
  setDefaultValue(value) {
    this._myTempDefaultValue[0] = value;
    return super.setDefaultValue(this._myTempValue);
  }
};
var EasyTuneInt = class extends EasyTuneNumber {
  constructor(name, value, onValueChangedEventListener, showOnWidget, stepPerSecond, min, max, extraParams, engine) {
    super(name, value, onValueChangedEventListener, showOnWidget, 0, stepPerSecond, min, max, extraParams, engine);
  }
};
var EasyTuneIntArray = class extends EasyTuneNumberArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, stepPerSecond, min, max, editAllValuesTogether, extraParams, engine) {
    let roundedValue = value.pp_clone();
    for (let i = 0; i < value.length; i++) {
      roundedValue[i] = Math.round(roundedValue[i]);
    }
    super(name, roundedValue, onValueChangedEventListener, showOnWidget, 0, stepPerSecond, min != null ? Math.round(min) : null, max != null ? Math.round(max) : max, editAllValuesTogether, extraParams, engine);
  }
};
var EasyTuneBoolArray = class extends EasyTuneVariableArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, extraParams, engine) {
    super(name, EasyTuneVariableType.BOOL, value, onValueChangedEventListener, showOnWidget, extraParams, engine);
  }
};
var EasyTuneBool = class extends EasyTuneBoolArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, extraParams, engine) {
    super(name, [value], onValueChangedEventListener, showOnWidget, extraParams, engine);
    this._myTempValue = [0];
    this._myTempDefaultValue = [0];
  }
  getValue() {
    return super.getValue()[0];
  }
  setValue(value, resetDefaultValue = false) {
    this._myTempValue[0] = value;
    return super.setValue(this._myTempValue, resetDefaultValue);
  }
  getDefaultValue() {
    return super.getDefaultValue()[0];
  }
  setDefaultValue(value) {
    this._myTempDefaultValue[0] = value;
    return super.setDefaultValue(this._myTempValue);
  }
};
var EasyTuneTransform = class _EasyTuneTransform extends EasyTuneVariable {
  constructor(name, value, onValueChangedEventListener, showOnWidget, scaleAsOne = true, decimalPlaces = 3, positionStepPerSecond = 1, rotationStepPerSecond = 50, scaleStepPerSecond = 1, extraParams, engine) {
    super(name, EasyTuneVariableType.TRANSFORM, onValueChangedEventListener, showOnWidget, extraParams, engine);
    this._myDecimalPlaces = decimalPlaces;
    this._myPosition = value.mat4_getPosition();
    this._myRotation = value.mat4_getRotationDegrees();
    this._myScale = value.mat4_getScale();
    let decimalPlacesMultiplier = Math.pow(10, this._myDecimalPlaces);
    for (let i = 0; i < 3; i++) {
      this._myScale[i] = Math.max(this._myScale[i], 1 / decimalPlacesMultiplier);
    }
    this._myScaleAsOne = scaleAsOne;
    this._myPositionStepPerSecond = positionStepPerSecond;
    this._myRotationStepPerSecond = rotationStepPerSecond;
    this._myScaleStepPerSecond = scaleStepPerSecond;
    this._myDefaultPosition = this._myPosition.vec3_clone();
    this._myDefaultRotation = this._myRotation.vec3_clone();
    this._myDefaultScale = this._myScale.vec3_clone();
    this._myDefaultPositionStepPerSecond = this._myPositionStepPerSecond;
    this._myDefaultRotationStepPerSecond = this._myRotationStepPerSecond;
    this._myDefaultScaleStepPerSecond = this._myScaleStepPerSecond;
    this._myTransform = mat4_create();
    this._myTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    this._myTempTransform = mat4_create();
  }
  getValue() {
    this._myTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    return this._myTransform;
  }
  setValue(value, resetDefaultValue = false) {
    this._myTempTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    value.mat4_getPosition(this._myPosition);
    value.mat4_getRotationDegrees(this._myRotation);
    value.mat4_getScale(this._myScale);
    this._myTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    let valueChanged = !this._myTempTransform.pp_equals(this._myTransform);
    if (resetDefaultValue) {
      _EasyTuneTransform.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged) {
      this._myValueChangedEmitter.notify(this.getValue(), this);
    }
    return this;
  }
  setDefaultValue(value) {
    this._myDefaultPosition = value.mat4_getPosition();
    this._myDefaultRotation = value.mat4_getRotationDegrees();
    this._myDefaultScale = value.mat4_getScale();
    return this;
  }
  fromJSON(valueJSON, resetDefaultValue = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue);
  }
  toJSON() {
    return this.getValue().vec_toString();
  }
};

// dist/tool/easy_tune/components/easy_tune_tool_component.js
import { Component as Component55, Property as Property45 } from "@wonderlandengine/api";

// dist/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget.js
import { Emitter as Emitter15 } from "@wonderlandengine/api";
var EasyTuneBaseWidgetParams = class {
  constructor() {
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneBaseWidget = class {
  constructor(params) {
    this._myConfig = null;
    this._myUI = null;
    this._myParams = params;
    this._myVariable = null;
    this._myVisible = true;
    this._myScrollVariableRequestEmitter = new Emitter15();
    this._myAppendToVariableName = "";
    this._myScrollVariableActive = false;
    this._myScrollDirection = 0;
    this._myScrollVariableTimer = 0;
    this._myHasScrolled = false;
    this._myResetImportLabelTimer = new Timer(0, false);
    this._myResetExportLabelTimer = new Timer(0, false);
    this._myDestroyed = false;
  }
  setVisible(visible) {
    if (visible) {
      this._refreshUI();
    }
    this._myUI.setVisible(visible);
    this._myVisible = visible;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    this._myVariable = variable;
    if (typeof appendToVariableName !== "undefined") {
      this._myAppendToVariableName = appendToVariableName;
    } else {
      this._myAppendToVariableName = "";
    }
    this._setEasyTuneVariableHook();
    this._refreshUI();
  }
  isScrollVariableActive() {
    return this._myScrollVariableActive;
  }
  getScrollVariableDirection() {
    return this._myScrollDirection;
  }
  setScrollVariableActive(active, scrollDirection) {
    this._myScrollVariableActive = active;
    this._myScrollDirection = scrollDirection;
    this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
    this._myHasScrolled = false;
  }
  getWidget() {
    return this;
  }
  syncWidget(otherEasyTuneWidget) {
    if (otherEasyTuneWidget != null) {
      if (otherEasyTuneWidget._myResetImportLabelTimer.isRunning()) {
        this._myResetImportLabelTimer.start(otherEasyTuneWidget._myResetImportLabelTimer.getTimeLeft());
      } else {
        this._myResetImportLabelTimer.reset();
      }
      if (otherEasyTuneWidget._myResetExportLabelTimer.isRunning()) {
        this._myResetExportLabelTimer.start(otherEasyTuneWidget._myResetExportLabelTimer.getTimeLeft());
      } else {
        this._myResetExportLabelTimer.reset();
      }
      this._myUI.myImportButtonTextComponent.text = otherEasyTuneWidget._myUI.myImportButtonTextComponent.text;
      this._myUI.myExportButtonTextComponent.text = otherEasyTuneWidget._myUI.myExportButtonTextComponent.text;
      this.setScrollVariableActive(otherEasyTuneWidget.isScrollVariableActive(), otherEasyTuneWidget.getScrollVariableDirection());
    } else {
      this._myResetImportLabelTimer.reset();
      this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
      this._myResetExportLabelTimer.reset();
      this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
    }
  }
  onImportSuccess() {
    this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportSuccessButtonText;
    this._myResetImportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onImportFailure() {
    this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportFailureButtonText;
    this._myResetImportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onExportSuccess() {
    this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportSuccessButtonText;
    this._myResetExportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onExportFailure() {
    this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportFailureButtonText;
    this._myResetExportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  registerScrollVariableRequestEventListener(id, listener) {
    this._myScrollVariableRequestEmitter.add(listener, { id });
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestEmitter.remove(id);
  }
  start(parentObject, easyTuneParams) {
    this._myConfig.build();
    this._myResetImportLabelTimer.setDuration(this._myConfig.myImportExportResetLabelSeconds);
    this._myResetExportLabelTimer.setDuration(this._myConfig.myImportExportResetLabelSeconds);
    this._myUI.build(parentObject, this._myConfig, easyTuneParams);
    this._myUI.setImportExportButtonsVisible(easyTuneParams.myShowVariablesImportExportButtons);
    this._startHook(parentObject, easyTuneParams);
    this._addListeners();
  }
  update(dt) {
    if (this._isActive()) {
      this._updateHook(dt);
      this._updateScrollVariable(dt);
      this._updateImportExportLabel(dt);
    }
  }
  // Hooks
  _setEasyTuneVariableHook() {
  }
  _refreshUIHook() {
  }
  _startHook(parentObject, easyTuneParams) {
  }
  _addListenersHook() {
  }
  _updateHook(dt) {
  }
  // Hooks end
  _refreshUI() {
    if (this._myVariable) {
      if (this._myVariable.getName() != null) {
        this._myUI.myVariableLabelTextComponent.text = this._myVariable.getName().concat(this._myAppendToVariableName);
      } else {
        let name = "Unknown";
        this._myUI.myVariableLabelTextComponent.text = name.concat(this._myAppendToVariableName);
      }
      this._refreshUIHook();
    }
  }
  _updateScrollVariable(dt) {
    if (this._myScrollVariableActive) {
      if (this._myScrollVariableTimer <= 0) {
        this._scrollVariableRequest(this._myScrollDirection);
        this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
        this._myHasScrolled = true;
      } else {
        this._myScrollVariableTimer -= dt;
      }
    }
  }
  _updateImportExportLabel(dt) {
    if (this._myResetImportLabelTimer.isRunning(dt)) {
      this._myResetImportLabelTimer.update(dt);
      if (this._myResetImportLabelTimer.isDone()) {
        this._myResetImportLabelTimer.reset();
        this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
      }
    }
    if (this._myResetExportLabelTimer.isRunning(dt)) {
      this._myResetExportLabelTimer.update(dt);
      if (this._myResetExportLabelTimer.isDone()) {
        this._myResetExportLabelTimer.reset();
        this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
      }
    }
  }
  _isActive() {
    return this._myVisible && this._myVariable;
  }
  _addListeners() {
    let ui = this._myUI;
    ui.myNextButtonCursorTargetComponent.onDown.add(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.onDownOnHover.add(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.onUpWithDown.add(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myNextButtonCursorTargetComponent.onUpWithNoDown.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.onUnhover.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myNextButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.onDown.add(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.onDownOnHover.add(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.onUpWithDown.add(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myPreviousButtonCursorTargetComponent.onUpWithNoDown.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.onUnhover.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.onUpWithDown.add(this._importVariables.bind(this));
    ui.myImportButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.onUpWithDown.add(this._exportVariables.bind(this));
    ui.myExportButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myExportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myExportButtonBackgroundComponent.material));
    this._addListenersHook();
  }
  _setScrollVariableActive(active, scrollDirection, skipForceScroll) {
    if (this._isActive() || !active) {
      let forceScroll = !active && !this._myHasScrolled && !skipForceScroll;
      let oldScrollDirection = this._myScrollDirection;
      this.setScrollVariableActive(active, scrollDirection);
      if (forceScroll) {
        this._scrollVariableRequest(oldScrollDirection);
      }
    }
  }
  _scrollVariableRequest(amount) {
    if (this._isActive() && amount != 0) {
      this._myScrollVariableRequestEmitter.notify(amount);
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _genericUnhover(material) {
    material.color = this._myConfig.myBackgroundColor;
  }
  _importVariables() {
    if (this._myUI.myImportButtonTextComponent.text == this._myConfig.myImportButtonText) {
      this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportingButtonText;
      this._myResetImportLabelTimer.reset();
      this._myParams.myVariablesImportCallback();
    }
  }
  _exportVariables() {
    if (this._myUI.myExportButtonTextComponent.text == this._myConfig.myExportButtonText) {
      this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportingButtonText;
      this._myResetExportLabelTimer.reset();
      this._myParams.myVariablesExportCallback();
    }
  }
  destroy() {
    this._myDestroyed = true;
    if (this._myUI != null) {
      this._myUI.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_array_widget_selector.js
import { Emitter as Emitter16 } from "@wonderlandengine/api";
var EasyTuneBaseArrayWidgetSelector = class {
  constructor(params, gamepad, engine = Globals.getMainEngine()) {
    this._myGamepad = gamepad;
    this._myParentObject = null;
    this._myParams = params;
    this._myEasyTuneParams = null;
    this._myWidgets = /* @__PURE__ */ new Map();
    this._myVariable = null;
    this._myVisible = true;
    this._myAppendToVariableName = null;
    this._myScrollVariableRequestEmitter = new Emitter16();
    this._myCurrentArraySize = null;
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    this._myVariable = variable;
    this._myCurrentArraySize = this._myVariable.getValue().length;
    this._myAppendToVariableName = appendToVariableName;
    if (!this._myWidgets.has(this._myCurrentArraySize)) {
      this._createWidget(this._myCurrentArraySize);
    }
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setEasyTuneVariable(variable, appendToVariableName);
    }
    this.setVisible(this._myVisible);
  }
  setVisible(visible) {
    for (let widget of this._myWidgets.values()) {
      widget.setVisible(false);
    }
    if (this._myVariable) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.setVisible(visible);
      }
    }
    this._myVisible = visible;
  }
  isScrollVariableActive() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.isScrollVariableActive();
    }
    return false;
  }
  getScrollVariableDirection() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.getScrollVariableDirection();
    }
    return 0;
  }
  setScrollVariableActive(active, scrollDirection) {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setScrollVariableActive(active, scrollDirection);
    }
  }
  getWidget() {
    return this._myWidgets.get(this._myCurrentArraySize);
  }
  registerScrollVariableRequestEventListener(id, listener) {
    this._myScrollVariableRequestEmitter.add(listener, { id });
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestEmitter.remove(id);
  }
  start(parentObject, easyTuneParams) {
    this._myParentObject = parentObject;
    this._myEasyTuneParams = easyTuneParams;
    this._createWidget(1);
    if (this._myVariable) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  update(dt) {
    if (this._isActive()) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.update(dt);
      }
    }
  }
  onImportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportSuccess();
    }
  }
  onImportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportFailure();
    }
  }
  onExportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportSuccess();
    }
  }
  onExportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportFailure();
    }
  }
  _isActive() {
    return this._myVisible && this._myVariable;
  }
  _scrollVariableRequest(amount) {
    this._myScrollVariableRequestEmitter.notify(amount);
  }
  _createWidget(arraySize) {
    this._myWidgets.set(arraySize, this._getEasyTuneArrayWidget(arraySize));
    this._myWidgets.get(arraySize).start(this._myParentObject, this._myEasyTuneParams);
    this._myWidgets.get(arraySize).setVisible(false);
    this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariableRequest.bind(this));
  }
  _sizeChangedCheck() {
    if (this._myVariable.getValue().length != this._myCurrentArraySize) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  /**
   * TS type inference helper
   *
   * @returns {any}
   */
  _getEasyTuneArrayWidget(arraySize) {
    return null;
  }
  destroy() {
    this._myDestroyed = true;
    for (let widget of this._myWidgets.values()) {
      widget.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_config.js
import { Alignment as Alignment8, Collider as Collider4, Justification as Justification8 } from "@wonderlandengine/api";
var EasyTuneBaseWidgetConfig = class {
  constructor() {
  }
  build() {
    this._setupBuildConfig();
    this._setupRuntimeConfig();
  }
  // Hooks
  _getBackPanelMaxY() {
    return this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + this._mySideButtonDistanceFromBorder * 1.25;
  }
  _getBackPanelMinY() {
    return this.myDisplayPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getBackPanelMaxX() {
    return this._mySideButtonPanelHalfWidth;
  }
  _getBackPanelMinX() {
    return -this._mySideButtonPanelHalfWidth;
  }
  // Small Z offset to avoid glitching with other widgets
  _getPivotZOffset() {
    return 0;
  }
  _setupBuildConfigHook() {
  }
  _setupRuntimeConfigHook() {
  }
  // Hooks end
  _setupBuildConfig() {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider4.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment8.Center;
    this.myTextJustification = Justification8.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myLabelTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this._myPanelZOffset = 0.01;
    this._myColliderZOffset = 0.017;
    this._mySideButtonDistanceFromBorder = 0.0125;
    this._mySideButtonPanelHalfWidth = 0.2;
    this.myPivotObjectPositions = [];
    this.myPivotObjectPositions[ToolHandedness.NONE] = vec3_create(0, 0, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.LEFT] = vec3_create(-0.04, 0.02, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.RIGHT] = vec3_create(-0.08, 0.02, this._getPivotZOffset());
    this.mySideButtonBackgroundScale = vec3_create(0.015, 0.015, 1);
    this.mySideButtonTextScale = this.myButtonTextScale;
    this.mySideButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.mySideButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.mySideButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.pp_clone();
    this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myLeftSideButtonPosition = vec3_create(0, 0, -1e-5);
    this.myLeftSideButtonPosition[0] = -this._mySideButtonPanelHalfWidth + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
    this.myRightSideButtonPosition = vec3_create(0, 0, -1e-5);
    this.myRightSideButtonPosition[0] = -this.myLeftSideButtonPosition[0];
    this.myDisplayPanelPosition = vec3_create(0, 0.1, 0);
    this.myVariableLabelPanelPosition = vec3_create(0, 0.025, this._myPanelZOffset);
    this.myVariableLabelTextScale = this.myLabelTextScale;
    this.myVariableLabelCursorTargetPosition = vec3_create(0, 0, 0);
    this.myVariableLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myVariableLabelCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNextButtonText = ">";
    this.myPreviousButtonText = "<";
    this._setupBuildConfigHook();
    {
      let maxX = this._getBackPanelMaxX();
      let minX = this._getBackPanelMinX();
      let maxY = this._getBackPanelMaxY();
      let minY = this._getBackPanelMinY();
      this.myBackPanelPosition = [(maxX + minX) / 2, (maxY + minY) / 2, 0];
      this.myBackBackgroundScale = [(maxX - minX) / 2, (maxY - minY) / 2, 1];
      this.myBackBackgroundColor = vec4_create(70 / 255, 70 / 255, 70 / 255, 1);
    }
    this.myImportExportButtonBackgroundScale = vec3_create(0.04, 0.02, 1);
    this.myImportExportButtonTextScale = this.myButtonTextScale;
    this.myImportExportButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myImportExportPanelPosition = [0, this._getBackPanelMaxY() + this._mySideButtonDistanceFromBorder + this.myImportExportButtonBackgroundScale[1], this._myPanelZOffset];
    this.myImportExportButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myImportExportButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myImportExportButtonCollisionExtents = this.myImportExportButtonBackgroundScale.pp_clone();
    this.myImportExportButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myImportButtonText = "Import";
    this.myExportButtonText = "Export";
    this.myImportExportResetLabelSeconds = 2;
    this.myImportingButtonText = "...";
    this.myImportSuccessButtonText = "Done";
    this.myImportFailureButtonText = "Error";
    this.myExportingButtonText = "...";
    this.myExportSuccessButtonText = "Done";
    this.myExportFailureButtonText = "Error";
    this.myImportButtonPosition = vec3_create(0, 0, -1e-5);
    this.myImportButtonPosition[0] = -this.myImportExportButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder / 2;
    this.myExportButtonPosition = vec3_create(0, 0, -1e-5);
    this.myExportButtonPosition[0] = -this.myImportButtonPosition[0];
    this.myPointerCollisionExtents = this.myBackBackgroundScale.pp_clone();
    this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myPointerCursorTargetPosition = this.myBackPanelPosition.pp_clone();
    this.myPointerCursorTargetPosition[2] = this._myColliderZOffset - 1e-4;
  }
  _setupRuntimeConfig() {
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myScrollVariableDelay = 0.5;
    this._setupRuntimeConfigHook();
  }
};

// dist/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_config.js
var EasyTuneBoolArrayWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    return super._getBackPanelMinY() + this.myValuesPanelPosition[1] + valuePanelLastPosition;
  }
  _getPivotZOffset() {
    return 802713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myThumbstickToggleThreshold = 0.6;
    this.myButtonEditDelay = 0;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
import { CollisionComponent as CollisionComponent7, MeshComponent as MeshComponent17, TextComponent as TextComponent12 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget10 } from "@wonderlandengine/components";

// dist/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_ui.js
import { CollisionComponent as CollisionComponent6, MeshComponent as MeshComponent16, TextComponent as TextComponent11 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget9 } from "@wonderlandengine/components";
var EasyTuneBaseWidgetUI = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myImportExportButtonsVisible = true;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._buildHook();
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
    if (visible) {
      this.setImportExportButtonsVisible(this._myImportExportButtonsVisible);
    }
    this._setVisibleHook(visible);
  }
  setImportExportButtonsVisible(visible) {
    this._myImportExportButtonsVisible = visible;
    this.myImportExportPanel.pp_setActive(this._myImportExportButtonsVisible);
  }
  // Hooks
  _buildHook() {
  }
  _setVisibleHook(visible) {
  }
  _createSkeletonHook() {
  }
  _setTransformHook() {
  }
  _addComponentsHook() {
  }
  // Hooks end
  // Skeleton
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addObject();
    this.myBackPanel = this.myPivotObject.pp_addObject();
    this.myBackBackground = this.myBackPanel.pp_addObject();
    this.myDisplayPanel = this.myPivotObject.pp_addObject();
    this.myVariableLabelPanel = this.myDisplayPanel.pp_addObject();
    this.myVariableLabelText = this.myVariableLabelPanel.pp_addObject();
    this.myVariableLabelCursorTarget = this.myVariableLabelPanel.pp_addObject();
    this.myNextButtonPanel = this.myVariableLabelPanel.pp_addObject();
    this.myNextButtonBackground = this.myNextButtonPanel.pp_addObject();
    this.myNextButtonText = this.myNextButtonPanel.pp_addObject();
    this.myNextButtonCursorTarget = this.myNextButtonPanel.pp_addObject();
    this.myPreviousButtonPanel = this.myVariableLabelPanel.pp_addObject();
    this.myPreviousButtonBackground = this.myPreviousButtonPanel.pp_addObject();
    this.myPreviousButtonText = this.myPreviousButtonPanel.pp_addObject();
    this.myPreviousButtonCursorTarget = this.myPreviousButtonPanel.pp_addObject();
    this.myImportExportPanel = this.myPivotObject.pp_addObject();
    this.myImportButtonPanel = this.myImportExportPanel.pp_addObject();
    this.myImportButtonBackground = this.myImportButtonPanel.pp_addObject();
    this.myImportButtonText = this.myImportButtonPanel.pp_addObject();
    this.myImportButtonCursorTarget = this.myImportButtonPanel.pp_addObject();
    this.myExportButtonPanel = this.myImportExportPanel.pp_addObject();
    this.myExportButtonBackground = this.myExportButtonPanel.pp_addObject();
    this.myExportButtonText = this.myExportButtonPanel.pp_addObject();
    this.myExportButtonCursorTarget = this.myExportButtonPanel.pp_addObject();
    this.myPointerCursorTarget = this.myPivotObject.pp_addObject();
    this._createSkeletonHook();
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[this._myParams.myHandedness]);
    this.myBackPanel.pp_setPositionLocal(this._myConfig.myBackPanelPosition);
    this.myBackBackground.pp_scaleObject(this._myConfig.myBackBackgroundScale);
    this.myDisplayPanel.pp_setPositionLocal(this._myConfig.myDisplayPanelPosition);
    this.myVariableLabelPanel.pp_setPositionLocal(this._myConfig.myVariableLabelPanelPosition);
    this.myVariableLabelText.pp_scaleObject(this._myConfig.myVariableLabelTextScale);
    this.myVariableLabelCursorTarget.pp_setPositionLocal(this._myConfig.myVariableLabelCursorTargetPosition);
    this.myNextButtonPanel.pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
    this.myNextButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myNextButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myNextButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myNextButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myPreviousButtonPanel.pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
    this.myPreviousButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPreviousButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPreviousButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPreviousButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myImportExportPanel.pp_setPositionLocal(this._myConfig.myImportExportPanelPosition);
    this.myImportButtonPanel.pp_setPositionLocal(this._myConfig.myImportButtonPosition);
    this.myImportButtonBackground.pp_scaleObject(this._myConfig.myImportExportButtonBackgroundScale);
    this.myImportButtonText.pp_setPositionLocal(this._myConfig.myImportExportButtonTextPosition);
    this.myImportButtonText.pp_scaleObject(this._myConfig.myImportExportButtonTextScale);
    this.myImportButtonCursorTarget.pp_setPositionLocal(this._myConfig.myImportExportButtonCursorTargetPosition);
    this.myExportButtonPanel.pp_setPositionLocal(this._myConfig.myExportButtonPosition);
    this.myExportButtonBackground.pp_scaleObject(this._myConfig.myImportExportButtonBackgroundScale);
    this.myExportButtonText.pp_setPositionLocal(this._myConfig.myImportExportButtonTextPosition);
    this.myExportButtonText.pp_scaleObject(this._myConfig.myImportExportButtonTextScale);
    this.myExportButtonCursorTarget.pp_setPositionLocal(this._myConfig.myImportExportButtonCursorTargetPosition);
    this.myPointerCursorTarget.pp_setPositionLocal(this._myConfig.myPointerCursorTargetPosition);
    this._setTransformHook();
  }
  // Components
  _addComponents() {
    this.myBackBackgroundComponent = this.myBackBackground.pp_addComponent(MeshComponent16);
    this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
    this.myBackBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myBackBackgroundComponent.material.color = this._myConfig.myBackBackgroundColor;
    this.myVariableLabelTextComponent = this.myVariableLabelText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myVariableLabelTextComponent);
    this.myVariableLabelTextComponent.text = " ";
    this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.pp_addComponent(CursorTarget9);
    this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.pp_addComponent(CollisionComponent6);
    this.myVariableLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myVariableLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myVariableLabelCollisionComponent.extents = this._myConfig.myVariableLabelCollisionExtents;
    this.myNextButtonBackgroundComponent = this.myNextButtonBackground.pp_addComponent(MeshComponent16);
    this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNextButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myNextButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myNextButtonTextComponent = this.myNextButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myNextButtonTextComponent);
    this.myNextButtonTextComponent.text = this._myConfig.myNextButtonText;
    this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.pp_addComponent(CursorTarget9);
    this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myNextButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myNextButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myNextButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.pp_addComponent(MeshComponent16);
    this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPreviousButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPreviousButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPreviousButtonTextComponent = this.myPreviousButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myPreviousButtonTextComponent);
    this.myPreviousButtonTextComponent.text = this._myConfig.myPreviousButtonText;
    this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CursorTarget9);
    this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myPreviousButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPreviousButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPreviousButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myImportButtonBackgroundComponent = this.myImportButtonBackground.pp_addComponent(MeshComponent16);
    this.myImportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myImportButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myImportButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myImportButtonTextComponent = this.myImportButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myImportButtonTextComponent);
    this.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
    this.myImportButtonCursorTargetComponent = this.myImportButtonCursorTarget.pp_addComponent(CursorTarget9);
    this.myImportButtonCollisionComponent = this.myImportButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myImportButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myImportButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myImportButtonCollisionComponent.extents = this._myConfig.myImportExportButtonCollisionExtents;
    this.myExportButtonBackgroundComponent = this.myExportButtonBackground.pp_addComponent(MeshComponent16);
    this.myExportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myExportButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myExportButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myExportButtonTextComponent = this.myExportButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myExportButtonTextComponent);
    this.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
    this.myExportButtonCursorTargetComponent = this.myExportButtonCursorTarget.pp_addComponent(CursorTarget9);
    this.myExportButtonCollisionComponent = this.myExportButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myExportButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myExportButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myExportButtonCollisionComponent.extents = this._myConfig.myImportExportButtonCollisionExtents;
    this.myPointerCollisionComponent = this.myPointerCursorTarget.pp_addComponent(CollisionComponent6);
    this.myPointerCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPointerCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPointerCollisionComponent.extents = this._myConfig.myPointerCollisionExtents;
    this._addComponentsHook();
  }
  _setupTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.justification = this._myConfig.myTextJustification;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[this._myParams.myHandedness]);
  }
  _setTransformForNonXR() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[ToolHandedness.NONE]);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
var EasyTuneBoolArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addObject();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addObject();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addObject();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
    }
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._myConfig.myValuesPanelPosition);
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent12);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget10);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent7);
      this.myValueCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent17);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent12);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget10);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent7);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent17);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent12);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget10);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent7);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsVisible(this._myAdditionalButtonsVisible);
    }
  }
};

// dist/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget.js
var EasyTuneBoolArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine = Globals.getMainEngine()) {
    super(params);
    this._myNonArray = arraySize == null;
    this._myArraySize = this._myNonArray ? 1 : arraySize;
    this._myConfig = new EasyTuneBoolArrayWidgetConfig(this._myArraySize);
    this._myUI = new EasyTuneBoolArrayWidgetUI(engine);
    this._myGamepad = gamepad;
    this._myValueEditIndex = 0;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myTempValue = [];
    this._myTempNonArrayValue = [0];
    this._myTempNonArrayDefaultValue = [0];
  }
  _refreshUIHook() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._getVariableValue()[i] ? "true" : "false";
    }
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempValue.pp_copy(this._getVariableValue());
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      stickVariableIntensity = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
      if (Math.abs(valueIntensity) > this._myConfig.myThumbstickToggleThreshold) {
        this._myTempValue.pp_copy(this._getVariableValue());
        this._myTempValue[this._myValueEditIndex] = valueIntensity > 0;
        this._setVariableValue(this._myTempValue);
        this._refreshUI();
      }
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    for (let i = 0; i < this._myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
    }
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setValueEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myTempValue[index] = this._getVariableDefaultValue()[index];
      this._setVariableValue(this._myTempValue);
      this._myUI.myValueTextComponents[index].text = this._getVariableValue()[index] ? "true" : "false";
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
  _getVariableValue() {
    if (this._myNonArray) {
      this._myTempNonArrayValue[0] = this._myVariable.getValue();
      return this._myTempNonArrayValue;
    }
    return this._myVariable.getValue();
  }
  _getVariableDefaultValue() {
    if (this._myNonArray) {
      this._myTempNonArrayDefaultValue[0] = this._myVariable.getDefaultValue();
      return this._myTempNonArrayDefaultValue;
    }
    return this._myVariable.getDefaultValue();
  }
  _setVariableValue(value) {
    if (this._myNonArray) {
      this._myVariable.setValue(value[0]);
    } else {
      this._myVariable.setValue(this._myTempValue);
    }
  }
};

// dist/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_selector.js
var EasyTuneBoolArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneBoolArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// dist/tool/easy_tune/easy_tune_widgets/easy_tune_widget_config.js
var EasyTuneWidgetConfig = class {
  constructor() {
    this._setupRuntimeConfig();
  }
  _setupRuntimeConfig() {
    this.myGamepadHandedness = ToolHandedness.RIGHT;
    this.myScrollVariableDelay = 0.5;
    this.myScrollVariableMinXThreshold = 0.6;
    this.myScrollVariableMaxYThreshold = 0.25;
    this.myScrollVariableButtonID = null;
    this.myRefreshVariablesDelay = null;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_config.js
var EasyTuneNoneWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myTypeNotSupportedPanelPosition[1];
  }
  _getPivotZOffset() {
    return 804713e-8;
  }
  _setupBuildConfigHook() {
    this.myTypeNotSupportedPanelPosition = vec3_create(0, -0.03, this._myPanelZOffset);
    this.myTypeNotSupportedTextScale = vec3_create(0.275, 0.275, 0.275);
    this.myTypeNotSupportedText = "Type Not Supported";
  }
};

// dist/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_ui.js
import { TextComponent as TextComponent13 } from "@wonderlandengine/api";
var EasyTuneNoneWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  _createSkeletonHook() {
    this.myTypeNotSupportedPanel = this.myDisplayPanel.pp_addObject();
    this.myTypeNotSupportedText = this.myTypeNotSupportedPanel.pp_addObject();
    this.myTypeNotSupportedCursorTarget = this.myTypeNotSupportedPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myTypeNotSupportedPanel.pp_setPositionLocal(this._myConfig.myTypeNotSupportedPanelPosition);
    this.myTypeNotSupportedText.pp_scaleObject(this._myConfig.myTypeNotSupportedTextScale);
  }
  _addComponentsHook() {
    this.myTypeNotSupportedTextComponent = this.myTypeNotSupportedText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myTypeNotSupportedTextComponent);
    this.myTypeNotSupportedTextComponent.text = this._myConfig.myTypeNotSupportedText;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget.js
var EasyTuneNoneWidget = class extends EasyTuneBaseWidget {
  constructor(params, engine = Globals.getMainEngine()) {
    super(params);
    this._myConfig = new EasyTuneNoneWidgetConfig();
    this._myUI = new EasyTuneNoneWidgetUI(engine);
  }
};

// dist/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_config.js
var EasyTuneNumberArrayWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    return this.myStepPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getPivotZOffset() {
    return 803713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    this.myStepPanelPosition = [0, this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_ui.js
import { CollisionComponent as CollisionComponent8, MeshComponent as MeshComponent18, TextComponent as TextComponent14 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget11 } from "@wonderlandengine/components";
var EasyTuneNumberArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addObject();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addObject();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addObject();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
    }
    this.myStepPanel = this.myPivotObject.pp_addObject();
    this.myStepText = this.myStepPanel.pp_addObject();
    this.myStepCursorTarget = this.myStepPanel.pp_addObject();
    this.myStepIncreaseButtonPanel = this.myStepPanel.pp_addObject();
    this.myStepIncreaseButtonBackground = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepIncreaseButtonText = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepIncreaseButtonCursorTarget = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonPanel = this.myStepPanel.pp_addObject();
    this.myStepDecreaseButtonBackground = this.myStepDecreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonText = this.myStepDecreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonCursorTarget = this.myStepDecreaseButtonPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._myConfig.myValuesPanelPosition);
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
    this.myStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
    this.myStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent18);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent18);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myStepTextComponent = this.myStepText.pp_addComponent(TextComponent14);
    this._setupTextComponent(this.myStepTextComponent);
    this.myStepTextComponent.text = " ";
    this.myStepCursorTargetComponent = this.myStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myStepCollisionComponent = this.myStepCursorTarget.pp_addComponent(CollisionComponent8);
    this.myStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myStepIncreaseButtonBackgroundComponent = this.myStepIncreaseButtonBackground.pp_addComponent(MeshComponent18);
    this.myStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myStepIncreaseButtonTextComponent = this.myStepIncreaseButtonText.pp_addComponent(TextComponent14);
    this._setupTextComponent(this.myStepIncreaseButtonTextComponent);
    this.myStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myStepIncreaseButtonCursorTargetComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myStepIncreaseButtonCollisionComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent8);
    this.myStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myStepDecreaseButtonBackgroundComponent = this.myStepDecreaseButtonBackground.pp_addComponent(MeshComponent18);
    this.myStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myStepDecreaseButtonTextComponent = this.myStepDecreaseButtonText.pp_addComponent(TextComponent14);
    this._setupTextComponent(this.myStepDecreaseButtonTextComponent);
    this.myStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myStepDecreaseButtonCursorTargetComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myStepDecreaseButtonCollisionComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent8);
    this.myStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsVisible(this._myAdditionalButtonsVisible);
    }
  }
};

// dist/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget.js
var EasyTuneNumberArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine = Globals.getMainEngine()) {
    super(params);
    this._myGamepad = gamepad;
    this._myNonArray = arraySize == null;
    this._myArraySize = this._myNonArray ? 1 : arraySize;
    this._myConfig = new EasyTuneNumberArrayWidgetConfig(this._myArraySize);
    this._myUI = new EasyTuneNumberArrayWidgetUI(engine);
    this._myValueEditIndex = -1;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myStepEditEnabled = false;
    this._myValueRealValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myTempValue = [];
    this._myTempNonArrayValue = [0];
    this._myTempNonArrayDefaultValue = [0];
  }
  _refreshUIHook() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._getVariableValue()[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myStepPerSecond);
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempValue.pp_copy(this._getVariableValue());
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._myConfig.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._myConfig.myEditThumbstickMinThreshold) / (1 - this._myConfig.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
      if (valueIntensity != 0) {
        let amountToAdd = valueIntensity * this._myVariable._myStepPerSecond * dt;
        this._myValueRealValue += amountToAdd;
        if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
          this._myValueRealValue = Math.pp_clamp(this._myValueRealValue, this._myVariable._myMin, this._myVariable._myMax);
        } else if (this._myVariable._myMin != null) {
          this._myValueRealValue = Math.max(this._myValueRealValue, this._myVariable._myMin);
        } else if (this._myVariable._myMax != null) {
          this._myValueRealValue = Math.min(this._myValueRealValue, this._myVariable._myMax);
        }
        let decimalPlacesMultiplier = Math.pow(10, this._myVariable._myDecimalPlaces);
        this._myTempValue.pp_copy(this._getVariableValue());
        if (this._myVariable._myEditAllValuesTogether) {
          let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          let difference = newValue - this._myTempValue[this._myValueEditIndex];
          for (let i = 0; i < this._myArraySize; i++) {
            this._myTempValue[i] = Math.round((this._myTempValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
              this._myTempValue[i] = Math.pp_clamp(this._myTempValue[i], this._myVariable._myMin, this._myVariable._myMax);
            } else if (this._myVariable._myMin != null) {
              this._myTempValue[i] = Math.max(this._myTempValue[i], this._myVariable._myMin);
            } else if (this._myVariable._myMax != null) {
              this._myTempValue[i] = Math.min(this._myTempValue[i], this._myVariable._myMax);
            }
            this._myUI.myValueTextComponents[i].text = this._myTempValue[i].toFixed(this._myVariable._myDecimalPlaces);
          }
        } else {
          this._myTempValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
            this._myTempValue[this._myValueEditIndex] = Math.pp_clamp(this._myTempValue[this._myValueEditIndex], this._myVariable._myMin, this._myVariable._myMax);
          } else if (this._myVariable._myMin != null) {
            this._myTempValue[this._myValueEditIndex] = Math.max(this._myTempValue[this._myValueEditIndex], this._myVariable._myMin);
          } else if (this._myVariable._myMax != null) {
            this._myTempValue[this._myValueEditIndex] = Math.min(this._myTempValue[this._myValueEditIndex], this._myVariable._myMax);
          }
          this._myUI.myValueTextComponents[this._myValueEditIndex].text = this._myTempValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
        }
        this._setVariableValue(this._myTempValue);
      } else {
        this._myValueRealValue = this._getVariableValue()[this._myValueEditIndex];
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditEnabled) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._myConfig.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myVariable._myStepPerSecond * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myVariable._myStepPerSecond * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    for (let i = 0; i < this._myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
    }
    ui.myStepCursorTargetComponent.onClick.add(this._resetStep.bind(this));
    ui.myStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, ui.myStepText, true));
    ui.myStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, ui.myStepText, false));
    ui.myStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueRealValue = this._getVariableValue()[index];
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
    }
  }
  _setValueEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        this._myValueRealValue = this._getVariableValue()[index];
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _setStepEditEnabled(text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myStepTextScale);
      }
      this._myStepEditEnabled = enabled;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myTempValue[index] = this._getVariableDefaultValue()[index];
      this._setVariableValue(this._myTempValue);
      this._myUI.myValueTextComponents[index].text = this._getVariableValue()[index].toFixed(this._myVariable._myDecimalPlaces);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _resetStep() {
    if (this._isActive()) {
      this._changeStep(this._myVariable._myDefaultStepPerSecond);
    }
  }
  _changeStep(step) {
    step = Math.pp_roundDecimal(step, 10);
    this._myVariable._myStepPerSecond = step;
    this._myUI.myStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myStepPerSecond);
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
  _getVariableValue() {
    if (this._myNonArray) {
      this._myTempNonArrayValue[0] = this._myVariable.getValue();
      return this._myTempNonArrayValue;
    }
    return this._myVariable.getValue();
  }
  _getVariableDefaultValue() {
    if (this._myNonArray) {
      this._myTempNonArrayDefaultValue[0] = this._myVariable.getDefaultValue();
      return this._myTempNonArrayDefaultValue;
    }
    return this._myVariable.getDefaultValue();
  }
  _setVariableValue(value) {
    if (this._myNonArray) {
      this._myVariable.setValue(value[0]);
    } else {
      this._myVariable.setValue(this._myTempValue);
    }
  }
};

// dist/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_widget_selector.js
var EasyTuneNumberArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneNumberArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// dist/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_config.js
var EasyTuneTransformWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myPositionPanelPosition[1] + this.myStepPanelPosition[1];
  }
  _getBackPanelMaxX() {
    return this.myDisplayPanelPosition[0] + this.myRotationPanelPosition[0] + this.myIncreaseButtonPosition[0] + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
  }
  _getBackPanelMinX() {
    return this.myDisplayPanelPosition[0] + this.myScalePanelPosition[0] + this.myDecreaseButtonPosition[0] - this.mySideButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder;
  }
  _getPivotZOffset() {
    return 805713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this.myDecreaseButtonPosition = vec3_create(-0.13, 0, -1e-5);
    this.myIncreaseButtonPosition = vec3_create(-this.myDecreaseButtonPosition[0], 0, -1e-5);
    let distanceBetweenComponents = Math.abs(this.myIncreaseButtonPosition[0]) + Math.abs(this.myRightSideButtonPosition[0]);
    let distanceFromVariableLabel = 0.045;
    this.myPositionPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myRotationPanelPosition = [this.myPositionPanelPosition[0] + distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myScalePanelPosition = [this.myPositionPanelPosition[0] - distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myPositionText = "Position";
    this.myRotationText = "Rotation";
    this.myScaleText = "Scale";
    this.myComponentLabelTextScale = this.myLabelTextScale;
    this.myComponentLabelCursorTargetPosition = vec3_create(0, 0, 0);
    this.myComponentLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myComponentLabelCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myComponentLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, -this._myValuePanelDistanceFromVariableLabelPanel, 0);
    for (let i = 1; i < 3; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[2][1];
    this.myStepPanelPosition = [0, valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, 0];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_ui.js
import { CollisionComponent as CollisionComponent9, MeshComponent as MeshComponent19, TextComponent as TextComponent15 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget12 } from "@wonderlandengine/components";
var EasyTuneTransformWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < 3; i++) {
      this.myPositionIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myPositionDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myPositionStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myPositionStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    for (let i = 0; i < 3; i++) {
      this.myRotationIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myRotationDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myRotationStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myRotationStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    for (let i = 0; i < 3; i++) {
      this.myScaleIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myScaleDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myScaleStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myScaleStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myPositionPanel = this.myDisplayPanel.pp_addObject();
    this.myPositionLabelText = this.myPositionPanel.pp_addObject();
    this.myPositionLabelCursorTarget = this.myPositionPanel.pp_addObject();
    this.myPositionPanels = [];
    this.myPositionTexts = [];
    this.myPositionCursorTargets = [];
    this.myPositionIncreaseButtonPanels = [];
    this.myPositionIncreaseButtonBackgrounds = [];
    this.myPositionIncreaseButtonTexts = [];
    this.myPositionIncreaseButtonCursorTargets = [];
    this.myPositionDecreaseButtonPanels = [];
    this.myPositionDecreaseButtonBackgrounds = [];
    this.myPositionDecreaseButtonTexts = [];
    this.myPositionDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i] = this.myPositionPanel.pp_addObject();
      this.myPositionTexts[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionCursorTargets[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionIncreaseButtonPanels[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionIncreaseButtonBackgrounds[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionIncreaseButtonTexts[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionIncreaseButtonCursorTargets[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonPanels[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionDecreaseButtonBackgrounds[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonTexts[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonCursorTargets[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
    }
    this.myRotationPanel = this.myDisplayPanel.pp_addObject();
    this.myRotationLabelText = this.myRotationPanel.pp_addObject();
    this.myRotationLabelCursorTarget = this.myRotationPanel.pp_addObject();
    this.myRotationPanels = [];
    this.myRotationTexts = [];
    this.myRotationCursorTargets = [];
    this.myRotationIncreaseButtonPanels = [];
    this.myRotationIncreaseButtonBackgrounds = [];
    this.myRotationIncreaseButtonTexts = [];
    this.myRotationIncreaseButtonCursorTargets = [];
    this.myRotationDecreaseButtonPanels = [];
    this.myRotationDecreaseButtonBackgrounds = [];
    this.myRotationDecreaseButtonTexts = [];
    this.myRotationDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i] = this.myRotationPanel.pp_addObject();
      this.myRotationTexts[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationCursorTargets[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationIncreaseButtonPanels[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationIncreaseButtonBackgrounds[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationIncreaseButtonTexts[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationIncreaseButtonCursorTargets[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonPanels[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationDecreaseButtonBackgrounds[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonTexts[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonCursorTargets[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
    }
    this.myScalePanel = this.myDisplayPanel.pp_addObject();
    this.myScaleLabelText = this.myScalePanel.pp_addObject();
    this.myScaleLabelCursorTarget = this.myScalePanel.pp_addObject();
    this.myScalePanels = [];
    this.myScaleTexts = [];
    this.myScaleCursorTargets = [];
    this.myScaleIncreaseButtonPanels = [];
    this.myScaleIncreaseButtonBackgrounds = [];
    this.myScaleIncreaseButtonTexts = [];
    this.myScaleIncreaseButtonCursorTargets = [];
    this.myScaleDecreaseButtonPanels = [];
    this.myScaleDecreaseButtonBackgrounds = [];
    this.myScaleDecreaseButtonTexts = [];
    this.myScaleDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i] = this.myScalePanel.pp_addObject();
      this.myScaleTexts[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleCursorTargets[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleIncreaseButtonPanels[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleIncreaseButtonBackgrounds[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleIncreaseButtonTexts[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleIncreaseButtonCursorTargets[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonPanels[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleDecreaseButtonBackgrounds[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonTexts[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonCursorTargets[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
    }
    this.myPositionStepPanel = this.myPositionPanel.pp_addObject();
    this.myPositionStepText = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepCursorTarget = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepIncreaseButtonPanel = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepIncreaseButtonBackground = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepIncreaseButtonText = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepIncreaseButtonCursorTarget = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonPanel = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepDecreaseButtonBackground = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonText = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonCursorTarget = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepPanel = this.myRotationPanel.pp_addObject();
    this.myRotationStepText = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepCursorTarget = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepIncreaseButtonPanel = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepIncreaseButtonBackground = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepIncreaseButtonText = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepIncreaseButtonCursorTarget = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonPanel = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepDecreaseButtonBackground = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonText = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonCursorTarget = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepPanel = this.myScalePanel.pp_addObject();
    this.myScaleStepText = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepCursorTarget = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepIncreaseButtonPanel = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepIncreaseButtonBackground = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepIncreaseButtonText = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepIncreaseButtonCursorTarget = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonPanel = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepDecreaseButtonBackground = this.myScaleStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonText = this.myScaleStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonCursorTarget = this.myScaleStepDecreaseButtonPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myPositionPanel.pp_setPositionLocal(this._myConfig.myPositionPanelPosition);
    this.myPositionLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myPositionLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myPositionTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myPositionCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myPositionIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myPositionIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myPositionIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myPositionIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myPositionIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myPositionDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myPositionDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myPositionDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myPositionDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myPositionDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myRotationPanel.pp_setPositionLocal(this._myConfig.myRotationPanelPosition);
    this.myRotationLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myRotationLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myRotationTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myRotationCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myRotationIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myRotationIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myRotationIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myRotationIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myRotationIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myRotationDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myRotationDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myRotationDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myRotationDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myRotationDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myScalePanel.pp_setPositionLocal(this._myConfig.myScalePanelPosition);
    this.myScaleLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myScaleLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myScaleTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myScaleCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myScaleIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myScaleIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myScaleIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myScaleIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myScaleIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myScaleDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myScaleDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myScaleDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myScaleDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myScaleDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myPositionStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myPositionStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myPositionStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myPositionStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myPositionStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPositionStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPositionStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPositionStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myPositionStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myPositionStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPositionStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPositionStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPositionStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myRotationStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myRotationStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myRotationStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myRotationStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myRotationStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myRotationStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myRotationStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myRotationStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myRotationStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myRotationStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myRotationStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myRotationStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myRotationStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myScaleStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myScaleStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myScaleStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myScaleStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myScaleStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myScaleStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myScaleStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myScaleStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myScaleStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myScaleStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myScaleStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myScaleStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myScaleStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myPositionLabelTextComponent = this.myPositionLabelText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionLabelTextComponent);
    this.myPositionLabelTextComponent.text = this._myConfig.myPositionText;
    this.myPositionLabelCursorTargetComponent = this.myPositionLabelCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionLabelCollisionComponent = this.myPositionLabelCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myPositionTextComponents = [];
    this.myPositionCursorTargetComponents = [];
    this.myPositionCollisionComponents = [];
    this.myPositionIncreaseButtonBackgroundComponents = [];
    this.myPositionIncreaseButtonTextComponents = [];
    this.myPositionIncreaseButtonCursorTargetComponents = [];
    this.myPositionIncreaseButtonCollisionComponents = [];
    this.myPositionDecreaseButtonBackgroundComponents = [];
    this.myPositionDecreaseButtonTextComponents = [];
    this.myPositionDecreaseButtonCursorTargetComponents = [];
    this.myPositionDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionTextComponents[i] = this.myPositionTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myPositionTextComponents[i]);
      this.myPositionTextComponents[i].text = " ";
      this.myPositionCursorTargetComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myPositionCollisionComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myPositionCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myPositionIncreaseButtonBackgroundComponents[i] = this.myPositionIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myPositionIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myPositionIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myPositionIncreaseButtonTextComponents[i] = this.myPositionIncreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myPositionIncreaseButtonTextComponents[i]);
      this.myPositionIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myPositionIncreaseButtonCursorTargetComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myPositionIncreaseButtonCollisionComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myPositionIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myPositionDecreaseButtonBackgroundComponents[i] = this.myPositionDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myPositionDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myPositionDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myPositionDecreaseButtonTextComponents[i] = this.myPositionDecreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myPositionDecreaseButtonTextComponents[i]);
      this.myPositionDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myPositionDecreaseButtonCursorTargetComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myPositionDecreaseButtonCollisionComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myPositionDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myRotationLabelTextComponent = this.myRotationLabelText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationLabelTextComponent);
    this.myRotationLabelTextComponent.text = this._myConfig.myRotationText;
    this.myRotationLabelCursorTargetComponent = this.myRotationLabelCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationLabelCollisionComponent = this.myRotationLabelCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myRotationTextComponents = [];
    this.myRotationCursorTargetComponents = [];
    this.myRotationCollisionComponents = [];
    this.myRotationIncreaseButtonBackgroundComponents = [];
    this.myRotationIncreaseButtonTextComponents = [];
    this.myRotationIncreaseButtonCursorTargetComponents = [];
    this.myRotationIncreaseButtonCollisionComponents = [];
    this.myRotationDecreaseButtonBackgroundComponents = [];
    this.myRotationDecreaseButtonTextComponents = [];
    this.myRotationDecreaseButtonCursorTargetComponents = [];
    this.myRotationDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationTextComponents[i] = this.myRotationTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myRotationTextComponents[i]);
      this.myRotationTextComponents[i].text = " ";
      this.myRotationCursorTargetComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myRotationCollisionComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myRotationCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myRotationIncreaseButtonBackgroundComponents[i] = this.myRotationIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myRotationIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myRotationIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myRotationIncreaseButtonTextComponents[i] = this.myRotationIncreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myRotationIncreaseButtonTextComponents[i]);
      this.myRotationIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myRotationIncreaseButtonCursorTargetComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myRotationIncreaseButtonCollisionComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myRotationIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myRotationDecreaseButtonBackgroundComponents[i] = this.myRotationDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myRotationDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myRotationDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myRotationDecreaseButtonTextComponents[i] = this.myRotationDecreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myRotationDecreaseButtonTextComponents[i]);
      this.myRotationDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myRotationDecreaseButtonCursorTargetComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myRotationDecreaseButtonCollisionComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myRotationDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myScaleLabelTextComponent = this.myScaleLabelText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleLabelTextComponent);
    this.myScaleLabelTextComponent.text = this._myConfig.myScaleText;
    this.myScaleLabelCursorTargetComponent = this.myScaleLabelCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleLabelCollisionComponent = this.myScaleLabelCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myScaleTextComponents = [];
    this.myScaleCursorTargetComponents = [];
    this.myScaleCollisionComponents = [];
    this.myScaleIncreaseButtonBackgroundComponents = [];
    this.myScaleIncreaseButtonTextComponents = [];
    this.myScaleIncreaseButtonCursorTargetComponents = [];
    this.myScaleIncreaseButtonCollisionComponents = [];
    this.myScaleDecreaseButtonBackgroundComponents = [];
    this.myScaleDecreaseButtonTextComponents = [];
    this.myScaleDecreaseButtonCursorTargetComponents = [];
    this.myScaleDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myScaleTextComponents[i] = this.myScaleTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myScaleTextComponents[i]);
      this.myScaleTextComponents[i].text = " ";
      this.myScaleCursorTargetComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myScaleCollisionComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myScaleCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myScaleIncreaseButtonBackgroundComponents[i] = this.myScaleIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myScaleIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myScaleIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myScaleIncreaseButtonTextComponents[i] = this.myScaleIncreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myScaleIncreaseButtonTextComponents[i]);
      this.myScaleIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myScaleIncreaseButtonCursorTargetComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myScaleIncreaseButtonCollisionComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myScaleIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myScaleDecreaseButtonBackgroundComponents[i] = this.myScaleDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myScaleDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myScaleDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myScaleDecreaseButtonTextComponents[i] = this.myScaleDecreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myScaleDecreaseButtonTextComponents[i]);
      this.myScaleDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myScaleDecreaseButtonCursorTargetComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myScaleDecreaseButtonCollisionComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myScaleDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
  _addStepComponents() {
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget12);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
};

// dist/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget.js
var EasyTuneTransformWidget = class extends EasyTuneBaseWidget {
  constructor(params, gamepad, engine = Globals.getMainEngine()) {
    super(params);
    this._myGamepad = gamepad;
    this._myConfig = new EasyTuneTransformWidgetConfig();
    this._myUI = new EasyTuneTransformWidgetUI(engine);
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myStepEditEnabled = false;
    this._myValueRealValue = 0;
    this._myComponentStepValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myValueEditIndex = -1;
    this._myComponentIndex = 0;
    this._myStepIndex = 0;
    this._myTempTransformValue = mat4_create();
    this._myTempPositionValue = vec3_create();
    this._myTempRotationValue = vec3_create();
    this._myTempScaleValue = vec3_create();
  }
  _refreshUIHook() {
    for (let i = 0; i < 3; i++) {
      this._myUI.myPositionTextComponents[i].text = this._myVariable._myPosition[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myPositionStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myPositionStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myRotationTextComponents[i].text = this._myVariable._myRotation[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myRotationStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myRotationStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myScaleTextComponents[i].text = this._myVariable._myScale[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myScaleStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myScaleStepPerSecond);
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
      this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
      this._myTempScaleValue.pp_copy(this._myVariable._myScale);
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._myConfig.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._myConfig.myEditThumbstickMinThreshold) / (1 - this._myConfig.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < 3) {
      if (valueIntensity != 0) {
        this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
        this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
        this._myTempScaleValue.pp_copy(this._myVariable._myScale);
        let amountToAdd = valueIntensity * this._myComponentStepValue * dt;
        this._myValueRealValue += amountToAdd;
        let decimalPlacesMultiplier = Math.pow(10, this._myVariable._myDecimalPlaces);
        switch (this._myComponentIndex) {
          case 0:
            this._myTempPositionValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myUI.myPositionTextComponents[this._myValueEditIndex].text = this._myTempPositionValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            break;
          case 1:
            if (this._myValueRealValue > 180) {
              while (this._myValueRealValue > 180) {
                this._myValueRealValue -= 180;
              }
              this._myValueRealValue = -180 + this._myValueRealValue;
            }
            if (this._myValueRealValue < -180) {
              while (this._myValueRealValue < -180) {
                this._myValueRealValue += 180;
              }
              this._myValueRealValue = 180 - this._myValueRealValue;
            }
            this._myTempRotationValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myUI.myRotationTextComponents[this._myValueEditIndex].text = this._myTempRotationValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            break;
          case 2:
            if (this._myValueRealValue <= 0) {
              this._myValueRealValue = 1 / decimalPlacesMultiplier;
            }
            if (this._myVariable._myScaleAsOne) {
              let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              let difference = newValue - this._myTempScaleValue[this._myValueEditIndex];
              for (let i = 0; i < 3; i++) {
                this._myTempScaleValue[i] = Math.round((this._myTempScaleValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                this._myTempScaleValue[i] = Math.max(this._myTempScaleValue[i], 1 / decimalPlacesMultiplier);
                this._myUI.myScaleTextComponents[i].text = this._myTempScaleValue[i].toFixed(this._myVariable._myDecimalPlaces);
              }
            } else {
              this._myTempScaleValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              this._myTempScaleValue[this._myValueEditIndex] = Math.max(this._myTempScaleValue[this._myValueEditIndex], 1 / decimalPlacesMultiplier);
              this._myUI.myScaleTextComponents[this._myValueEditIndex].text = this._myTempScaleValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            }
            break;
        }
        this._myTempTransformValue.mat4_setPositionRotationDegreesScale(this._myTempPositionValue, this._myTempRotationValue, this._myTempScaleValue);
        this._myVariable.setValue(this._myTempTransformValue);
      } else {
        switch (this._myComponentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[this._myValueEditIndex];
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[this._myValueEditIndex];
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[this._myValueEditIndex];
            break;
        }
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditEnabled) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._myConfig.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        let stepValue = 0;
        switch (this._myStepIndex) {
          case 0:
            stepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            stepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            stepValue = this._myVariable._myScaleStepPerSecond;
            break;
          default:
            stepValue = 0;
        }
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myStepIndex, stepValue * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myStepIndex, stepValue * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    ui.myPositionLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 0));
    ui.myPositionLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myPositionLabelText));
    ui.myPositionLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myPositionLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 0, i));
      ui.myPositionCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], true));
      ui.myPositionCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], false));
    }
    ui.myRotationLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 1));
    ui.myRotationLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myRotationLabelText));
    ui.myRotationLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myRotationLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 1, i));
      ui.myRotationCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], true));
      ui.myRotationCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], false));
    }
    ui.myScaleLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 2));
    ui.myScaleLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myScaleLabelText));
    ui.myScaleLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myScaleLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 2, i));
      ui.myScaleCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], true));
      ui.myScaleCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], false));
    }
    ui.myPositionStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 0));
    ui.myPositionStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, true));
    ui.myPositionStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, false));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 1));
    ui.myRotationStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, true));
    ui.myRotationStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, false));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 2));
    ui.myScaleStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, true));
    ui.myScaleStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, false));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(componentIndex, index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[index];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[index];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[index];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
      this._myStepIndex = index;
    }
  }
  _setValueEditEnabled(componentIndex, index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[index];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[index];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[index];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _setStepEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myStepTextScale);
      }
      this._myStepEditEnabled = enabled;
      this._myStepIndex = index;
    }
  }
  _resetValue(componentIndex, index) {
    if (this._isActive()) {
      this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
      this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
      this._myTempScaleValue.pp_copy(this._myVariable._myScale);
      switch (componentIndex) {
        case 0:
          this._myTempPositionValue[index] = this._myVariable._myDefaultPosition[index];
          this._myUI.myPositionTextComponents[index].text = this._myTempPositionValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
        case 1:
          this._myTempRotationValue[index] = this._myVariable._myDefaultRotation[index];
          this._myUI.myRotationTextComponents[index].text = this._myTempRotationValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
        case 2:
          this._myTempScaleValue[index] = this._myVariable._myDefaultScale[index];
          this._myUI.myScaleTextComponents[index].text = this._myTempScaleValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
      }
      this._myTempTransformValue.mat4_setPositionRotationDegreesScale(this._myTempPositionValue, this._myTempRotationValue, this._myTempScaleValue);
      this._myVariable.setValue(this._myTempTransformValue);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < 3; i++) {
      this._resetComponentValues(i);
    }
  }
  _resetComponentValues(index) {
    for (let i = 0; i < 3; i++) {
      this._resetValue(index, i);
    }
  }
  _resetStep(index) {
    if (this._isActive()) {
      let defaultValue = 0;
      switch (index) {
        case 0:
          defaultValue = this._myVariable._myDefaultPositionStepPerSecond;
          break;
        case 1:
          defaultValue = this._myVariable._myDefaultRotationStepPerSecond;
          break;
        case 2:
          defaultValue = this._myVariable._myDefaultScaleStepPerSecond;
          break;
        default:
          defaultValue = 0;
      }
      this._changeStep(index, defaultValue);
    }
  }
  _changeStep(index, step) {
    step = Math.pp_roundDecimal(step, 10);
    switch (index) {
      case 0:
        this._myVariable._myPositionStepPerSecond = step;
        this._myUI.myPositionStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myPositionStepPerSecond);
        break;
      case 1:
        this._myVariable._myRotationStepPerSecond = step;
        this._myUI.myRotationStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myRotationStepPerSecond);
        break;
      case 2:
        this._myVariable._myScaleStepPerSecond = step;
        this._myUI.myScaleStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myScaleStepPerSecond);
        break;
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
};

// dist/tool/easy_tune/easy_tune_widgets/easy_tune_widget.js
var EasyTuneWidgetParams = class extends WidgetParams {
  constructor() {
    super();
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myShowAdditionalButtons = false;
    this.myGamepadScrollVariableEnabled = false;
    this.myShowVariablesImportExportButtons = false;
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneWidget = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myStarted = false;
    this._myStartVariable = null;
    this._myWidgetFrame = new WidgetFrame("E", 1, engine);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._myConfig = new EasyTuneWidgetConfig();
    this._myParams = null;
    this._myWidgets = [];
    this._myEasyTuneVariables = null;
    this._myEasyTuneLastSize = 0;
    this._myVariableNames = null;
    this._myCurrentWidget = null;
    this._myCurrentVariable = null;
    this._myScrollVariableTimer = 0;
    this._myGamepad = null;
    this._myRefreshVariablesTimer = 0;
    this._myDirty = false;
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  setCurrentVariable(variableName) {
    if (!this._myStarted) {
      this._myStartVariable = variableName;
    } else if (this._myEasyTuneVariables.has(variableName)) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(variableName);
      this._selectCurrentWidget();
    } else {
      console.warn("Can't change easy tune current variable to inexistent variable:", variableName);
    }
  }
  refresh() {
    if (this._myWidgetFrame.isVisible()) {
      this._myDirty = true;
    }
  }
  setVisible(visible) {
    this._myWidgetFrame.setVisible(visible);
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, params, easyTuneVariables) {
    this._myRightGamepad = Globals.getRightGamepad(this._myEngine);
    this._myLeftGamepad = Globals.getLeftGamepad(this._myEngine);
    if (this._myConfig.myGamepadHandedness == ToolHandedness.RIGHT) {
      this._myGamepad = this._myRightGamepad;
    } else if (this._myConfig.myGamepadHandedness == ToolHandedness.LEFT) {
      this._myGamepad = this._myLeftGamepad;
    }
    this._myStarted = true;
    this._myParams = params;
    this._myWidgetFrame.start(parentObject, params);
    this._myEasyTuneVariables = easyTuneVariables;
    this._myEasyTuneLastSize = this.getValidEasyTuneVariablesLength();
    this._myVariableNames = this.getValidEasyTuneVariablesNames();
    if (this.getValidEasyTuneVariablesLength() > 0) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    if (this._myStartVariable != null) {
      if (this._myEasyTuneVariables.has(this._myStartVariable)) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myStartVariable);
      } else {
        console.warn("Can't change easy tune current variable to inexistent variable:", this._myStartVariable);
      }
    }
    this._initializeWidgets();
  }
  update(dt) {
    this._myWidgetFrame.update(dt);
    if (this.getValidEasyTuneVariablesLength() != this._myEasyTuneLastSize || this._myDirty) {
      this._refreshEasyTuneVariables();
    }
    if (this._myWidgetFrame.isVisible() && this.getValidEasyTuneVariablesLength() > 0) {
      if (this._myConfig.myRefreshVariablesDelay != null) {
        this._myRefreshVariablesTimer += dt;
        if (this._myRefreshVariablesTimer > this._myConfig.myRefreshVariablesDelay) {
          this._myRefreshVariablesTimer = 0;
          this._refreshEasyTuneVariables();
        }
      }
      if (this._myCurrentWidget) {
        this._myCurrentWidget.update(dt);
      }
      if (this._myParams.myGamepadScrollVariableEnabled) {
        this._updateGamepadScrollVariable(dt);
      }
    }
    this._updateGamepadWidgetVisibility();
    this._updateWidgetCurrentVariable();
  }
  _initializeWidgets() {
    let widgetParams = new EasyTuneBaseWidgetParams();
    widgetParams.myVariablesImportCallback = this._importVariables.bind(this);
    widgetParams.myVariablesExportCallback = this._exportVariables.bind(this);
    this._myWidgets[EasyTuneVariableType.NONE] = new EasyTuneNoneWidget(widgetParams, this._myEngine);
    this._myWidgets[EasyTuneVariableType.NUMBER] = new EasyTuneNumberArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.BOOL] = new EasyTuneBoolArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.TRANSFORM] = new EasyTuneTransformWidget(widgetParams, this._myGamepad, this._myEngine);
    for (let widget of this._myWidgets) {
      if (widget != null) {
        widget.start(this._myWidgetFrame.getWidgetObject(), this._myParams);
        widget.setVisible(false);
        widget.registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
      }
    }
    this._selectCurrentWidget();
  }
  _selectCurrentWidget() {
    if (this.getValidEasyTuneVariablesLength() <= 0) {
      return;
    } else if (this._myCurrentVariable == null) {
      this._myVariableNames = this.getValidEasyTuneVariablesNames();
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    let prevWidget = null;
    if (this._myCurrentWidget != null) {
      prevWidget = this._myCurrentWidget.getWidget();
    }
    if (this._myCurrentVariable.getType() in this._myWidgets) {
      this._myCurrentWidget = this._myWidgets[this._myCurrentVariable.getType()];
    } else {
      this._myCurrentWidget = this._myWidgets[EasyTuneVariableType.NONE];
    }
    this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
    this._myCurrentWidget.getWidget().syncWidget(prevWidget);
    if (prevWidget != null) {
      prevWidget.setVisible(false);
    }
    this._myCurrentWidget.setVisible(this._myWidgetFrame.isVisible());
  }
  _refreshEasyTuneVariables() {
    this._myVariableNames = this.getValidEasyTuneVariablesNames();
    this._myEasyTuneLastSize = this.getValidEasyTuneVariablesLength();
    if (this.getValidEasyTuneVariablesLength() > 0) {
      if (this._myCurrentVariable && this._myVariableNames.pp_hasEqual(this._myCurrentVariable.getName())) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myCurrentVariable.getName());
      } else {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
      }
      this._selectCurrentWidget();
    } else {
      this._myCurrentVariable = null;
      if (this._myCurrentWidget) {
        this._myCurrentWidget.setVisible(false);
        this._myCurrentWidget = null;
      }
    }
    this._myDirty = false;
  }
  _updateGamepadWidgetVisibility() {
    if (this._myGamepad) {
      if (this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        this._toggleVisibility();
      }
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    for (let widget of this._myWidgets) {
      if (widget != null) {
        widget.setVisible(false);
      }
    }
    if (this._myCurrentWidget) {
      if (this.getValidEasyTuneVariablesLength() > 0) {
        this._myCurrentWidget.setVisible(visible);
      } else {
        this._myCurrentWidget.setVisible(false);
      }
    }
    if (visible) {
      this._refreshEasyTuneVariables();
    }
  }
  _updateGamepadScrollVariable(dt) {
    if (this._myGamepad && (!this._myConfig.myScrollVariableButtonID || this._myGamepad.getButtonInfo(this._myConfig.myScrollVariableButtonID).isPressed())) {
      let x = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[0];
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(x) > this._myConfig.myScrollVariableMinXThreshold && Math.abs(y) < this._myConfig.myScrollVariableMaxYThreshold) {
        this._myScrollVariableTimer += dt;
        while (this._myScrollVariableTimer > this._myConfig.myScrollVariableDelay) {
          this._myScrollVariableTimer -= this._myConfig.myScrollVariableDelay;
          this._scrollVariable(Math.sign(x));
        }
      } else {
        this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
      }
    } else {
      this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
    }
  }
  _scrollVariable(amount) {
    if (this.getValidEasyTuneVariablesLength() <= 0) {
      return;
    }
    let variableIndex = this._getVariableIndex(this._myCurrentVariable);
    if (variableIndex >= 0) {
      let newIndex = ((variableIndex + amount) % this._myVariableNames.length + this._myVariableNames.length) % this._myVariableNames.length;
      if (this._myEasyTuneVariables.has(this._myVariableNames[newIndex])) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[newIndex]);
        this._selectCurrentWidget();
      } else {
        this._refreshEasyTuneVariables();
      }
    } else {
      this._refreshEasyTuneVariables();
    }
  }
  _createIndexString() {
    let indexString = " (";
    let index = (this._getVariableIndex(this._myCurrentVariable) + 1).toString();
    let length5 = this.getValidEasyTuneVariablesLength().toString();
    while (index.length < length5.length) {
      index = "0".concat(index);
    }
    indexString = indexString.concat(index).concat(" - ").concat(length5).concat(")");
    return indexString;
  }
  _getVariableIndex(variable) {
    let variableIndex = this._myVariableNames.indexOf(variable.getName());
    return variableIndex;
  }
  _updateWidgetCurrentVariable() {
    for (let variable of this._myEasyTuneVariables.getEasyTuneVariablesList()) {
      variable.setWidgetCurrentVariable(false);
    }
    if (this._myWidgetFrame.isVisible() && this._myCurrentVariable) {
      this._myCurrentVariable.setWidgetCurrentVariable(true);
    }
  }
  _importVariables() {
    this._myParams.myVariablesImportCallback(this._onImportSuccess.bind(this), this._onImportFailure.bind(this));
  }
  _exportVariables() {
    this._myParams.myVariablesExportCallback(this._onExportSuccess.bind(this), this._onExportFailure.bind(this));
  }
  _onImportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportSuccess();
    }
  }
  _onImportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportFailure();
    }
  }
  _onExportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportSuccess();
    }
  }
  _onExportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportFailure();
    }
  }
  destroy() {
    this._myDestroyed = true;
    for (let widget of this._myWidgets) {
      widget.destroy();
    }
    this._myWidgetFrame.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
  getValidEasyTuneVariablesLength() {
    return this.getValidEasyTuneVariablesNames().length;
  }
  getValidEasyTuneVariablesNames() {
    let names = this._myEasyTuneVariables.getEasyTuneVariablesNames();
    let validNames = [];
    for (let name of names) {
      let variable = this._myEasyTuneVariables.getEasyTuneVariable(name);
      if (variable.isShownOnWidget()) {
        validNames.push(name);
      }
    }
    return validNames;
  }
};

// dist/tool/easy_tune/components/easy_tune_tool_component.js
var EasyTuneToolComponent = class extends Component55 {
  static TypeName = "pp-easy-tune-tool";
  static Properties = {
    _myHandedness: Property45.enum(["None", "Left", "Right"], "None"),
    _myShowOnStart: Property45.bool(false),
    _myShowVisibilityButton: Property45.bool(false),
    _myGamepadScrollVariableEnabled: Property45.bool(true),
    _myShowVariablesImportExportButtons: Property45.bool(false),
    _myVariablesImportURL: Property45.string(""),
    // The URL can contain parameters inside brackets, like {param}
    _myVariablesExportURL: Property45.string(""),
    // Those parameters will be replaced with the same one on the current page url, like www.currentpage.com/?param=2
    _myImportVariablesOnStart: Property45.bool(false),
    _myResetVariablesDefaultValueOnImport: Property45.bool(false)
  };
  init() {
    this.object.pp_addComponent(InitEasyTuneVariablesComponent);
    this._myWidget = new EasyTuneWidget(this.engine);
    EasyTuneUtils.addSetWidgetCurrentVariableCallback(this, function(variableName) {
      this._myWidget.setCurrentVariable(variableName);
    }.bind(this), this.engine);
    EasyTuneUtils.addRefreshWidgetCallback(this, function() {
      this._myWidget.refresh();
    }.bind(this), this.engine);
    this._myStarted = false;
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      let params = new EasyTuneWidgetParams();
      params.myHandedness = [null, "left", "right"][this._myHandedness];
      params.myShowOnStart = this._myShowOnStart;
      params.myShowVisibilityButton = this._myShowVisibilityButton;
      params.myShowAdditionalButtons = true;
      params.myGamepadScrollVariableEnabled = this._myGamepadScrollVariableEnabled;
      params.myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      params.myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
      params.myShowVariablesImportExportButtons = this._myShowVariablesImportExportButtons;
      params.myVariablesImportCallback = function(onSuccessCallback, onFailureCallback) {
        EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, true, onSuccessCallback, onFailureCallback, this.engine);
      }.bind(this);
      params.myVariablesExportCallback = function(onSuccessCallback, onFailureCallback) {
        EasyTuneUtils.exportVariables(this._myVariablesExportURL, onSuccessCallback, onFailureCallback, this.engine);
      }.bind(this);
      this._myWidget.start(this.object, params, Globals.getEasyTuneVariables(this.engine));
      this._myWidgetVisibleBackup = null;
      this._myStarted = true;
      this._myFirstUpdate = true;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        if (this._myFirstUpdate) {
          this._myFirstUpdate = false;
          if (this._myImportVariablesOnStart) {
            EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, false, void 0, void 0, this.engine);
          }
        }
        if (this._myWidgetVisibleBackup != null) {
          this._myWidget.setVisible(false);
          this._myWidget.setVisible(this._myWidgetVisibleBackup);
          this._myWidgetVisibleBackup = null;
        }
        this._myWidget.update(dt);
      }
    } else if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDestroy() {
    this._myWidget.destroy();
    EasyTuneUtils.removeSetWidgetCurrentVariableCallback(this, this.engine);
    EasyTuneUtils.removeRefreshWidgetCallback(this, this.engine);
  }
};

// dist/tool/easy_tune/components/easy_tune_import_variables_component.js
import { Component as Component56, Property as Property46 } from "@wonderlandengine/api";
var EasyTuneImportVariablesComponent = class extends Component56 {
  static TypeName = "pp-easy-tune-import-variables";
  static Properties = {
    _myVariablesImportURL: Property46.string(""),
    _myResetVariablesDefaultValueOnImport: Property46.bool(true)
  };
  start() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, false, void 0, void 0, this.engine);
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_object_tuner.js
var EasyObjectTuner = class {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine = Globals.getMainEngine()) {
    this._myObject = object;
    this._myUseTuneTarget = useTuneTarget;
    this._mySetAsWidgetCurrentVariable = setAsWidgetCurrentVariable;
    this._myEasyObject = this._myObject;
    if (this._myUseTuneTarget) {
      this._myEasyObject = Globals.getEasyTuneTarget(engine);
    }
    this._myPrevEasyObject = null;
    let variableNamePrefix = this._getVariableNamePrefix();
    if (variableName == "") {
      let objectName = this._myObject.pp_getName();
      if (objectName != "") {
        this._myEasyTuneVariableName = variableNamePrefix.concat(objectName);
      } else {
        this._myEasyTuneVariableName = variableNamePrefix.concat(this._myObject.pp_getID());
      }
    } else {
      this._myEasyTuneVariableName = variableNamePrefix.concat(variableName);
    }
    this._myEngine = engine;
  }
  start() {
    let easyTuneVariable = this._createEasyTuneVariable(this._myEasyTuneVariableName);
    Globals.getEasyTuneVariables(this._myEngine).add(easyTuneVariable);
    if (this._mySetAsWidgetCurrentVariable) {
      EasyTuneUtils.setWidgetCurrentVariable(this._myEasyTuneVariableName, this._myEngine);
    }
  }
  update(dt) {
    if (Globals.getEasyTuneVariables(this._myEngine).isWidgetCurrentVariable(this._myEasyTuneVariableName)) {
      if (this._myUseTuneTarget) {
        this._myEasyObject = Globals.getEasyTuneTarget(this._myEngine);
      }
      if (this._myPrevEasyObject != this._myEasyObject) {
        this._myPrevEasyObject = this._myEasyObject;
        if (this._myEasyObject) {
          let value = this._getObjectValue(this._myEasyObject);
          Globals.getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value, true);
        } else {
          let value = this._getDefaultValue();
          Globals.getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value, true);
        }
      }
      if (this._myEasyObject) {
        this._updateObjectValue(this._myEasyObject, Globals.getEasyTuneVariables(this._myEngine).get(this._myEasyTuneVariableName));
      }
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_light_attenuation.js
import { LightComponent as LightComponent3 } from "@wonderlandengine/api";
var EasyLightAttenuation = class extends EasyObjectTuner {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget);
  }
  _getVariableNamePrefix() {
    let nameFirstPart = "Light Attenuation ";
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), null, true, 3, 0.01, 0, 1, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let attenuation = this._getLightAttenuation(object);
    return attenuation;
  }
  _getDefaultValue() {
    return 0;
  }
  _updateObjectValue(object, value) {
    let attenuation = value;
    let light = object.pp_getComponent(LightComponent3);
    if (light) {
      light.color[3] = attenuation;
    }
  }
  _getLightAttenuation(object) {
    let attenuation = this._getDefaultValue();
    let light = object.pp_getComponent(LightComponent3);
    if (light) {
      attenuation = light.color[3];
    }
    return attenuation;
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_light_color.js
import { LightComponent as LightComponent4 } from "@wonderlandengine/api";
var EasyLightColor = class extends EasyObjectTuner {
  constructor(colorModel, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myColorModel = colorModel;
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Light RGB ";
    } else {
      nameFirstPart = "Light HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255, false, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let color = null;
    let lightColor = this._getLightColor(object);
    if (lightColor) {
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbCodeToHuman(lightColor);
      } else {
        color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHSV(lightColor));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec3_create();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.rgbHumanToCode(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.hsvHumanToCode(color));
    }
    let light = object.pp_getComponent(LightComponent4);
    if (light != null) {
      light.color[0] = color[0];
      light.color[1] = color[1];
      light.color[2] = color[2];
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHSV(color));
      let rgbColor = ColorUtils.color1To255(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getLightColor(object) {
    let color = null;
    let light = object.pp_getComponent(LightComponent4);
    if (light) {
      color = light.color.slice(0, 3);
    }
    return color;
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_mesh_color.js
import { MeshComponent as MeshComponent20 } from "@wonderlandengine/api";
var EasyMeshColor = class extends EasyObjectTuner {
  constructor(colorModel, colorType, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
    this._myColorVariableNames = ["color", "diffuseColor", "ambientColor", "specularColor", "emissiveColor", "fogColor", "ambientFactor"];
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Mesh RGB ";
    } else {
      nameFirstPart = "Mesh HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    if (this._myColorType == 6) {
      return new EasyTuneNumberArray(variableName, this._getDefaultValue(), null, true, 3, 0.1, 0, 1, false, void 0, this._myEngine);
    }
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255, false, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let color = null;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      if (this._myColorType != 6) {
        color = meshMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
        if (this._myColorModel == 0) {
          color = ColorUtils.rgbCodeToHuman(color);
        } else {
          color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHSV(color));
        }
      } else {
        color = [meshMaterial[this._myColorVariableNames[this._myColorType]]];
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    if (this._myColorType == 6) {
      return [0];
    }
    return vec4_create();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorType != 6) {
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbHumanToCode(color);
      } else {
        color = ColorUtils.hsvToRGB(ColorUtils.hsvHumanToCode(color));
      }
    }
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial[this._myColorVariableNames[this._myColorType]] = color;
    }
    if (this._myColorType != 6) {
      if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHSV(color));
        let rgbColor = ColorUtils.color1To255(color);
        console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
      }
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    let mesh = object.pp_getComponent(MeshComponent20);
    if (mesh) {
      material = mesh.material;
    }
    return material;
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_scale.js
var EasyScale = class extends EasyObjectTuner {
  constructor(local, scaleAsOne, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myLocal = local;
    this._myScaleAsOne = scaleAsOne;
  }
  _getVariableNamePrefix() {
    return "Scale ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumberArray(variableName, this._getDefaultValue(), null, true, 3, 1, 1e-3, null, this._myScaleAsOne, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    return this._myLocal ? object.pp_getScaleLocal() : object.pp_getScale();
  }
  _getDefaultValue() {
    return vec3_create(1, 1, 1);
  }
  _updateObjectValue(object, value) {
    if (this._myLocal) {
      object.pp_setScaleLocal(value);
    } else {
      object.pp_setScale(value);
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_transform.js
var EasyTransform = class extends EasyObjectTuner {
  constructor(local, scaleAsOne, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myLocal = local;
    this._myScaleAsOne = scaleAsOne;
  }
  _getVariableNamePrefix() {
    return "Transform ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneTransform(variableName, this._getDefaultValue(), null, true, this._myScaleAsOne, 3, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    return this._myLocal ? object.pp_getTransformLocal() : object.pp_getTransform();
  }
  _getDefaultValue() {
    return mat4_create();
  }
  _updateObjectValue(object, value) {
    if (this._myLocal) {
      object.pp_setTransformLocal(value);
    } else {
      object.pp_setTransform(value);
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_mesh_ambient_factor.js
import { MeshComponent as MeshComponent21 } from "@wonderlandengine/api";
var EasyMeshAmbientFactor = class extends EasyObjectTuner {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Mesh AF ";
    } else {
      nameFirstPart = "Mesh AF ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), null, true, 3, 0.1, 0, 1, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let ambientFactor = null;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      ambientFactor = meshMaterial.ambientFactor;
    } else {
      ambientFactor = this._getDefaultValue();
    }
    return ambientFactor;
  }
  _getDefaultValue() {
    return 0;
  }
  _updateObjectValue(object, value) {
    let ambientFactor = value;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial.ambientFactor = ambientFactor;
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    let mesh = object.pp_getComponent(MeshComponent21);
    if (mesh) {
      material = mesh.material;
    }
    return material;
  }
};

// dist/tool/easy_tune/easy_object_tuners/easy_text_color.js
import { TextComponent as TextComponent16 } from "@wonderlandengine/api";
var EasyTextColor = class extends EasyObjectTuner {
  constructor(colorModel, colorType, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
    this._myColorVariableNames = ["color", "effectColor"];
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Text RGB ";
    } else {
      nameFirstPart = "Text HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255, false, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let color = null;
    let textMaterial = this._getTextMaterial(object);
    if (textMaterial) {
      color = textMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbCodeToHuman(color);
      } else {
        color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHSV(color));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec4_create();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.rgbHumanToCode(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.hsvHumanToCode(color));
    }
    let textMaterial = this._getTextMaterial(object);
    if (textMaterial) {
      textMaterial[this._myColorVariableNames[this._myColorType]] = color;
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHSV(color));
      let rgbColor = ColorUtils.color1To255(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getTextMaterial(object) {
    let material = null;
    let text = object.pp_getComponent(TextComponent16);
    if (text) {
      material = text.material;
    }
    return material;
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_light_attenuation_component.js
import { Component as Component57, Property as Property47 } from "@wonderlandengine/api";
var EasyLightAttenuationComponent = class extends Component57 {
  static TypeName = "pp-easy-light-attenuation";
  static Properties = {
    _myVariableName: Property47.string(""),
    _mySetAsWidgetCurrentVariable: Property47.bool(false),
    _myUseTuneTarget: Property47.bool(false)
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyLightAttenuation(this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_light_color_component.js
import { Component as Component58, Property as Property48 } from "@wonderlandengine/api";
var EasyLightColorComponent = class extends Component58 {
  static TypeName = "pp-easy-light-color";
  static Properties = {
    _myVariableName: Property48.string(""),
    _mySetAsWidgetCurrentVariable: Property48.bool(false),
    _myUseTuneTarget: Property48.bool(false),
    _myColorModel: Property48.enum(["RGB", "HSV"], "HSV")
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyLightColor(this._myColorModel, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_mesh_ambient_factor_component.js
import { Component as Component59, Property as Property49 } from "@wonderlandengine/api";
var EasyMeshAmbientFactorComponent = class extends Component59 {
  static TypeName = "pp-easy-mesh-ambient-factor";
  static Properties = {
    _myVariableName: Property49.string(""),
    _myUseTuneTarget: Property49.bool(false),
    _mySetAsWidgetCurrentVariable: Property49.bool(false)
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyMeshAmbientFactor(this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_mesh_color_component.js
import { Component as Component60, Property as Property50 } from "@wonderlandengine/api";
var EasyMeshColorComponent = class extends Component60 {
  static TypeName = "pp-easy-mesh-color";
  static Properties = {
    _myVariableName: Property50.string(""),
    _myUseTuneTarget: Property50.bool(false),
    _mySetAsWidgetCurrentVariable: Property50.bool(false),
    _myColorModel: Property50.enum(["RGB", "HSV"], "HSV"),
    _myColorType: Property50.enum(["Color", "Diffuse Color", "Ambient Color", "Specular Color", "Emissive Color", "Fog Color", "Ambient Factor"], "Color")
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyMeshColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_scale_component.js
import { Component as Component61, Property as Property51 } from "@wonderlandengine/api";
var EasyScaleComponent = class extends Component61 {
  static TypeName = "pp-easy-scale";
  static Properties = {
    _myVariableName: Property51.string(""),
    _mySetAsWidgetCurrentVariable: Property51.bool(false),
    _myUseTuneTarget: Property51.bool(false),
    _myLocal: Property51.bool(false),
    _myScaleAsOne: Property51.bool(true)
    // Edit all scale values together
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyScale(this._myLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_child_number_component.js
import { Component as Component62, Property as Property52 } from "@wonderlandengine/api";
var EasySetTuneTargetChildNumberComponent = class extends Component62 {
  static TypeName = "pp-easy-set-tune-target-child-number";
  static Properties = {
    _myVariableName: Property52.string(""),
    _mySetAsWidgetCurrentVariable: Property52.bool(false)
  };
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyTuneVariableName = "Target Child ";
      if (this._myVariableName == "") {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this.object.pp_getID());
      } else {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this._myVariableName);
      }
      let childrenCount = this.object.pp_getChildren().length;
      let min = 1;
      let max = childrenCount;
      if (childrenCount == 0) {
        min = 0;
        max = 0;
      }
      Globals.getEasyTuneVariables(this.engine).add(new EasyTuneInt(this._myEasyTuneVariableName, 0, null, true, 10, min, max, void 0, this.engine));
      if (this._mySetAsWidgetCurrentVariable) {
        EasyTuneUtils.setWidgetCurrentVariable(this._myEasyTuneVariableName, this.engine);
      }
      this._myCurrentChildIndex = -1;
      this._myCurrentChildrenCount = childrenCount;
      this._myEasyTuneTarget = null;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (Globals.getEasyTuneVariables(this.engine).isWidgetCurrentVariable(this._myEasyTuneVariableName)) {
        let childrenCount = this.object.pp_getChildren().length;
        if (childrenCount != this._myCurrentChildrenCount) {
          this._myCurrentChildrenCount = childrenCount;
          let min = 1;
          let max = childrenCount;
          if (childrenCount == 0) {
            min = 0;
            max = 0;
          }
          let easyTuneVariable = Globals.getEasyTuneVariables(this.engine).getEasyTuneVariable(this._myEasyTuneVariableName);
          easyTuneVariable.setMin(min);
          easyTuneVariable.setMax(max);
        }
        let childIndex = Globals.getEasyTuneVariables(this.engine).get(this._myEasyTuneVariableName);
        if (childIndex != this._myCurrentChildIndex) {
          if (childIndex == 0 && this._myCurrentChildIndex != -1) {
            if (Globals.getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
              Globals.removeEasyTuneTarget(this.engine);
            }
            this._myEasyTuneTarget = null;
          } else if (childIndex > 0) {
            this._myEasyTuneTarget = this.object.pp_getChildren()[childIndex - 1];
            Globals.setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
          }
          this._myCurrentChildIndex = childIndex;
        }
      }
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_grab_component.js
import { Component as Component63 } from "@wonderlandengine/api";
var EasySetTuneTargeetGrabComponent = class extends Component63 {
  static TypeName = "pp-easy-set-tune-target-grab";
  static Properties = {};
  start() {
    this._myGrabber = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myGrabber = this.object.pp_getComponent(GrabberHandComponent);
      this._myEasyTuneTarget = null;
    }
  }
  _onRelease(grabber, grabbable) {
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyTuneTarget = grabbable.object;
      Globals.setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
    }
  }
  _onGrab(grabber, grabbable) {
    if (Globals.isToolEnabled(this.engine)) {
      if (Globals.getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
        Globals.removeEasyTuneTarget(this.engine);
      }
      this._myEasyTuneTarget = null;
    }
  }
  onActivate() {
    if (this._myGrabber != null) {
      this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
    }
  }
  onDeactivate() {
    if (this._myGrabber != null) {
      this._myGrabber.unregisterThrowEventListener(this);
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_text_color_component.js
import { Component as Component64, Property as Property53 } from "@wonderlandengine/api";
var EasyTextColorComponent = class extends Component64 {
  static TypeName = "pp-easy-text-color";
  static Properties = {
    _myVariableName: Property53.string(""),
    _mySetAsWidgetCurrentVariable: Property53.bool(false),
    _myUseTuneTarget: Property53.bool(false),
    _myColorModel: Property53.enum(["RGB", "HSV"], "HSV"),
    _myColorType: Property53.enum(["Color", "Effect Color"], "Color")
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyTextColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};

// dist/tool/easy_tune/easy_object_tuners/components/easy_transform_component.js
import { Component as Component65, Property as Property54 } from "@wonderlandengine/api";
var EasyTransformComponent = class extends Component65 {
  static TypeName = "pp-easy-transform";
  static Properties = {
    _myVariableName: Property54.string(""),
    _mySetAsWidgetCurrentVariable: Property54.bool(false),
    _myUseTuneTarget: Property54.bool(false),
    _myLocal: Property54.bool(true),
    _myScaleAsOne: Property54.bool(true)
    // Edit all scale values together
  };
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyTransform(this._myLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
export {
  AddPPToWindowComponent,
  AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent,
  AnalyticsManager,
  AnalyticsManagerComponent,
  AnalyticsUtils,
  ArrayUtils,
  AudioEvent,
  AudioManager,
  AudioManagerComponent,
  AudioPlayer,
  AudioSetup,
  AudioUtils,
  BaseGamepad,
  BasePose,
  BasePoseParams,
  BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent,
  BrowserUtils,
  CADisplayLeaderboardComponent,
  CADummyServer,
  CAError,
  CAUtils,
  CharacterColliderAdditionalParams,
  CharacterColliderDebugParams,
  CharacterColliderHorizontalCheckParams,
  CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSetupUtils,
  CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementParams,
  CharacterColliderSurfaceParams,
  CharacterColliderVerticalCheckParams,
  CharacterColliderWallSlideParams,
  CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType,
  CharacterCollisionDebugResults,
  CharacterCollisionInternalResults,
  CharacterCollisionMovementResults,
  CharacterCollisionResults,
  CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults,
  CharacterCollisionSystem,
  CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults,
  CharacterControllerUtils,
  ClassicGamepadCore,
  ClearConsoleOnXRSessionStartComponent,
  CloneParams,
  CollisionCheck,
  CollisionCheckBridge,
  CollisionCheckParams,
  CollisionCheckUtils,
  CollisionRuntimeParams,
  ColorUtils,
  ComponentUtils,
  ConsoleOriginalFunctions,
  ConsoleVR,
  ConsoleVRToolComponent,
  ConsoleVRWidget,
  ConsoleVRWidgetConfig,
  ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType,
  ConsoleVRWidgetParams,
  ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender,
  ConsoleVRWidgetUI,
  CopyHandTransformComponent,
  CopyHeadTransformComponent,
  CopyPlayerTransformComponent,
  CopyReferenceSpaceTransformComponent,
  CustomCloneParams,
  DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager,
  DebugManagerComponent,
  DebugPPArrayCreationPerformanceAnalyzerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent,
  DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent,
  DeepCloneParams,
  DefaultResources,
  DefaultResourcesMaterials,
  DefaultResourcesMeshes,
  DefaultWLComponentCloneCallbacks,
  Direction2DTo3DConverter,
  Direction2DTo3DConverterParams,
  EasingFunction,
  EasingSupportFunction,
  EasyLightAttenuation,
  EasyLightAttenuationComponent,
  EasyLightColor,
  EasyLightColorComponent,
  EasyMeshAmbientFactor,
  EasyMeshAmbientFactorComponent,
  EasyMeshColor,
  EasyMeshColorComponent,
  EasyObjectTuner,
  EasyScale,
  EasyScaleComponent,
  EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent,
  EasyTextColor,
  EasyTextColorComponent,
  EasyTransform,
  EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget,
  EasyTuneBaseWidgetConfig,
  EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetUI,
  EasyTuneBool,
  EasyTuneBoolArray,
  EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetConfig,
  EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent,
  EasyTuneInt,
  EasyTuneIntArray,
  EasyTuneNoneWidget,
  EasyTuneNoneWidgetConfig,
  EasyTuneNoneWidgetUI,
  EasyTuneNumber,
  EasyTuneNumberArray,
  EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetConfig,
  EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent,
  EasyTuneTransform,
  EasyTuneTransformWidget,
  EasyTuneTransformWidgetConfig,
  EasyTuneTransformWidgetUI,
  EasyTuneUtils,
  EasyTuneVariable,
  EasyTuneVariableArray,
  EasyTuneVariableExtraParams,
  EasyTuneVariableType,
  EasyTuneVariables,
  EasyTuneWidget,
  EasyTuneWidgetConfig,
  EasyTuneWidgetParams,
  EnableDebugComponent,
  EnableToolComponent,
  FSM,
  FingerCursorComponent,
  GamepadAxesEvent,
  GamepadAxesID,
  GamepadAxesInfo,
  GamepadButtonEvent,
  GamepadButtonID,
  GamepadButtonInfo,
  GamepadControlSchemeComponent,
  GamepadCore,
  GamepadMeshAnimatorComponent,
  GamepadPulseInfo,
  GamepadUtils,
  GamepadsManager,
  GetDefaultResourcesComponent,
  GetSceneObjectsComponent,
  Globals,
  GrabbableComponent,
  GrabberHandComponent,
  HandPose,
  HandPoseParams,
  Handedness,
  HandednessIndex,
  HeadPose,
  HowlerAudioPlayer,
  InitConsoleVRComponent,
  InitEasyTuneVariablesComponent,
  InputManager,
  InputManagerComponent,
  InputSourceType,
  InputUtils,
  IntOverFactor,
  IntRangeOverFactor,
  JSUtils,
  KeyID,
  Keyboard,
  KeyboardGamepadCore,
  Mat3Utils,
  Mat4Utils,
  MaterialUtils,
  MathUtils,
  MeshCreationParams,
  MeshCreationTriangleParams,
  MeshCreationVertexParams,
  MeshUtils,
  Mouse,
  MouseButtonID,
  MuteEverythingComponent,
  NonVRReferenceSpaceMode,
  NumberOverFactor,
  NumberRangeOverFactor,
  ObjectPool,
  ObjectPoolManager,
  ObjectPoolManagerComponent,
  ObjectPoolParams,
  ObjectUtils,
  OverrideBrowserConsoleFunctions,
  PPGatewayComponent,
  PerformDelayedMode,
  PerformMode,
  PhysicsCollisionCollector,
  PhysicsLayerFlags,
  PhysicsUtils,
  PlayerHeadManager,
  PlayerHeadManagerParams,
  PlayerLocomotion,
  PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams,
  PlayerLocomotionRotate,
  PlayerLocomotionRotateParams,
  PlayerLocomotionSmooth,
  PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleport,
  PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType,
  PlayerLocomotionType,
  PlayerObjects,
  PlayerObscureManager,
  PlayerObscureManagerParams,
  PlayerTransformManager,
  PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag,
  PluginUtils,
  Quat2Utils,
  QuatUtils,
  RaycastHit,
  RaycastParams,
  RaycastResults,
  SaveManager,
  SaveManagerComponent,
  SaveUtils,
  SceneObjects,
  SceneUtils,
  SetActiveComponent,
  SetHandLocalTransformComponent,
  SetHeadLocalTransformComponent,
  SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent,
  SkipStateFunction,
  SpatialAudioListenerComponent,
  State,
  StateData,
  SwitchHandObjectComponent,
  TextUtils,
  Timer,
  TimerState,
  ToolCursorComponent,
  ToolHandedness,
  ToolInputSourceType,
  TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent,
  TrackedHandJointID,
  TrackedHandJointIDIndex,
  TrackedHandJointPose,
  TrackedHandPose,
  TrackedHandPoseParams,
  Transition,
  TransitionData,
  UniversalGamepad,
  Vec2Utils,
  Vec3Utils,
  Vec4Utils,
  VecUtils,
  VirtualGamepad,
  VirtualGamepadButtonParams,
  VirtualGamepadComponent,
  VirtualGamepadGamepadCore,
  VirtualGamepadIcon,
  VirtualGamepadIconParams,
  VirtualGamepadIconType,
  VirtualGamepadParams,
  VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick,
  VisualArrow,
  VisualArrowParams,
  VisualElementType,
  VisualLine,
  VisualLineParams,
  VisualManager,
  VisualManagerComponent,
  VisualMesh,
  VisualMeshParams,
  VisualPoint,
  VisualPointParams,
  VisualRaycast,
  VisualRaycastParams,
  VisualResources,
  VisualResourcesMaterials,
  VisualText,
  VisualTextParams,
  VisualTorus,
  VisualTorusParams,
  VisualTransform,
  VisualTransformParams,
  WidgetFrame,
  WidgetFrameConfig,
  WidgetFrameUI,
  WidgetParams,
  XRGamepadCore,
  XRUtils,
  initArrayExtension,
  initArrayExtensionProtoype,
  initComponentMods,
  initCursorComponentMod,
  initCursorComponentModPrototype,
  initCursorTargetComponentMod,
  initCursorTargetComponentModPrototype,
  initJSExtensions,
  initJSPlugins,
  initMathExtension,
  initMathExtensionStatic,
  initMouseLookComponentMod,
  initMouseLookComponentModPrototype,
  initNumberExtension,
  initNumberExtensionPrototype,
  initObjectExtension,
  initObjectExtensionProtoype,
  initPP,
  initPlugins,
  initSceneExtension,
  initSceneExtensionPrototype,
  initWLExtensions,
  initWLMods,
  initWLPlugins,
  mat3_create,
  mat4_create,
  quat2_create,
  quat_create,
  registerPPComponents,
  registerWLComponents,
  vec2_create,
  vec3_create,
  vec4_create
};
//# sourceMappingURL=bundle.js.map
