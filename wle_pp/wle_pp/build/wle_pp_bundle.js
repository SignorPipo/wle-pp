var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// js/pp/index.js
var pp_exports = {};
__export(pp_exports, {
  AddPPToWindowComponent: () => AddPPToWindowComponent,
  AddWLToWindowComponent: () => AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent: () => AdjustHierarchyPhysXScaleComponent,
  AudioEvent: () => AudioEvent,
  AudioManager: () => AudioManager,
  AudioManagerComponent: () => AudioManagerComponent,
  AudioPlayer: () => AudioPlayer,
  AudioSetup: () => AudioSetup,
  AudioUtils: () => AudioUtils,
  BaseGamepad: () => BaseGamepad,
  BasePose: () => BasePose,
  BasePoseParams: () => BasePoseParams2,
  BenchmarkMaxPhysXComponent: () => BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent: () => BenchmarkMaxVisibleTrianglesComponent,
  BrowserUtils: () => BrowserUtils,
  CADisplayLeaderboardComponent: () => CADisplayLeaderboardComponent,
  CADummyServer: () => CADummyServer,
  CAError: () => CAError,
  CAUtils: () => CAUtils2,
  CharacterColliderAdditionalSetup: () => CharacterColliderAdditionalSetup,
  CharacterColliderDebugSetup: () => CharacterColliderDebugSetup,
  CharacterColliderHorizontalCheckSetup: () => CharacterColliderHorizontalCheckSetup,
  CharacterColliderHorizontalPositionVerticalCheckDirection: () => CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup: () => CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel: () => CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams: () => CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSlideFlickerPreventionMode: () => CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementSetup: () => CharacterColliderSplitMovementSetup,
  CharacterColliderSurfaceSetup: () => CharacterColliderSurfaceSetup,
  CharacterColliderUtils: () => CharacterColliderUtils,
  CharacterColliderVerticalCheckSetup: () => CharacterColliderVerticalCheckSetup,
  CharacterColliderWallSlideSetup: () => CharacterColliderWallSlideSetup,
  CharacterCollisionCheckTransformResults: () => CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType: () => CharacterCollisionCheckType,
  CharacterCollisionDebugResults: () => CharacterCollisionDebugResults,
  CharacterCollisionInternalResults: () => CharacterCollisionInternalResults,
  CharacterCollisionMovementResults: () => CharacterCollisionMovementResults,
  CharacterCollisionResults: () => CharacterCollisionResults,
  CharacterCollisionSplitMovementResults: () => CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo: () => CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults: () => CharacterCollisionSurfaceResults,
  CharacterCollisionSystem: () => CharacterCollisionSystem,
  CharacterCollisionSystemComponent: () => CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults: () => CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults: () => CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults: () => CharacterCollisionWallSlideResults,
  CharacterController: () => CharacterController,
  CharacterControllerComponent: () => CharacterControllerComponent,
  CharacterControllerUtils: () => CharacterControllerUtils,
  ClassicGamepadCore: () => ClassicGamepadCore,
  CleanedPlayerLocomotion: () => CleanedPlayerLocomotion,
  CleanedPlayerLocomotionSmooth: () => CleanedPlayerLocomotionSmooth,
  CleanedPlayerTransformManager: () => CleanedPlayerTransformManager,
  ClearConsoleOnXRSessionStartComponent: () => ClearConsoleOnXRSessionStartComponent,
  CloneParams: () => CloneParams,
  CollisionCheck: () => CollisionCheck,
  CollisionCheckBridge: () => CollisionCheckBridge,
  CollisionCheckParams: () => CollisionCheckParams,
  CollisionCheckUtils: () => CollisionCheckUtils,
  CollisionRuntimeParams: () => CollisionRuntimeParams,
  ColorUtils: () => ColorUtils,
  ConsoleVR: () => ConsoleVR,
  ConsoleVRToolComponent: () => ConsoleVRToolComponent,
  ConsoleVRWidget: () => ConsoleVRWidget,
  ConsoleVRWidgetAdditionalSetup: () => ConsoleVRWidgetAdditionalSetup,
  ConsoleVRWidgetConsoleFunction: () => ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage: () => ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType: () => ConsoleVRWidgetMessageType,
  ConsoleVRWidgetPulseOnNewMessage: () => ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender: () => ConsoleVRWidgetSender,
  ConsoleVRWidgetSetup: () => ConsoleVRWidgetSetup,
  ConsoleVRWidgetUI: () => ConsoleVRWidgetUI,
  CopyHandTransformComponent: () => CopyHandTransformComponent,
  CopyHeadTransformComponent: () => CopyHeadTransformComponent,
  CopyPlayerPivotTransformComponent: () => CopyPlayerPivotTransformComponent,
  CopyPlayerTransformComponent: () => CopyPlayerTransformComponent,
  CustomCloneParams: () => CustomCloneParams,
  DebugArrayFunctionsPerformanceAnalyzerComponent: () => DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults: () => DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter: () => DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams: () => DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger: () => DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams: () => DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer: () => DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent: () => DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams: () => DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder: () => DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager: () => DebugManager,
  DebugManagerComponent: () => DebugManagerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent: () => DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent: () => DebugTransformComponent,
  DebugVisualManager: () => DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent: () => DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent: () => DebugWLFunctionsPerformanceAnalyzerComponent,
  DeepCloneParams: () => DeepCloneParams,
  DefaultResources: () => DefaultResources,
  DefaultResourcesMaterials: () => DefaultResourcesMaterials,
  DefaultResourcesMeshes: () => DefaultResourcesMeshes,
  Direction2DTo3DConverter: () => Direction2DTo3DConverter,
  Direction2DTo3DConverterParams: () => Direction2DTo3DConverterParams,
  EPSILON: () => EPSILON,
  EPSILON_DEGREES: () => EPSILON_DEGREES,
  EasingFunction: () => EasingFunction2,
  EasyLightAttenuation: () => EasyLightAttenuation,
  EasyLightAttenuationComponent: () => EasyLightAttenuationComponent,
  EasyLightColor: () => EasyLightColor,
  EasyLightColorComponent: () => EasyLightColorComponent,
  EasyMeshAmbientFactor: () => EasyMeshAmbientFactor,
  EasyMeshAmbientFactorComponent: () => EasyMeshAmbientFactorComponent,
  EasyMeshColor: () => EasyMeshColor,
  EasyMeshColorComponent: () => EasyMeshColorComponent,
  EasyObjectTuner: () => EasyObjectTuner,
  EasyScale: () => EasyScale,
  EasyScaleComponent: () => EasyScaleComponent,
  EasySetTuneTargeetGrabComponent: () => EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent: () => EasySetTuneTargetChildNumberComponent,
  EasyTextColor: () => EasyTextColor,
  EasyTextColorComponent: () => EasyTextColorComponent,
  EasyTransform: () => EasyTransform,
  EasyTransformComponent: () => EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector: () => EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget: () => EasyTuneBaseWidget,
  EasyTuneBaseWidgetParams: () => EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetSetup: () => EasyTuneBaseWidgetSetup,
  EasyTuneBaseWidgetUI: () => EasyTuneBaseWidgetUI,
  EasyTuneBool: () => EasyTuneBool,
  EasyTuneBoolArray: () => EasyTuneBoolArray,
  EasyTuneBoolArrayWidget: () => EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetSelector: () => EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetSetup: () => EasyTuneBoolArrayWidgetSetup,
  EasyTuneBoolArrayWidgetUI: () => EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent: () => EasyTuneImportVariablesComponent,
  EasyTuneInt: () => EasyTuneInt2,
  EasyTuneIntArray: () => EasyTuneIntArray,
  EasyTuneNoneWidget: () => EasyTuneNoneWidget,
  EasyTuneNoneWidgetSetup: () => EasyTuneNoneWidgetSetup,
  EasyTuneNoneWidgetUI: () => EasyTuneNoneWidgetUI,
  EasyTuneNumber: () => EasyTuneNumber,
  EasyTuneNumberArray: () => EasyTuneNumberArray,
  EasyTuneNumberArrayWidget: () => EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetSelector: () => EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetSetup: () => EasyTuneNumberArrayWidgetSetup,
  EasyTuneNumberArrayWidgetUI: () => EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent: () => EasyTuneToolComponent,
  EasyTuneTransform: () => EasyTuneTransform,
  EasyTuneTransformWidget: () => EasyTuneTransformWidget,
  EasyTuneTransformWidgetSetup: () => EasyTuneTransformWidgetSetup,
  EasyTuneTransformWidgetUI: () => EasyTuneTransformWidgetUI,
  EasyTuneUtils: () => EasyTuneUtils,
  EasyTuneVariable: () => EasyTuneVariable,
  EasyTuneVariableArray: () => EasyTuneVariableArray,
  EasyTuneVariableType: () => EasyTuneVariableType,
  EasyTuneVariables: () => EasyTuneVariables,
  EasyTuneWidget: () => EasyTuneWidget,
  EasyTuneWidgetAdditionalSetup: () => EasyTuneWidgetAdditionalSetup,
  EasyTuneWidgetSetup: () => EasyTuneWidgetSetup,
  EnableDebugsComponent: () => EnableDebugsComponent,
  EnableToolsComponent: () => EnableToolsComponent,
  ExtensionUtils: () => ExtensionUtils,
  FSM: () => FSM,
  FingerCursorComponent: () => FingerCursorComponent,
  GamepadAxesEvent: () => GamepadAxesEvent,
  GamepadAxesID: () => GamepadAxesID,
  GamepadAxesInfo: () => GamepadAxesInfo,
  GamepadButtonEvent: () => GamepadButtonEvent,
  GamepadButtonID: () => GamepadButtonID,
  GamepadButtonInfo: () => GamepadButtonInfo,
  GamepadControlSchemeComponent: () => GamepadControlSchemeComponent,
  GamepadCore: () => GamepadCore,
  GamepadMeshAnimatorComponent: () => GamepadMeshAnimatorComponent,
  GamepadPulseInfo: () => GamepadPulseInfo,
  GamepadUtils: () => GamepadUtils,
  GamepadsManager: () => GamepadsManager,
  GetDefaultResourcesComponent: () => GetDefaultResourcesComponent,
  GetPlayerObjectsComponent: () => GetPlayerObjectsComponent,
  GlobalGravityComponent: () => GlobalGravityComponent,
  GrabbableComponent: () => GrabbableComponent,
  GrabberHandComponent: () => GrabberHandComponent,
  HandPose: () => HandPose,
  HandPoseParams: () => HandPoseParams,
  Handedness: () => Handedness,
  HandednessIndex: () => HandednessIndex,
  HeadPose: () => HeadPose,
  HowlerAudioPlayer: () => HowlerAudioPlayer,
  InitConsoleVRComponent: () => InitConsoleVRComponent,
  InitEasyTuneVariablesComponent: () => InitEasyTuneVariablesComponent,
  InputManager: () => InputManager,
  InputManagerComponent: () => InputManagerComponent,
  InputSourceType: () => InputSourceType,
  InputUtils: () => InputUtils,
  IntOverValue: () => IntOverValue,
  IntRangeOverValue: () => IntRangeOverValue,
  JSUtils: () => JSUtils,
  KeyID: () => KeyID,
  Keyboard: () => Keyboard,
  KeyboardGamepadCore: () => KeyboardGamepadCore,
  LocomotionUtils: () => LocomotionUtils,
  MaterialUtils: () => MaterialUtils,
  MeshCreationParams: () => MeshCreationParams,
  MeshCreationTriangleParams: () => MeshCreationTriangleParams,
  MeshCreationVertexParams: () => MeshCreationVertexParams,
  MeshUtils: () => MeshUtils,
  Mouse: () => Mouse,
  MouseButtonID: () => MouseButtonID,
  MuteEverythingComponent: () => MuteEverythingComponent,
  NumberOverValue: () => NumberOverValue,
  NumberRangeOverValue: () => NumberRangeOverValue,
  ObjectPool: () => ObjectPool,
  ObjectPoolParams: () => ObjectPoolParams,
  ObjectPoolsManager: () => ObjectPoolsManager,
  PPGatewayComponent: () => PPGatewayComponent,
  PerformDelayedMode: () => PerformDelayedMode,
  PerformMode: () => PerformMode,
  PhysicsCollisionCollector: () => PhysicsCollisionCollector,
  PhysicsLayerFlags: () => PhysicsLayerFlags,
  PhysicsUtils: () => PhysicsUtils,
  PlayerCharacterController: () => PlayerCharacterController,
  PlayerCharacterControllerComponent: () => PlayerCharacterControllerComponent,
  PlayerHandCharacterController: () => PlayerHandCharacterController,
  PlayerHandCharacterControllerComponent: () => PlayerHandCharacterControllerComponent,
  PlayerHeadCharacterController: () => PlayerHeadCharacterController,
  PlayerHeadCharacterControllerComponent: () => PlayerHeadCharacterControllerComponent,
  PlayerHeadController: () => PlayerHeadController,
  PlayerHeadControllerComponent: () => PlayerHeadControllerComponent,
  PlayerHeadManager: () => PlayerHeadManager,
  PlayerHeadManagerParams: () => PlayerHeadManagerParams,
  PlayerLocomotion: () => PlayerLocomotion,
  PlayerLocomotionComponent: () => PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType: () => PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionGravity: () => PlayerLocomotionGravity,
  PlayerLocomotionGravityComponent: () => PlayerLocomotionGravityComponent,
  PlayerLocomotionMovement: () => PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams: () => PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams: () => PlayerLocomotionParams,
  PlayerLocomotionRotateComponent: () => PlayerLocomotionRotateComponent,
  PlayerLocomotionRotateParams: () => PlayerLocomotionRotateParams,
  PlayerLocomotionSmoothComponent: () => PlayerLocomotionSmoothComponent,
  PlayerLocomotionSmoothParams: () => PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleportComponent: () => PlayerLocomotionTeleportComponent,
  PlayerLocomotionTeleportDetectionParams: () => PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams: () => PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState: () => PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer: () => PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams: () => PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable: () => PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams: () => PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams: () => PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState: () => PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState: () => PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams: () => PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState: () => PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState: () => PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType: () => PlayerLocomotionTeleportTeleportType,
  PlayerObjects: () => PlayerObjects,
  PlayerObscureManager: () => PlayerObscureManager,
  PlayerObscureManagerParams: () => PlayerObscureManagerParams,
  PlayerTransformManager: () => PlayerTransformManager,
  PlayerTransformManagerParams: () => PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag: () => PlayerTransformManagerSyncFlag,
  PlayerViewOcclusion: () => PlayerViewOcclusion,
  PlayerViewOcclusionComponent: () => PlayerViewOcclusionComponent,
  RaycastHit: () => RaycastHit,
  RaycastResults: () => RaycastResults,
  RaycastSetup: () => RaycastSetup,
  SaveManager: () => SaveManager,
  SaveUtils: () => SaveUtils,
  SetActiveComponent: () => SetActiveComponent,
  SetHandLocalTransformComponent: () => SetHandLocalTransformComponent,
  SetHeadLocalTransformComponent: () => SetHeadLocalTransformComponent,
  SetHeadNonVRLocalTransformComponent: () => SetHeadNonVRLocalTransformComponent,
  SetHeadVRLocalTransformComponent: () => SetHeadVRLocalTransformComponent,
  SetPlayerHeightComponent: () => SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent: () => SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent: () => ShowFPSComponent,
  SkipStateFunction: () => SkipStateFunction,
  SpatialAudioListenerComponent: () => SpatialAudioListenerComponent,
  State: () => State,
  StateData: () => StateData,
  SwitchHandObjectComponent: () => SwitchHandObjectComponent,
  SyncedCharacterController: () => SyncedCharacterController,
  TextUtils: () => TextUtils,
  Timer: () => Timer,
  TimerState: () => TimerState,
  ToolCursorComponent: () => ToolCursorComponent,
  ToolHandedness: () => ToolHandedness,
  ToolInputSourceType: () => ToolInputSourceType,
  TrackedHandDrawAllJointsComponent: () => TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent: () => TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent: () => TrackedHandDrawSkinComponent,
  TrackedHandJointID: () => TrackedHandJointID,
  TrackedHandJointIDIndex: () => TrackedHandJointIDIndex,
  TrackedHandJointPose: () => TrackedHandJointPose,
  TrackedHandPose: () => TrackedHandPose,
  TrackedHandPoseParams: () => TrackedHandPoseParams,
  Transition: () => Transition,
  TransitionData: () => TransitionData,
  UniversalGamepad: () => UniversalGamepad,
  VirtualGamepad: () => VirtualGamepad,
  VirtualGamepadButtonParams: () => VirtualGamepadButtonParams,
  VirtualGamepadComponent: () => VirtualGamepadComponent,
  VirtualGamepadGamepadCore: () => VirtualGamepadGamepadCore,
  VirtualGamepadIcon: () => VirtualGamepadIcon,
  VirtualGamepadIconParams: () => VirtualGamepadIconParams,
  VirtualGamepadIconType: () => VirtualGamepadIconType,
  VirtualGamepadParams: () => VirtualGamepadParams,
  VirtualGamepadThumbstickParams: () => VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton: () => VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick: () => VirtualGamepadVirtualThumbstick,
  VisualArrow: () => VisualArrow,
  VisualArrowParams: () => VisualArrowParams,
  VisualData: () => VisualData,
  VisualDataMaterials: () => VisualDataMaterials,
  VisualElementType: () => VisualElementType,
  VisualLine: () => VisualLine,
  VisualLineParams: () => VisualLineParams,
  VisualManager: () => VisualManager,
  VisualManagerComponent: () => VisualManagerComponent,
  VisualMesh: () => VisualMesh,
  VisualMeshParams: () => VisualMeshParams,
  VisualPoint: () => VisualPoint,
  VisualPointParams: () => VisualPointParams,
  VisualRaycast: () => VisualRaycast,
  VisualRaycastParams: () => VisualRaycastParams,
  VisualText: () => VisualText,
  VisualTextParams: () => VisualTextParams,
  VisualTorus: () => VisualTorus,
  VisualTorusParams: () => VisualTorusParams,
  VisualTransform: () => VisualTransform,
  VisualTransformParams: () => VisualTransformParams,
  WidgetFrame: () => WidgetFrame,
  WidgetFrameSetup: () => WidgetFrameSetup,
  WidgetFrameUI: () => WidgetFrameUI,
  XRGamepadCore: () => XRGamepadCore,
  XRUtils: () => XRUtils,
  addEngine: () => addEngine,
  addRefreshEasyTuneWidgetCallback: () => addRefreshEasyTuneWidgetCallback,
  addSetEasyTuneWidgetActiveVariableCallback: () => addSetEasyTuneWidgetActiveVariableCallback,
  areButtonsPressEnd: () => areButtonsPressEnd,
  areButtonsPressStart: () => areButtonsPressStart,
  areButtonsTouchEnd: () => areButtonsTouchEnd,
  areButtonsTouchStart: () => areButtonsTouchStart,
  assignProperties: () => assignProperties,
  checkMovement: () => checkMovement,
  checkTeleportToTransform: () => checkTeleportToTransform,
  checkTransform: () => checkTransform,
  cleanObjectProperties: () => cleanObjectProperties,
  clear: () => clear,
  cloneMesh: () => cloneMesh,
  color1To255: () => color1To255,
  color255To1: () => color255To1,
  computeCeilingPerceivedAngle: () => computeCeilingPerceivedAngle,
  computeGroundPerceivedAngle: () => computeGroundPerceivedAngle,
  convertCharacterColliderSetupToCollisionCheckParams: () => convertCharacterColliderSetupToCollisionCheckParams,
  convertCharacterCollisionResultsToCollisionRuntimeParams: () => convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults: () => convertCollisionRuntimeParamsToCharacterCollisionResults,
  copyObjectProperties: () => copyObjectProperties,
  createCharacterColliderSetupSimplified: () => createCharacterColliderSetupSimplified,
  createMesh: () => createMesh,
  createPlaneMesh: () => createPlaneMesh,
  createTeleportColliderFromMovementCollider: () => createTeleportColliderFromMovementCollider,
  doesObjectPropertyUseAccessors: () => doesObjectPropertyUseAccessors,
  exportEasyTuneVariables: () => exportEasyTuneVariables,
  generate360TeleportParamsFromMovementParams: () => generate360TeleportParamsFromMovementParams,
  getAudioManager: () => getAudioManager,
  getCharacterCollisionSystem: () => getCharacterCollisionSystem,
  getComponentObjects: () => getComponentObjects,
  getComponentsObjects: () => getComponentsObjects,
  getConsoleVR: () => getConsoleVR,
  getDebugManager: () => getDebugManager,
  getDebugVisualManager: () => getDebugVisualManager2,
  getDefaultResources: () => getDefaultResources,
  getDummyServer: () => getDummyServer,
  getEasyTuneTarget: () => getEasyTuneTarget,
  getEasyTuneVariables: () => getEasyTuneVariables,
  getEngines: () => getEngines,
  getFrame: () => getFrame,
  getGamepads: () => getGamepads,
  getGamepadsManager: () => getGamepadsManager,
  getGlobalGravityAcceleration: () => getGlobalGravityAcceleration,
  getGlobalGravityDirection: () => getGlobalGravityDirection,
  getHandednessByIndex: () => getHandednessByIndex,
  getInputManager: () => getInputManager,
  getInputSource: () => getInputSource,
  getInputSourceType: () => getInputSourceType,
  getInputSourceTypeByHandedness: () => getInputSourceTypeByHandedness,
  getJointIDByIndex: () => getJointIDByIndex,
  getKeyboard: () => getKeyboard,
  getLayerFlagsNames: () => getLayerFlagsNames,
  getLeaderboard: () => getLeaderboard,
  getLeaderboardDummy: () => getLeaderboardDummy,
  getLeftGamepad: () => getLeftGamepad,
  getMainEngine: () => getMainEngine2,
  getMouse: () => getMouse,
  getObjectByIDObjects: () => getObjectByIDObjects,
  getObjectByNameObjects: () => getObjectByNameObjects,
  getObjectFromPath: () => getObjectFromPath,
  getObjectNameFromPath: () => getObjectNameFromPath,
  getObjectParentFromPath: () => getObjectParentFromPath,
  getObjectProperty: () => getObjectProperty,
  getObjectPropertyDescriptor: () => getObjectPropertyDescriptor,
  getObjectPropertyNames: () => getObjectPropertyNames,
  getObjectPropertyOwnParent: () => getObjectPropertyOwnParent,
  getObjectPropertyOwnParents: () => getObjectPropertyOwnParents,
  getObjectPrototypes: () => getObjectPrototypes,
  getObjectsByIDObjects: () => getObjectsByIDObjects,
  getObjectsByNameObjects: () => getObjectsByNameObjects,
  getOppositeHandedness: () => getOppositeHandedness,
  getOriginalConsoleAssert: () => getOriginalConsoleAssert,
  getOriginalConsoleClear: () => getOriginalConsoleClear,
  getOriginalConsoleDebug: () => getOriginalConsoleDebug,
  getOriginalConsoleError: () => getOriginalConsoleError,
  getOriginalConsoleInfo: () => getOriginalConsoleInfo,
  getOriginalConsoleLog: () => getOriginalConsoleLog,
  getOriginalConsoleWarn: () => getOriginalConsoleWarn,
  getPlayerObjects: () => getPlayerObjects2,
  getReferenceSpaceType: () => getReferenceSpaceType,
  getRightGamepad: () => getRightGamepad,
  getSession: () => getSession,
  getSimultaneousPressMaxDelay: () => getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay: () => getSimultaneousTouchMaxDelay,
  getUser: () => getUser,
  getUserDummy: () => getUserDummy,
  getVisualData: () => getVisualData,
  getVisualManager: () => getVisualManager,
  getWebXR: () => getWebXR,
  has: () => has,
  hasAudioManager: () => hasAudioManager,
  hasCharacterCollisionSystem: () => hasCharacterCollisionSystem,
  hasConsoleVR: () => hasConsoleVR,
  hasDebugEnabled: () => hasDebugEnabled,
  hasDebugManager: () => hasDebugManager,
  hasDefaultResources: () => hasDefaultResources,
  hasEasyTuneTarget: () => hasEasyTuneTarget,
  hasEasyTuneVariables: () => hasEasyTuneVariables,
  hasEngine: () => hasEngine,
  hasGlobalGravityAcceleration: () => hasGlobalGravityAcceleration,
  hasGlobalGravityDirection: () => hasGlobalGravityDirection,
  hasInputManager: () => hasInputManager,
  hasPlayerObjects: () => hasPlayerObjects,
  hasToolEnabled: () => hasToolEnabled,
  hasVisualData: () => hasVisualData,
  hasVisualManager: () => hasVisualManager,
  hsvCodeToHuman: () => hsvCodeToHuman,
  hsvHumanToCode: () => hsvHumanToCode,
  hsvToRgb: () => hsvToRgb,
  importEasyTuneVariables: () => importEasyTuneVariables,
  initArrayExtension: () => initArrayExtension,
  initArrayExtensionProtoype: () => initArrayExtensionProtoype,
  initBridge: () => initBridge,
  initComponentCloneMod: () => initComponentCloneMod,
  initComponentMods: () => initComponentMods,
  initCursorComponentMod: () => initCursorComponentMod,
  initCursorComponentModPrototype: () => initCursorComponentModPrototype,
  initCursorTargetComponentMod: () => initCursorTargetComponentMod,
  initCursorTargetComponentModPrototype: () => initCursorTargetComponentModPrototype,
  initEngine: () => initEngine,
  initJSExtensions: () => initJSExtensions,
  initJSPlugins: () => initJSPlugins,
  initMathExtension: () => initMathExtension,
  initMathExtensionStatic: () => initMathExtensionStatic,
  initMouseLookComponentMod: () => initMouseLookComponentMod,
  initMouseLookComponentModPrototype: () => initMouseLookComponentModPrototype,
  initNumberExtension: () => initNumberExtension,
  initNumberExtensionPrototype: () => initNumberExtensionPrototype,
  initObjectExtension: () => initObjectExtension,
  initObjectExtensionProtoype: () => initObjectExtensionProtoype,
  initPP: () => initPP,
  initPlugins: () => initPlugins,
  initSceneExtension: () => initSceneExtension,
  initSceneExtensionPrototype: () => initSceneExtensionPrototype,
  initWLExtensions: () => initWLExtensions,
  initWLMods: () => initWLMods,
  initWLPlugins: () => initWLPlugins,
  invertMesh: () => invertMesh,
  isARSupported: () => isARSupported,
  isAnyButtonPressEnd: () => isAnyButtonPressEnd,
  isAnyButtonPressStart: () => isAnyButtonPressStart,
  isAnyButtonTouchEnd: () => isAnyButtonTouchEnd,
  isAnyButtonTouchStart: () => isAnyButtonTouchStart,
  isAudioPlaybackBlocked: () => isAudioPlaybackBlocked,
  isClassByName: () => isClassByName,
  isDebugEnabled: () => isDebugEnabled,
  isDesktop: () => isDesktop,
  isDeviceEmulated: () => isDeviceEmulated,
  isFunctionByName: () => isFunctionByName,
  isMobile: () => isMobile,
  isObjectByName: () => isObjectByName,
  isReferenceSpaceLocalFloor: () => isReferenceSpaceLocalFloor,
  isSDKAvailable: () => isSDKAvailable,
  isSessionActive: () => isSessionActive,
  isToolEnabled: () => isToolEnabled,
  isUseDummyServerOnError: () => isUseDummyServerOnError,
  isUseDummyServerOnSDKMissing: () => isUseDummyServerOnSDKMissing,
  isVRSupported: () => isVRSupported,
  load: () => load,
  loadBool: () => loadBool,
  loadNumber: () => loadNumber,
  loadString: () => loadString,
  mat3_create: () => mat3_create,
  mat4_create: () => mat4_create,
  mat4_fromPositionRotation: () => mat4_fromPositionRotation,
  mat4_fromPositionRotationDegrees: () => mat4_fromPositionRotationDegrees,
  mat4_fromPositionRotationDegreesScale: () => mat4_fromPositionRotationDegreesScale,
  mat4_fromPositionRotationQuat: () => mat4_fromPositionRotationQuat,
  mat4_fromPositionRotationQuatScale: () => mat4_fromPositionRotationQuatScale,
  mat4_fromPositionRotationRadians: () => mat4_fromPositionRotationRadians,
  mat4_fromPositionRotationRadiansScale: () => mat4_fromPositionRotationRadiansScale,
  mat4_fromPositionRotationScale: () => mat4_fromPositionRotationScale,
  overwriteObjectProperty: () => overwriteObjectProperty,
  quat2_create: () => quat2_create,
  quat2_fromPositionRotation: () => quat2_fromPositionRotation,
  quat2_fromPositionRotationDegrees: () => quat2_fromPositionRotationDegrees,
  quat2_fromPositionRotationQuat: () => quat2_fromPositionRotationQuat,
  quat2_fromPositionRotationRadians: () => quat2_fromPositionRotationRadians,
  quat_create: () => quat_create,
  raycast: () => raycast,
  refreshEasyTuneWidget: () => refreshEasyTuneWidget,
  registerPPComponents: () => registerPPComponents,
  registerSessionEndEventListener: () => registerSessionEndEventListener,
  registerSessionStartEndEventListeners: () => registerSessionStartEndEventListeners,
  registerSessionStartEventListener: () => registerSessionStartEventListener,
  registerWLComponents: () => registerWLComponents,
  remove: () => remove,
  removeAudioManager: () => removeAudioManager,
  removeCharacterCollisionSystem: () => removeCharacterCollisionSystem,
  removeConsoleVR: () => removeConsoleVR,
  removeDebugEnabled: () => removeDebugEnabled,
  removeDebugManager: () => removeDebugManager,
  removeDefaultResources: () => removeDefaultResources,
  removeEasyTuneTarget: () => removeEasyTuneTarget,
  removeEasyTuneVariables: () => removeEasyTuneVariables,
  removeEngine: () => removeEngine,
  removeGlobalGravityAcceleration: () => removeGlobalGravityAcceleration,
  removeGlobalGravityDirection: () => removeGlobalGravityDirection,
  removeInputManager: () => removeInputManager,
  removePlayerObjects: () => removePlayerObjects,
  removeRefreshEasyTuneWidgetCallback: () => removeRefreshEasyTuneWidgetCallback,
  removeSetEasyTuneWidgetActiveVariableCallback: () => removeSetEasyTuneWidgetActiveVariableCallback,
  removeToolEnabled: () => removeToolEnabled,
  removeVisualData: () => removeVisualData,
  removeVisualManager: () => removeVisualManager,
  rgbCodeToHuman: () => rgbCodeToHuman,
  rgbHumanToCode: () => rgbHumanToCode,
  rgbToHsv: () => rgbToHsv,
  save: () => save,
  setActiveObjects: () => setActiveObjects,
  setAlpha: () => setAlpha,
  setAudioManager: () => setAudioManager,
  setCharacterCollisionSystem: () => setCharacterCollisionSystem,
  setClonedMaterials: () => setClonedMaterials,
  setConsoleVR: () => setConsoleVR,
  setDebugEnabled: () => setDebugEnabled,
  setDebugManager: () => setDebugManager,
  setDefaultResources: () => setDefaultResources,
  setDummyServer: () => setDummyServer,
  setEasyTuneTarget: () => setEasyTuneTarget,
  setEasyTuneVariables: () => setEasyTuneVariables,
  setEasyTuneWidgetActiveVariable: () => setEasyTuneWidgetActiveVariable,
  setGlobalGravityAcceleration: () => setGlobalGravityAcceleration,
  setGlobalGravityDirection: () => setGlobalGravityDirection,
  setInputManager: () => setInputManager,
  setLayerFlagsNames: () => setLayerFlagsNames,
  setMainEngine: () => setMainEngine,
  setObjectAlpha: () => setObjectAlpha,
  setObjectClonedMaterials: () => setObjectClonedMaterials,
  setObjectFogColor: () => setObjectFogColor,
  setObjectMaterial: () => setObjectMaterial,
  setObjectProperty: () => setObjectProperty,
  setObjectSpecularColor: () => setObjectSpecularColor,
  setPlayerObjects: () => setPlayerObjects,
  setSimultaneousPressMaxDelay: () => setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay: () => setSimultaneousTouchMaxDelay,
  setToolEnabled: () => setToolEnabled,
  setUseDummyServerOnError: () => setUseDummyServerOnError,
  setUseDummyServerOnSDKMissing: () => setUseDummyServerOnSDKMissing,
  setVisualData: () => setVisualData,
  setVisualManager: () => setVisualManager,
  submitScore: () => submitScore,
  submitScoreDummy: () => submitScoreDummy,
  unregisterSessionEndEventListener: () => unregisterSessionEndEventListener,
  unregisterSessionStartEndEventListeners: () => unregisterSessionStartEndEventListeners,
  unregisterSessionStartEventListener: () => unregisterSessionStartEventListener,
  updateCeilingInfo: () => updateCeilingInfo,
  updateGroundInfo: () => updateGroundInfo,
  vec2_create: () => vec2_create,
  vec3_create: () => vec3_create2,
  vec4_create: () => vec4_create2
});

// js/pp/plugin/js/extensions/array_extension.js
import * as glMatrix from "gl-matrix";

// js/pp/plugin/utils/extension_utils.js
function assignProperties(fromReference, toReference, enumerable = false, writable = true, configurable = true) {
  let ownPropertyNames = Object.getOwnPropertyNames(fromReference);
  for (let ownPropertyName of ownPropertyNames) {
    Object.defineProperty(toReference, ownPropertyName, {
      value: fromReference[ownPropertyName],
      enumerable,
      writable,
      configurable
    });
  }
}
var ExtensionUtils = {
  assignProperties
};

// js/pp/plugin/js/extensions/array_extension.js
function initArrayExtension() {
  initArrayExtensionProtoype();
}
function vec2_create(x, y) {
  let out = glMatrix.vec2.create();
  if (x !== void 0) {
    _vec2_set(out, x, y);
  }
  return out;
}
function vec3_create2(x, y, z) {
  let out = glMatrix.vec3.create();
  if (x !== void 0) {
    _vec3_set(out, x, y, z);
  }
  return out;
}
function vec4_create2(x, y, z, w) {
  let out = glMatrix.vec4.create();
  if (x !== void 0) {
    _vec4_set(out, x, y, z, w);
  }
  return out;
}
function quat_create(x, y, z, w) {
  let out = glMatrix.quat.create();
  if (x !== void 0) {
    _quat_set(out, x, y, z, w);
  }
  return out;
}
function quat2_create(x1, y1, z1, w1, x2, y2, z2, w2) {
  let out = glMatrix.quat2.create();
  if (x1 !== void 0) {
    _quat2_set(out, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return out;
}
function mat3_create(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = glMatrix.mat3.create();
  if (m00 !== void 0) {
    _mat3_set(
      out,
      m00,
      m01,
      m02,
      m10,
      m11,
      m12,
      m20,
      m21,
      m22
    );
  }
  return out;
}
function mat4_create(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = glMatrix.mat4.create();
  if (m00 !== void 0) {
    _mat4_set(
      out,
      m00,
      m01,
      m02,
      m03,
      m10,
      m11,
      m12,
      m13,
      m20,
      m21,
      m22,
      m23,
      m30,
      m31,
      m32,
      m33
    );
  }
  return out;
}
function quat2_fromPositionRotation(position, rotation) {
  return quat2_fromPositionRotationDegrees(position, rotation);
}
function quat2_fromPositionRotationDegrees(position, rotation) {
  let out = quat2_create();
  out.quat2_setPositionRotationDegrees(position, rotation);
  return out;
}
function quat2_fromPositionRotationRadians(position, rotation) {
  let out = quat2_create();
  out.quat2_setPositionRotationRadians(position, rotation);
  return out;
}
function quat2_fromPositionRotationQuat(position, rotation) {
  let out = quat2_create();
  out.quat2_setPositionRotationQuat(position, rotation);
  return out;
}
function mat4_fromPositionRotation(position, rotation) {
  return mat4_fromPositionRotationDegrees(position, rotation);
}
function mat4_fromPositionRotationDegrees(position, rotation) {
  let out = mat4_create();
  out.mat4_setPositionRotationDegrees(position, rotation);
  return out;
}
function mat4_fromPositionRotationRadians(position, rotation) {
  let out = mat4_create();
  out.mat4_setPositionRotationRadians(position, rotation);
  return out;
}
function mat4_fromPositionRotationQuat(position, rotation) {
  let out = mat4_create();
  out.mat4_setPositionRotationQuat(position, rotation);
  return out;
}
function mat4_fromPositionRotationScale(position, rotation, scale) {
  return mat4_fromPositionRotationDegreesScale(position, rotation, scale);
}
function mat4_fromPositionRotationDegreesScale(position, rotation, scale) {
  let out = mat4_create();
  out.mat4_setPositionRotationDegreesScale(position, rotation, scale);
  return out;
}
function mat4_fromPositionRotationRadiansScale(position, rotation, scale) {
  let out = mat4_create();
  out.mat4_setPositionRotationRadiansScale(position, rotation, scale);
  return out;
}
function mat4_fromPositionRotationQuatScale(position, rotation, scale) {
  let out = mat4_create();
  out.mat4_setPositionRotationQuatScale(position, rotation, scale);
  return out;
}
function initArrayExtensionProtoype() {
  let arrayExtension = {};
  arrayExtension.vec2_set = function vec2_set(x, y) {
    return _vec2_set(this, x, y);
  };
  arrayExtension.vec3_set = function vec3_set(x, y, z) {
    return _vec3_set(this, x, y, z);
  };
  arrayExtension.vec4_set = function vec4_set(x, y, z, w) {
    return _vec4_set(this, x, y, z, w);
  };
  arrayExtension.quat_set = function quat_set(x, y, z, w) {
    return _quat_set(this, x, y, z, w);
  };
  arrayExtension.quat2_set = function quat2_set(x1, y1, z1, w1, x2, y2, z2, w2) {
    return _quat2_set(this, x1, y1, z1, w1, x2, y2, z2, w2);
  };
  arrayExtension.mat3_set = function mat3_set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    return _mat3_set(
      this,
      m00,
      m01,
      m02,
      m10,
      m11,
      m12,
      m20,
      m21,
      m22
    );
  };
  arrayExtension.mat4_set = function mat4_set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    return _mat4_set(
      this,
      m00,
      m01,
      m02,
      m03,
      m10,
      m11,
      m12,
      m13,
      m20,
      m21,
      m22,
      m23,
      m30,
      m31,
      m32,
      m33
    );
  };
  arrayExtension.pp_first = function pp_first() {
    return this.length > 0 ? this[0] : void 0;
  };
  arrayExtension.pp_last = function pp_last() {
    return this.length > 0 ? this[this.length - 1] : void 0;
  };
  arrayExtension.pp_has = function pp_has(callback) {
    return this.pp_find(callback) != void 0;
  };
  arrayExtension.pp_hasEqual = function pp_hasEqual(elementToFind, elementsEqualCallback = null) {
    return this.pp_findEqual(elementToFind, elementsEqualCallback) != void 0;
  };
  arrayExtension.pp_find = function pp_find(callback) {
    let elementFound = void 0;
    let index = this.findIndex(callback);
    if (index >= 0) {
      elementFound = this[index];
    }
    return elementFound;
  };
  arrayExtension.pp_findIndex = function pp_findIndex(callback) {
    return this.findIndex(callback);
  };
  arrayExtension.pp_findAll = function pp_findAll(callback) {
    let elementsFound = this.filter(callback);
    return elementsFound;
  };
  arrayExtension.pp_findAllIndexes = function pp_findAllIndexes(callback) {
    let indexes = [];
    for (let i = 0; i < this.length; i++) {
      let element = this[i];
      if (callback(element)) {
        indexes.push(i);
      }
    }
    return indexes;
  };
  arrayExtension.pp_findEqual = function pp_findEqual(elementToFind, elementsEqualCallback = null) {
    if (elementsEqualCallback == null) {
      let index = this.pp_findIndexEqual(elementToFind);
      return index < 0 ? void 0 : this[index];
    }
    let elementFound = void 0;
    for (let i = 0; i < this.length; i++) {
      let currentElement = this[i];
      if (elementsEqualCallback(currentElement, elementToFind)) {
        elementFound = currentElement;
        break;
      }
    }
    return elementFound;
  };
  arrayExtension.pp_findAllEqual = function pp_findAllEqual(elementToFind, elementsEqualCallback = null) {
    if (elementsEqualCallback == null) {
      return _findAllEqualOptimized(this, elementToFind, false);
    }
    let elementsFound = [];
    for (let i = 0; i < this.length; i++) {
      let currentElement = this[i];
      if (elementsEqualCallback(currentElement, elementToFind)) {
        elementsFound.push(currentElement);
      }
    }
    return elementsFound;
  };
  arrayExtension.pp_findIndexEqual = function pp_findIndexEqual(elementToFind, elementsEqualCallback = null) {
    if (elementsEqualCallback == null) {
      return this.indexOf(elementToFind);
    }
    let indexFound = -1;
    for (let i = 0; i < this.length; i++) {
      let currentElement = this[i];
      if (elementsEqualCallback(currentElement, elementToFind)) {
        indexFound = i;
        break;
      }
    }
    return indexFound;
  };
  arrayExtension.pp_findAllIndexesEqual = function pp_findAllIndexesEqual(elementToFind, elementsEqualCallback = null) {
    if (elementsEqualCallback == null) {
      return _findAllEqualOptimized(this, elementToFind, true);
    }
    let indexesFound = [];
    for (let i = 0; i < this.length; i++) {
      let currentElement = this[i];
      if (elementsEqualCallback(currentElement, elementToFind)) {
        indexesFound.push(i);
      }
    }
    return indexesFound;
  };
  arrayExtension.pp_removeIndex = function pp_removeIndex(index) {
    let elementRemoved = void 0;
    if (index >= 0 && index < this.length) {
      let arrayRemoved = this.splice(index, 1);
      if (arrayRemoved.length == 1) {
        elementRemoved = arrayRemoved[0];
      }
    }
    return elementRemoved;
  };
  arrayExtension.pp_removeAllIndexes = function pp_removeAllIndexes(indexes) {
    let elementsRemoved = [];
    for (let index of indexes) {
      let elementRemoved = this.pp_removeIndex(index);
      if (elementRemoved !== void 0) {
        elementsRemoved.push(elementRemoved);
      }
    }
    return elementsRemoved;
  };
  arrayExtension.pp_remove = function pp_remove(callback) {
    let elementRemoved = void 0;
    let index = this.findIndex(callback);
    if (index >= 0) {
      elementRemoved = this.pp_removeIndex(index);
    }
    return elementRemoved;
  };
  arrayExtension.pp_removeAll = function pp_removeAll(callback) {
    let elementsRemoved = [];
    let currentElement = void 0;
    do {
      currentElement = this.pp_remove(callback);
      if (currentElement !== void 0) {
        elementsRemoved.push(currentElement);
      }
    } while (currentElement !== void 0);
    return elementsRemoved;
  };
  arrayExtension.pp_removeEqual = function pp_removeEqual(elementToRemove, elementsEqualCallback = null) {
    return this.pp_removeIndex(this.pp_findIndexEqual(elementToRemove, elementsEqualCallback));
  };
  arrayExtension.pp_removeAllEqual = function pp_removeAllEqual(elementToRemove, elementsEqualCallback = null) {
    return this.pp_removeAllIndexes(this.pp_findAllIndexesEqual(elementToRemove, elementsEqualCallback));
  };
  arrayExtension.pp_pushUnique = function pp_pushUnique(element, elementsEqualCallback = null) {
    let length2 = this.length;
    let hasElement = this.pp_hasEqual(element, elementsEqualCallback);
    if (!hasElement) {
      length2 = this.push(element);
    }
    return length2;
  };
  arrayExtension.pp_unshiftUnique = function pp_unshiftUnique(element, elementsEqualCallback = null) {
    let length2 = this.length;
    let hasElement = this.pp_hasEqual(element, elementsEqualCallback);
    if (!hasElement) {
      length2 = this.unshift(element);
    }
    return length2;
  };
  arrayExtension.pp_copy = function pp_copy(array, copyCallback = null) {
    while (this.length > array.length) {
      this.pop();
    }
    for (let i = 0; i < array.length; i++) {
      if (copyCallback == null) {
        this[i] = array[i];
      } else {
        this[i] = copyCallback(this[i], array[i]);
      }
    }
    return this;
  };
  arrayExtension.pp_clone = function pp_clone(cloneCallback = null) {
    if (cloneCallback == null) {
      return this.slice(0);
    }
    let clone = null;
    switch (this.constructor.name) {
      case "Array":
        clone = new Array(this.length);
        break;
      case "Uint8ClampedArray":
        clone = new Uint8ClampedArray(this.length);
        break;
      case "Uint8Array":
        clone = new Uint8Array(this.length);
        break;
      case "Uint16Array":
        clone = new Uint16Array(this.length);
        break;
      case "Uint32Array":
        clone = new Uint32Array(this.length);
        break;
      case "Int8Array":
        clone = new Int8Array(this.length);
        break;
      case "Int16Array":
        clone = new Int16Array(this.length);
        break;
      case "Int32Array":
        clone = new Int32Array(this.length);
        break;
      case "Float32Array":
        clone = new Float32Array(this.length);
        break;
      case "Float64Array":
        clone = new Float64Array(this.length);
        break;
      default:
        clone = new Array(this.length);
        console.error("Cloned array type not supported!");
        break;
    }
    for (let i = 0; i < this.length; i++) {
      clone[i] = cloneCallback(this[i]);
    }
    return clone;
  };
  arrayExtension.pp_equals = function pp_equals(array, elementsEqualCallback = null) {
    let equals = true;
    if (array != null && this.length == array.length) {
      for (let i = 0; i < this.length; i++) {
        if (elementsEqualCallback != null && !elementsEqualCallback(this[i], array[i]) || elementsEqualCallback == null && this[i] != array[i]) {
          equals = false;
          break;
        }
      }
    } else {
      equals = false;
    }
    return equals;
  };
  arrayExtension.pp_clear = function pp_clear() {
    this.length = 0;
    return this;
  };
  arrayExtension.vec_toString = function vec_toString(decimalPlaces = null) {
    let message = _vec_buildConsoleMessage(this, decimalPlaces);
    return message;
  };
  arrayExtension.vec_log = function vec_log(decimalPlaces = 4) {
    let message = _vec_buildConsoleMessage(this, decimalPlaces);
    console.log(message);
  };
  arrayExtension.vec_error = function vec_error(decimalPlaces = 4) {
    let message = _vec_buildConsoleMessage(this, decimalPlaces);
    console.error(message);
  };
  arrayExtension.vec_warn = function vec_warn(decimalPlaces = 4) {
    let message = _vec_buildConsoleMessage(this, decimalPlaces);
    console.warn(message);
  };
  arrayExtension.vec_scale = function vec_scale(value, out = null) {
    out = _vec_prepareOut(this, out);
    for (let i = 0; i < out.length; i++) {
      out[i] = out[i] * value;
    }
    return out;
  };
  arrayExtension.vec_round = function vec_round(out = null) {
    out = _vec_prepareOut(this, out);
    for (let i = 0; i < out.length; i++) {
      out[i] = Math.round(out[i]);
    }
    return out;
  };
  arrayExtension.vec_floor = function vec_floor(out = null) {
    out = _vec_prepareOut(this, out);
    for (let i = 0; i < out.length; i++) {
      out[i] = Math.floor(out[i]);
    }
    return out;
  };
  arrayExtension.vec_ceil = function vec_ceil(out = null) {
    out = _vec_prepareOut(this, out);
    for (let i = 0; i < out.length; i++) {
      out[i] = Math.ceil(out[i]);
    }
    return out;
  };
  arrayExtension.vec_clamp = function vec_clamp(start, end, out = null) {
    out = _vec_prepareOut(this, out);
    let fixedStart = start != null ? start : -Number.MAX_VALUE;
    let fixedEnd = end != null ? end : Number.MAX_VALUE;
    let min = Math.min(fixedStart, fixedEnd);
    let max = Math.max(fixedStart, fixedEnd);
    for (let i = 0; i < out.length; i++) {
      out[i] = Math.pp_clamp(out[i], min, max);
    }
    return out;
  };
  arrayExtension.vec_equals = function vec_equals(vector, epsilon = 0) {
    let equals = this.length == vector.length;
    for (let i = 0; i < this.length && equals; i++) {
      equals = equals && Math.abs(this[i] - vector[i]) <= epsilon;
    }
    return equals;
  };
  arrayExtension.vec2_length = function vec2_length() {
    return glMatrix.vec2.length(this);
  };
  arrayExtension.vec2_normalize = function vec2_normalize(out = vec2_create()) {
    glMatrix.vec2.normalize(out, this);
    return out;
  };
  arrayExtension.vec2_copy = function vec2_copy(vector) {
    glMatrix.vec2.copy(this, vector);
    return this;
  };
  arrayExtension.vec2_clone = function vec2_clone(out = vec2_create()) {
    glMatrix.vec2.copy(out, this);
    return out;
  };
  arrayExtension.vec2_zero = function vec2_zero() {
    glMatrix.vec2.zero(this);
    return this;
  };
  arrayExtension.vec2_isZero = function vec2_isZero(epsilon = 0) {
    return this.vec2_length() <= epsilon;
  };
  arrayExtension.vec3_normalize = function vec3_normalize(out = vec3_create2()) {
    glMatrix.vec3.normalize(out, this);
    return out;
  };
  arrayExtension.vec3_copy = function vec3_copy(vector) {
    glMatrix.vec3.copy(this, vector);
    return this;
  };
  arrayExtension.vec3_clone = function vec3_clone(out = vec3_create2()) {
    glMatrix.vec3.copy(out, this);
    return out;
  };
  arrayExtension.vec3_zero = function vec3_zero() {
    glMatrix.vec3.zero(this);
    return this;
  };
  arrayExtension.vec3_angle = function vec3_angle(vector) {
    return this.vec3_angleDegrees(vector);
  };
  arrayExtension.vec3_angleDegrees = function vec3_angleDegrees(vector) {
    return Math.pp_toDegrees(this.vec3_angleRadians(vector));
  };
  arrayExtension.vec3_angleRadians = function vec3_angleRadians(vector) {
    let thisX = this[0];
    let thisY = this[1];
    let thisZ = this[2];
    let vectorX = vector[0];
    let vectorY = vector[1];
    let vectorZ = vector[2];
    let thisLengthSquared = thisX * thisX + thisY * thisY + thisZ * thisZ;
    let vectorLengthSquared = vectorX * vectorX + vectorY * vectorY + vectorZ * vectorZ;
    let lengthSquared = thisLengthSquared * vectorLengthSquared;
    let angle = 0;
    if (lengthSquared > Math.PP_EPSILON_SQUARED) {
      let length2 = Math.sqrt(lengthSquared);
      let cos = this.vec3_dot(vector) / length2;
      angle = Math.acos(Math.pp_clamp(cos, -1, 1));
    }
    return angle;
  };
  arrayExtension.vec3_equals = function vec3_equals(vector, epsilon = 0) {
    let equals = this.length == vector.length;
    if (equals) {
      equals &&= Math.abs(this[0] - vector[0]) <= epsilon;
      equals &&= Math.abs(this[1] - vector[1]) <= epsilon;
      equals &&= Math.abs(this[2] - vector[2]) <= epsilon;
    }
    return equals;
  };
  arrayExtension.vec3_length = function vec3_length() {
    return glMatrix.vec3.length(this);
  };
  arrayExtension.vec3_lengthSquared = function vec3_lengthSquared() {
    return glMatrix.vec3.squaredLength(this);
  };
  arrayExtension.vec3_distance = function vec3_distance(vector) {
    return glMatrix.vec3.dist(this, vector);
  };
  arrayExtension.vec3_distanceSquared = function vec3_distanceSquared(vector) {
    return glMatrix.vec3.squaredDistance(this, vector);
  };
  arrayExtension.vec3_add = function vec3_add(vector, out = vec3_create2()) {
    glMatrix.vec3.add(out, this, vector);
    return out;
  };
  arrayExtension.vec3_sub = function vec3_sub(vector, out = vec3_create2()) {
    glMatrix.vec3.sub(out, this, vector);
    return out;
  };
  arrayExtension.vec3_mul = function vec3_mul(vector, out = vec3_create2()) {
    glMatrix.vec3.mul(out, this, vector);
    return out;
  };
  arrayExtension.vec3_div = function vec3_div(vector, out = vec3_create2()) {
    glMatrix.vec3.div(out, this, vector);
    return out;
  };
  arrayExtension.vec3_scale = function vec3_scale(value, out = vec3_create2()) {
    glMatrix.vec3.scale(out, this, value);
    return out;
  };
  arrayExtension.vec3_dot = function vec3_dot(vector) {
    return glMatrix.vec3.dot(this, vector);
  };
  arrayExtension.vec3_negate = function vec3_negate(out = vec3_create2()) {
    glMatrix.vec3.negate(out, this);
    return out;
  };
  arrayExtension.vec3_cross = function vec3_cross(vector, out = vec3_create2()) {
    glMatrix.vec3.cross(out, this, vector);
    return out;
  };
  arrayExtension.vec3_transformQuat = function vec3_transformQuat(quat3, out = vec3_create2()) {
    glMatrix.vec3.transformQuat(out, this, quat3);
    return out;
  };
  arrayExtension.vec3_transformMat3 = function vec3_transformMat3(mat32, out = vec3_create2()) {
    glMatrix.vec3.transformMat3(out, this, mat32);
    return out;
  };
  arrayExtension.vec3_transformMat4 = function vec3_transformMat4(mat42, out = vec3_create2()) {
    glMatrix.vec3.transformMat4(out, this, mat42);
    return out;
  };
  arrayExtension.vec3_lengthSigned = function vec3_lengthSigned(positiveDirection) {
    let signedLength = this.vec3_length();
    if (!this.vec3_isConcordant(positiveDirection)) {
      signedLength *= -1;
    }
    return signedLength;
  };
  arrayExtension.vec3_angleSigned = function vec3_angleSigned(vector, upAxis) {
    return this.vec3_angleSignedDegrees(vector, upAxis);
  };
  arrayExtension.vec3_angleSignedDegrees = function vec3_angleSignedDegrees(vector, upAxis) {
    return Math.pp_toDegrees(this.vec3_angleSignedRadians(vector, upAxis));
  };
  arrayExtension.vec3_angleSignedRadians = function() {
    let crossAxis = vec3_create2();
    return function vec3_angleSignedRadians(vector, upAxis) {
      this.vec3_cross(vector, crossAxis);
      let angle = this.vec3_angleRadians(vector);
      if (!crossAxis.vec3_isConcordant(upAxis)) {
        angle = -angle;
      }
      return angle;
    };
  }();
  arrayExtension.vec3_toRadians = function vec3_toRadians(out = vec3_create2()) {
    glMatrix.vec3.set(out, glMatrix.glMatrix.toRadian(this[0]), glMatrix.glMatrix.toRadian(this[1]), glMatrix.glMatrix.toRadian(this[2]));
    return out;
  };
  arrayExtension.vec3_toDegrees = function vec3_toDegrees(out = vec3_create2()) {
    glMatrix.vec3.set(out, Math.pp_toDegrees(this[0]), Math.pp_toDegrees(this[1]), Math.pp_toDegrees(this[2]));
    return out;
  };
  arrayExtension.vec3_toQuat = function vec3_toQuat(out) {
    return this.vec3_degreesToQuat(out);
  };
  arrayExtension.vec3_radiansToQuat = function vec3_radiansToQuat(out = quat_create()) {
    out.quat_fromRadians(this);
    return out;
  };
  arrayExtension.vec3_degreesToQuat = function vec3_degreesToQuat(out = quat_create()) {
    out.quat_fromDegrees(this);
    return out;
  };
  arrayExtension.vec3_isNormalized = function vec3_isNormalized(epsilon = Math.PP_EPSILON) {
    return Math.abs(this.vec3_lengthSquared() - 1) < epsilon;
  };
  arrayExtension.vec3_isZero = function vec3_isZero(epsilon = 0) {
    return this.vec3_lengthSquared() <= epsilon * epsilon;
  };
  arrayExtension.vec3_componentAlongAxis = function vec3_componentAlongAxis(axis, out = vec3_create2()) {
    let componentAlongAxisLength = this.vec3_dot(axis);
    glMatrix.vec3.copy(out, axis);
    glMatrix.vec3.scale(out, out, componentAlongAxisLength);
    return out;
  };
  arrayExtension.vec3_valueAlongAxis = function vec3_valueAlongAxis(axis) {
    let valueAlongAxis = this.vec3_dot(axis);
    return valueAlongAxis;
  };
  arrayExtension.vec3_removeComponentAlongAxis = function() {
    let componentAlong = vec3_create2();
    return function vec3_removeComponentAlongAxis(axis, out = vec3_create2()) {
      this.vec3_componentAlongAxis(axis, componentAlong);
      glMatrix.vec3.sub(out, this, componentAlong);
      return out;
    };
  }();
  arrayExtension.vec3_copyComponentAlongAxis = function() {
    let componentAlong = vec3_create2();
    return function vec3_copyComponentAlongAxis(vector, axis, out = vec3_create2()) {
      this.vec3_removeComponentAlongAxis(axis, out);
      vector.vec3_componentAlongAxis(axis, componentAlong);
      out.vec3_add(componentAlong, out);
      return out;
    };
  }();
  arrayExtension.vec3_isConcordant = function vec3_isConcordant(vector) {
    return this.vec3_dot(vector) >= 0;
  };
  arrayExtension.vec3_isFartherAlongAxis = function vec3_isFartherAlongAxis(vector, axis) {
    return this.vec3_valueAlongAxis(axis) > vector.vec3_valueAlongAxis(axis);
  };
  arrayExtension.vec3_isToTheRight = function vec3_isToTheRight(vector, upAxis) {
    return this.vec3_signTo(vector, upAxis) >= 0;
  };
  arrayExtension.vec3_signTo = function() {
    let componentAlongThis = vec3_create2();
    let componentAlongVector = vec3_create2();
    return function vec3_signTo(vector, upAxis, zeroSign = 1) {
      this.vec3_removeComponentAlongAxis(upAxis, componentAlongThis);
      vector.vec3_removeComponentAlongAxis(upAxis, componentAlongVector);
      let angleSigned = this.vec3_angleSigned(vector, upAxis);
      return angleSigned > 0 ? 1 : angleSigned == 0 ? zeroSign : -1;
    };
  }();
  arrayExtension.vec3_projectOnAxis = function vec3_projectOnAxis(axis, out = vec3_create2()) {
    this.vec3_componentAlongAxis(axis, out);
    return out;
  };
  arrayExtension.vec3_projectOnAxisAlongAxis = function() {
    let up = vec3_create2();
    let thisToAxis = vec3_create2();
    let fixedProjectAlongAxis = vec3_create2();
    return function vec3_projectOnAxisAlongAxis(axis, projectAlongAxis, out = vec3_create2()) {
      if (this.vec3_isOnAxis(axis) || projectAlongAxis.vec3_isOnAxis(axis)) {
        out.vec3_copy(this);
      } else {
        projectAlongAxis.vec3_cross(axis, up);
        up.vec3_normalize(up);
        this.vec3_removeComponentAlongAxis(up, out);
        if (!out.vec3_isOnAxis(axis)) {
          out.vec3_projectOnAxis(axis, thisToAxis);
          thisToAxis.vec3_sub(out, thisToAxis);
          if (thisToAxis.vec3_isConcordant(projectAlongAxis)) {
            fixedProjectAlongAxis.vec3_copy(projectAlongAxis);
          } else {
            projectAlongAxis.vec3_negate(fixedProjectAlongAxis);
          }
          let angleWithAlongAxis = fixedProjectAlongAxis.vec3_angleRadians(thisToAxis);
          let lengthToRemove = thisToAxis.vec3_length() / Math.cos(angleWithAlongAxis);
          fixedProjectAlongAxis.vec3_normalize(fixedProjectAlongAxis);
          fixedProjectAlongAxis.vec3_scale(lengthToRemove, fixedProjectAlongAxis);
          out.vec3_add(fixedProjectAlongAxis, out);
          out.vec3_projectOnAxis(axis, out);
        }
      }
      return out;
    };
  }();
  arrayExtension.vec3_projectOnPlane = function vec3_projectOnPlane(planeNormal, out = vec3_create2()) {
    this.vec3_removeComponentAlongAxis(planeNormal, out);
    return out;
  };
  arrayExtension.vec3_projectOnPlaneAlongAxis = function() {
    let thisToPlane = vec3_create2();
    let fixedProjectAlongAxis = vec3_create2();
    return function vec3_projectOnPlaneAlongAxis(planeNormal, projectAlongAxis, out = vec3_create2()) {
      if (this.vec3_isOnPlane(planeNormal) || projectAlongAxis.vec3_isOnPlane(planeNormal)) {
        out.vec3_copy(this);
      } else {
        out.vec3_copy(this);
        out.vec3_projectOnPlane(planeNormal, thisToPlane);
        thisToPlane.vec3_sub(out, thisToPlane);
        if (thisToPlane.vec3_isConcordant(projectAlongAxis)) {
          fixedProjectAlongAxis.vec3_copy(projectAlongAxis);
        } else {
          projectAlongAxis.vec3_negate(fixedProjectAlongAxis);
        }
        let angleWithAlongAxis = fixedProjectAlongAxis.vec3_angleRadians(thisToPlane);
        let lengthToRemove = thisToPlane.vec3_length() / Math.cos(angleWithAlongAxis);
        fixedProjectAlongAxis.vec3_normalize(fixedProjectAlongAxis);
        fixedProjectAlongAxis.vec3_scale(lengthToRemove, fixedProjectAlongAxis);
        out.vec3_add(fixedProjectAlongAxis, out);
        out.vec3_projectOnPlane(planeNormal, out);
      }
      return out;
    };
  }();
  arrayExtension.vec3_isOnAxis = function vec3_isOnAxis(axis) {
    let angle = this.vec3_angle(axis);
    return Math.abs(angle) < Math.PP_EPSILON_DEGREES || Math.abs(angle - 180) < Math.PP_EPSILON_DEGREES;
  };
  arrayExtension.vec3_isOnPlane = function vec3_isOnPlane(planeNormal) {
    let angle = this.vec3_angle(planeNormal);
    return Math.abs(angle - 90) < Math.PP_EPSILON_DEGREES;
  };
  arrayExtension.vec3_rotate = function vec3_rotate(rotation, out) {
    return this.vec3_rotateDegrees(rotation, out);
  };
  arrayExtension.vec3_rotateDegrees = function() {
    let zero = vec3_create2();
    return function vec3_rotateDegrees(rotation, out) {
      return this.vec3_rotateAroundDegrees(rotation, zero, out);
    };
  }();
  arrayExtension.vec3_rotateRadians = function() {
    let zero = vec3_create2();
    return function vec3_rotateRadians(rotation, out) {
      return this.vec3_rotateAroundRadians(rotation, zero, out);
    };
  }();
  arrayExtension.vec3_rotateQuat = function() {
    let zero = vec3_create2();
    return function vec3_rotateQuat(rotation, out) {
      return this.vec3_rotateAroundQuat(rotation, zero, out);
    };
  }();
  arrayExtension.vec3_rotateAxis = function vec3_rotateAxis(angle, axis, out) {
    return this.vec3_rotateAxisDegrees(angle, axis, out);
  };
  arrayExtension.vec3_rotateAxisDegrees = function() {
    let zero = vec3_create2();
    return function vec3_rotateAxisDegrees(angle, axis, out) {
      return this.vec3_rotateAroundAxisDegrees(angle, axis, zero, out);
    };
  }();
  arrayExtension.vec3_rotateAxisRadians = function() {
    let zero = vec3_create2();
    return function vec3_rotateAxisRadians(angle, axis, out) {
      return this.vec3_rotateAroundAxisRadians(angle, axis, zero, out);
    };
  }();
  arrayExtension.vec3_rotateAround = function vec3_rotateAround(rotation, origin, out) {
    return this.vec3_rotateAroundDegrees(rotation, origin, out);
  };
  arrayExtension.vec3_rotateAroundDegrees = function() {
    let quat3 = quat_create();
    return function vec3_rotateAroundDegrees(rotation, origin, out = vec3_create2()) {
      rotation.vec3_degreesToQuat(quat3);
      return this.vec3_rotateAroundQuat(quat3, origin, out);
    };
  }();
  arrayExtension.vec3_rotateAroundRadians = function() {
    let quat3 = quat_create();
    return function vec3_rotateAroundRadians(rotation, origin, out = vec3_create2()) {
      rotation.vec3_radiansToQuat(quat3);
      return this.vec3_rotateAroundQuat(quat3, origin, out);
    };
  }();
  arrayExtension.vec3_rotateAroundQuat = function vec3_rotateAroundQuat(rotation, origin, out = vec3_create2()) {
    glMatrix.vec3.sub(out, this, origin);
    glMatrix.vec3.transformQuat(out, out, rotation);
    glMatrix.vec3.add(out, out, origin);
    return out;
  };
  arrayExtension.vec3_rotateAroundAxis = function vec3_rotateAroundAxis(angle, axis, origin, out) {
    return this.vec3_rotateAroundAxisDegrees(angle, axis, origin, out);
  };
  arrayExtension.vec3_rotateAroundAxisDegrees = function vec3_rotateAroundAxisDegrees(angle, axis, origin, out) {
    return this.vec3_rotateAroundAxisRadians(glMatrix.glMatrix.toRadian(angle), axis, origin, out);
  };
  arrayExtension.vec3_rotateAroundAxisRadians = function() {
    let quat3 = quat_create();
    return function vec3_rotateAroundAxisRadians(angle, axis, origin, out = vec3_create2()) {
      glMatrix.quat.setAxisAngle(quat3, axis, angle);
      return this.vec3_rotateAroundQuat(quat3, origin, out);
    };
  }();
  arrayExtension.vec3_convertPositionToWorld = function vec3_convertPositionToWorld(parentTransform, out) {
    return this.vec3_convertPositionToWorldMatrix(parentTransform, out);
  };
  arrayExtension.vec3_convertPositionToLocal = function vec3_convertPositionToLocal(parentTransform, out) {
    return this.vec3_convertPositionToLocalMatrix(parentTransform, out);
  };
  arrayExtension.vec3_convertPositionToWorldMatrix = function vec3_convertPositionToWorldMatrix(parentTransform, out = vec3_create2()) {
    glMatrix.vec3.transformMat4(out, this, parentTransform);
    return out;
  };
  arrayExtension.vec3_convertPositionToLocalMatrix = function() {
    let inverse = mat4_create();
    return function vec3_convertPositionToLocalMatrix(parentTransform, out = vec3_create2()) {
      glMatrix.mat4.invert(inverse, parentTransform);
      glMatrix.vec3.transformMat4(out, this, inverse);
      return out;
    };
  }();
  arrayExtension.vec3_convertPositionToWorldQuat = function() {
    let parentTransformMatrix = mat4_create();
    let position = vec3_create2();
    let rotation = quat_create();
    let one = vec3_create2();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function vec3_convertPositionToWorldQuat(parentTransform, out = vec3_create2()) {
      parentTransform.quat2_getPosition(position);
      parentTransform.quat2_getRotationQuat(rotation);
      parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
      return this.vec3_convertPositionToWorldMatrix(parentTransformMatrix, out);
    };
  }();
  arrayExtension.vec3_convertPositionToLocalQuat = function() {
    let parentTransformMatrix = mat4_create();
    let position = vec3_create2();
    let rotation = quat_create();
    let one = vec3_create2();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function vec3_convertPositionToLocalQuat(parentTransform, out = vec3_create2()) {
      parentTransform.quat2_getPosition(position);
      parentTransform.quat2_getRotationQuat(rotation);
      parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
      return this.vec3_convertPositionToLocalMatrix(parentTransformMatrix, out);
    };
  }();
  arrayExtension.vec3_convertDirectionToWorld = function vec3_convertDirectionToWorld(parentTransform, out) {
    return this.vec3_convertDirectionToWorldMatrix(parentTransform, out);
  };
  arrayExtension.vec3_convertDirectionToLocal = function vec3_convertDirectionToLocal(parentTransform, out) {
    return this.vec3_convertDirectionToLocalMatrix(parentTransform, out);
  };
  arrayExtension.vec3_convertDirectionToWorldMatrix = function() {
    let rotation = quat_create();
    return function vec3_convertDirectionToWorldMatrix(parentTransform, out = vec3_create2()) {
      parentTransform.mat4_getRotationQuat(rotation);
      glMatrix.vec3.transformQuat(out, this, rotation);
      return out;
    };
  }();
  arrayExtension.vec3_convertDirectionToLocalMatrix = function() {
    let rotation = quat_create();
    return function vec3_convertDirectionToLocalMatrix(parentTransform, out = vec3_create2()) {
      parentTransform.mat4_getRotationQuat(rotation);
      glMatrix.quat.conjugate(rotation, rotation);
      glMatrix.vec3.transformQuat(out, this, rotation);
      return out;
    };
  }();
  arrayExtension.vec3_convertDirectionToWorldQuat = function() {
    let rotation = quat_create();
    return function vec3_convertDirectionToWorldQuat(parentTransform, out = vec3_create2()) {
      parentTransform.quat2_getRotationQuat(rotation);
      glMatrix.vec3.transformQuat(out, this, rotation);
      return out;
    };
  }();
  arrayExtension.vec3_convertDirectionToLocalQuat = function() {
    let rotation = quat_create();
    return function vec3_convertDirectionToLocalQuat(parentTransform, out = vec3_create2()) {
      parentTransform.quat2_getRotationQuat(rotation);
      glMatrix.quat.conjugate(rotation, rotation);
      glMatrix.vec3.transformQuat(out, this, rotation);
      return out;
    };
  }();
  arrayExtension.vec3_log = function vec3_log(decimalPlaces = 4) {
    this.vec_log(decimalPlaces);
  };
  arrayExtension.vec3_error = function vec3_error(decimalPlaces = 4) {
    this.vec_error(decimalPlaces);
  };
  arrayExtension.vec3_warn = function vec3_warn(decimalPlaces = 4) {
    this.vec_warn(decimalPlaces);
  };
  arrayExtension.vec3_addRotation = function vec3_addRotation(rotation, out) {
    return this.vec3_degreesAddRotation(rotation, out);
  };
  arrayExtension.vec3_addRotationDegrees = function vec3_addRotationDegrees(rotation, out) {
    return quat.vec3_degreesAddRotationDegrees(rotation, out);
  };
  arrayExtension.vec3_addRotationRadians = function vec3_addRotationRadians(rotation, out) {
    return quat.vec3_degreesAddRotationRadians(rotation, out);
  };
  arrayExtension.vec3_addRotationQuat = function vec3_addRotationQuat(rotation, out) {
    return quat.vec3_degreesAddRotationQuat(rotation, out);
  };
  arrayExtension.vec3_degreesAddRotation = function vec3_degreesAddRotation(rotation, out) {
    return this.vec3_degreesAddRotationDegrees(rotation, out);
  };
  arrayExtension.vec3_degreesAddRotationDegrees = function() {
    let quat3 = quat_create();
    return function vec3_degreesAddRotationDegrees(rotation, out = vec3_create2()) {
      this.vec3_degreesToQuat(quat3);
      return quat3.quat_addRotationDegrees(rotation, quat3).quat_toDegrees(out);
    };
  }();
  arrayExtension.vec3_degreesAddRotationRadians = function() {
    let quat3 = quat_create();
    return function vec3_degreesAddRotationRadians(rotation, out = vec3_create2()) {
      this.vec3_degreesToQuat(quat3);
      return quat3.quat_addRotationRadians(rotation, quat3).quat_toDegrees(out);
    };
  }();
  arrayExtension.vec3_degreesAddRotationQuat = function() {
    let quat3 = quat_create();
    return function vec3_degreesAddRotationQuat(rotation, out = vec3_create2()) {
      this.vec3_degreesToQuat(quat3);
      return quat3.quat_addRotationQuat(rotation, quat3).quat_toDegrees(out);
    };
  }();
  arrayExtension.vec3_radiansAddRotation = function vec3_radiansAddRotation(rotation, out) {
    return this.vec3_radiansAddRotationDegrees(rotation, out);
  };
  arrayExtension.vec3_radiansAddRotationDegrees = function() {
    let quat3 = quat_create();
    return function vec3_radiansAddRotationDegrees(rotation, out = vec3_create2()) {
      this.vec3_radiansToQuat(quat3);
      return quat3.quat_addRotationDegrees(rotation, quat3).quat_toRadians(out);
    };
  }();
  arrayExtension.vec3_radiansAddRotationRadians = function() {
    let quat3 = quat_create();
    return function vec3_radiansAddRotationRadians(rotation, out = vec3_create2()) {
      this.vec3_radiansToQuat(quat3);
      return quat3.quat_addRotationRadians(rotation, quat3).quat_toRadians(out);
    };
  }();
  arrayExtension.vec3_radiansAddRotationQuat = function() {
    let quat3 = quat_create();
    return function vec3_radiansAddRotationQuat(rotation, out = vec3_create2()) {
      this.vec3_radiansToQuat(quat3);
      return quat3.quat_addRotationQuat(rotation, quat3).quat_toRadians(out);
    };
  }();
  arrayExtension.vec3_toMatrix = function vec3_toMatrix(out = mat3_create()) {
    return this.vec3_degreesToMatrix(out);
  };
  arrayExtension.vec3_degreesToMatrix = function() {
    let quat3 = quat_create();
    return function vec3_degreesToMatrix(out = mat3_create()) {
      this.vec3_degreesToQuat(quat3);
      return quat3.quat_toMatrix(out);
    };
  }();
  arrayExtension.vec3_radiansToMatrix = function() {
    let quat3 = quat_create();
    return function vec3_radiansToMatrix(out = mat3_create()) {
      this.vec3_radiansToQuat(quat3);
      return quat3.quat_toMatrix(out);
    };
  }();
  arrayExtension.vec3_rotationTo = function vec3_rotationTo(direction, out) {
    return this.vec3_rotationToDegrees(direction, out);
  };
  arrayExtension.vec3_rotationToDegrees = function() {
    let rotationQuat = quat_create();
    return function vec3_rotationToDegrees(direction, out = vec3_create2()) {
      this.vec3_rotationToQuat(direction, rotationQuat);
      rotationQuat.quat_toDegrees(out);
      return out;
    };
  }();
  arrayExtension.vec3_rotationToRadians = function() {
    let rotationQuat = quat_create();
    return function vec3_rotationToRadians(direction, out = vec3_create2()) {
      this.vec3_rotationToQuat(direction, rotationQuat);
      rotationQuat.quat_toRadians(out);
      return out;
    };
  }();
  arrayExtension.vec3_rotationToQuat = function() {
    let rotationAxis = vec3_create2();
    return function vec3_rotationToQuat(direction, out = quat_create()) {
      this.vec3_cross(direction, rotationAxis);
      rotationAxis.vec3_normalize(rotationAxis);
      let signedAngle = this.vec3_angleSigned(direction, rotationAxis);
      out.quat_fromAxis(signedAngle, rotationAxis);
      return out;
    };
  }();
  arrayExtension.vec3_rotationToPivoted = function vec3_rotationToPivoted(direction, pivotAxis, out) {
    return this.vec3_rotationToPivotedDegrees(direction, pivotAxis, out);
  };
  arrayExtension.vec3_rotationToPivotedDegrees = function() {
    let rotationQuat = quat_create();
    return function vec3_rotationToPivotedDegrees(direction, pivotAxis, out = vec3_create2()) {
      this.vec3_rotationToPivotedQuat(direction, pivotAxis, rotationQuat);
      rotationQuat.quat_toDegrees(out);
      return out;
    };
  }();
  arrayExtension.vec3_rotationToPivotedRadians = function() {
    let rotationQuat = quat_create();
    return function vec3_rotationToPivotedRadians(direction, pivotAxis, out = vec3_create2()) {
      this.vec3_rotationToPivotedQuat(direction, pivotAxis, rotationQuat);
      rotationQuat.quat_toRadians(out);
      return out;
    };
  }();
  arrayExtension.vec3_rotationToPivotedQuat = function() {
    let thisFlat = vec3_create2();
    let directionFlat = vec3_create2();
    let rotationAxis = vec3_create2();
    return function vec3_rotationToPivotedQuat(direction, pivotAxis, out = quat_create()) {
      this.vec3_removeComponentAlongAxis(pivotAxis, thisFlat);
      direction.vec3_removeComponentAlongAxis(pivotAxis, directionFlat);
      thisFlat.vec3_cross(directionFlat, rotationAxis);
      rotationAxis.vec3_normalize(rotationAxis);
      let signedAngle = thisFlat.vec3_angleSigned(directionFlat, rotationAxis);
      out.quat_fromAxis(signedAngle, rotationAxis);
      return out;
    };
  }();
  arrayExtension.vec3_lerp = function vec3_lerp(to, interpolationValue, out = vec3_create2()) {
    if (interpolationValue <= 0) {
      out.vec3_copy(this);
      return out;
    } else if (interpolationValue >= 1) {
      out.vec3_copy(to);
      return out;
    }
    glMatrix.vec3.lerp(out, this, to, interpolationValue);
    return out;
  };
  arrayExtension.vec3_interpolate = function vec3_interpolate(to, interpolationValue, easingFunction = EasingFunction.linear, out = vec3_create2()) {
    let lerpValue = easingFunction(interpolationValue);
    return this.vec3_lerp(to, lerpValue, out);
  };
  arrayExtension.vec4_copy = function vec4_copy(vector) {
    glMatrix.vec4.copy(this, vector);
    return this;
  };
  arrayExtension.vec4_clone = function vec4_clone(out = vec4_create2()) {
    glMatrix.vec4.copy(out, this);
    return out;
  };
  arrayExtension.quat_normalize = function quat_normalize(out = quat_create()) {
    glMatrix.quat.normalize(out, this);
    return out;
  };
  arrayExtension.quat_copy = function quat_copy(quat3) {
    glMatrix.quat.copy(this, quat3);
    return this;
  };
  arrayExtension.quat_clone = function quat_clone(out = quat_create()) {
    glMatrix.quat.copy(out, this);
    return out;
  };
  arrayExtension.quat_identity = function quat_identity() {
    glMatrix.quat.identity(this);
    return this;
  };
  arrayExtension.quat_length = function quat_length() {
    return glMatrix.quat.length(this);
  };
  arrayExtension.quat_lengthSquared = function quat_lengthSquared() {
    return glMatrix.quat.squaredLength(this);
  };
  arrayExtension.quat_invert = function quat_invert(out = quat_create()) {
    glMatrix.quat.invert(out, this);
    return out;
  };
  arrayExtension.quat_conjugate = function quat_conjugate(out = quat_create()) {
    glMatrix.quat.conjugate(out, this);
    return out;
  };
  arrayExtension.quat_mul = function quat_mul(rotation, out = quat_create()) {
    glMatrix.quat.mul(out, this, rotation);
    return out;
  };
  arrayExtension.quat_getAxis = function() {
    let zero = vec3_create2(0, 0, 0);
    return function quat_getAxis(out = vec3_create2()) {
      let angle = glMatrix.quat.getAxisAngle(out, this);
      if (angle <= Math.PP_EPSILON) {
        out.vec3_copy(zero);
      }
      return out;
    };
  }();
  arrayExtension.quat_getAngle = function quat_getAngle() {
    return this.quat_getAngleDegrees();
  };
  arrayExtension.quat_getAngleDegrees = function quat_getAngleDegrees() {
    let angle = this.quat_getAngleRadians();
    return Math.pp_toDegrees(angle);
  };
  arrayExtension.quat_getAngleRadians = function() {
    let vector = vec3_create2();
    return function quat_getAngleRadians() {
      let angle = glMatrix.quat.getAxisAngle(vector, this);
      return angle;
    };
  }();
  arrayExtension.quat_getAxisScaled = function quat_getAxisScaled(out = vec3_create2()) {
    return this.quat_getAxisScaledDegrees(out);
  };
  arrayExtension.quat_getAxisScaledDegrees = function quat_getAxisScaledDegrees(out = vec3_create2()) {
    this.quat_getAxis(out);
    let angle = this.quat_getAngleDegrees();
    out.vec3_scale(angle, out);
    return out;
  };
  arrayExtension.quat_getAxisScaledRadians = function() {
    let zero = vec3_create2(0, 0, 0);
    return function quat_getAxisScaledRadians(out = vec3_create2()) {
      this.quat_getAxis(out);
      let angle = this.quat_getAngleRadians();
      if (angle <= Math.PP_EPSILON) {
        out.vec3_copy(zero);
      } else {
        out.vec3_scale(angle, out);
      }
      return out;
    };
  }();
  arrayExtension.quat_getAxes = function quat_getAxes(out = [vec3_create2(), vec3_create2(), vec3_create2()]) {
    this.quat_getLeft(out[0]);
    this.quat_getUp(out[1]);
    this.quat_getForward(out[2]);
    return out;
  };
  arrayExtension.quat_getForward = function() {
    let rotationMatrix = mat3_create();
    return function quat_getForward(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(rotationMatrix, this);
      glMatrix.vec3.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
      glMatrix.vec3.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.quat_getBackward = function quat_getBackward(out) {
    out = this.quat_getForward(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.quat_getLeft = function() {
    let rotationMatrix = mat3_create();
    return function quat_getLeft(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(rotationMatrix, this);
      glMatrix.vec3.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
      glMatrix.vec3.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.quat_getRight = function quat_getRight(out) {
    out = this.quat_getLeft(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.quat_getUp = function() {
    let rotationMatrix = mat3_create();
    return function quat_getUp(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(rotationMatrix, this);
      glMatrix.vec3.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
      glMatrix.vec3.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.quat_getDown = function quat_getDown(out) {
    out = this.quat_getUp(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.quat_setAxes = function quat_setAxes(left, up, forward) {
    if (forward != null) {
      return this.quat_setForward(forward, up, left);
    } else if (up != null) {
      return this.quat_setUp(up, forward, left);
    } else {
      return this.quat_setLeft(left, up, forward);
    }
  };
  arrayExtension.quat_setForward = function quat_setForward(forward, up = null, left = null) {
    return _quat_setAxes(this, [left, up, forward], [2, 1, 0]);
  };
  arrayExtension.quat_setBackward = function() {
    let forward = vec3_create2();
    return function quat_setBackward(backward, up = null, left = null) {
      backward.vec3_negate(forward);
      return _quat_setAxes(this, [left, up, forward], [2, 1, 0]);
    };
  }();
  arrayExtension.quat_setUp = function quat_setUp(up, forward = null, left = null) {
    return _quat_setAxes(this, [left, up, forward], [1, 2, 0]);
  };
  arrayExtension.quat_setDown = function() {
    let up = vec3_create2();
    return function quat_setDown(down, forward = null, left = null) {
      down.vec3_negate(up);
      return _quat_setAxes(this, [left, up, forward], [1, 2, 0]);
    };
  }();
  arrayExtension.quat_setLeft = function quat_setLeft(left, up = null, forward = null) {
    return _quat_setAxes(this, [left, up, forward], [0, 1, 2]);
  };
  arrayExtension.quat_setRight = function() {
    let left = vec3_create2();
    return function quat_setRight(right, up = null, forward = null) {
      right.vec3_negate(left);
      return _quat_setAxes(this, [left, up, forward], [0, 1, 2]);
    };
  }();
  arrayExtension.quat_toWorld = function quat_toWorld(parentQuat, out = quat_create()) {
    glMatrix.quat.mul(out, parentQuat, this);
    return out;
  };
  arrayExtension.quat_toLocal = function() {
    let invertQuat = quat_create();
    return function quat_toLocal(parentQuat, out = quat_create()) {
      glMatrix.quat.conjugate(invertQuat, parentQuat);
      glMatrix.quat.mul(out, invertQuat, this);
      return out;
    };
  }();
  arrayExtension.quat_fromAxis = function quat_fromAxis(angle, axis) {
    return this.quat_fromAxisDegrees(angle, axis);
  };
  arrayExtension.quat_fromAxisDegrees = function quat_fromAxisDegrees(angle, axis) {
    glMatrix.quat.setAxisAngle(this, axis, glMatrix.glMatrix.toRadian(angle));
    return this;
  };
  arrayExtension.quat_fromAxisRadians = function quat_fromAxisRadians(angle, axis) {
    glMatrix.quat.setAxisAngle(this, axis, angle);
    return this;
  };
  arrayExtension.quat_fromAxes = function() {
    let mat32 = mat3_create();
    return function quat_fromAxes(leftAxis, upAxis, forwardAxis) {
      mat32.mat3_fromAxes(leftAxis, upAxis, forwardAxis);
      return mat32.mat3_toQuat(this);
    };
  }();
  arrayExtension.quat_fromRadians = function() {
    let vector = vec3_create2();
    return function quat_fromRadians(radiansRotation) {
      radiansRotation.vec3_toDegrees(vector);
      return this.quat_fromDegrees(vector);
    };
  }();
  arrayExtension.quat_fromDegrees = function quat_fromDegrees(degreesRotation) {
    glMatrix.quat.fromEuler(this, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
    return this;
  };
  arrayExtension.quat_toRadians = function() {
    let mat32 = mat3_create();
    return function quat_toRadians(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(mat32, this);
      out[1] = Math.asin(-Math.pp_clamp(mat32[2], -1, 1));
      if (Math.abs(mat32[2]) < 1 - Math.PP_EPSILON) {
        out[0] = Math.atan2(mat32[5], mat32[8]);
        out[2] = Math.atan2(mat32[1], mat32[0]);
      } else {
        out[0] = 0;
        out[2] = Math.atan2(-mat32[3], mat32[4]);
      }
      return out;
    };
  }();
  arrayExtension.quat_toDegrees = function quat_toDegrees(out = vec3_create2()) {
    this.quat_toRadians(out);
    out.vec3_toDegrees(out);
    return out;
  };
  arrayExtension.quat_isNormalized = function quat_isNormalized(epsilon = Math.PP_EPSILON) {
    return Math.abs(this.quat_lengthSquared() - 1) < epsilon;
  };
  arrayExtension.quat_addRotation = function quat_addRotation(rotation, out) {
    return this.quat_addRotationDegrees(rotation, out);
  };
  arrayExtension.quat_addRotationDegrees = function() {
    let quat3 = quat_create();
    return function quat_addRotationDegrees(rotation, out) {
      rotation.vec3_degreesToQuat(quat3);
      return this.quat_addRotationQuat(quat3, out);
    };
  }();
  arrayExtension.quat_addRotationRadians = function() {
    let quat3 = quat_create();
    return function quat_addRotationRadians(rotation, out) {
      rotation.vec3_radiansToQuat(quat3);
      return this.quat_addRotationQuat(quat3, out);
    };
  }();
  arrayExtension.quat_addRotationQuat = function quat_addRotationQuat(rotation, out = quat_create()) {
    rotation.quat_mul(this, out);
    return out;
  };
  arrayExtension.quat_subRotation = function quat_subRotation(rotation, out) {
    return this.quat_subRotationDegrees(rotation, out);
  };
  arrayExtension.quat_subRotationDegrees = function() {
    let quat3 = quat_create();
    return function quat_subRotationDegrees(rotation, out) {
      rotation.vec3_degreesToQuat(quat3);
      return this.quat_subRotationQuat(quat3, out);
    };
  }();
  arrayExtension.quat_subRotationRadians = function() {
    let quat3 = quat_create();
    return function quat_subRotationRadians(rotation, out) {
      rotation.vec3_radiansToQuat(quat3);
      return this.quat_subRotationQuat(quat3, out);
    };
  }();
  arrayExtension.quat_subRotationQuat = function() {
    let inverse = quat_create();
    return function quat_subRotationQuat(rotation, out = quat_create()) {
      rotation.quat_invert(inverse);
      this.quat_mul(inverse, out);
      if (this.quat_isNormalized() && rotation.quat_isNormalized()) {
        out.quat_normalize(out);
      }
      return out;
    };
  }();
  arrayExtension.quat_rotationTo = function quat_rotationTo(rotation, out) {
    return this.quat_rotationToDegrees(rotation, out);
  };
  arrayExtension.quat_rotationToDegrees = function() {
    let rotationQuat = quat_create();
    return function quat_rotationToDegrees(rotation, out) {
      rotation.vec3_degreesToQuat(rotationQuat);
      return this.quat_rotationToQuat(rotationQuat, out);
    };
  }();
  arrayExtension.quat_rotationToRadians = function() {
    let rotationQuat = quat_create();
    return function quat_rotationToRadians(rotation, out) {
      rotation.vec3_radiansToQuat(rotationQuat);
      return this.quat_rotationToQuat(rotationQuat, out);
    };
  }();
  arrayExtension.quat_rotationToQuat = function quat_rotationToQuat(rotation, out) {
    return rotation.quat_subRotationQuat(this, out);
  };
  arrayExtension.quat_getTwist = function() {
    let rotationAxis = vec3_create2();
    let projection = vec3_create2();
    let rotationAlongAxis = quat_create();
    return function quat_getTwist(axis, out = quat_create()) {
      rotationAxis[0] = this[0];
      rotationAxis[1] = this[1];
      rotationAxis[2] = this[2];
      let dotProd = glMatrix.vec3.dot(axis, rotationAxis);
      axis.vec3_scale(dotProd, projection);
      rotationAlongAxis[0] = projection[0];
      rotationAlongAxis[1] = projection[1];
      rotationAlongAxis[2] = projection[2];
      rotationAlongAxis[3] = this[3];
      rotationAlongAxis.quat_normalize(rotationAlongAxis);
      if (dotProd < 0) {
        rotationAlongAxis[0] = -rotationAlongAxis[0];
        rotationAlongAxis[1] = -rotationAlongAxis[1];
        rotationAlongAxis[2] = -rotationAlongAxis[2];
        rotationAlongAxis[3] = -rotationAlongAxis[3];
      }
      return out.quat_copy(rotationAlongAxis);
    };
  }();
  arrayExtension.quat_getSwing = function() {
    let twist = quat_create();
    return function quat_getSwing(axis, out = quat_create()) {
      this.quat_getTwist(axis, twist);
      this.quat_getSwingFromTwist(twist, out);
      return out;
    };
  }();
  arrayExtension.quat_getSwingFromTwist = function quat_getSwingFromTwist(twist, out = quat_create()) {
    return this.quat_subRotationQuat(twist, out);
  };
  arrayExtension.quat_getTwistFromSwing = function() {
    let inverse = quat_create();
    return function quat_getTwistFromSwing(swing, out = quat_create()) {
      swing.quat_invert(inverse);
      this.quat_addRotationQuat(inverse, out);
      return out;
    };
  }();
  arrayExtension.quat_fromTwistSwing = function quat_fromTwistSwing(twist, swing) {
    return twist.quat_addRotationQuat(swing, this);
  };
  arrayExtension.quat_toMatrix = function quat_toMatrix(out = mat3_create()) {
    glMatrix.mat3.fromQuat(out, this);
    return out;
  };
  arrayExtension.quat_rotate = function quat_rotate(rotation, out) {
    return this.quat_rotateDegrees(rotation, out);
  };
  arrayExtension.quat_rotateDegrees = function quat_rotateDegrees(rotation, out) {
    return this.quat_addRotationDegrees(rotation, out);
  };
  arrayExtension.quat_rotateRadians = function quat_rotateRadians(rotation, out) {
    return this.quat_addRotationRadians(rotation, out);
  };
  arrayExtension.quat_rotateQuat = function quat_rotateQuat(rotation, out) {
    return this.quat_addRotationQuat(rotation, out);
  };
  arrayExtension.quat_rotateAxis = function quat_rotateAxis(angle, axis, out) {
    return this.quat_rotateAxisDegrees(angle, axis, out);
  };
  arrayExtension.quat_rotateAxisDegrees = function() {
    let rotationQuat = quat_create();
    return function quat_rotateAxisDegrees(angle, axis, out) {
      rotationQuat.quat_fromAxisDegrees(angle, axis);
      return this.quat_rotateQuat(rotationQuat, out);
    };
  }();
  arrayExtension.quat_rotateAxisRadians = function() {
    let rotationQuat = quat_create();
    return function quat_rotateAxisRadians(angle, axis, out) {
      rotationQuat.quat_fromAxisRadians(angle, axis);
      return this.quat_rotateQuat(rotationQuat, out);
    };
  }();
  arrayExtension.quat_lerp = function quat_lerp(to, interpolationValue, out = quat_create()) {
    if (interpolationValue <= 0) {
      out.quat_copy(this);
      return out;
    } else if (interpolationValue >= 1) {
      out.quat_copy(to);
      return out;
    }
    glMatrix.quat.lerp(out, this, to, interpolationValue);
    return out;
  };
  arrayExtension.quat_interpolate = function quat_interpolate(to, interpolationValue, easingFunction = EasingFunction.linear, out = quat_create()) {
    let lerpValue = easingFunction(interpolationValue);
    return this.quat_lerp(to, lerpValue, out);
  };
  arrayExtension.quat_slerp = function quat_slerp(to, interpolationValue, out = quat_create()) {
    if (interpolationValue <= 0) {
      out.quat_copy(this);
      return out;
    } else if (interpolationValue >= 1) {
      out.quat_copy(to);
      return out;
    }
    glMatrix.quat.slerp(out, this, to, interpolationValue);
    return out;
  };
  arrayExtension.quat_sinterpolate = function quat_sinterpolate(to, interpolationValue, easingFunction = EasingFunction.linear, out = quat_create()) {
    let lerpValue = easingFunction(interpolationValue);
    return this.quat_slerp(to, lerpValue, out);
  };
  arrayExtension.quat2_normalize = function quat2_normalize(out = quat2_create()) {
    glMatrix.quat2.normalize(out, this);
    return out;
  };
  arrayExtension.quat2_invert = function quat2_invert(out = quat2_create()) {
    glMatrix.quat2.invert(out, this);
    return out;
  };
  arrayExtension.quat2_conjugate = function quat2_conjugate(out = quat2_create()) {
    glMatrix.quat2.conjugate(out, this);
    return out;
  };
  arrayExtension.quat2_copy = function quat2_copy(quat23) {
    glMatrix.quat2.copy(this, quat23);
    return this;
  };
  arrayExtension.quat2_identity = function quat2_identity() {
    glMatrix.quat2.identity(this);
    return this;
  };
  arrayExtension.quat2_getPosition = function quat2_getPosition(out = vec3_create2()) {
    glMatrix.quat2.getTranslation(out, this);
    return out;
  };
  arrayExtension.quat2_getRotation = function quat2_getRotation(out) {
    return this.quat2_getRotationDegrees(out);
  };
  arrayExtension.quat2_getRotationDegrees = function() {
    let rotationQuat = quat_create();
    return function quat2_getRotationDegrees(out = vec3_create2()) {
      this.quat2_getRotationQuat(rotationQuat).quat_toDegrees(out);
      return out;
    };
  }();
  arrayExtension.quat2_getRotationRadians = function() {
    let rotationQuat = quat_create();
    return function quat2_getRotationRadians(out = vec3_create2()) {
      this.quat2_getRotationQuat(rotationQuat).quat_toRadians(out);
      return out;
    };
  }();
  arrayExtension.quat2_getRotationQuat = function quat2_getRotationQuat(out = quat_create()) {
    glMatrix.quat.copy(out, this);
    return out;
  };
  arrayExtension.quat2_setPosition = function() {
    let rotationQuat = quat_create();
    return function quat2_setPosition(position) {
      this.quat2_getRotationQuat(rotationQuat);
      this.quat2_setPositionRotationQuat(position, rotationQuat);
      return this;
    };
  }();
  arrayExtension.quat2_setRotation = function quat2_setRotation(rotation) {
    return this.quat2_setRotationDegrees(rotation);
  };
  arrayExtension.quat2_setRotationDegrees = function() {
    let position = vec3_create2();
    return function quat2_setRotationDegrees(rotation) {
      this.quat2_getPosition(position);
      this.quat2_setPositionRotationDegrees(position, rotation);
      return this;
    };
  }();
  arrayExtension.quat2_setRotationRadians = function() {
    let position = vec3_create2();
    return function quat2_setRotationRadians(rotation) {
      this.quat2_getPosition(position);
      this.quat2_setPositionRotationRadians(position, rotation);
      return this;
    };
  }();
  arrayExtension.quat2_setRotationQuat = function() {
    let position = vec3_create2();
    return function quat2_setRotationQuat(rotation) {
      this.quat2_getPosition(position);
      this.quat2_setPositionRotationQuat(position, rotation);
      return this;
    };
  }();
  arrayExtension.quat2_setPositionRotation = function quat2_setPositionRotation(position, rotation) {
    return this.quat2_setPositionRotationDegrees(position, rotation);
  };
  arrayExtension.quat2_setPositionRotationDegrees = function() {
    let rotationQuat = quat_create();
    return function quat2_setPositionRotationDegrees(position, rotation) {
      rotation.vec3_degreesToQuat(rotationQuat);
      glMatrix.quat2.fromRotationTranslation(this, rotationQuat, position);
      return this;
    };
  }();
  arrayExtension.quat2_setPositionRotationRadians = function() {
    let rotationQuat = quat_create();
    return function quat2_setPositionRotationRadians(position, rotation) {
      rotation.vec3_radiansToQuat(rotationQuat);
      glMatrix.quat2.fromRotationTranslation(this, rotationQuat, position);
      return this;
    };
  }();
  arrayExtension.quat2_setPositionRotationQuat = function quat2_setPositionRotationQuat(position, rotation) {
    glMatrix.quat2.fromRotationTranslation(this, rotation, position);
    return this;
  };
  arrayExtension.quat2_isNormalized = function quat2_isNormalized(epsilon = Math.PP_EPSILON) {
    return Math.abs(this.quat2_lengthSquared() - 1) < epsilon;
  };
  arrayExtension.quat2_length = function quat2_length() {
    return glMatrix.quat2.length(this);
  };
  arrayExtension.quat2_lengthSquared = function quat2_lengthSquared() {
    return glMatrix.quat2.squaredLength(this);
  };
  arrayExtension.quat2_mul = function quat2_mul(quat23, out = quat2_create()) {
    glMatrix.quat2.mul(out, this, quat23);
    return out;
  };
  arrayExtension.quat2_getAxes = function quat2_getAxes(out = [vec3_create2(), vec3_create2(), vec3_create2()]) {
    this.quat2_getLeft(out[0]);
    this.quat2_getUp(out[1]);
    this.quat2_getForward(out[2]);
    return out;
  };
  arrayExtension.quat2_getForward = function() {
    let rotationMatrix = mat3_create();
    return function quat2_getForward(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(rotationMatrix, this);
      glMatrix.vec3.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
      glMatrix.vec3.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.quat2_getBackward = function quat2_getBackward(out) {
    out = this.quat2_getForward(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.quat2_getLeft = function() {
    let rotationMatrix = mat3_create();
    return function quat2_getLeft(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(rotationMatrix, this);
      glMatrix.vec3.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
      glMatrix.vec3.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.quat2_getRight = function quat2_getRight(out) {
    out = this.quat2_getLeft(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.quat2_getUp = function() {
    let rotationMatrix = mat3_create();
    return function quat2_getUp(out = vec3_create2()) {
      glMatrix.mat3.fromQuat(rotationMatrix, this);
      glMatrix.vec3.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
      glMatrix.vec3.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.quat2_getDown = function quat2_getDown(out) {
    out = this.quat2_getUp(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.quat2_toWorld = function quat2_toWorld(parentTransformQuat, out = quat2_create()) {
    glMatrix.quat2.mul(out, parentTransformQuat, this);
    return out;
  };
  arrayExtension.quat2_toLocal = function() {
    let invertQuat = quat2_create();
    return function quat2_toLocal(parentTransformQuat, out = quat2_create()) {
      glMatrix.quat2.conjugate(invertQuat, parentTransformQuat);
      glMatrix.quat2.mul(out, invertQuat, this);
      return out;
    };
  }();
  arrayExtension.quat2_rotateAxis = function quat2_rotateAxis(angle, axis, out) {
    return this.quat2_rotateAxisDegrees(angle, axis, out);
  };
  arrayExtension.quat2_rotateAxisDegrees = function quat2_rotateAxisDegrees(angle, axis, out) {
    return this.quat2_rotateAxisRadians(glMatrix.glMatrix.toRadian(angle), axis, out);
  };
  arrayExtension.quat2_rotateAxisRadians = function() {
    let rotationQuat = quat_create();
    return function quat2_rotateAxisRadians(angle, axis, out) {
      this.quat2_getRotationQuat(rotationQuat);
      rotationQuat.quat_rotateAxisRadians(angle, axis, rotationQuat);
      out.quat2_copy(this);
      out.quat2_setRotationQuat(rotationQuat);
      return out;
    };
  }();
  arrayExtension.quat2_toMatrix = function quat2_toMatrix(out = mat4_create()) {
    glMatrix.mat4.fromQuat2(out, this);
    return out;
  };
  arrayExtension.quat2_fromMatrix = function quat2_fromMatrix(mat42) {
    mat42.mat4_toQuat(this);
    return this;
  };
  arrayExtension.quat2_lerp = function quat2_lerp(to, interpolationValue, out = quat2_create()) {
    if (interpolationValue <= 0) {
      out.quat2_copy(this);
      return out;
    } else if (interpolationValue >= 1) {
      out.quat2_copy(to);
      return out;
    }
    glMatrix.quat2.lerp(out, this, to, interpolationValue);
    return out;
  };
  arrayExtension.quat2_interpolate = function quat2_interpolate(to, interpolationValue, easingFunction = EasingFunction.linear, out = quat2_create()) {
    let lerpValue = easingFunction(interpolationValue);
    return this.quat2_lerp(to, lerpValue, out);
  };
  arrayExtension.mat3_toDegrees = function() {
    let quat3 = quat_create();
    return function mat3_toDegrees(out = vec3_create2()) {
      this.mat3_toQuat(quat3);
      quat3.quat_toDegrees(out);
      return out;
    };
  }();
  arrayExtension.mat3_toRadians = function() {
    let quat3 = quat_create();
    return function mat3_toRadians(out = vec3_create2()) {
      this.mat3_toQuat(quat3);
      quat3.quat_toRadians(out);
      return out;
    };
  }();
  arrayExtension.mat3_toQuat = function mat3_toQuat(out = quat_create()) {
    glMatrix.quat.fromMat3(out, this);
    return out;
  };
  arrayExtension.mat3_fromAxes = function mat3_fromAxes(leftAxis, upAxis, forwardAxis) {
    glMatrix.mat3.set(
      this,
      leftAxis[0],
      leftAxis[1],
      leftAxis[2],
      upAxis[0],
      upAxis[1],
      upAxis[2],
      forwardAxis[0],
      forwardAxis[1],
      forwardAxis[2]
    );
    return this;
  };
  arrayExtension.mat4_copy = function mat4_copy(mat42) {
    glMatrix.mat4.copy(this, mat42);
    return this;
  };
  arrayExtension.mat4_identity = function mat4_identity() {
    glMatrix.mat4.identity(this);
    return this;
  };
  arrayExtension.mat4_invert = function mat4_invert(out = mat4_create()) {
    glMatrix.mat4.invert(out, this);
    return out;
  };
  arrayExtension.mat4_mul = function mat4_mul(mat42, out = mat4_create()) {
    glMatrix.mat4.mul(out, this, mat42);
    return out;
  };
  arrayExtension.mat4_scale = function mat4_scale(vector, out = mat4_create()) {
    glMatrix.mat4.scale(out, this, vector);
    return out;
  };
  arrayExtension.mat4_clone = function mat4_clone(out = mat4_create()) {
    glMatrix.mat4.copy(out, this);
    return out;
  };
  arrayExtension.mat4_getPosition = function mat4_getPosition(out = vec3_create2()) {
    glMatrix.mat4.getTranslation(out, this);
    return out;
  };
  arrayExtension.mat4_getRotation = function mat4_getRotation(out = vec3_create2()) {
    return this.mat4_getRotationDegrees(out);
  };
  arrayExtension.mat4_getRotationDegrees = function() {
    let quat3 = quat_create();
    return function mat4_getRotationDegrees(out = vec3_create2()) {
      this.mat4_getRotationQuat(quat3);
      quat3.quat_toDegrees(out);
      return out;
    };
  }();
  arrayExtension.mat4_getRotationRadians = function() {
    let quat3 = quat_create();
    return function mat4_getRotationRadians(out = vec3_create2()) {
      this.mat4_getRotationQuat(quat3);
      quat3.quat_toRadians(out);
      return out;
    };
  }();
  arrayExtension.mat4_getRotationQuat = function() {
    let scale = vec3_create2();
    let transformMatrixNoScale = mat4_create();
    let inverseScale = vec3_create2();
    let one = vec3_create2();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function mat4_getRotationQuat(out = quat_create()) {
      glMatrix.mat4.getScaling(scale, this);
      glMatrix.vec3.divide(inverseScale, one, scale);
      glMatrix.mat4.scale(transformMatrixNoScale, this, inverseScale);
      glMatrix.mat4.getRotation(out, transformMatrixNoScale);
      glMatrix.quat.normalize(out, out);
      return out;
    };
  }();
  arrayExtension.mat4_getScale = function mat4_getScale(out = vec3_create2()) {
    glMatrix.mat4.getScaling(out, this);
    return out;
  };
  arrayExtension.mat4_setPosition = function mat4_setPosition(position) {
    this[12] = position[0];
    this[13] = position[1];
    this[14] = position[2];
    return this;
  };
  arrayExtension.mat4_setRotation = function mat4_setRotation(rotation) {
    this.mat4_setRotationDegrees(rotation);
    return this;
  };
  arrayExtension.mat4_setRotationDegrees = function() {
    let quat3 = quat_create();
    return function mat4_setRotationDegrees(rotation) {
      this.mat4_setRotationQuat(rotation.vec3_degreesToQuat(quat3));
      return this;
    };
  }();
  arrayExtension.mat4_setRotationRadians = function() {
    let vector = vec3_create2();
    return function mat4_setRotationRadians(rotation) {
      this.mat4_setRotationDegrees(rotation.vec3_toDegrees(vector));
      return this;
    };
  }();
  arrayExtension.mat4_setRotationQuat = function() {
    let position = vec3_create2();
    let scale = vec3_create2();
    return function mat4_setRotationQuat(rotation) {
      this.mat4_getPosition(position);
      this.mat4_getScale(scale);
      this.mat4_setPositionRotationQuatScale(position, rotation, scale);
      return this;
    };
  }();
  arrayExtension.mat4_setScale = function() {
    let tempScale = vec3_create2();
    return function mat4_setScale(scale) {
      glMatrix.mat4.getScaling(tempScale, this);
      glMatrix.vec3.divide(tempScale, scale, tempScale);
      glMatrix.mat4.scale(this, this, tempScale);
      return this;
    };
  }();
  arrayExtension.mat4_setPositionRotationScale = function mat4_setPositionRotationScale(position, rotation, scale) {
    this.mat4_setPositionRotationDegreesScale(position, rotation, scale);
    return this;
  };
  arrayExtension.mat4_setPositionRotationDegreesScale = function() {
    let quat3 = quat_create();
    return function mat4_setPositionRotationDegreesScale(position, rotation, scale) {
      this.mat4_setPositionRotationQuatScale(position, rotation.vec3_degreesToQuat(quat3), scale);
      return this;
    };
  }();
  arrayExtension.mat4_setPositionRotationRadiansScale = function() {
    let vector = vec3_create2();
    return function mat4_setPositionRotationRadiansScale(position, rotation, scale) {
      this.mat4_setPositionRotationDegreesScale(position, rotation.vec3_toDegrees(vector), scale);
      return this;
    };
  }();
  arrayExtension.mat4_setPositionRotationQuatScale = function mat4_setPositionRotationQuatScale(position, rotation, scale) {
    glMatrix.mat4.fromRotationTranslationScale(this, rotation, position, scale);
    return this;
  };
  arrayExtension.mat4_setPositionRotation = function mat4_setPositionRotation(position, rotation) {
    this.mat4_setPositionRotationDegrees(position, rotation);
    return this;
  };
  arrayExtension.mat4_setPositionRotationDegrees = function() {
    let quat3 = quat_create();
    return function mat4_setPositionRotationDegrees(position, rotation) {
      this.mat4_setPositionRotationQuat(position, rotation.vec3_degreesToQuat(quat3));
      return this;
    };
  }();
  arrayExtension.mat4_setPositionRotationRadians = function() {
    let vector = vec3_create2();
    return function mat4_setPositionRotationRadians(position, rotation) {
      this.mat4_setPositionRotationDegrees(position, rotation.vec3_toDegrees(vector));
      return this;
    };
  }();
  arrayExtension.mat4_setPositionRotationQuat = function mat4_setPositionRotationQuat(position, rotation) {
    glMatrix.mat4.fromRotationTranslation(this, rotation, position);
    return this;
  };
  arrayExtension.mat4_getAxes = function mat4_getAxes(out = [vec3_create2(), vec3_create2(), vec3_create2()]) {
    this.mat4_getLeft(out[0]);
    this.mat4_getUp(out[1]);
    this.mat4_getForward(out[2]);
    return out;
  };
  arrayExtension.mat4_getForward = function mat4_getForward(out = vec3_create2()) {
    glMatrix.vec3.set(out, this[8], this[9], this[10]);
    glMatrix.vec3.normalize(out, out);
    return out;
  };
  arrayExtension.mat4_getBackward = function mat4_getBackward(out) {
    out = this.mat4_getForward(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.mat4_getLeft = function mat4_getLeft(out = vec3_create2()) {
    glMatrix.vec3.set(out, this[0], this[1], this[2]);
    glMatrix.vec3.normalize(out, out);
    return out;
  };
  arrayExtension.mat4_getRight = function mat4_getRight(out) {
    out = this.mat4_getLeft(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.mat4_getUp = function mat4_getUp(out = vec3_create2()) {
    glMatrix.vec3.set(out, this[4], this[5], this[6]);
    glMatrix.vec3.normalize(out, out);
    return out;
  };
  arrayExtension.mat4_getDown = function mat4_getDown(out) {
    out = this.mat4_getUp(out);
    out.vec3_negate(out);
    return out;
  };
  arrayExtension.mat4_toWorld = function() {
    let convertTransform = mat4_create();
    let position = vec3_create2();
    let scale = vec3_create2();
    let inverseScale = vec3_create2();
    let one = vec3_create2();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function mat4_toWorld(parentTransformMatrix, out = mat4_create()) {
      if (parentTransformMatrix.mat4_hasUniformScale()) {
        glMatrix.mat4.mul(out, parentTransformMatrix, this);
      } else {
        glMatrix.vec3.set(position, this[12], this[13], this[14]);
        position.vec3_convertPositionToWorldMatrix(parentTransformMatrix, position);
        glMatrix.mat4.getScaling(scale, parentTransformMatrix);
        glMatrix.vec3.divide(inverseScale, one, scale);
        glMatrix.mat4.scale(convertTransform, parentTransformMatrix, inverseScale);
        glMatrix.mat4.mul(out, convertTransform, this);
        glMatrix.mat4.scale(out, out, scale);
        out[12] = position[0];
        out[13] = position[1];
        out[14] = position[2];
        out[15] = 1;
      }
      return out;
    };
  }();
  arrayExtension.mat4_toLocal = function() {
    let convertTransform = mat4_create();
    let position = vec3_create2();
    let scale = vec3_create2();
    let inverseScale = vec3_create2();
    let one = vec3_create2();
    glMatrix.vec3.set(one, 1, 1, 1);
    return function mat4_toLocal(parentTransformMatrix, out = mat4_create()) {
      if (parentTransformMatrix.mat4_hasUniformScale()) {
        glMatrix.mat4.invert(convertTransform, parentTransformMatrix);
        glMatrix.mat4.mul(out, convertTransform, this);
      } else {
        glMatrix.vec3.set(position, this[12], this[13], this[14]);
        position.vec3_convertPositionToLocalMatrix(parentTransformMatrix, position);
        glMatrix.mat4.getScaling(scale, parentTransformMatrix);
        glMatrix.vec3.divide(inverseScale, one, scale);
        glMatrix.mat4.scale(convertTransform, parentTransformMatrix, inverseScale);
        glMatrix.mat4.invert(convertTransform, convertTransform);
        glMatrix.mat4.mul(out, convertTransform, this);
        glMatrix.mat4.scale(out, out, inverseScale);
        out[12] = position[0];
        out[13] = position[1];
        out[14] = position[2];
        out[15] = 1;
      }
      return out;
    };
  }();
  arrayExtension.mat4_hasUniformScale = function() {
    let scale = vec3_create2();
    return function mat4_hasUniformScale() {
      glMatrix.mat4.getScaling(scale, this);
      return Math.abs(scale[0] - scale[1]) < Math.PP_EPSILON && Math.abs(scale[1] - scale[2]) < Math.PP_EPSILON && Math.abs(scale[0] - scale[2]) < Math.PP_EPSILON;
    };
  }();
  arrayExtension.mat4_toQuat = function() {
    let position = vec3_create2();
    let rotation = quat_create();
    return function mat4_toQuat(out = quat2_create()) {
      glMatrix.mat4.getTranslation(position, this);
      this.mat4_getRotationQuat(rotation);
      glMatrix.quat2.fromRotationTranslation(out, rotation, position);
      return out;
    };
  }();
  arrayExtension.mat4_fromQuat = function mat4_fromQuat(quat23) {
    quat23.quat2_toMatrix(this);
    return this;
  };
  let arrayPrototypesToExtend = [
    Array.prototype,
    Uint8ClampedArray.prototype,
    Uint8Array.prototype,
    Uint16Array.prototype,
    Uint32Array.prototype,
    Int8Array.prototype,
    Int16Array.prototype,
    Int32Array.prototype,
    Float32Array.prototype,
    Float64Array.prototype
  ];
  for (let arrayPrototypeToExtend of arrayPrototypesToExtend) {
    ExtensionUtils.assignProperties(arrayExtension, arrayPrototypeToExtend, false, true, true);
  }
}
function _vec_buildConsoleMessage(vector, decimalPlaces) {
  let message = "[";
  for (let i = 0; i < vector.length; i++) {
    if (i != 0) {
      message = message.concat(", ");
    }
    if (decimalPlaces != null) {
      message = message.concat(vector[i].toFixed(decimalPlaces));
    } else {
      message = message.concat(vector[i].toString());
    }
  }
  message = message.concat("]");
  return message;
}
function _vec_prepareOut(vector, out) {
  if (out == null) {
    out = vector.pp_clone();
  } else if (out != vector) {
    out.pp_copy(vector);
  }
  return out;
}
function _findAllEqualOptimized(array, elementToFind, getIndexes) {
  let elementsFound = [];
  let index = -1;
  while ((index = array.indexOf(elementToFind, index + 1)) >= 0) {
    elementsFound.push(getIndexes ? index : array[index]);
  }
  return elementsFound;
}
var _quat_setAxes = function() {
  let fixedAxes = [vec3_create2(), vec3_create2(), vec3_create2()];
  let fixedAxesFixSignMap = [
    [1, -1, 1],
    [1, 1, -1],
    [-1, 1, -1]
  ];
  let fixedLeft = vec3_create2();
  let fixedUp = vec3_create2();
  let fixedForward = vec3_create2();
  let currentAxis = vec3_create2();
  let rotationAxis = vec3_create2();
  let rotationMat = mat3_create();
  let rotationQuat = quat_create();
  return function _quat_setAxes2(vector, axes, priority) {
    let firstAxis = axes[priority[0]];
    let secondAxis = axes[priority[1]];
    let thirdAxis = axes[priority[2]];
    if (firstAxis == null || firstAxis.vec3_isZero(Math.PP_EPSILON)) {
      return;
    }
    let secondAxisValid = false;
    if (secondAxis != null) {
      let angleBetween = firstAxis.vec3_angleRadians(secondAxis);
      if (angleBetween > Math.PP_EPSILON) {
        secondAxisValid = true;
      }
    }
    let thirdAxisValid = false;
    if (thirdAxis != null) {
      let angleBetween = firstAxis.vec3_angleRadians(thirdAxis);
      if (angleBetween > Math.PP_EPSILON) {
        thirdAxisValid = true;
      }
    }
    if (secondAxisValid || thirdAxisValid) {
      let crossAxis = null;
      let secondAxisIndex = null;
      let thirdAxisIndex = null;
      if (secondAxisValid) {
        crossAxis = secondAxis;
        secondAxisIndex = 1;
        thirdAxisIndex = 2;
      } else {
        crossAxis = thirdAxis;
        secondAxisIndex = 2;
        thirdAxisIndex = 1;
      }
      let fixSignMap = fixedAxesFixSignMap[priority[0]];
      glMatrix.vec3.cross(fixedAxes[thirdAxisIndex], firstAxis, crossAxis);
      glMatrix.vec3.scale(fixedAxes[thirdAxisIndex], fixedAxes[thirdAxisIndex], fixSignMap[priority[thirdAxisIndex]]);
      glMatrix.vec3.cross(fixedAxes[secondAxisIndex], firstAxis, fixedAxes[thirdAxisIndex]);
      glMatrix.vec3.scale(fixedAxes[secondAxisIndex], fixedAxes[secondAxisIndex], fixSignMap[priority[secondAxisIndex]]);
      glMatrix.vec3.cross(fixedAxes[0], fixedAxes[1], fixedAxes[2]);
      glMatrix.vec3.scale(fixedAxes[0], fixedAxes[0], fixSignMap[priority[0]]);
      glMatrix.vec3.normalize(fixedLeft, fixedAxes[priority.pp_findIndexEqual(0)]);
      glMatrix.vec3.normalize(fixedUp, fixedAxes[priority.pp_findIndexEqual(1)]);
      glMatrix.vec3.normalize(fixedForward, fixedAxes[priority.pp_findIndexEqual(2)]);
      glMatrix.mat3.set(
        rotationMat,
        fixedLeft[0],
        fixedLeft[1],
        fixedLeft[2],
        fixedUp[0],
        fixedUp[1],
        fixedUp[2],
        fixedForward[0],
        fixedForward[1],
        fixedForward[2]
      );
      glMatrix.quat.fromMat3(rotationQuat, rotationMat);
      glMatrix.quat.normalize(rotationQuat, rotationQuat);
      vector.quat_copy(rotationQuat);
    } else {
      if (priority[0] == 0) {
        vector.quat_getLeft(currentAxis);
      } else if (priority[0] == 1) {
        vector.quat_getUp(currentAxis);
      } else {
        vector.quat_getForward(currentAxis);
      }
      let angleBetween = firstAxis.vec3_angleRadians(currentAxis);
      if (angleBetween > Math.PP_EPSILON) {
        glMatrix.vec3.cross(rotationAxis, currentAxis, firstAxis);
        glMatrix.vec3.normalize(rotationAxis, rotationAxis);
        glMatrix.quat.setAxisAngle(rotationQuat, rotationAxis, angleBetween);
        vector.quat_rotateQuat(rotationQuat, vector);
      }
    }
    return vector;
  };
}();
function _vec2_set(vector, x, y) {
  if (y === void 0) {
    glMatrix.vec2.set(vector, x, x);
  } else {
    glMatrix.vec2.set(vector, x, y);
  }
  return vector;
}
function _vec3_set(vector, x, y, z) {
  if (y === void 0) {
    glMatrix.vec3.set(vector, x, x, x);
  } else {
    glMatrix.vec3.set(vector, x, y, z);
  }
  return vector;
}
function _vec4_set(vector, x, y, z, w) {
  if (y === void 0) {
    glMatrix.vec4.set(vector, x, x, x, x);
  } else {
    glMatrix.vec4.set(vector, x, y, z, w);
  }
  return vector;
}
function _quat_set(vector, x, y, z, w) {
  if (y === void 0) {
    glMatrix.quat.set(vector, x, x, x, x);
  } else {
    glMatrix.quat.set(vector, x, y, z, w);
  }
  return vector;
}
function _quat2_set(vector, x1, y1, z1, w1, x2, y2, z2, w2) {
  if (y1 === void 0) {
    glMatrix.quat2.set(vector, x1, x1, x1, x1, x1, x1, x1, x1);
  } else {
    glMatrix.quat2.set(vector, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return vector;
}
function _mat3_set(vector, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  if (m01 === void 0) {
    glMatrix.mat3.set(
      vector,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00
    );
  } else {
    glMatrix.mat3.set(
      vector,
      m00,
      m01,
      m02,
      m10,
      m11,
      m12,
      m20,
      m21,
      m22
    );
  }
  return vector;
}
function _mat4_set(vector, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  if (m01 === void 0) {
    glMatrix.mat4.set(
      vector,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00
    );
  } else {
    glMatrix.mat4.set(
      vector,
      m00,
      m01,
      m02,
      m03,
      m10,
      m11,
      m12,
      m13,
      m20,
      m21,
      m22,
      m23,
      m30,
      m31,
      m32,
      m33
    );
  }
  return vector;
}

// js/pp/plugin/js/extensions/math_extension.js
function initMathExtension() {
  initMathExtensionStatic();
}
var EasingFunction2 = {
  linear: (t) => t,
  easeIn: (t) => t * t * t,
  easeOut: (t) => (t - 1) * (t - 1) * (t - 1) + 1,
  easeInOut: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
};
function initMathExtensionStatic() {
  let mathExtension = {};
  mathExtension.PP_EPSILON = 1e-6;
  mathExtension.PP_EPSILON_SQUARED = mathExtension.PP_EPSILON * mathExtension.PP_EPSILON;
  mathExtension.PP_EPSILON_DEGREES = 1e-5;
  mathExtension.pp_clamp = function pp_clamp(value, start, end) {
    let fixedStart = start != null ? start : -Number.MAX_VALUE;
    let fixedEnd = end != null ? end : Number.MAX_VALUE;
    let min = Math.min(fixedStart, fixedEnd);
    let max = Math.max(fixedStart, fixedEnd);
    return Math.min(Math.max(value, min), max);
  };
  mathExtension.pp_sign = function pp_sign(value, zeroSign = 1) {
    let sign = Math.sign(value);
    if (sign == 0) {
      sign = Math.sign(zeroSign);
    }
    return sign;
  };
  mathExtension.pp_toDegrees = function pp_toDegrees(angle) {
    return angle * (180 / Math.PI);
  };
  mathExtension.pp_toRadians = function pp_toRadians(angle) {
    return angle * (Math.PI / 180);
  };
  mathExtension.pp_roundDecimal = function pp_roundDecimal(number, decimalPlaces) {
    let factor = Math.pow(10, decimalPlaces);
    number = Math.round(number * factor) / factor;
    return number;
  };
  mathExtension.pp_mapToRange = function pp_mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
    if (originRangeStart == originRangeEnd) {
      return newRangeStart;
    }
    let clampedValue = this.pp_clamp(value, originRangeStart, originRangeEnd);
    if (clampedValue == originRangeStart) {
      return newRangeStart;
    } else if (clampedValue == originRangeEnd) {
      return newRangeEnd;
    }
    let newValue = newRangeStart + (newRangeEnd - newRangeStart) / (originRangeEnd - originRangeStart) * (clampedValue - originRangeStart);
    let clampedNewValue = this.pp_clamp(newValue, newRangeStart, newRangeEnd);
    return clampedNewValue;
  };
  mathExtension.pp_random = function pp_random(start = 0, end = 1) {
    return Math.random() * (end - start) + start;
  };
  mathExtension.pp_randomInt = function pp_randomInt(start, end) {
    let min = Math.min(start, end);
    let max = Math.max(start, end);
    return Math.floor(Math.random() * (max - min + 1) + min);
  };
  mathExtension.pp_randomBool = function pp_randomBool() {
    return this.pp_randomInt(0, 1) == 0;
  };
  mathExtension.pp_randomSign = function pp_randomSign() {
    return Math.random() < 0.5 ? 1 : -1;
  };
  mathExtension.pp_randomPick = function pp_randomPick(...args) {
    let random = null;
    if (args.length > 0) {
      if (args.length == 1 && args[0].length != null) {
        if (args[0].length > 0) {
          let randomIndex = this.pp_randomInt(0, args[0].length - 1);
          random = args[0][randomIndex];
        }
      } else {
        let randomIndex = this.pp_randomInt(0, args.length - 1);
        random = args[randomIndex];
      }
    }
    return random;
  };
  mathExtension.pp_lerp = function pp_lerp(from, to, interpolationValue) {
    if (interpolationValue <= 0) {
      return from;
    } else if (interpolationValue >= 1) {
      return to;
    }
    return interpolationValue * (to - from) + from;
  };
  mathExtension.pp_interpolate = function pp_interpolate(from, to, interpolationValue, easingFunction = EasingFunction2.linear) {
    let lerpValue = easingFunction(interpolationValue);
    return this.pp_lerp(from, to, lerpValue);
  };
  mathExtension.pp_angleDistance = function pp_angleDistance(from, to) {
    return this.pp_angleDistanceDegrees(from, to);
  };
  mathExtension.pp_angleDistanceDegrees = function pp_angleDistanceDegrees(from, to) {
    return Math.abs(this.pp_angleDistanceSignedDegrees(from, to));
  };
  mathExtension.pp_angleDistanceRadians = function pp_angleDistanceRadians(from, to) {
    return Math.abs(this.pp_angleDistanceSignedRadians(from, to));
  };
  mathExtension.pp_angleDistanceSigned = function pp_angleDistanceSigned(from, to) {
    return this.pp_angleDistanceSignedDegrees(from, to);
  };
  mathExtension.pp_angleDistanceSignedDegrees = function pp_angleDistanceSignedDegrees(from, to) {
    let clampedFrom = this.pp_angleClampDegrees(from, true);
    let clampedTo = this.pp_angleClampDegrees(to, true);
    let distance = clampedTo - clampedFrom;
    if (clampedTo - clampedFrom > 180) {
      distance = clampedTo - clampedFrom - 360;
    } else if (clampedTo - clampedFrom < -180) {
      distance = clampedTo - clampedFrom + 360;
    }
    return distance;
  };
  mathExtension.pp_angleDistanceSignedRadians = function pp_angleDistanceSignedRadians(from, to) {
    return this.pp_toRadians(this.pp_angleDistanceSignedDegrees(this.pp_toDegrees(from), this.pp_toDegrees(to)));
  };
  mathExtension.pp_angleClamp = function pp_angleClamp(angle, usePositiveRange = false) {
    return this.pp_angleClampDegrees(angle, usePositiveRange);
  };
  mathExtension.pp_angleClampDegrees = function pp_angleClampDegrees(angle, usePositiveRange = false) {
    let clampedAngle = angle % 360;
    if (clampedAngle < 0) {
      clampedAngle += 360;
    }
    if (!usePositiveRange) {
      if (clampedAngle > 180) {
        clampedAngle -= 360;
      }
    }
    return clampedAngle;
  };
  mathExtension.pp_angleClampRadians = function pp_angleClampRadians(angle, usePositiveRange = false) {
    return this.pp_toRadians(this.pp_angleClampDegrees(this.pp_toDegrees(angle), usePositiveRange));
  };
  mathExtension.pp_isInsideAngleRange = function pp_isInsideAngleRange(angle, start, end, useShortestAngle = false) {
    return this.pp_isInsideAngleRangeDegrees(angle, start, end, useShortestAngle);
  };
  mathExtension.pp_isInsideAngleRangeDegrees = function pp_isInsideAngleRangeDegrees(angle, start, end, useShortestAngle = false) {
    let isInside = false;
    let anglePositive = this.pp_angleClampDegrees(angle, true);
    let startPositive = this.pp_angleClampDegrees(start, true);
    let endPositive = this.pp_angleClampDegrees(end, true);
    if (useShortestAngle) {
      if (this.pp_angleDistanceSignedDegrees(startPositive, endPositive) < 0) {
        let temp = startPositive;
        startPositive = endPositive;
        endPositive = temp;
      }
    }
    if (startPositive < endPositive) {
      isInside = anglePositive >= startPositive && anglePositive <= endPositive;
    } else {
      isInside = anglePositive >= startPositive || anglePositive <= endPositive;
    }
    return isInside;
  };
  mathExtension.pp_isInsideAngleRangeRadians = function pp_isInsideAngleRangeRadians(angle, start, end, useShortestAngle = false) {
    return this.pp_isInsideAngleRangeDegrees(this.pp_toDegrees(angle), this.pp_toDegrees(start), this.pp_toDegrees(end), useShortestAngle);
  };
  ExtensionUtils.assignProperties(mathExtension, Math, false, true, true);
}

// js/pp/plugin/js/extensions/number_extension.js
function initNumberExtension(engine2) {
  initNumberExtensionPrototype();
}
function initNumberExtensionPrototype() {
  let numberExtension = {};
  numberExtension.get = function get() {
    return this.valueOf();
  };
  ExtensionUtils.assignProperties(numberExtension, Number.prototype, false, true, true);
}

// js/pp/plugin/js/extensions/init_js_extentions.js
function initJSExtensions() {
  initMathExtension();
  initArrayExtension();
  initNumberExtension();
}

// js/pp/plugin/js/init_js_plugins.js
function initJSPlugins(engine2) {
  initJSExtensions(engine2);
}

// js/pp/plugin/wl/extensions/object_extension.js
import { Object as WLObject } from "@wonderlandengine/api";
function initObjectExtension() {
  initObjectExtensionProtoype();
}
function getComponentObjects(objects, type2, index = 0) {
  let component = null;
  for (let object of objects) {
    component = object.getComponent(type2, index);
    if (component != null) {
      break;
    }
  }
  return component;
}
function getComponentsObjects(objects, type2) {
  let components = [];
  for (let object of objects) {
    components.push(...object.getComponents(type2));
  }
  return components;
}
function setActiveObjects(objects, active) {
  for (let object of objects) {
    object.active = active;
  }
}
function getObjectByNameObjects(objects, name, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (let object of objects) {
    if (object.pp_getName() == name) {
      if (currentIndex == 0) {
        objectFound = object;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByNameObjects(objects, name) {
  let objectsFound = [];
  for (let object of objects) {
    if (object.pp_getName() == name) {
      objectsFound.push(object);
    }
  }
  return objectsFound;
}
function getObjectByIDObjects(objects, id, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (let object of objects) {
    if (object.pp_getID() == id) {
      if (currentIndex == 0) {
        objectFound = object;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByIDObjects(objects, id) {
  let objectsFound = [];
  for (let object of objects) {
    if (object.pp_getID() == id) {
      objectsFound.push(object);
    }
  }
  return objectsFound;
}
var CloneParams = class {
  constructor() {
    this.myIgnoreNonCloneable = false;
    this.myIgnoreComponents = false;
    this.myIgnoreChildren = false;
    this.myComponentsToIgnore = [];
    this.myComponentsToInclude = [];
    this.myIgnoreComponentCallback = null;
    this.myChildrenToIgnore = [];
    this.myChildrenToInclude = [];
    this.myIgnoreChildCallback = null;
    this.myUseWLClone = false;
    this.myUseWLCloneAsFallback = false;
    this.myDeepCloneParams = new DeepCloneParams();
    this.myCustomCloneParams = new CustomCloneParams();
  }
};
var DeepCloneParams = class {
  constructor() {
    this._myDeepCloneObject = false;
    this._myOverrideDeepCloneComponentsMap = /* @__PURE__ */ new Map();
    this._myOverrideDeepCloneComponentsVariablesMap = /* @__PURE__ */ new Map();
  }
  setDeepCloneObject(deepClone) {
    this._myDeepCloneObject = deepClone;
  }
  setDeepCloneComponent(componentName, deepClone) {
    this._myOverrideDeepCloneComponentsMap.set(componentName, deepClone);
  }
  setDeepCloneComponentVariable(componentName, variableName, deepClone) {
    let componentsVariablesMap = null;
    if (!this._myOverrideDeepCloneComponentsVariablesMap.has(componentName)) {
      this._myOverrideDeepCloneComponentsVariablesMap.set(componentName, /* @__PURE__ */ new Map());
    }
    componentsVariablesMap = this._myOverrideDeepCloneComponentsVariablesMap.get(componentName);
    componentsVariablesMap.set(variableName, deepClone);
  }
  isDeepCloneComponent(componentName) {
    let overrideValue = this._myOverrideDeepCloneComponentsMap.get(componentName);
    if (overrideValue != null) {
      return overrideValue;
    }
    return this._myDeepCloneObject;
  }
  isDeepCloneComponentVariable(componentName, variableName) {
    let componentsVariablesMap = this._myOverrideDeepCloneComponentsVariablesMap.get(componentName);
    if (componentsVariablesMap != null) {
      let overrideValue = componentsVariablesMap.get(variableName);
      if (overrideValue != null) {
        return overrideValue;
      }
    }
    return this.isDeepCloneComponent(componentName);
  }
};
var CustomCloneParams = class {
  constructor() {
    this._myParams = /* @__PURE__ */ new Map();
  }
  addParam(name, value) {
    this._myParams.set(name, value);
  }
  removeParam(name) {
    this._myParams.delete(name);
  }
  getParam(name) {
    this._myParams.get(name);
  }
  hasParam(name) {
    this._myParams.has(name);
  }
};
function initObjectExtensionProtoype() {
  let objectExtension = {};
  objectExtension.pp_getPosition = function pp_getPosition(position) {
    return this.pp_getPositionWorld(position);
  };
  objectExtension.pp_getPositionWorld = function pp_getPositionWorld(position = vec3_create2()) {
    this.getTranslationWorld(position);
    return position;
  };
  objectExtension.pp_getPositionLocal = function pp_getPositionLocal(position = vec3_create2()) {
    this.getTranslationLocal(position);
    return position;
  };
  objectExtension.pp_getRotation = function pp_getRotation(rotation) {
    return this.pp_getRotationWorld(rotation);
  };
  objectExtension.pp_getRotationDegrees = function pp_getRotationDegrees(rotation) {
    return this.pp_getRotationWorldDegrees(rotation);
  };
  objectExtension.pp_getRotationRadians = function pp_getRotationRadians(rotation) {
    return this.pp_getRotationWorldRadians(rotation);
  };
  objectExtension.pp_getRotationMatrix = function pp_getRotationMatrix(rotation) {
    return this.pp_getRotationWorldMatrix(rotation);
  };
  objectExtension.pp_getRotationQuat = function pp_getRotationQuat(rotation) {
    return this.pp_getRotationWorldQuat(rotation);
  };
  objectExtension.pp_getRotationWorld = function pp_getRotationWorld(rotation) {
    return this.pp_getRotationWorldDegrees(rotation);
  };
  objectExtension.pp_getRotationWorldDegrees = function pp_getRotationWorldDegrees(rotation) {
    rotation = this.pp_getRotationWorldRadians(rotation);
    rotation.forEach(function(value, index, array) {
      array[index] = Math.pp_toDegrees(value);
    }.bind(this));
    return rotation;
  };
  objectExtension.pp_getRotationWorldRadians = function() {
    let quat3 = quat_create();
    return function pp_getRotationWorldRadians(rotation = vec3_create2()) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_toRadians(rotation);
      return rotation;
    };
  }();
  objectExtension.pp_getRotationWorldMatrix = function() {
    let quat3 = quat_create();
    return function pp_getRotationWorldMatrix(rotation = mat3_create()) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_toMatrix(rotation);
      return rotation;
    };
  }();
  objectExtension.pp_getRotationWorldQuat = function pp_getRotationWorldQuat(rotation = quat_create()) {
    rotation.quat_copy(this.rotationWorld);
    return rotation;
  };
  objectExtension.pp_getRotationLocal = function pp_getRotationLocal(rotation) {
    return this.pp_getRotationLocalDegrees(rotation);
  };
  objectExtension.pp_getRotationLocalDegrees = function pp_getRotationLocalDegrees(rotation) {
    rotation = this.pp_getRotationLocalRadians(rotation);
    rotation.forEach(function(value, index, array) {
      array[index] = Math.pp_toDegrees(value);
    }.bind(this));
    return rotation;
  };
  objectExtension.pp_getRotationLocalRadians = function() {
    let quat3 = quat_create();
    return function pp_getRotationLocalRadians(rotation = vec3_create2()) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_toRadians(rotation);
      return rotation;
    };
  }();
  objectExtension.pp_getRotationLocalMatrix = function() {
    let quat3 = quat_create();
    return function pp_getRotationLocalMatrix(rotation = mat3_create()) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_toMatrix(rotation);
      return rotation;
    };
  }();
  objectExtension.pp_getRotationLocalQuat = function pp_getRotationLocalQuat(rotation = quat_create()) {
    rotation.quat_copy(this.rotationLocal);
    return rotation;
  };
  objectExtension.pp_getScale = function pp_getScale(scale) {
    return this.pp_getScaleWorld(scale);
  };
  objectExtension.pp_getScaleWorld = function pp_getScaleWorld(scale = vec3_create2()) {
    scale.vec3_copy(this.scalingWorld);
    return scale;
  };
  objectExtension.pp_getScaleLocal = function pp_getScaleLocal(scale = vec3_create2()) {
    scale.vec3_copy(this.scalingLocal);
    return scale;
  };
  objectExtension.pp_getTransform = function pp_getTransform(transform) {
    return this.pp_getTransformWorld(transform);
  };
  objectExtension.pp_getTransformMatrix = function pp_getTransformMatrix(transform) {
    return this.pp_getTransformWorldMatrix(transform);
  };
  objectExtension.pp_getTransformQuat = function pp_getTransformQuat(transform) {
    return this.pp_getTransformWorldQuat(transform);
  };
  objectExtension.pp_getTransformWorld = function pp_getTransformWorld(transform) {
    return this.pp_getTransformWorldMatrix(transform);
  };
  objectExtension.pp_getTransformWorldMatrix = function() {
    let transformQuat = quat2_create();
    let scale = vec3_create2();
    return function pp_getTransformWorldMatrix(transform = mat4_create()) {
      this.pp_getTransformWorldQuat(transformQuat);
      this.pp_getScaleWorld(scale);
      transform.mat4_fromQuat(transformQuat);
      transform.mat4_scale(scale, transform);
      return transform;
    };
  }();
  objectExtension.pp_getTransformWorldQuat = function pp_getTransformWorldQuat(transform = quat2_create()) {
    transform.quat2_copy(this.transformWorld);
    return transform;
  };
  objectExtension.pp_getTransformLocal = function(transform) {
    return this.pp_getTransformLocalMatrix(transform);
  };
  objectExtension.pp_getTransformLocalMatrix = function pp_getTransformLocalMatrix() {
    let transformQuat = quat2_create();
    let scale = vec3_create2();
    return function pp_getTransformLocalMatrix2(transform = mat4_create()) {
      this.pp_getTransformLocalQuat(transformQuat);
      this.pp_getScaleLocal(scale);
      transform.mat4_fromQuat(transformQuat);
      transform.mat4_scale(scale, transform);
      return transform;
    };
  }();
  objectExtension.pp_getTransformLocalQuat = function pp_getTransformLocalQuat(transform = quat2_create()) {
    transform.quat2_copy(this.transformLocal);
    return transform;
  };
  objectExtension.pp_getAxes = function pp_getAxes(axes) {
    return this.pp_getAxesWorld(axes);
  };
  objectExtension.pp_getAxesWorld = function pp_getAxesWorld(axes = [vec3_create2(), vec3_create2(), vec3_create2()]) {
    this.pp_getLeftWorld(axes[0]);
    this.pp_getUpWorld(axes[1]);
    this.pp_getForwardWorld(axes[2]);
    return axes;
  };
  objectExtension.pp_getAxesLocal = function pp_getAxesLocal(axes = [vec3_create2(), vec3_create2(), vec3_create2()]) {
    this.pp_getLeftLocal(axes[0]);
    this.pp_getUpLocal(axes[1]);
    this.pp_getForwardLocal(axes[2]);
    return axes;
  };
  objectExtension.pp_getForward = function pp_getForward(forward) {
    return this.pp_getForwardWorld(forward);
  };
  objectExtension.pp_getForwardWorld = function() {
    let rotation = mat3_create();
    return function pp_getForwardWorld(forward = vec3_create2()) {
      this.pp_getRotationWorldMatrix(rotation);
      forward[0] = rotation[6];
      forward[1] = rotation[7];
      forward[2] = rotation[8];
      return forward;
    };
  }();
  objectExtension.pp_getForwardLocal = function() {
    let rotation = mat3_create();
    return function pp_getForwardLocal(forward = vec3_create2()) {
      this.pp_getRotationLocalMatrix(rotation);
      forward[0] = rotation[6];
      forward[1] = rotation[7];
      forward[2] = rotation[8];
      return forward;
    };
  }();
  objectExtension.pp_getBackward = function pp_getBackward(backward) {
    return this.pp_getBackwardWorld(backward);
  };
  objectExtension.pp_getBackwardWorld = function() {
    let rotation = mat3_create();
    return function pp_getBackwardWorld(backward = vec3_create2()) {
      this.pp_getRotationWorldMatrix(rotation);
      backward[0] = -rotation[6];
      backward[1] = -rotation[7];
      backward[2] = -rotation[8];
      return backward;
    };
  }();
  objectExtension.pp_getBackwardLocal = function() {
    let rotation = mat3_create();
    return function pp_getBackwardLocal(backward = vec3_create2()) {
      this.pp_getRotationLocalMatrix(rotation);
      backward[0] = -rotation[6];
      backward[1] = -rotation[7];
      backward[2] = -rotation[8];
      return backward;
    };
  }();
  objectExtension.pp_getUp = function pp_getUp(up) {
    return this.pp_getUpWorld(up);
  };
  objectExtension.pp_getUpWorld = function() {
    let rotation = mat3_create();
    return function pp_getUpWorld(up = vec3_create2()) {
      this.pp_getRotationWorldMatrix(rotation);
      up[0] = rotation[3];
      up[1] = rotation[4];
      up[2] = rotation[5];
      return up;
    };
  }();
  objectExtension.pp_getUpLocal = function() {
    let rotation = mat3_create();
    return function pp_getUpLocal(up = vec3_create2()) {
      this.pp_getRotationLocalMatrix(rotation);
      up[0] = rotation[3];
      up[1] = rotation[4];
      up[2] = rotation[5];
      return up;
    };
  }();
  objectExtension.pp_getDown = function pp_getDown(down) {
    return this.pp_getDownWorld(down);
  };
  objectExtension.pp_getDownWorld = function() {
    let rotation = mat3_create();
    return function pp_getDownWorld(down = vec3_create2()) {
      this.pp_getRotationWorldMatrix(rotation);
      down[0] = -rotation[3];
      down[1] = -rotation[4];
      down[2] = -rotation[5];
      return down;
    };
  }();
  objectExtension.pp_getDownLocal = function() {
    let rotation = mat3_create();
    return function pp_getDownLocal(down = vec3_create2()) {
      this.pp_getRotationLocalMatrix(rotation);
      down[0] = -rotation[3];
      down[1] = -rotation[4];
      down[2] = -rotation[5];
      return down;
    };
  }();
  objectExtension.pp_getLeft = function pp_getLeft(left) {
    return this.pp_getLeftWorld(left);
  };
  objectExtension.pp_getLeftWorld = function() {
    let rotation = mat3_create();
    return function pp_getLeftWorld(left = vec3_create2()) {
      this.pp_getRotationWorldMatrix(rotation);
      left[0] = rotation[0];
      left[1] = rotation[1];
      left[2] = rotation[2];
      return left;
    };
  }();
  objectExtension.pp_getLeftLocal = function() {
    let rotation = mat3_create();
    return function pp_getLeftLocal(left = vec3_create2()) {
      this.pp_getRotationLocalMatrix(rotation);
      left[0] = rotation[0];
      left[1] = rotation[1];
      left[2] = rotation[2];
      return left;
    };
  }();
  objectExtension.pp_getRight = function pp_getRight(right) {
    return this.pp_getRightWorld(right);
  };
  objectExtension.pp_getRightWorld = function() {
    let rotation = mat3_create();
    return function pp_getRightWorld(right = vec3_create2()) {
      this.pp_getRotationWorldMatrix(rotation);
      right[0] = -rotation[0];
      right[1] = -rotation[1];
      right[2] = -rotation[2];
      return right;
    };
  }();
  objectExtension.pp_getRightLocal = function() {
    let rotation = mat3_create();
    return function pp_getRightLocal(right = vec3_create2()) {
      this.pp_getRotationLocalMatrix(rotation);
      right[0] = -rotation[0];
      right[1] = -rotation[1];
      right[2] = -rotation[2];
      return right;
    };
  }();
  objectExtension.pp_setPosition = function pp_setPosition(position) {
    this.pp_setPositionWorld(position);
  };
  objectExtension.pp_setPositionWorld = function pp_setPositionWorld(position) {
    this.setTranslationWorld(position);
  };
  objectExtension.pp_setPositionLocal = function pp_setPositionLocal(position) {
    this.setTranslationLocal(position);
  };
  objectExtension.pp_setRotation = function pp_setRotation(rotation) {
    this.pp_setRotationWorld(rotation);
  };
  objectExtension.pp_setRotationDegrees = function pp_setRotationDegrees(rotation) {
    this.pp_setRotationWorldDegrees(rotation);
  };
  objectExtension.pp_setRotationRadians = function pp_setRotationRadians(rotation) {
    this.pp_setRotationWorldRadians(rotation);
  };
  objectExtension.pp_setRotationMatrix = function pp_setRotationMatrix(rotation) {
    this.pp_setRotationWorldMatrix(rotation);
  };
  objectExtension.pp_setRotationQuat = function pp_setRotationQuat(rotation) {
    this.pp_setRotationWorldQuat(rotation);
  };
  objectExtension.pp_setRotationWorld = function pp_setRotationWorld(rotation) {
    this.pp_setRotationWorldDegrees(rotation);
  };
  objectExtension.pp_setRotationWorldDegrees = function() {
    let quat3 = quat_create();
    return function pp_setRotationWorldDegrees(rotation) {
      rotation.vec3_degreesToQuat(quat3);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setRotationWorldRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_setRotationWorldRadians(rotation) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_setRotationWorldDegrees(degreesRotation);
    };
  }();
  objectExtension.pp_setRotationWorldMatrix = function() {
    let quat3 = quat_create();
    return function pp_setRotationWorldMatrix(rotation) {
      rotation.mat3_toQuat(quat3);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setRotationWorldQuat = function pp_setRotationWorldQuat(rotation) {
    this.rotationWorld = rotation;
  };
  objectExtension.pp_setRotationLocal = function pp_setRotationLocal(rotation) {
    this.pp_setRotationLocalDegrees(rotation);
  };
  objectExtension.pp_setRotationLocalDegrees = function() {
    let quat3 = quat_create();
    return function pp_setRotationLocalDegrees(rotation) {
      rotation.vec3_degreesToQuat(quat3);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setRotationLocalRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_setRotationLocalRadians(rotation) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_setRotationLocalDegrees(degreesRotation);
    };
  }();
  objectExtension.pp_setRotationLocalMatrix = function() {
    let quat3 = quat_create();
    return function pp_setRotationLocalMatrix(rotation) {
      rotation.mat3_toQuat(quat3);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setRotationLocalQuat = function pp_setRotationLocalQuat(rotation) {
    this.rotationLocal = rotation;
  };
  objectExtension.pp_setScale = function pp_setScale(scale) {
    this.pp_setScaleWorld(scale);
  };
  objectExtension.pp_setScaleWorld = function() {
    let vector = vec3_create2();
    return function pp_setScaleWorld(scale) {
      if (isNaN(scale)) {
        this.scalingWorld = scale;
      } else {
        vector.vec3_set(scale);
        this.scalingWorld = vector;
      }
    };
  }();
  objectExtension.pp_setScaleLocal = function() {
    let vector = vec3_create2();
    return function pp_setScaleLocal(scale) {
      if (isNaN(scale)) {
        this.scalingLocal = scale;
      } else {
        vector.vec3_set(scale);
        this.scalingLocal = vector;
      }
    };
  }();
  objectExtension.pp_setAxes = function pp_setAxes(left, up, forward) {
    this.pp_setAxesWorld(left, up, forward);
  };
  objectExtension.pp_setAxesWorld = function pp_setAxesWorld(left, up, forward) {
    if (forward != null) {
      this.pp_setForwardWorld(forward, up, left);
    } else if (up != null) {
      this.pp_setUpWorld(up, forward, left);
    } else {
      this.pp_setLeftWorld(left, up, forward);
    }
  };
  objectExtension.pp_setAxesLocal = function pp_setAxesLocal(left, up, forward) {
    if (forward != null) {
      this.pp_setForwardLocal(forward, up, left);
    } else if (up != null) {
      this.pp_setUpLocal(up, forward, left);
    } else {
      this.pp_setLeftLocal(left, up, forward);
    }
  };
  objectExtension.pp_setForward = function pp_setForward(forward, up, left) {
    this.pp_setForwardWorld(forward, up, left);
  };
  objectExtension.pp_setForwardWorld = function() {
    let quat3 = quat_create();
    return function pp_setForwardWorld(forward, up = null, left = null) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_setForward(forward, up, left);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setForwardLocal = function() {
    let quat3 = quat_create();
    return function pp_setForwardLocal(forward, up = null, left = null) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_setForward(forward, up, left);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setBackward = function pp_setBackward(backward, up, left) {
    this.pp_setBackwardWorld(backward, up, left);
  };
  objectExtension.pp_setBackwardWorld = function() {
    let quat3 = quat_create();
    return function pp_setBackwardWorld(backward, up = null, left = null) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_setBackward(backward, up, left);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setBackwardLocal = function() {
    let quat3 = quat_create();
    return function pp_setBackwardLocal(backward, up = null, left = null) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_setBackward(backward, up, left);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setUp = function pp_setUp(up, forward, left) {
    this.pp_setUpWorld(up, forward, left);
  };
  objectExtension.pp_setUpWorld = function() {
    let quat3 = quat_create();
    return function pp_setUpWorld(up, forward = null, left = null) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_setUp(up, forward, left);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setUpLocal = function() {
    let quat3 = quat_create();
    return function pp_setUpLocal(up, forward = null, left = null) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_setUp(up, forward, left);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setDown = function pp_setDown(down, forward, left) {
    this.pp_setDownWorld(down, forward, left);
  };
  objectExtension.pp_setDownWorld = function() {
    let quat3 = quat_create();
    return function pp_setDownWorld(down, forward = null, left = null) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_setDown(down, forward, left);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setDownLocal = function() {
    let quat3 = quat_create();
    return function pp_setDownLocal(down, forward = null, left = null) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_setDown(down, forward, left);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setLeft = function pp_setLeft(left, up, forward) {
    this.pp_setLeftWorld(left, up, forward);
  };
  objectExtension.pp_setLeftWorld = function() {
    let quat3 = quat_create();
    return function pp_setLeftWorld(left, up = null, forward = null) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_setLeft(left, up, forward);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setLeftLocal = function() {
    let quat3 = quat_create();
    return function pp_setLeftLocal(left, up = null, forward = null) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_setLeft(left, up, forward);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setRight = function pp_setRight(right, up, forward) {
    this.pp_setRightWorld(right, up, forward);
  };
  objectExtension.pp_setRightWorld = function() {
    let quat3 = quat_create();
    return function pp_setRightWorld(right, up = null, forward = null) {
      this.pp_getRotationWorldQuat(quat3);
      quat3.quat_setRight(right, up, forward);
      this.pp_setRotationWorldQuat(quat3);
    };
  }();
  objectExtension.pp_setRightLocal = function() {
    let quat3 = quat_create();
    return function pp_setRightLocal(right, up = null, forward = null) {
      this.pp_getRotationLocalQuat(quat3);
      quat3.quat_setRight(right, up, forward);
      this.pp_setRotationLocalQuat(quat3);
    };
  }();
  objectExtension.pp_setTransform = function pp_setTransform(transform) {
    this.pp_setTransformWorld(transform);
  };
  objectExtension.pp_setTransformMatrix = function pp_setTransformMatrix(transform) {
    this.pp_setTransformWorldMatrix(transform);
  };
  objectExtension.pp_setTransformQuat = function pp_setTransformQuat(transform) {
    this.pp_setTransformWorldQuat(transform);
  };
  objectExtension.pp_setTransformWorld = function pp_setTransformWorld(transform) {
    return this.pp_setTransformWorldMatrix(transform);
  };
  objectExtension.pp_setTransformWorldMatrix = function() {
    let position = vec3_create2();
    let rotation = quat_create();
    let scale = vec3_create2();
    let transformMatrixNoScale = mat4_create();
    let inverseScale = vec3_create2();
    let one = vec3_create2(1);
    return function pp_setTransformWorldMatrix(transform) {
      transform.mat4_getPosition(position);
      transform.mat4_getScale(scale);
      one.vec3_div(scale, inverseScale);
      transform.mat4_scale(inverseScale, transformMatrixNoScale);
      transformMatrixNoScale.mat4_getRotationQuat(rotation);
      rotation.quat_normalize(rotation);
      this.pp_setScaleWorld(scale);
      this.pp_setRotationWorldQuat(rotation);
      this.pp_setPositionWorld(position);
    };
  }();
  objectExtension.pp_setTransformWorldQuat = function pp_setTransformWorldQuat(transform) {
    this.transformWorld = transform;
  };
  objectExtension.pp_setTransformLocal = function pp_setTransformLocal(transform) {
    return this.pp_setTransformLocalMatrix(transform);
  };
  objectExtension.pp_setTransformLocalMatrix = function() {
    let position = vec3_create2();
    let rotation = quat_create();
    let scale = vec3_create2();
    let transformMatrixNoScale = mat4_create();
    let inverseScale = vec3_create2();
    let one = vec3_create2(1);
    return function pp_setTransformLocalMatrix(transform) {
      transform.mat4_getPosition(position);
      transform.mat4_getScale(scale);
      one.vec3_div(scale, inverseScale);
      transform.mat4_scale(inverseScale, transformMatrixNoScale);
      transformMatrixNoScale.mat4_getRotationQuat(rotation);
      rotation.quat_normalize(rotation);
      this.pp_setScaleLocal(scale);
      this.pp_setRotationLocalQuat(rotation);
      this.pp_setPositionLocal(position);
    };
  }();
  objectExtension.pp_setTransformLocalQuat = function pp_setTransformLocalQuat(transform) {
    this.transformLocal = transform;
  };
  objectExtension.pp_resetPosition = function pp_resetPosition() {
    this.pp_resetPositionWorld();
  };
  objectExtension.pp_resetPositionWorld = function() {
    let zero = vec3_create2();
    return function pp_resetPositionWorld() {
      this.pp_setPositionWorld(zero);
    };
  }();
  objectExtension.pp_resetPositionLocal = function() {
    let zero = vec3_create2();
    return function pp_resetPositionLocal() {
      this.pp_setPositionLocal(zero);
    };
  }();
  objectExtension.pp_resetRotation = function pp_resetRotation() {
    this.pp_resetRotationWorld();
  };
  objectExtension.pp_resetRotationWorld = function() {
    let identity = quat_create();
    return function pp_resetRotationWorld() {
      this.pp_setRotationWorldQuat(identity);
    };
  }();
  objectExtension.pp_resetRotationLocal = function() {
    let identity = quat_create();
    return function pp_resetRotationLocal() {
      this.pp_setRotationLocalQuat(identity);
    };
  }();
  objectExtension.pp_resetScale = function pp_resetScale() {
    this.pp_resetScaleWorld();
  };
  objectExtension.pp_resetScaleWorld = function() {
    let one = vec3_create2(1);
    return function pp_resetScaleWorld() {
      this.pp_setScaleWorld(one);
    };
  }();
  objectExtension.pp_resetScaleLocal = function() {
    let one = vec3_create2(1);
    return function pp_resetScaleLocal() {
      this.pp_setScaleLocal(one);
    };
  }();
  objectExtension.pp_resetTransform = function pp_resetTransform() {
    this.pp_resetTransformWorld();
  };
  objectExtension.pp_resetTransformWorld = function pp_resetTransformWorld() {
    this.pp_resetScaleWorld();
    this.pp_resetRotationWorld();
    this.pp_resetPositionWorld();
  };
  objectExtension.pp_resetTransformLocal = function pp_resetTransformLocal() {
    this.pp_resetScaleLocal();
    this.pp_resetRotationLocal();
    this.pp_resetPositionLocal();
  };
  objectExtension.pp_translate = function pp_translate(translation) {
    this.pp_translateWorld(translation);
  };
  objectExtension.pp_translateWorld = function pp_translateWorld(translation) {
    this.translateWorld(translation);
  };
  objectExtension.pp_translateLocal = function pp_translateLocal(translation) {
    this.translate(translation);
  };
  objectExtension.pp_translateObject = function pp_translateObject(translation) {
    this.translateObject(translation);
  };
  objectExtension.pp_translateAxis = function pp_translateAxis(amount, direction) {
    this.pp_translateAxisWorld(amount, direction);
  };
  objectExtension.pp_translateAxisWorld = function() {
    let translation = vec3_create2();
    return function pp_translateAxisWorld(amount, direction) {
      direction.vec3_scale(amount, translation);
      this.pp_translateWorld(translation);
    };
  }();
  objectExtension.pp_translateAxisLocal = function() {
    let translation = vec3_create2();
    return function pp_translateAxisLocal(amount, direction) {
      direction.vec3_scale(amount, translation);
      this.pp_translateLocal(translation);
    };
  }();
  objectExtension.pp_translateAxisObject = function() {
    let translation = vec3_create2();
    return function pp_translateAxisObject(amount, direction) {
      direction.vec3_scale(amount, translation);
      this.pp_translateObject(translation);
    };
  }();
  objectExtension.pp_rotate = function pp_rotate(rotation) {
    this.pp_rotateWorld(rotation);
  };
  objectExtension.pp_rotateDegrees = function pp_rotateDegrees(rotation) {
    this.pp_rotateWorldDegrees(rotation);
  };
  objectExtension.pp_rotateRadians = function pp_rotateRadians(rotation) {
    this.pp_rotateWorldRadians(rotation);
  };
  objectExtension.pp_rotateMatrix = function pp_rotateMatrix(rotation) {
    this.pp_rotateWorldMatrix(rotation);
  };
  objectExtension.pp_rotateQuat = function pp_rotateQuat(rotation) {
    this.pp_rotateWorldQuat(rotation);
  };
  objectExtension.pp_rotateWorld = function pp_rotateWorld(rotation) {
    this.pp_rotateWorldDegrees(rotation);
  };
  objectExtension.pp_rotateWorldDegrees = function() {
    let rotationQuat = quat_create();
    return function pp_rotateWorldDegrees(rotation) {
      rotation.vec3_degreesToQuat(rotationQuat);
      this.pp_rotateWorldQuat(rotationQuat);
    };
  }();
  objectExtension.pp_rotateWorldRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_rotateWorldRadians(rotation) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_rotateWorldDegrees(degreesRotation);
    };
  }();
  objectExtension.pp_rotateWorldMatrix = function() {
    let rotationQuat = quat_create();
    return function pp_rotateWorldMatrix(rotation) {
      rotation.mat3_toQuat(rotationQuat);
      rotationQuat.quat_normalize(rotationQuat);
      this.pp_rotateWorldQuat(rotationQuat);
    };
  }();
  objectExtension.pp_rotateWorldQuat = function() {
    let currentRotationQuat = quat_create();
    return function pp_rotateWorldQuat(rotation) {
      this.pp_getRotationWorldQuat(currentRotationQuat);
      rotation.quat_mul(currentRotationQuat, currentRotationQuat);
      currentRotationQuat.quat_normalize(currentRotationQuat);
      this.pp_setRotationWorldQuat(currentRotationQuat);
    };
  }();
  objectExtension.pp_rotateLocal = function pp_rotateLocal(rotation) {
    this.pp_rotateLocalDegrees(rotation);
  };
  objectExtension.pp_rotateLocalDegrees = function() {
    let rotationQuat = quat_create();
    return function pp_rotateLocalDegrees(rotation) {
      rotation.vec3_degreesToQuat(rotationQuat);
      this.pp_rotateLocalQuat(rotationQuat);
    };
  }();
  objectExtension.pp_rotateLocalRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_rotateLocalRadians(rotation) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_rotateLocalDegrees(degreesRotation);
    };
  }();
  objectExtension.pp_rotateLocalMatrix = function() {
    let rotationQuat = quat_create();
    return function pp_rotateLocalMatrix(rotation) {
      rotation.mat3_toQuat(rotationQuat);
      rotationQuat.quat_normalize(rotationQuat);
      this.pp_rotateLocalQuat(rotationQuat);
    };
  }();
  objectExtension.pp_rotateLocalQuat = function() {
    let currentRotationQuat = quat_create();
    return function pp_rotateLocalQuat(rotation) {
      this.pp_getRotationLocalQuat(currentRotationQuat);
      rotation.quat_mul(currentRotationQuat, currentRotationQuat);
      currentRotationQuat.quat_normalize(currentRotationQuat);
      this.pp_setRotationLocalQuat(currentRotationQuat);
    };
  }();
  objectExtension.pp_rotateObject = function pp_rotateObject(rotation) {
    this.pp_rotateObjectDegrees(rotation);
  };
  objectExtension.pp_rotateObjectDegrees = function() {
    let rotationQuat = quat_create();
    return function pp_rotateObjectDegrees(rotation) {
      rotation.vec3_degreesToQuat(rotationQuat);
      this.pp_rotateObjectQuat(rotationQuat);
    };
  }();
  objectExtension.pp_rotateObjectRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_rotateObjectRadians(rotation) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_rotateObjectDegrees(degreesRotation);
    };
  }();
  objectExtension.pp_rotateObjectMatrix = function() {
    let rotationQuat = quat_create();
    return function pp_rotateObjectMatrix(rotation) {
      rotation.mat3_toQuat(rotationQuat);
      rotationQuat.quat_normalize(rotationQuat);
      this.pp_rotateObjectQuat(rotationQuat);
    };
  }();
  objectExtension.pp_rotateObjectQuat = function pp_rotateObjectQuat(rotation) {
    this.rotateObject(rotation);
  };
  objectExtension.pp_rotateAxis = function pp_rotateAxis(angle, axis) {
    this.pp_rotateAxisWorld(angle, axis);
  };
  objectExtension.pp_rotateAxisDegrees = function pp_rotateAxisDegrees(angle, axis) {
    this.pp_rotateAxisWorldDegrees(angle, axis);
  };
  objectExtension.pp_rotateAxisRadians = function pp_rotateAxisRadians(angle, axis) {
    this.pp_rotateAxisWorldRadians(angle, axis);
  };
  objectExtension.pp_rotateAxisWorld = function pp_rotateAxisWorld(angle, axis) {
    this.pp_rotateAxisWorldDegrees(angle, axis);
  };
  objectExtension.pp_rotateAxisWorldDegrees = function pp_rotateAxisWorldDegrees(angle, axis) {
    this.pp_rotateAxisWorldRadians(Math.pp_toRadians(angle), axis);
  };
  objectExtension.pp_rotateAxisWorldRadians = function() {
    let rotation = quat_create();
    return function pp_rotateAxisWorldRadians(angle, axis) {
      rotation.quat_fromAxisRadians(angle, axis);
      this.pp_rotateWorldQuat(rotation);
    };
  }();
  objectExtension.pp_rotateAxisLocal = function pp_rotateAxisLocal(angle, axis) {
    this.pp_rotateAxisLocalDegrees(angle, axis);
  };
  objectExtension.pp_rotateAxisLocalDegrees = function pp_rotateAxisLocalDegrees(angle, axis) {
    this.pp_rotateAxisLocalRadians(Math.pp_toRadians(angle), axis);
  };
  objectExtension.pp_rotateAxisLocalRadians = function() {
    let rotation = quat_create();
    return function pp_rotateAxisLocalRadians(angle, axis) {
      rotation.quat_fromAxisRadians(angle, axis);
      this.pp_rotateLocalQuat(rotation);
    };
  }();
  objectExtension.pp_rotateAxisObject = function pp_rotateAxisObject(angle, axis) {
    this.pp_rotateAxisObjectDegrees(angle, axis);
  };
  objectExtension.pp_rotateAxisObjectDegrees = function pp_rotateAxisObjectDegrees(angle, axis) {
    this.pp_rotateAxisObjectRadians(Math.pp_toRadians(angle), axis);
  };
  objectExtension.pp_rotateAxisObjectRadians = function() {
    let rotation = quat_create();
    return function pp_rotateAxisObjectRadians(angle, axis) {
      rotation.quat_fromAxisRadians(angle, axis);
      this.pp_rotateObjectQuat(rotation);
    };
  }();
  objectExtension.pp_rotateAround = function pp_rotateAround(rotation, origin) {
    this.pp_rotateAroundWorld(rotation, origin);
  };
  objectExtension.pp_rotateAroundDegrees = function pp_rotateAroundDegrees(rotation, origin) {
    this.pp_rotateAroundWorldDegrees(rotation, origin);
  };
  objectExtension.pp_rotateAroundRadians = function pp_rotateAroundRadians(rotation, origin) {
    this.pp_rotateAroundWorldRadians(rotation, origin);
  };
  objectExtension.pp_rotateAroundMatrix = function pp_rotateAroundMatrix(rotation, origin) {
    this.pp_rotateAroundWorldMatrix(rotation, origin);
  };
  objectExtension.pp_rotateAroundQuat = function pp_rotateAroundQuat(rotation, origin) {
    this.pp_rotateAroundWorldQuat(rotation, origin);
  };
  objectExtension.pp_rotateAroundWorld = function pp_rotateAroundWorld(rotation, origin) {
    this.pp_rotateAroundWorldDegrees(rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldDegrees = function() {
    let rotationQuat = quat_create();
    return function pp_rotateAroundWorldDegrees(rotation, origin) {
      rotation.vec3_degreesToQuat(rotationQuat);
      this.pp_rotateAroundWorldQuat(rotationQuat, origin);
    };
  }();
  objectExtension.pp_rotateAroundWorldRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_rotateAroundWorldRadians(rotation, origin) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_rotateAroundWorldDegrees(degreesRotation, origin);
    };
  }();
  objectExtension.pp_rotateAroundWorldMatrix = function() {
    let rotationQuat = quat_create();
    return function pp_rotateAroundWorldMatrix(rotation, origin) {
      rotation.mat3_toQuat(rotationQuat);
      rotationQuat.quat_normalize(rotationQuat);
      this.pp_rotateAroundWorldQuat(rotationQuat, origin);
    };
  }();
  objectExtension.pp_rotateAroundWorldQuat = function() {
    let axis = vec3_create2();
    return function pp_rotateAroundWorldQuat(rotation, origin) {
      rotation.quat_getAxis(axis);
      let angle = rotation.quat_getAngleRadians();
      this.pp_rotateAroundAxisWorldRadians(angle, axis, origin);
    };
  }();
  objectExtension.pp_rotateAroundLocal = function pp_rotateAroundLocal(rotation, origin) {
    this.pp_rotateAroundLocalDegrees(rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalDegrees = function() {
    let rotationQuat = quat_create();
    return function pp_rotateAroundLocalDegrees(rotation, origin) {
      rotation.vec3_degreesToQuat(rotationQuat);
      this.pp_rotateAroundLocalQuat(rotationQuat, origin);
    };
  }();
  objectExtension.pp_rotateAroundLocalRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_rotateAroundLocalRadians(rotation, origin) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_rotateAroundLocalDegrees(degreesRotation, origin);
    };
  }();
  objectExtension.pp_rotateAroundLocalMatrix = function() {
    let rotationQuat = quat_create();
    return function pp_rotateAroundLocalMatrix(rotation, origin) {
      rotation.mat3_toQuat(rotationQuat);
      rotationQuat.quat_normalize(rotationQuat);
      this.pp_rotateAroundLocalQuat(rotationQuat, origin);
    };
  }();
  objectExtension.pp_rotateAroundLocalQuat = function() {
    let axis = vec3_create2();
    return function pp_rotateAroundLocalQuat(rotation, origin) {
      rotation.quat_getAxis(axis);
      let angle = rotation.quat_getAngleRadians();
      this.pp_rotateAroundAxisLocalRadians(angle, axis, origin);
    };
  }();
  objectExtension.pp_rotateAroundObject = function pp_rotateAroundObject(rotation, origin) {
    this.pp_rotateAroundObjectDegrees(rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectDegrees = function() {
    let rotationQuat = quat_create();
    return function pp_rotateAroundObjectDegrees(rotation, origin) {
      rotation.vec3_degreesToQuat(rotationQuat);
      this.pp_rotateAroundObjectQuat(rotationQuat, origin);
    };
  }();
  objectExtension.pp_rotateAroundObjectRadians = function() {
    let degreesRotation = vec3_create2();
    return function pp_rotateAroundObjectRadians(rotation, origin) {
      rotation.forEach(function(value, index, array) {
        degreesRotation[index] = Math.pp_toDegrees(value);
      }.bind(this));
      this.pp_rotateAroundObjectDegrees(degreesRotation, origin);
    };
  }();
  objectExtension.pp_rotateAroundObjectMatrix = function() {
    let rotationQuat = quat_create();
    return function pp_rotateAroundObjectMatrix(rotation, origin) {
      rotation.mat3_toQuat(rotationQuat);
      rotationQuat.quat_normalize(rotationQuat);
      this.pp_rotateAroundObjectQuat(rotationQuat, origin);
    };
  }();
  objectExtension.pp_rotateAroundObjectQuat = function() {
    let axis = vec3_create2();
    return function pp_rotateAroundObjectQuat(rotation, origin) {
      rotation.quat_getAxis(axis);
      let angle = rotation.quat_getAngleRadians();
      this.pp_rotateAroundAxisObjectRadians(angle, axis, origin);
    };
  }();
  objectExtension.pp_rotateAroundAxis = function pp_rotateAroundAxis(angle, axis, origin) {
    this.pp_rotateAroundAxisWorld(angle, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisDegrees = function pp_rotateAroundAxisDegrees(angle, axis, origin) {
    this.pp_rotateAroundAxisWorldDegrees(angle, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisRadians = function pp_rotateAroundAxisRadians(angle, axis, origin) {
    this.pp_rotateAroundAxisWorldRadians(angle, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorld = function pp_rotateAroundAxisWorld(angle, axis, origin) {
    this.pp_rotateAroundAxisWorldDegrees(angle, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorldDegrees = function pp_rotateAroundAxisWorldDegrees(angle, axis, origin) {
    this.pp_rotateAroundAxisWorldRadians(Math.pp_toRadians(angle), axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorldRadians = function() {
    let transformToRotate = quat2_create();
    let transformToRotateConjugate = quat2_create();
    let transformQuat = quat2_create();
    let defaultQuat = quat_create();
    return function pp_rotateAroundAxisWorldRadians(angle, axis, origin) {
      transformToRotate.quat2_setPositionRotationQuat(origin, defaultQuat);
      this.pp_getTransformWorldQuat(transformQuat);
      transformToRotate.quat2_conjugate(transformToRotateConjugate);
      transformToRotateConjugate.quat2_mul(transformQuat, transformQuat);
      transformToRotate.quat2_rotateAxisRadians(angle, axis, transformToRotate);
      transformToRotate.quat2_mul(transformQuat, transformQuat);
      this.pp_setTransformWorldQuat(transformQuat);
    };
  }();
  objectExtension.pp_rotateAroundAxisLocal = function pp_rotateAroundAxisLocal(angle, axis, origin) {
    this.pp_rotateAroundAxisLocalDegrees(angle, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocalDegrees = function pp_rotateAroundAxisLocalDegrees(angle, axis, origin) {
    this.pp_rotateAroundAxisLocalRadians(Math.pp_toRadians(angle), axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocalRadians = function() {
    let convertedPosition = vec3_create2();
    let convertedAxis = vec3_create2();
    return function pp_rotateAroundAxisLocalRadians(angle, axis, origin) {
      this.pp_convertPositionLocalToWorld(origin, convertedPosition);
      this.pp_convertDirectionLocalToWorld(axis, convertedAxis);
      this.pp_rotateAroundAxisWorldRadians(angle, convertedAxis, convertedPosition);
    };
  }();
  objectExtension.pp_rotateAroundAxisObject = function pp_rotateAroundAxisObject(angle, axis, origin) {
    this.pp_rotateAroundAxisObjectDegrees(angle, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObjectDegrees = function pp_rotateAroundAxisObjectDegrees(angle, axis, origin) {
    this.pp_rotateAroundAxisObjectRadians(Math.pp_toRadians(angle), axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObjectRadians = function() {
    let convertedPosition = vec3_create2();
    let convertedAxis = vec3_create2();
    return function pp_rotateAroundAxisObjectRadians(angle, axis, origin) {
      this.pp_convertPositionObjectToWorld(origin, convertedPosition);
      this.pp_convertDirectionObjectToWorld(axis, convertedAxis);
      this.pp_rotateAroundAxisWorldRadians(angle, convertedAxis, convertedPosition);
    };
  }();
  objectExtension.pp_scaleObject = function() {
    let vector = vec3_create2();
    return function pp_scaleObject(scale) {
      if (isNaN(scale)) {
        this.scale(scale);
      } else {
        vector.vec3_set(scale);
        this.scale(vector);
      }
    };
  }();
  objectExtension.pp_lookAt = function pp_lookAt(position, up) {
    this.pp_lookAtWorld(position, up);
  };
  objectExtension.pp_lookAtWorld = function() {
    let direction = vec3_create2();
    return function pp_lookAtWorld(position, up) {
      this.pp_getPositionWorld(direction);
      position.vec3_sub(direction, direction);
      this.pp_lookToWorld(direction, up);
    };
  }();
  objectExtension.pp_lookAtLocal = function() {
    let direction = vec3_create2();
    return function pp_lookAtLocal(position, up) {
      this.pp_getPositionLocal(direction);
      position.vec3_sub(direction, direction);
      this.pp_lookToLocal(direction, up);
    };
  }();
  objectExtension.pp_lookTo = function pp_lookTo(direction, up) {
    this.pp_lookToWorld(direction, up);
  };
  objectExtension.pp_lookToWorld = function() {
    let internalUp = vec3_create2();
    return function pp_lookToWorld(direction, up = this.pp_getUpWorld(internalUp)) {
      this.pp_setForwardWorld(direction, up);
    };
  }();
  objectExtension.pp_lookToLocal = function() {
    let internalUp = vec3_create2();
    return function pp_lookToLocal(direction, up = this.pp_getUpLocal(internalUp)) {
      this.pp_setForwardLocal(direction, up);
    };
  }();
  objectExtension.pp_setParent = function() {
    let position = vec3_create2();
    let rotation = quat_create();
    let scale = vec3_create2();
    return function pp_setParent(newParent, keepTransform = true) {
      if (!keepTransform) {
        this.parent = newParent;
      } else {
        this.pp_getPositionWorld(position);
        this.pp_getRotationWorldQuat(rotation);
        this.pp_getScaleWorld(scale);
        this.parent = newParent;
        this.pp_setScaleWorld(scale);
        this.pp_setRotationWorldQuat(rotation);
        this.pp_setPositionWorld(position);
      }
    };
  }();
  objectExtension.pp_getParent = function pp_getParent() {
    return this.parent;
  };
  objectExtension.pp_convertPositionObjectToWorld = function() {
    let matrix = mat4_create();
    return function pp_convertPositionObjectToWorld(position, resultPosition = vec3_create2()) {
      this.pp_getTransformWorldMatrix(matrix);
      position.vec3_transformMat4(matrix, resultPosition);
      return resultPosition;
    };
  }();
  objectExtension.pp_convertDirectionObjectToWorld = function() {
    let rotation = quat_create();
    return function pp_convertDirectionObjectToWorld(direction, resultDirection = vec3_create2()) {
      this.pp_getRotationWorldQuat(rotation);
      direction.vec3_transformQuat(rotation, resultDirection);
      return resultDirection;
    };
  }();
  objectExtension.pp_convertPositionWorldToObject = function() {
    let matrix = mat4_create();
    return function pp_convertPositionWorldToObject(position, resultPosition = vec3_create2()) {
      this.pp_getTransformWorldMatrix(matrix);
      matrix.mat4_invert(matrix);
      position.vec3_transformMat4(matrix, resultPosition);
      return resultPosition;
    };
  }();
  objectExtension.pp_convertDirectionWorldToObject = function() {
    let rotation = quat_create();
    return function pp_convertDirectionWorldToObject(direction, resultDirection = vec3_create2()) {
      this.pp_getRotationWorldQuat(rotation);
      rotation.quat_conjugate(rotation);
      direction.vec3_transformQuat(rotation, resultDirection);
      return resultDirection;
    };
  }();
  objectExtension.pp_convertPositionLocalToWorld = function pp_convertPositionLocalToWorld(position, resultPosition = vec3_create2()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertPositionObjectToWorld(position, resultPosition);
    } else {
      resultPosition.vec3_copy(position);
    }
    return resultPosition;
  };
  objectExtension.pp_convertDirectionLocalToWorld = function pp_convertDirectionLocalToWorld(direction, resultDirection = vec3_create2()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertDirectionObjectToWorld(direction, resultDirection);
    } else {
      resultDirection.vec3_copy(direction);
    }
    return resultDirection;
  };
  objectExtension.pp_convertPositionWorldToLocal = function pp_convertPositionWorldToLocal(position, resultPosition = vec3_create2()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertPositionWorldToObject(position, resultPosition);
    } else {
      resultPosition.vec3_copy(position);
    }
    return resultPosition;
  };
  objectExtension.pp_convertDirectionWorldToLocal = function pp_convertDirectionWorldToLocal(direction, resultDirection = vec3_create2()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertDirectionWorldToObject(direction, resultDirection);
    } else {
      resultDirection.vec3_copy(direction);
    }
    return resultDirection;
  };
  objectExtension.pp_convertPositionObjectToLocal = function pp_convertPositionObjectToLocal(position, resultPosition = vec3_create2()) {
    this.pp_convertPositionObjectToWorld(position, resultPosition);
    this.pp_convertPositionWorldToLocal(resultPosition, resultPosition);
    return resultPosition;
  };
  objectExtension.pp_convertDirectionObjectToLocal = function pp_convertDirectionObjectToLocal(direction, resultDirection = vec3_create2()) {
    this.pp_convertDirectionObjectToWorld(direction, resultDirection);
    this.pp_convertDirectionWorldToLocal(resultDirection, resultDirection);
    return resultDirection;
  };
  objectExtension.pp_convertPositionLocalToObject = function pp_convertPositionLocalToObject(position, resultPosition = vec3_create2()) {
    this.pp_convertPositionLocalToWorld(position, resultPosition);
    this.pp_convertPositionWorldToObject(resultPosition, resultPosition);
    return resultPosition;
  };
  objectExtension.pp_convertDirectionLocalToObject = function pp_convertDirectionLocalToObject(direction, resultDirection = vec3_create2()) {
    this.pp_convertDirectionLocalToWorld(direction, resultDirection);
    this.pp_convertDirectionWorldToObject(resultDirection, resultDirection);
    return resultDirection;
  };
  objectExtension.pp_convertTransformObjectToWorld = function pp_convertTransformObjectToWorld(transform, resultTransform) {
    return this.pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToWorldMatrix = function() {
    let convertTransform = mat4_create();
    let position = vec3_create2();
    let scale = vec3_create2();
    let inverseScale = vec3_create2();
    let one = vec3_create2(1);
    return function pp_convertTransformObjectToWorldMatrix(transform, resultTransform = mat4_create()) {
      this.pp_getTransformWorldMatrix(convertTransform);
      if (this.pp_hasUniformScaleWorld()) {
        convertTransform.mat4_mul(transform, resultTransform);
      } else {
        position.vec3_set(transform[12], transform[13], transform[14]);
        this.pp_convertPositionObjectToWorld(position, position);
        convertTransform.mat4_getScale(scale);
        one.vec3_div(scale, inverseScale);
        convertTransform.mat4_scale(inverseScale, convertTransform);
        convertTransform.mat4_mul(transform, resultTransform);
        resultTransform.mat4_scale(scale, resultTransform);
        resultTransform[12] = position[0];
        resultTransform[13] = position[1];
        resultTransform[14] = position[2];
        resultTransform[15] = 1;
      }
      return resultTransform;
    };
  }();
  objectExtension.pp_convertTransformObjectToWorldQuat = function() {
    let position = vec3_create2();
    let rotation = quat_create();
    return function pp_convertTransformObjectToWorldQuat(transform, resultTransform = quat2_create()) {
      this.pp_getRotationWorldQuat(rotation);
      rotation.quat_mul(transform, rotation);
      transform.quat2_getPosition(position);
      this.pp_convertPositionObjectToWorld(position, position);
      resultTransform.quat2_setPositionRotationQuat(position, rotation);
      return resultTransform;
    };
  }();
  objectExtension.pp_convertTransformWorldToObject = function pp_convertTransformWorldToObject(transform, resultTransform) {
    return this.pp_convertTransformWorldToObjectMatrix(transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObjectMatrix = function() {
    let convertTransform = mat4_create();
    let position = vec3_create2();
    let scale = vec3_create2();
    let inverseScale = vec3_create2();
    let one = vec3_create2(1);
    return function pp_convertTransformWorldToObjectMatrix(transform, resultTransform = mat4_create()) {
      this.pp_getTransformWorldMatrix(convertTransform);
      if (this.pp_hasUniformScaleWorld()) {
        convertTransform.mat4_invert(convertTransform);
        convertTransform.mat4_mul(transform, resultTransform);
      } else {
        position.vec3_set(transform[12], transform[13], transform[14]);
        this.pp_convertPositionWorldToObject(position, position);
        convertTransform.mat4_getScale(scale);
        one.vec3_div(scale, inverseScale);
        convertTransform.mat4_scale(inverseScale, convertTransform);
        convertTransform.mat4_invert(convertTransform);
        convertTransform.mat4_mul(transform, resultTransform);
        resultTransform.mat4_scale(inverseScale, resultTransform);
        resultTransform[12] = position[0];
        resultTransform[13] = position[1];
        resultTransform[14] = position[2];
        resultTransform[15] = 1;
      }
      return resultTransform;
    };
  }();
  objectExtension.pp_convertTransformWorldToObjectQuat = function() {
    let position = vec3_create2();
    let rotation = quat_create();
    return function pp_convertTransformWorldToObjectQuat(transform, resultTransform = quat2_create()) {
      this.pp_getRotationWorldQuat(rotation);
      rotation.quat_conjugate(rotation);
      rotation.quat_mul(transform, rotation);
      transform.quat2_getPosition(position);
      this.pp_convertPositionWorldToObject(position, position);
      resultTransform.quat2_setPositionRotationQuat(position, rotation);
      return resultTransform;
    };
  }();
  objectExtension.pp_convertTransformLocalToWorld = function pp_convertTransformLocalToWorld(transform, resultTransform) {
    return this.pp_convertTransformLocalToWorldMatrix(transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorldMatrix = function pp_convertTransformLocalToWorldMatrix(transform, resultTransform = mat4_create()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
    } else {
      resultTransform.mat4_copy(transform);
    }
    return resultTransform;
  };
  objectExtension.pp_convertTransformLocalToWorldQuat = function pp_convertTransformLocalToWorldQuat(transform, resultTransform = quat2_create()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertTransformObjectToWorldQuat(transform, resultTransform);
    } else {
      resultTransform.quat2_copy(transform);
    }
    return resultTransform;
  };
  objectExtension.pp_convertTransformWorldToLocal = function pp_convertTransformWorldToLocal(transform, resultTransform) {
    return this.pp_convertTransformWorldToLocalMatrix(transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocalMatrix = function pp_convertTransformWorldToLocalMatrix(transform, resultTransform = mat4_create()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertTransformWorldToObjectMatrix(transform, resultTransform);
    } else {
      resultTransform.mat4_copy(transform);
    }
    return resultTransform;
  };
  objectExtension.pp_convertTransformWorldToLocalQuat = function pp_convertTransformWorldToLocalQuat(transform, resultTransform = quat2_create()) {
    if (this.pp_getParent()) {
      this.pp_getParent().pp_convertTransformWorldToObjectQuat(transform, resultTransform);
    } else {
      resultTransform.quat2_copy(transform);
    }
    return resultTransform;
  };
  objectExtension.pp_convertTransformObjectToLocal = function pp_convertTransformObjectToLocal(transform, resultTransform) {
    return this.pp_convertTransformObjectToLocalMatrix(transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocalMatrix = function pp_convertTransformObjectToLocalMatrix(transform, resultTransform = mat4_create()) {
    this.pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
    this.pp_convertTransformWorldToLocalMatrix(resultTransform, resultTransform);
    return resultTransform;
  };
  objectExtension.pp_convertTransformObjectToLocalQuat = function pp_convertTransformObjectToLocalQuat(transform, resultTransform = quat2_create()) {
    this.pp_convertTransformObjectToWorldQuat(transform, resultTransform);
    this.pp_convertTransformWorldToLocalQuat(resultTransform, resultTransform);
    return resultTransform;
  };
  objectExtension.pp_convertTransformLocalToObject = function pp_convertTransformLocalToObject(transform, resultTransform) {
    return this.pp_convertTransformLocalToObjectMatrix(transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObjectMatrix = function pp_convertTransformLocalToObjectMatrix(transform, resultTransform = mat4_create()) {
    this.pp_convertTransformLocalToWorldMatrix(transform, resultTransform);
    this.pp_convertTransformWorldToObjectMatrix(resultTransform, resultTransform);
    return resultTransform;
  };
  objectExtension.pp_convertTransformLocalToObjectQuat = function pp_convertTransformLocalToObjectQuat(transform, resultTransform = quat2_create()) {
    this.pp_convertTransformLocalToWorldQuat(transform, resultTransform);
    this.pp_convertTransformWorldToObjectQuat(resultTransform, resultTransform);
    return resultTransform;
  };
  objectExtension.pp_addComponent = function pp_addComponent(type2, paramsOrActive, active = null) {
    let params = null;
    if (typeof paramsOrActive == "boolean") {
      params = {};
      params["active"] = paramsOrActive;
    } else {
      params = paramsOrActive;
      if (active != null) {
        if (params == null) {
          params = {};
        }
        params["active"] = active;
      }
    }
    return this.addComponent(type2, params);
  };
  objectExtension.pp_getComponent = function pp_getComponent(type2, index = 0) {
    return this.pp_getComponentHierarchy(type2, index);
  };
  objectExtension.pp_getComponentSelf = function pp_getComponentSelf(type2, index = 0) {
    return this.getComponent(type2, index);
  };
  objectExtension.pp_getComponentHierarchy = function pp_getComponentHierarchy(type2, index = 0) {
    return this.pp_getComponentHierarchyBreadth(type2, index);
  };
  objectExtension.pp_getComponentHierarchyBreadth = function pp_getComponentHierarchyBreadth(type2, index = 0) {
    let objects = this.pp_getHierarchyBreadth();
    return getComponentObjects(objects, type2, index);
  };
  objectExtension.pp_getComponentHierarchyDepth = function pp_getComponentHierarchyDepth(type2, index = 0) {
    let objects = this.pp_getHierarchyDepth();
    return getComponentObjects(objects, type2, index);
  };
  objectExtension.pp_getComponentDescendants = function pp_getComponentDescendants(type2, index = 0) {
    return this.pp_getComponentDescendantsBreadth(type2, index);
  };
  objectExtension.pp_getComponentDescendantsBreadth = function pp_getComponentDescendantsBreadth(type2, index = 0) {
    let objects = this.pp_getDescendantsBreadth();
    return getComponentObjects(objects, type2, index);
  };
  objectExtension.pp_getComponentDescendantsDepth = function pp_getComponentDescendantsDepth(type2, index = 0) {
    let objects = this.pp_getDescendantsDepth();
    return getComponentObjects(objects, type2, index);
  };
  objectExtension.pp_getComponentChildren = function pp_getComponentChildren(type2, index = 0) {
    let objects = this.pp_getChildren();
    return getComponentObjects(objects, type2, index);
  };
  objectExtension.pp_getComponents = function pp_getComponents(type2) {
    return this.pp_getComponentsHierarchy(type2);
  };
  objectExtension.pp_getComponentsSelf = function pp_getComponentsSelf(type2) {
    return this.getComponents(type2);
  };
  objectExtension.pp_getComponentsHierarchy = function pp_getComponentsHierarchy(type2) {
    return this.pp_getComponentsHierarchyBreadth(type2);
  };
  objectExtension.pp_getComponentsHierarchyBreadth = function pp_getComponentsHierarchyBreadth(type2) {
    let objects = this.pp_getHierarchyBreadth();
    return getComponentsObjects(objects, type2);
  };
  objectExtension.pp_getComponentsHierarchyDepth = function pp_getComponentsHierarchyDepth(type2) {
    let objects = this.pp_getHierarchyDepth();
    return getComponentsObjects(objects, type2);
  };
  objectExtension.pp_getComponentsDescendants = function pp_getComponentsDescendants(type2) {
    return this.pp_getComponentsDescendantsBreadth(type2);
  };
  objectExtension.pp_getComponentsDescendantsBreadth = function pp_getComponentsDescendantsBreadth(type2) {
    let objects = this.pp_getDescendantsBreadth();
    return getComponentsObjects(objects, type2);
  };
  objectExtension.pp_getComponentsDescendantsDepth = function pp_getComponentsDescendantsDepth(type2) {
    let objects = this.pp_getDescendantsDepth();
    return getComponentsObjects(objects, type2);
  };
  objectExtension.pp_getComponentsChildren = function pp_getComponentsChildren(type2) {
    let objects = this.pp_getChildren();
    return getComponentsObjects(objects, type2);
  };
  objectExtension.pp_setActive = function pp_setActive(active, applyToHierarchy = true) {
    if (applyToHierarchy) {
      this.pp_setActiveHierarchy(active);
    } else {
      this.active = active;
    }
  };
  objectExtension.pp_setActiveSelf = function pp_setActiveSelf(active) {
    this.pp_setActive(active, false);
  };
  objectExtension.pp_setActiveHierarchy = function pp_setActiveHierarchy(active) {
    this.pp_setActiveHierarchyBreadth(active);
  };
  objectExtension.pp_setActiveHierarchyBreadth = function pp_setActiveHierarchyBreadth(active) {
    let objects = this.pp_getHierarchyBreadth();
    setActiveObjects(objects, active);
  };
  objectExtension.pp_setActiveHierarchyDepth = function pp_setActiveHierarchyDepth(active) {
    let objects = this.pp_getHierarchyDepth();
    setActiveObjects(objects, active);
  };
  objectExtension.pp_setActiveDescendants = function pp_setActiveDescendants(active) {
    this.pp_setActiveDescendantsBreadth(active);
  };
  objectExtension.pp_setActiveDescendantsBreadth = function pp_setActiveDescendantsBreadth(active) {
    let objects = this.pp_getDescendantsBreadth();
    setActiveObjects(objects, active);
  };
  objectExtension.pp_setActiveDescendantsDepth = function pp_setActiveDescendantsDepth(active) {
    let objects = this.pp_getDescendantsDepth();
    setActiveObjects(objects, active);
  };
  objectExtension.pp_setActiveChildren = function pp_setActiveChildren(active) {
    let objects = this.pp_getChildren();
    setActiveObjects(objects, active);
  };
  objectExtension.pp_hasUniformScale = function pp_hasUniformScale() {
    return this.pp_hasUniformScaleWorld();
  };
  objectExtension.pp_hasUniformScaleWorld = function() {
    let scale = vec3_create2();
    return function pp_hasUniformScaleWorld() {
      this.pp_getScaleWorld(scale);
      return Math.abs(scale[0] - scale[1]) < Math.PP_EPSILON && Math.abs(scale[1] - scale[2]) < Math.PP_EPSILON && Math.abs(scale[0] - scale[2]) < Math.PP_EPSILON;
    };
  }();
  objectExtension.pp_hasUniformScaleLocal = function() {
    let scale = vec3_create2();
    return function pp_hasUniformScaleLocal() {
      this.pp_getScaleLocal(scale);
      return Math.abs(scale[0] - scale[1]) < Math.PP_EPSILON && Math.abs(scale[1] - scale[2]) < Math.PP_EPSILON && Math.abs(scale[0] - scale[2]) < Math.PP_EPSILON;
    };
  }();
  objectExtension.pp_clone = function() {
    let scale = vec3_create2();
    let transformQuat = quat2_create();
    return function pp_clone(params = new CloneParams()) {
      let clonedObject = null;
      if (this.pp_isCloneable(params)) {
        let objectsToCloneData = [];
        objectsToCloneData.push([this.pp_getParent(), this]);
        let objectsToCloneComponentsData = [];
        while (objectsToCloneData.length > 0) {
          let cloneData = objectsToCloneData.shift();
          let parent = cloneData[0];
          let objectToClone = cloneData[1];
          let currentClonedObject = parent.pp_addObject();
          currentClonedObject.pp_setName(objectToClone.pp_getName());
          currentClonedObject.pp_setScaleLocal(objectToClone.pp_getScaleLocal(scale));
          currentClonedObject.pp_setTransformLocalQuat(objectToClone.pp_getTransformLocalQuat(transformQuat));
          if (!params.myIgnoreComponents) {
            objectsToCloneComponentsData.push([objectToClone, currentClonedObject]);
          }
          if (!params.myIgnoreChildren) {
            for (let child of objectToClone.pp_getChildren()) {
              let cloneChild = false;
              if (params.myChildrenToInclude.length > 0) {
                cloneChild = params.myChildrenToInclude.find((childToInclude) => childToInclude.pp_equals(child)) != null;
              } else {
                cloneChild = params.myChildrenToIgnore.find((childToIgnore) => childToIgnore.pp_equals(child)) == null;
              }
              if (cloneChild && params.myIgnoreChildCallback != null) {
                cloneChild = !params.myIgnoreChildCallback(child);
              }
              if (cloneChild) {
                objectsToCloneData.push([currentClonedObject, child]);
              }
            }
          }
          if (clonedObject == null) {
            clonedObject = currentClonedObject;
          }
        }
        let componentsToCloneData = [];
        while (objectsToCloneComponentsData.length > 0) {
          let cloneData = objectsToCloneComponentsData.shift();
          let objectToClone = cloneData[0];
          let currentClonedObject = cloneData[1];
          let components = objectToClone.pp_getComponentsSelf();
          for (let component of components) {
            if (component.pp_clone != null || params.myUseWLClone || params.myUseWLCloneAsFallback) {
              let cloneComponent = false;
              if (params.myComponentsToInclude.length > 0) {
                cloneComponent = params.myComponentsToInclude.indexOf(component.type) != -1;
              } else {
                cloneComponent = params.myComponentsToIgnore.indexOf(component.type) == -1;
              }
              if (cloneComponent && params.myIgnoreComponentCallback != null) {
                cloneComponent = !params.myIgnoreComponentCallback(component);
              }
              if (cloneComponent) {
                componentsToCloneData.push([component, currentClonedObject]);
              }
            }
          }
        }
        let componentsToPostProcessData = [];
        while (componentsToCloneData.length > 0) {
          let cloneData = componentsToCloneData.shift();
          let componentToClone = cloneData[0];
          let currentClonedObject = cloneData[1];
          let clonedComponent = null;
          if (!params.myUseWLClone && componentToClone.pp_clone != null) {
            clonedComponent = componentToClone.pp_clone(currentClonedObject, params.myDeepCloneParams, params.myCustomCloneParams);
          } else if (params.myUseWLClone || params.myUseWLCloneAsFallback) {
            clonedComponent = currentClonedObject.pp_addComponent(componentToClone.type, componentToClone);
          }
          if (clonedComponent != null) {
            if (componentToClone.pp_clonePostProcess != null) {
              componentsToPostProcessData.push([componentToClone, clonedComponent]);
            }
          }
        }
        while (componentsToPostProcessData.length > 0) {
          let cloneData = componentsToPostProcessData.shift();
          let componentToClone = cloneData[0];
          let currentClonedComponent = cloneData[1];
          componentToClone.pp_clonePostProcess(currentClonedComponent, params.myDeepCloneParams, params.myCustomCloneParams);
        }
      }
      return clonedObject;
    };
  }();
  objectExtension.pp_isCloneable = function pp_isCloneable(params = new CloneParams()) {
    if (params.myIgnoreNonCloneable || params.myIgnoreComponents || params.myUseWLClone || params.myUseWLCloneAsFallback) {
      return true;
    }
    let isCloneable = true;
    let objects = [];
    objects.push(this);
    while (isCloneable && objects.length > 0) {
      let object = objects.shift();
      let components = this.pp_getComponentsSelf();
      for (let component of components) {
        let cloneComponent = false;
        if (params.myComponentsToInclude.length > 0) {
          cloneComponent = params.myComponentsToInclude.indexOf(component.type) != -1;
        } else {
          cloneComponent = params.myComponentsToIgnore.indexOf(component.type) == -1;
        }
        if (cloneComponent && params.myIgnoreComponentCallback != null) {
          cloneComponent = !params.myIgnoreComponentCallback(component);
        }
        if (cloneComponent && component.pp_clone == null) {
          isCloneable = false;
          break;
        }
      }
      if (isCloneable && !params.myIgnoreChildren) {
        for (let child of object.pp_getChildren()) {
          let cloneChild = false;
          if (params.myChildrenToInclude.length > 0) {
            cloneChild = params.myChildrenToInclude.find((childToInclude) => childToInclude.pp_equals(child)) != null;
          } else {
            cloneChild = params.myChildrenToIgnore.find((childToInclude) => childToInclude.pp_equals(child)) == null;
          }
          if (cloneChild && params.myIgnoreChildCallback != null) {
            cloneChild = !params.myIgnoreChildCallback(child);
          }
          if (cloneChild) {
            objects.push(child);
          }
        }
      }
    }
    return isCloneable;
  };
  objectExtension.pp_toString = function pp_toString() {
    return this.pp_toStringCompact();
  };
  objectExtension.pp_toStringExtended = function() {
    let tab = "    ";
    let newLine = "\n";
    let startObject = "{";
    let endObject = "}";
    let nameLabel = "name: ";
    let idLabel = "id: ";
    let componentsLabel = "components: ";
    let typeLabel = "type: ";
    let childrenLabel = "children: ";
    let startComponents = "[";
    let endComponents = "]";
    let startChildren = startComponents;
    let endChildren = endComponents;
    let separator = ",";
    let newLineTab = newLine.concat(tab, tab);
    return function pp_toStringExtended() {
      let objectString = "";
      objectString = objectString.concat(startObject, newLine);
      let components = this.pp_getComponentsSelf();
      let children = this.pp_getChildren();
      let name = this.pp_getName();
      if (components.length > 0 || children.length > 0 || name.length > 0) {
        objectString = objectString.concat(tab, idLabel, this.pp_getID(), separator, newLine);
      } else {
        objectString = objectString.concat(tab, idLabel, this.pp_getID(), newLine);
      }
      if (name.length > 0) {
        if (components.length > 0 || children.length > 0) {
          objectString = objectString.concat(tab, nameLabel, this.pp_getName(), separator, newLine);
        } else {
          objectString = objectString.concat(tab, nameLabel, this.pp_getName(), newLine);
        }
      }
      if (components.length > 0) {
        objectString = objectString.concat(tab, componentsLabel, newLine, tab, startComponents, newLine);
        for (let i = 0; i < components.length; i++) {
          let component = components[i];
          objectString = objectString.concat(tab, tab, startObject, newLine);
          objectString = objectString.concat(tab, tab, tab, typeLabel, component.type, separator, newLine);
          objectString = objectString.concat(tab, tab, tab, idLabel, component._id, separator, newLine);
          objectString = objectString.concat(tab, tab, endObject);
          if (i != components.length - 1) {
            objectString = objectString.concat(separator, newLine);
          } else {
            objectString = objectString.concat(newLine);
          }
        }
        if (children.length > 0) {
          objectString = objectString.concat(tab, endComponents, separator, newLine);
        } else {
          objectString = objectString.concat(tab, endComponents, newLine);
        }
      }
      if (children.length > 0) {
        objectString = objectString.concat(tab, childrenLabel, newLine, tab, startChildren, newLine);
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          let childString = child.pp_toStringExtended();
          childString = childString.replaceAll(newLine, newLineTab);
          childString = tab.concat(tab, childString);
          objectString = objectString.concat(childString);
          if (i != children.length - 1) {
            objectString = objectString.concat(separator, newLine);
          } else {
            objectString = objectString.concat(newLine);
          }
        }
        objectString = objectString.concat(tab, endChildren, newLine);
      }
      objectString = objectString.concat(endObject);
      return objectString;
    };
  }();
  objectExtension.pp_toStringCompact = function() {
    let tab = "    ";
    let newLine = "\n";
    let emptyName = "<none>";
    let nameLabel = "name: ";
    let componentsLabel = "components: ";
    let separator = ", ";
    let newLineTab = newLine.concat(tab);
    return function pp_toStringCompact() {
      let objectString = "";
      let name = this.pp_getName();
      if (name.length > 0) {
        objectString = objectString.concat(nameLabel, name);
      } else {
        objectString = objectString.concat(nameLabel, emptyName);
      }
      let components = this.pp_getComponentsSelf();
      if (components.length > 0) {
        objectString = objectString.concat(separator, componentsLabel);
        for (let i = 0; i < components.length; i++) {
          let component = components[i];
          objectString = objectString.concat(component.type);
          if (i != components.length - 1) {
            objectString = objectString.concat(separator);
          }
        }
      }
      let children = this.pp_getChildren();
      if (children.length > 0) {
        objectString = objectString.concat(newLine);
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          let childString = child.pp_toStringCompact();
          childString = childString.replaceAll(newLine, newLineTab);
          childString = tab.concat(childString);
          objectString = objectString.concat(childString);
          if (i != children.length - 1) {
            objectString = objectString.concat(newLine);
          }
        }
      }
      return objectString;
    };
  }();
  objectExtension.pp_getObjectByName = function pp_getObjectByName(name, index = 0) {
    return this.pp_getObjectByNameHierarchy(name, index);
  };
  objectExtension.pp_getObjectByNameHierarchy = function pp_getObjectByNameHierarchy(name, index = 0) {
    return this.pp_getObjectByNameHierarchyBreadth(name, index);
  };
  objectExtension.pp_getObjectByNameHierarchyBreadth = function pp_getObjectByNameHierarchyBreadth(name, index = 0) {
    let objects = this.pp_getHierarchyBreadth();
    return getObjectByNameObjects(objects, name, index);
  };
  objectExtension.pp_getObjectByNameHierarchyDepth = function pp_getObjectByNameHierarchyDepth(name, index = 0) {
    let objects = this.pp_getHierarchyDepth();
    return getObjectByNameObjects(objects, name, index);
  };
  objectExtension.pp_getObjectByNameDescendants = function pp_getObjectByNameDescendants(name, index = 0) {
    return this.pp_getObjectByNameDescendantsBreadth(name, index);
  };
  objectExtension.pp_getObjectByNameDescendantsBreadth = function pp_getObjectByNameDescendantsBreadth(name, index = 0) {
    let objects = this.pp_getDescendantsBreadth();
    return getObjectByNameObjects(objects, name, index);
  };
  objectExtension.pp_getObjectByNameDescendantsDepth = function pp_getObjectByNameDescendantsDepth(name, index = 0) {
    let objects = this.pp_getDescendantsDepth();
    return getObjectByNameObjects(objects, name, index);
  };
  objectExtension.pp_getObjectByNameChildren = function pp_getObjectByNameChildren(name, index = 0) {
    let objects = this.pp_getChildren();
    return getObjectByNameObjects(objects, name, index);
  };
  objectExtension.pp_getObjectsByName = function pp_getObjectsByName(name) {
    return this.pp_getObjectsByNameHierarchy(name);
  };
  objectExtension.pp_getObjectsByNameHierarchy = function pp_getObjectsByNameHierarchy(name) {
    return this.pp_getObjectsByNameHierarchyBreadth(name);
  };
  objectExtension.pp_getObjectsByNameHierarchyBreadth = function pp_getObjectsByNameHierarchyBreadth(name) {
    let objects = this.pp_getHierarchyBreadth();
    return getObjectsByNameObjects(objects, name);
  };
  objectExtension.pp_getObjectsByNameHierarchyDepth = function pp_getObjectsByNameHierarchyDepth(name) {
    let objects = this.pp_getHierarchyDepth();
    return getObjectsByNameObjects(objects, name);
  };
  objectExtension.pp_getObjectsByNameDescendants = function pp_getObjectsByNameDescendants(name) {
    return this.pp_getObjectsByNameDescendantsBreadth(name);
  };
  objectExtension.pp_getObjectsByNameDescendantsBreadth = function pp_getObjectsByNameDescendantsBreadth(name) {
    let objects = this.pp_getDescendantsBreadth();
    return getObjectsByNameObjects(objects, name);
  };
  objectExtension.pp_getObjectsByNameDescendantsDepth = function pp_getObjectsByNameDescendantsDepth(name) {
    let objects = this.pp_getDescendantsDepth();
    return getObjectsByNameObjects(objects, name);
  };
  objectExtension.pp_getObjectsByNameChildren = function pp_getObjectsByNameChildren(name) {
    let objects = this.pp_getChildren();
    return getObjectsByNameObjects(objects, name);
  };
  objectExtension.pp_getObjectByID = function pp_getObjectByID(id) {
    return this.pp_getObjectByIDHierarchy(id);
  };
  objectExtension.pp_getObjectByIDHierarchy = function pp_getObjectByIDHierarchy(id) {
    return this.pp_getObjectByIDHierarchyBreadth(id);
  };
  objectExtension.pp_getObjectByIDHierarchyBreadth = function pp_getObjectByIDHierarchyBreadth(id) {
    let objects = this.pp_getHierarchyBreadth();
    return getObjectByIDObjects(objects, id);
  };
  objectExtension.pp_getObjectByIDHierarchyDepth = function pp_getObjectByIDHierarchyDepth(id) {
    let objects = this.pp_getHierarchyDepth();
    return getObjectByIDObjects(objects, id);
  };
  objectExtension.pp_getObjectByIDDescendants = function pp_getObjectByIDDescendants(id) {
    return this.pp_getObjectByIDDescendantsBreadth(id);
  };
  objectExtension.pp_getObjectByIDDescendantsBreadth = function pp_getObjectByIDDescendantsBreadth(id) {
    let objects = this.pp_getDescendantsBreadth();
    return getObjectByIDObjects(objects, id);
  };
  objectExtension.pp_getObjectByIDDescendantsDepth = function pp_getObjectByIDDescendantsDepth(id) {
    let objects = this.pp_getDescendantsDepth();
    return getObjectByIDObjects(objects, id);
  };
  objectExtension.pp_getObjectByIDChildren = function pp_getObjectByIDChildren(id) {
    let objects = this.pp_getChildren();
    return getObjectByIDObjects(objects, id);
  };
  objectExtension.pp_getHierarchy = function pp_getHierarchy() {
    return this.pp_getHierarchyBreadth();
  };
  objectExtension.pp_getHierarchyBreadth = function pp_getHierarchyBreadth() {
    let hierarchy = this.pp_getDescendantsBreadth();
    hierarchy.unshift(this);
    return hierarchy;
  };
  objectExtension.pp_getHierarchyDepth = function pp_getHierarchyDepth() {
    let hierarchy = this.pp_getDescendantsDepth();
    hierarchy.unshift(this);
    return hierarchy;
  };
  objectExtension.pp_getDescendants = function pp_getDescendants() {
    return this.pp_getDescendantsBreadth();
  };
  objectExtension.pp_getDescendantsBreadth = function pp_getDescendantsBreadth() {
    let descendants = [];
    let descendantsQueue = this.pp_getChildren();
    while (descendantsQueue.length > 0) {
      let descendant = descendantsQueue.shift();
      descendants.push(descendant);
      for (let object of descendant.pp_getChildren()) {
        descendantsQueue.push(object);
      }
    }
    return descendants;
  };
  objectExtension.pp_getDescendantsDepth = function pp_getDescendantsDepth() {
    let descendants = [];
    let children = this.pp_getChildren();
    for (let child of children) {
      descendants.push(child);
      let childDescendants = child.pp_getDescendantsDepth();
      if (childDescendants.length > 0) {
        descendants.push(...childDescendants);
      }
    }
    return descendants;
  };
  objectExtension.pp_getChildren = function pp_getChildren() {
    return this.children;
  };
  objectExtension.pp_getSelf = function pp_getSelf() {
    return this;
  };
  objectExtension.pp_addObject = function pp_addObject() {
    return this.pp_getEngine().scene.addObject(this);
  };
  objectExtension.pp_getName = function pp_getName() {
    return this.name;
  };
  objectExtension.pp_setName = function pp_setName(name) {
    this.name = name;
  };
  objectExtension.pp_getEngine = function pp_getEngine() {
    return this.engine;
  };
  objectExtension.pp_getID = function pp_getID() {
    return this.objectId;
  };
  objectExtension.pp_markDirty = function pp_markDirty() {
    return this.setDirty();
  };
  objectExtension.pp_isChangedTransform = function pp_isChangedTransform() {
    return this.changed;
  };
  objectExtension.pp_equals = function pp_equals(otherObject) {
    return this.equals(otherObject);
  };
  objectExtension.pp_destroy = function pp_destroy() {
    return this.destroy();
  };
  objectExtension.pp_reserveObjects = function pp_reserveObjects(count) {
    this.pp_reserveObjectsHierarchy(count);
  };
  objectExtension.pp_reserveObjectsSelf = function pp_reserveObjectsSelf(count) {
    let componentsAmountMap = this.pp_getComponentsAmountMapSelf();
    _reserveObjects(count, componentsAmountMap, this.pp_getEngine().scene);
  };
  objectExtension.pp_reserveObjectsHierarchy = function pp_reserveObjectsHierarchy(count) {
    let componentsAmountMap = this.pp_getComponentsAmountMapHierarchy();
    _reserveObjects(count, componentsAmountMap, this.pp_getEngine().scene);
  };
  objectExtension.pp_reserveObjectsDescendants = function pp_reserveObjectsDescendants(count) {
    let componentsAmountMap = this.pp_getComponentsAmountMapDescendants();
    _reserveObjects(count, componentsAmountMap, this.pp_getEngine().scene);
  };
  objectExtension.pp_reserveObjectsChildren = function pp_reserveObjectsChildren(count) {
    let componentsAmountMap = this.pp_getComponentsAmountMapChildren();
    _reserveObjects(count, componentsAmountMap, this.pp_getEngine().scene);
  };
  objectExtension.pp_getComponentsAmountMap = function pp_getComponentsAmountMap(amountMap = /* @__PURE__ */ new Map()) {
    return this.pp_getComponentsAmountMapHierarchy(amountMap);
  };
  objectExtension.pp_getComponentsAmountMapSelf = function pp_getComponentsAmountMapSelf(amountMap = /* @__PURE__ */ new Map()) {
    let objectsAmount = amountMap.get("object");
    if (objectsAmount == null) {
      objectsAmount = 0;
    }
    objectsAmount += 1;
    amountMap.set("object", objectsAmount);
    let components = this.pp_getComponentsSelf();
    for (let component of components) {
      let type2 = component.type;
      let typeAmount = amountMap.get(type2);
      if (typeAmount == null) {
        typeAmount = 0;
      }
      typeAmount += 1;
      amountMap.set(type2, typeAmount);
    }
    return amountMap;
  };
  objectExtension.pp_getComponentsAmountMapHierarchy = function pp_getComponentsAmountMapHierarchy(amountMap = /* @__PURE__ */ new Map()) {
    let hierarchy = this.pp_getHierarchy();
    for (let object of hierarchy) {
      object.pp_getComponentsAmountMapSelf(amountMap);
    }
    return amountMap;
  };
  objectExtension.pp_getComponentsAmountMapDescendants = function pp_getComponentsAmountMapDescendants(amountMap = /* @__PURE__ */ new Map()) {
    let descendants = this.pp_getDescendants();
    for (let object of descendants) {
      object.pp_getComponentsAmountMapSelf(amountMap);
    }
    return amountMap;
  };
  objectExtension.pp_getComponentsAmountMapChildren = function pp_getComponentsAmountMapChildren(amountMap = /* @__PURE__ */ new Map()) {
    let children = this.pp_getChildren();
    for (let object of children) {
      object.pp_getComponentsAmountMapSelf(amountMap);
    }
    return amountMap;
  };
  ExtensionUtils.assignProperties(objectExtension, WLObject.prototype, false, true, true);
}
function _reserveObjects(count, componentsAmountMap, scene) {
  let objectsToReserve = componentsAmountMap.get("object") * count;
  componentsAmountMap.delete("object");
  let componentsToReserve = {};
  for (let [componentName, componentCount] of componentsAmountMap.entries()) {
    componentsToReserve[componentName] = componentCount * count;
  }
  scene.reserveObjects(objectsToReserve, componentsToReserve);
}

// js/pp/plugin/wl/extensions/scene_extension.js
import { Scene } from "@wonderlandengine/api";
function initSceneExtension(engine2) {
  initSceneExtensionPrototype();
}
function initSceneExtensionPrototype() {
  let sceneExtension = {};
  sceneExtension.pp_getRoot = function pp_getRoot() {
    return this.engine.wrapObject(0);
  };
  sceneExtension.pp_addObject = function pp_addObject() {
    return this.pp_getRoot().pp_addObject();
  };
  sceneExtension.pp_getObjects = function pp_getObjects() {
    return this.pp_getObjectsBreadth();
  };
  sceneExtension.pp_getObjectsBreadth = function pp_getObjectsBreadth() {
    return this.pp_getRoot().pp_getHierarchyBreadth();
  };
  sceneExtension.pp_getObjectsDepth = function pp_getObjectsDepth() {
    return this.pp_getRoot().pp_getHierarchyDepth();
  };
  sceneExtension.pp_getComponent = function pp_getComponent(type2, index = 0) {
    return this.pp_getComponentBreadth(type2, index);
  };
  sceneExtension.pp_getComponentBreadth = function pp_getComponentBreadth(type2, index = 0) {
    return this.pp_getRoot().pp_getComponentHierarchyBreadth(type2, index);
  };
  sceneExtension.pp_getComponentDepth = function pp_getComponentDepth(type2, index = 0) {
    return this.pp_getRoot().pp_getComponentHierarchyDepth(type2, index);
  };
  sceneExtension.pp_getComponents = function pp_getComponents(type2) {
    return this.pp_getComponentsBreadth(type2);
  };
  sceneExtension.pp_getComponentsBreadth = function pp_getComponentsBreadth(type2) {
    return this.pp_getRoot().pp_getComponentsHierarchyBreadth(type2);
  };
  sceneExtension.pp_getComponentsDepth = function pp_getComponentsDepth(type2) {
    return this.pp_getRoot().pp_getComponentsHierarchyDepth(type2);
  };
  sceneExtension.pp_getObjectByName = function pp_getObjectByName(name, index = 0) {
    return this.pp_getObjectByNameBreadth(name, index);
  };
  sceneExtension.pp_getObjectByNameBreadth = function pp_getObjectByNameBreadth(name, index = 0) {
    return this.pp_getRoot().pp_getObjectByNameHierarchyBreadth(name, index);
  };
  sceneExtension.pp_getObjectByNameDepth = function pp_getObjectByNameDepth(name, index = 0) {
    return this.pp_getRoot().pp_getObjectByNameHierarchyDepth(name, index);
  };
  sceneExtension.pp_getObjectsByName = function pp_getObjectsByName(name, index = 0) {
    return this.pp_getObjectsByNameBreadth(name, index);
  };
  sceneExtension.pp_getObjectsByNameBreadth = function pp_getObjectsByNameBreadth(name, index = 0) {
    return this.pp_getRoot().pp_getObjectsByNameHierarchyBreadth(name, index);
  };
  sceneExtension.pp_getObjectsByNameDepth = function pp_getObjectsByNameDepth(name, index = 0) {
    return this.pp_getRoot().pp_getObjectsByNameHierarchyDepth(name, index);
  };
  sceneExtension.pp_getObjectByID = function pp_getObjectByID(id) {
    return this.pp_getObjectByIDBreadth(id);
  };
  sceneExtension.pp_getObjectByIDBreadth = function pp_getObjectByIDBreadth(id) {
    return this.pp_getRoot().pp_getObjectByIDHierarchyBreadth(id);
  };
  sceneExtension.pp_getObjectByIDDepth = function pp_getObjectByIDDepth(id) {
    return this.pp_getRoot().pp_getObjectByIDHierarchyDepth(id);
  };
  sceneExtension.pp_toString = function pp_toString() {
    return this.pp_toStringCompact();
  };
  sceneExtension.pp_toStringCompact = function pp_toStringCompact() {
    return this.pp_getRoot().pp_toStringCompact();
  };
  sceneExtension.pp_toStringExtended = function pp_toStringExtended() {
    return this.pp_getRoot().pp_toStringExtended();
  };
  sceneExtension.pp_getComponentsAmountMap = function pp_getComponentsAmountMap(amountMap = /* @__PURE__ */ new Map()) {
    return this.pp_getRoot().pp_getComponentsAmountMap(amountMap);
  };
  ExtensionUtils.assignProperties(sceneExtension, Scene.prototype, false, true, true);
}

// js/pp/plugin/wl/extensions/init_wl_extentions.js
function initWLExtensions(engine2) {
  initObjectExtension();
  initSceneExtension(engine2);
}

// js/pp/plugin/wl/mods/components/component_clone_mod.js
import { MeshComponent as MeshComponent2, CollisionComponent, TextComponent as TextComponent2, PhysXComponent } from "@wonderlandengine/api";

// js/pp/cauldron/utils/mesh_utils.js
import { Mesh, MeshAttribute, MeshIndexType } from "@wonderlandengine/api";

// js/pp/cauldron/wl/engine_globals.js
var _myMainEngine = null;
var _myEngines = [];
function initEngine(engine2) {
  if (engine2 != null) {
    addEngine(engine2);
    if (getMainEngine2() == null) {
      setMainEngine(engine2);
    }
  }
}
function getMainEngine2() {
  return _myMainEngine;
}
function setMainEngine(engine2) {
  if (hasEngine(engine2)) {
    _myMainEngine = engine2;
  }
}
function getEngines() {
  return _myEngines;
}
function addEngine(engine2) {
  removeEngine(engine2);
  _myEngines.push(engine2);
}
function removeEngine(engine2) {
  let index = _myEngines.indexOf(engine2);
  if (index >= 0) {
    _myEngines.splice(index, 1);
  }
}
function hasEngine(engine2) {
  return _myEngines.indexOf(engine2) >= 0;
}

// js/pp/cauldron/utils/mesh_utils.js
var MeshCreationVertexParams = class {
  constructor() {
    this.myPosition = null;
    this.myTextureCoordinates = null;
    this.myNormal = null;
    this.myColor = null;
  }
};
var MeshCreationTriangleParams = class {
  constructor() {
    this.myIndexes = new Uint32Array(3);
  }
};
var MeshCreationParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myVertexes = [];
    this.myTriangles = [];
    this.myEngine = engine2;
  }
};
function createPlaneMesh() {
  let vertexCount = 4;
  let meshParams = new MeshCreationParams();
  for (let i = 0; i < vertexCount; ++i) {
    let vertexParams = new MeshCreationVertexParams();
    vertexParams.myPosition = new vec3_create2();
    vertexParams.myPosition[0] = -1 + (i & 1) * 2;
    vertexParams.myPosition[1] = -1 + ((i & 2) >> 1) * 2;
    vertexParams.myPosition[2] = 0;
    vertexParams.myTextureCoordinates = new vec2_create();
    vertexParams.myTextureCoordinates[0] = i & 1;
    vertexParams.myTextureCoordinates[1] = (i & 2) >> 1;
    vertexParams.myNormal = new vec3_create2();
    vertexParams.myNormal[0] = 0;
    vertexParams.myNormal[1] = 0;
    vertexParams.myNormal[2] = 1;
    meshParams.myVertexes.push(vertexParams);
  }
  let firstTriangle = new MeshCreationTriangleParams();
  firstTriangle.myIndexes[0] = 0;
  firstTriangle.myIndexes[1] = 1;
  firstTriangle.myIndexes[2] = 2;
  let secondTriangle = new MeshCreationTriangleParams();
  secondTriangle.myIndexes[0] = 2;
  secondTriangle.myIndexes[1] = 1;
  secondTriangle.myIndexes[2] = 3;
  meshParams.myTriangles.push(firstTriangle);
  meshParams.myTriangles.push(secondTriangle);
  let mesh = createMesh(meshParams);
  return mesh;
}
function createMesh(meshCreationParams) {
  let indexData = [];
  for (let triangle of meshCreationParams.myTriangles) {
    indexData.push(triangle.myIndexes[0]);
    indexData.push(triangle.myIndexes[1]);
    indexData.push(triangle.myIndexes[2]);
  }
  let indexDataUnsignedInt = new Uint32Array(indexData.length);
  indexDataUnsignedInt.pp_copy(indexData);
  let vertexCount = meshCreationParams.myVertexes.length;
  let mesh = new Mesh(meshCreationParams.myEngine, {
    vertexCount,
    indexData: indexDataUnsignedInt,
    indexType: MeshIndexType.UnsignedInt
  });
  let positionAttribute = null;
  let textureCoordinatesAttribute = null;
  let normalAttribute = null;
  let colorAttribute = null;
  try {
    positionAttribute = mesh.attribute(MeshAttribute.Position);
  } catch (error) {
    positionAttribute = null;
  }
  try {
    textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
  } catch (error) {
    textureCoordinatesAttribute = null;
  }
  try {
    normalAttribute = mesh.attribute(MeshAttribute.Normal);
  } catch (error) {
    normalAttribute = null;
  }
  try {
    colorAttribute = mesh.attribute(MeshAttribute.Color);
  } catch (error) {
    colorAttribute = null;
  }
  for (let i = 0; i < meshCreationParams.myVertexes.length; i++) {
    let vertex = meshCreationParams.myVertexes[i];
    if (positionAttribute != null && vertex.myPosition) {
      positionAttribute.set(i, vertex.myPosition);
    }
    if (textureCoordinatesAttribute != null && vertex.myTextureCoordinates) {
      textureCoordinatesAttribute.set(i, vertex.myTextureCoordinates);
    }
    if (normalAttribute != null && vertex.myNormal) {
      normalAttribute.set(i, vertex.myNormal);
    }
    if (colorAttribute != null && vertex.myColor) {
      colorAttribute.set(i, vertex.myColor);
    }
  }
  return mesh;
}
var cloneMesh = function() {
  let position = vec3_create2();
  let textureCoordinates = vec2_create();
  let normal = vec3_create2();
  let color = vec4_create2();
  return function cloneMesh2(mesh) {
    if (mesh == null) {
      return null;
    }
    let clonedIndexData = new Uint32Array(mesh.indexData.length);
    for (let i = 0; i < mesh.indexData.length; i++) {
      clonedIndexData[i] = mesh.indexData[i];
    }
    let clonedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount,
      indexData: clonedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let clonedPositionAttribute = null;
    let clonedTextureCoordinatesAttribute = null;
    let clonedNormalAttribute = null;
    let clonedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      clonedPositionAttribute = clonedMesh.attribute(MeshAttribute.Position);
    } catch (error) {
      positionAttribute = null;
      clonedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      clonedTextureCoordinatesAttribute = clonedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error) {
      textureCoordinatesAttribute = null;
      clonedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      clonedNormalAttribute = clonedMesh.attribute(MeshAttribute.Normal);
    } catch (error) {
      normalAttribute = null;
      clonedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      clonedColorAttribute = clonedMesh.attribute(MeshAttribute.Color);
    } catch (error) {
      colorAttribute = null;
      clonedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && clonedPositionAttribute != null) {
        clonedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && clonedTextureCoordinatesAttribute != null) {
        clonedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && clonedNormalAttribute != null) {
        clonedNormalAttribute.set(i, normalAttribute.get(i, normal));
      }
      if (colorAttribute != null && clonedColorAttribute != null) {
        clonedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return clonedMesh;
  };
}();
var invertMesh = function() {
  let position = vec3_create2();
  let textureCoordinates = vec2_create();
  let normal = vec3_create2();
  let color = vec4_create2();
  return function invertMesh2(mesh) {
    if (mesh == null) {
      return null;
    }
    let invertedIndexData = new Uint32Array(mesh.indexData.length);
    for (let i = 0; i < mesh.indexData.length / 3; i++) {
      invertedIndexData[i * 3 + 0] = mesh.indexData[i * 3 + 2];
      invertedIndexData[i * 3 + 1] = mesh.indexData[i * 3 + 1];
      invertedIndexData[i * 3 + 2] = mesh.indexData[i * 3 + 0];
    }
    let invertedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount,
      indexData: invertedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let invertedPositionAttribute = null;
    let invertedTextureCoordinatesAttribute = null;
    let invertedNormalAttribute = null;
    let invertedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      invertedPositionAttribute = invertedMesh.attribute(MeshAttribute.Position);
    } catch (error) {
      positionAttribute = null;
      invertedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      invertedTextureCoordinatesAttribute = invertedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error) {
      textureCoordinatesAttribute = null;
      invertedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      invertedNormalAttribute = invertedMesh.attribute(MeshAttribute.Normal);
    } catch (error) {
      normalAttribute = null;
      invertedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      invertedColorAttribute = invertedMesh.attribute(MeshAttribute.Color);
    } catch (error) {
      colorAttribute = null;
      invertedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && invertedPositionAttribute != null) {
        invertedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && invertedTextureCoordinatesAttribute != null) {
        invertedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && invertedNormalAttribute != null) {
        normalAttribute.get(i, normal);
        normal.vec3_negate(normal);
        invertedNormalAttribute.set(i, normal);
      }
      if (colorAttribute != null && invertedColorAttribute != null) {
        invertedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return invertedMesh;
  };
}();
var MeshUtils = {
  createPlaneMesh,
  createMesh,
  cloneMesh,
  invertMesh
};

// js/pp/plugin/wl/mods/components/component_clone_mod.js
function initComponentCloneMod() {
  MeshComponent2.prototype.pp_clone = function pp_clone(targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
    let clonedComponent = targetObject.pp_addComponent(this.type);
    clonedComponent.active = this.active;
    if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent2.TypeName, "material")) {
      clonedComponent.material = this.material.clone();
    } else {
      clonedComponent.material = this.material;
    }
    if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent2.TypeName, "mesh")) {
      clonedComponent.mesh = MeshUtils.cloneMesh(this.mesh);
    } else {
      clonedComponent.mesh = this.mesh;
    }
    clonedComponent.skin = this.skin;
    return clonedComponent;
  };
  CollisionComponent.prototype.pp_clone = function pp_clone(targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
    let clonedComponent = targetObject.pp_addComponent(this.type);
    clonedComponent.active = this.active;
    clonedComponent.collider = this.collider;
    clonedComponent.extents = this.extents.pp_clone();
    clonedComponent.group = this.group;
    return clonedComponent;
  };
  TextComponent2.prototype.pp_clone = function pp_clone(targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
    let clonedComponent = targetObject.pp_addComponent(this.type);
    clonedComponent.active = this.active;
    if (deepCloneParams.isDeepCloneComponent(TextComponent2.TypeName)) {
      clonedComponent.text = this.text.slice(0);
    } else {
      clonedComponent.text = this.text;
    }
    if (deepCloneParams.isDeepCloneComponentVariable(TextComponent2.TypeName, "material")) {
      clonedComponent.material = this.material.clone();
    } else {
      clonedComponent.material = this.material;
    }
    clonedComponent.alignment = this.alignment;
    clonedComponent.justification = this.justification;
    return clonedComponent;
  };
  PhysXComponent.prototype.pp_clone = function pp_clone(targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
    let componentParams = {
      "static": this.static,
      "simulate": this.simulate,
      "angularDamping": this.angularDamping,
      "dynamicFriction": this.dynamicFriction,
      "extents": this.extents,
      "kinematic": this.kinematic,
      "linearDamping": this.linearDamping,
      "mass": this.mass,
      "restituition": this.restituition,
      "shape": this.shape,
      "shapeData": this.shapeData,
      "staticFriction": this.staticFriction,
      "bounciness": this.bounciness,
      "allowQuery": this.allowQuery,
      "allowSimulation": this.allowSimulation,
      "gravity": this.gravity,
      "trigger": this.trigger
    };
    if (!this.static) {
      componentParams["angularVelocity"] = this.angularVelocity;
      componentParams["linearVelocity"] = this.linearVelocity;
    }
    let clonedComponent = targetObject.pp_addComponent(this.type, componentParams);
    clonedComponent.active = this.active;
    return clonedComponent;
  };
  Object.defineProperty(MeshComponent2.prototype, "pp_clone", { enumerable: false });
  Object.defineProperty(CollisionComponent.prototype, "pp_clone", { enumerable: false });
  Object.defineProperty(TextComponent2.prototype, "pp_clone", { enumerable: false });
  Object.defineProperty(PhysXComponent.prototype, "pp_clone", { enumerable: false });
}

// js/pp/plugin/wl/mods/components/cursor_component_mod.js
import { InputComponent, ViewComponent } from "@wonderlandengine/api";
import { Cursor, CursorTarget } from "@wonderlandengine/components";

// js/pp/cauldron/utils/xr_utils.js
function getSession(engine2 = getMainEngine2()) {
  return engine2.xrSession;
}
function isSessionActive(engine2 = getMainEngine2()) {
  return getSession(engine2) != null;
}
function registerSessionStartEventListener(id, callback, engine2 = getMainEngine2()) {
  engine2.onXRSessionStart.add(callback, { id });
}
function unregisterSessionStartEventListener(id, engine2 = getMainEngine2()) {
  engine2.onXRSessionStart.remove(id);
}
function registerSessionEndEventListener(id, callback, engine2 = getMainEngine2()) {
  engine2.onXRSessionEnd.add(callback, { id });
}
function unregisterSessionEndEventListener(id, engine2 = getMainEngine2()) {
  return engine2.onXRSessionEnd.remove(id);
}
function registerSessionStartEndEventListeners(id, startCallback, endCallback, manuallyCallSessionStartIfSessionAlreadyActive = false, addManualCallFlagToStartCallback = false, engine2 = getMainEngine2()) {
  if (manuallyCallSessionStartIfSessionAlreadyActive && isSessionActive(engine2)) {
    if (addManualCallFlagToStartCallback) {
      startCallback(true, getSession(engine2));
    } else {
      startCallback(getSession(engine2));
    }
  }
  if (addManualCallFlagToStartCallback) {
    registerSessionStartEventListener(id, startCallback.bind(void 0, false), engine2);
  } else {
    registerSessionStartEventListener(id, startCallback, engine2);
  }
  registerSessionEndEventListener(id, endCallback, engine2);
}
function unregisterSessionStartEndEventListeners(id, engine2 = getMainEngine2()) {
  unregisterSessionStartEventListener(id, engine2);
  unregisterSessionEndEventListener(id, engine2);
}
function isReferenceSpaceLocalFloor(engine2 = getMainEngine2()) {
  return !["local", "viewer"].includes(getReferenceSpaceType(engine2));
}
function getReferenceSpaceType(engine2 = getMainEngine2()) {
  let refSpace = "local";
  try {
    refSpace = getWebXR(engine2).refSpace;
    ;
  } catch (error) {
  }
  return refSpace;
}
function getWebXR(engine2 = getMainEngine2()) {
  return engine2.wasm.WebXR;
}
function getFrame(engine2 = getMainEngine2()) {
  return engine2.xrFrame;
}
function isVRSupported(engine2 = getMainEngine2()) {
  return engine2.vrSupported;
}
function isARSupported(engine2 = getMainEngine2()) {
  return engine2.arSupported;
}
function isDeviceEmulated() {
  let isEmulated = "CustomWebXRPolyfill" in window;
  return isEmulated;
}
var XRUtils = {
  getSession,
  isSessionActive,
  registerSessionStartEventListener,
  unregisterSessionStartEventListener,
  registerSessionEndEventListener,
  unregisterSessionEndEventListener,
  registerSessionStartEndEventListeners,
  unregisterSessionStartEndEventListeners,
  isReferenceSpaceLocalFloor,
  getReferenceSpaceType,
  getFrame,
  isVRSupported,
  isARSupported,
  isDeviceEmulated
};

// js/pp/input/cauldron/input_types.js
var Handedness = {
  LEFT: "left",
  RIGHT: "right"
};
var HandednessIndex = {
  LEFT: 0,
  RIGHT: 1
};
var InputSourceType = {
  GAMEPAD: 0,
  TRACKED_HAND: 1
};
var TrackedHandJointID = {
  WRIST: "wrist",
  THUMB_METACARPAL: "thumb-metacarpal",
  THUMB_PHALANX_PROXIMAL: "thumb-phalanx-proximal",
  THUMB_PHALANX_DISTAL: "thumb-phalanx-distal",
  THUMB_TIP: "thumb-tip",
  INDEX_FINGER_METACARPAL: "index-finger-metacarpal",
  INDEX_FINGER_PHALANX_PROXIMAL: "index-finger-phalanx-proximal",
  INDEX_FINGER_PHALANX_INTERMEDIATE: "index-finger-phalanx-intermediate",
  INDEX_FINGER_PHALANX_DISTAL: "index-finger-phalanx-distal",
  INDEX_FINGER_TIP: "index-finger-tip",
  MIDDLE_FINGER_METACARPAL: "middle-finger-metacarpal",
  MIDDLE_FINGER_PHALANX_PROXIMAL: "middle-finger-phalanx-proximal",
  MIDDLE_FINGER_PHALANX_INTERMEDIATE: "middle-finger-phalanx-intermediate",
  MIDDLE_FINGER_PHALANX_DISTAL: "middle-finger-phalanx-distal",
  MIDDLE_FINGER_TIP: "middle-finger-tip",
  RING_FINGER_METACARPAL: "ring-finger-metacarpal",
  RING_FINGER_PHALANX_PROXIMAL: "ring-finger-phalanx-proximal",
  RING_FINGER_PHALANX_INTERMEDIATE: "ring-finger-phalanx-intermediate",
  RING_FINGER_PHALANX_DISTAL: "ring-finger-phalanx-distal",
  RING_FINGER_TIP: "ring-finger-tip",
  PINKY_FINGER_METACARPAL: "pinky-finger-metacarpal",
  PINKY_FINGER_PHALANX_PROXIMAL: "pinky-finger-phalanx-proximal",
  PINKY_FINGER_PHALANX_INTERMEDIATE: "pinky-finger-phalanx-intermediate",
  PINKY_FINGER_PHALANX_DISTAL: "pinky-finger-phalanx-distal",
  PINKY_FINGER_TIP: "pinky-finger-tip"
};
var TrackedHandJointIDIndex = {
  WRIST: 0,
  THUMB_METACARPAL: 1,
  THUMB_PHALANX_PROXIMAL: 2,
  THUMB_PHALANX_DISTAL: 3,
  THUMB_TIP: 4,
  INDEX_FINGER_METACARPAL: 5,
  INDEX_FINGER_PHALANX_PROXIMAL: 6,
  INDEX_FINGER_PHALANX_INTERMEDIATE: 7,
  INDEX_FINGER_PHALANX_DISTAL: 8,
  INDEX_FINGER_TIP: 9,
  MIDDLE_FINGER_METACARPAL: 10,
  MIDDLE_FINGER_PHALANX_PROXIMAL: 11,
  MIDDLE_FINGER_PHALANX_INTERMEDIATE: 12,
  MIDDLE_FINGER_PHALANX_DISTAL: 13,
  MIDDLE_FINGER_TIP: 14,
  RING_FINGER_METACARPAL: 15,
  RING_FINGER_PHALANX_PROXIMAL: 16,
  RING_FINGER_PHALANX_INTERMEDIATE: 17,
  RING_FINGER_PHALANX_DISTAL: 18,
  RING_FINGER_TIP: 19,
  PINKY_FINGER_METACARPAL: 20,
  PINKY_FINGER_PHALANX_PROXIMAL: 21,
  PINKY_FINGER_PHALANX_INTERMEDIATE: 22,
  PINKY_FINGER_PHALANX_DISTAL: 23,
  PINKY_FINGER_TIP: 24
};

// js/pp/input/cauldron/input_utils.js
function getHandednessByIndex(index) {
  let handedness = null;
  switch (index) {
    case HandednessIndex.LEFT:
      handedness = Handedness.LEFT;
      break;
    case HandednessIndex.RIGHT:
      handedness = Handedness.RIGHT;
      break;
  }
  return handedness;
}
function getInputSource(handedness, inputSourceType = null, engine2 = getMainEngine2()) {
  let inputSource = null;
  let xrSession = XRUtils.getSession(engine2);
  if (xrSession != null && xrSession.inputSources) {
    for (let i = 0; i < xrSession.inputSources.length; i++) {
      let input = xrSession.inputSources[i];
      let isCorrectType = !inputSourceType || inputSourceType == InputSourceType.GAMEPAD && !input.hand || inputSourceType == InputSourceType.TRACKED_HAND && input.hand;
      if (isCorrectType && input.handedness == handedness) {
        inputSource = input;
        break;
      }
    }
  }
  return inputSource;
}
function getInputSourceTypeByHandedness(handedness, engine2) {
  let inputSource = getInputSource(handedness, void 0, engine2);
  return getInputSourceType(inputSource);
}
function getInputSourceType(inputSource) {
  let inputSourceType = null;
  if (inputSource) {
    if (inputSource.hand) {
      inputSourceType = InputSourceType.TRACKED_HAND;
    } else {
      inputSourceType = InputSourceType.GAMEPAD;
    }
  }
  return inputSourceType;
}
function getOppositeHandedness(handedness) {
  let oppositeHandedness = null;
  switch (handedness) {
    case Handedness.LEFT:
      oppositeHandedness = Handedness.RIGHT;
      break;
    case Handedness.RIGHT:
      oppositeHandedness = Handedness.LEFT;
      break;
  }
  return oppositeHandedness;
}
function getJointIDByIndex(index) {
  let jointID = null;
  let jointIDKey = null;
  for (let jointIDIndexKey in TrackedHandJointIDIndex) {
    if (TrackedHandJointIDIndex[jointIDIndexKey] == index) {
      jointIDKey = jointIDIndexKey;
      break;
    }
  }
  if (jointIDKey != null) {
    jointID = TrackedHandJointID[jointIDKey];
  }
  return jointID;
}
var InputUtils = {
  getHandednessByIndex,
  getInputSource,
  getInputSourceTypeByHandedness,
  getInputSourceType,
  getOppositeHandedness,
  getJointIDByIndex
};

// js/pp/plugin/wl/mods/components/cursor_component_mod.js
function initCursorComponentMod() {
  initCursorComponentModPrototype();
}
function initCursorComponentModPrototype() {
  Cursor.prototype.init = function init() {
    this.session = null;
    this.collisionMask = 1 << this.collisionGroup;
    this.maxDistance = 100;
    this.doubleClickTimer = 0;
    this.tripleClickTimer = 0;
    this.multipleClickObject = null;
    this.multipleClickDelay = 0.3;
    this.visible = false;
    this.onDestroyCallbacks = [];
    this.prevHitLocationLocalToTarget = vec3_create2();
    this.pointerId = null;
    this.lastClientX = null;
    this.lastClientY = null;
    this.lastWidth = null;
    this.lastHeight = null;
  };
  Cursor.prototype.start = function start() {
    if (this.handedness == 0) {
      let inputComp = this.object.pp_getComponent(InputComponent);
      if (!inputComp) {
        console.warn("cursor component on object " + this.object.pp_getName() + ' was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness;
        this.input = inputComp;
      }
    } else {
      this.handedness = InputUtils.getHandednessByIndex(this.handedness - 1);
    }
    this.globalTarget = this.object.pp_addComponent(CursorTarget);
    this.transformQuat = quat2_create();
    this.rotationQuat = quat_create();
    this.transformMatrix = mat4_create();
    this.origin = vec3_create2();
    this.cursorObjScale = vec3_create2();
    this.direction = vec3_create2();
    this.tempQuat = quat_create();
    this.setViewComponent(this.object.pp_getComponent(ViewComponent));
    this.isHovering = false;
    this.visible = true;
    this.isDown = false;
    this.lastIsDown = false;
    this.isUpWithNoDown = false;
    this.isRealDown = false;
    this.cursorPos = vec3_create2();
    this.hoveringObject = null;
    XRUtils.registerSessionStartEventListener(this, this.setupVREvents.bind(this), this.engine);
    this.onDestroyCallbacks.push(() => {
      XRUtils.unregisterSessionStartEventListener(this, this.engine);
    });
    this.showRay = true;
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(true);
      this.showRay = false;
      this.cursorRayOrigin = vec3_create2();
      this.cursorRayScale = vec3_create2();
      this.cursorRayScale.set(this.cursorRayObject.pp_getScaleLocal());
      this._setCursorRayTransform(null);
    }
    this._setCursorVisibility(false);
  };
  Cursor.prototype.onViewportResize = function onViewportResize() {
    if (!this.viewComponent)
      return;
    this.viewComponent.projectionMatrix.mat4_invert(this.projectionMatrix);
  };
  Cursor.prototype._setCursorRayTransform = function _setCursorRayTransform(hitPosition) {
    if (!this.cursorRayObject)
      return;
    if (this.cursorRayScalingAxis != 4) {
      this.cursorRayObject.pp_resetScaleLocal();
      if (hitPosition != null) {
        this.cursorRayObject.pp_getPosition(this.cursorRayOrigin);
        let dist = this.cursorRayOrigin.vec3_distance(hitPosition);
        this.cursorRayScale[this.cursorRayScalingAxis] = dist;
        this.cursorRayObject.pp_scaleObject(this.cursorRayScale);
      }
    }
  };
  Cursor.prototype._setCursorVisibility = function _setCursorVisibility(visible) {
    this.visible = visible;
    if (!this.cursorObject)
      return;
    this.cursorObject.pp_setActive(visible);
  };
  Cursor.prototype.update = function update(dt) {
    if (this.doubleClickTimer > 0) {
      this.doubleClickTimer -= dt;
    }
    if (this.tripleClickTimer > 0) {
      this.tripleClickTimer -= dt;
    }
    this.doUpdate(false);
  };
  Cursor.prototype.doUpdate = function() {
    return function doUpdate(doClick) {
      if (this.session) {
        if (this.arTouchDown && this.input && XRUtils.getSession(this.engine).inputSources[0].handedness === "none" && XRUtils.getSession(this.engine).inputSources[0].gamepad) {
          let p = XRUtils.getSession(this.engine).inputSources[0].gamepad.axes;
          this.direction.vec3_set(p[0], -p[1], -1);
          this.updateDirection();
        } else {
          this.object.pp_getPosition(this.origin);
          this.object.pp_getForward(this.direction);
        }
        let rayHit = this.rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(this.origin, this.direction, this.collisionMask) : this.engine.physics.rayCast(this.origin, this.direction, this.collisionMask, this.maxDistance);
        if (rayHit.hitCount > 0) {
          this.cursorPos.set(rayHit.locations[0]);
        } else {
          this.cursorPos.fill(0);
        }
        this.hoverBehaviour(rayHit, doClick);
      } else {
        if (this.viewComponent != null && this.lastClientX != null) {
          let rayHit = this.updateMousePos(this.lastClientX, this.lastClientY, this.lastWidth, this.lastHeight);
          this.hoverBehaviour(rayHit, false);
        }
      }
      if (this.cursorObject) {
        if (this.hoveringObject && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
          this._setCursorVisibility(true);
          this.cursorObject.pp_setPosition(this.cursorPos);
          this.cursorObject.pp_setTransformLocalQuat(this.cursorObject.pp_getTransformLocalQuat(this.transformQuat).quat2_normalize(this.transformQuat));
          this._setCursorRayTransform(this.cursorPos);
        } else {
          if (this.visible && this.cursorRayObject) {
            this._setCursorRayTransform(null);
          }
          this._setCursorVisibility(false);
        }
      }
      if (this.cursorRayObject) {
        this.cursorRayObject.pp_setActive(true);
      }
      if (this.hoveringObject == null) {
        this.pointerId = null;
      }
    };
  }();
  Cursor.prototype.hoverBehaviour = function hoverBehaviour(rayHit, doClick, forceUnhover = false) {
    if (!forceUnhover && rayHit.hitCount > 0) {
      let hoveringObjectChanged = false;
      if (!this.hoveringObject || !this.hoveringObject.pp_equals(rayHit.objects[0])) {
        if (this.hoveringObject) {
          let cursorTarget3 = this.hoveringObject.pp_getComponent(CursorTarget);
          if (cursorTarget3)
            cursorTarget3.onUnhover(this.hoveringObject, this);
          this.globalTarget.onUnhover(this.hoveringObject, this);
        }
        hoveringObjectChanged = true;
        this.hoveringObject = rayHit.objects[0];
        if (this.styleCursor)
          document.body.style.cursor = "pointer";
        let cursorTarget2 = this.hoveringObject.pp_getComponent(CursorTarget);
        if (cursorTarget2) {
          cursorTarget2.onHover(this.hoveringObject, this);
        }
        this.globalTarget.onHover(this.hoveringObject, this);
        if (!this._isDown() && this.isRealDown) {
          this.isDown = false;
          this.lastIsDown = false;
          this.isUpWithNoDown = false;
          if (cursorTarget2)
            cursorTarget2.onDownOnHover(this.hoveringObject, this);
          this.globalTarget.onDownOnHover(this.hoveringObject, this);
        }
      }
      let cursorTarget = this.hoveringObject.pp_getComponent(CursorTarget);
      if (!hoveringObjectChanged && this._isMoving(rayHit.locations[0])) {
        if (cursorTarget)
          cursorTarget.onMove(this.hoveringObject, this);
        this.globalTarget.onMove(this.hoveringObject, this);
      }
      if (this._isDown()) {
        if (cursorTarget)
          cursorTarget.onDown(this.hoveringObject, this);
        this.globalTarget.onDown(this.hoveringObject, this);
        if (this.tripleClickTimer > 0 && this.multipleClickObject && this.multipleClickObject.pp_equals(this.hoveringObject)) {
          if (cursorTarget)
            cursorTarget.onTripleClick(this.hoveringObject, this);
          this.globalTarget.onTripleClick(this.hoveringObject, this);
          this.tripleClickTimer = 0;
        } else if (this.doubleClickTimer > 0 && this.multipleClickObject && this.multipleClickObject.pp_equals(this.hoveringObject)) {
          if (cursorTarget)
            cursorTarget.onDoubleClick(this.hoveringObject, this);
          this.globalTarget.onDoubleClick(this.hoveringObject, this);
          this.tripleClickTimer = this.multipleClickDelay;
          this.doubleClickTimer = 0;
        } else {
          if (cursorTarget)
            cursorTarget.onClick(this.hoveringObject, this);
          this.globalTarget.onClick(this.hoveringObject, this);
          this.tripleClickTimer = 0;
          this.doubleClickTimer = this.multipleClickDelay;
          this.multipleClickObject = this.hoveringObject;
        }
      } else {
        if (!this.isUpWithNoDown && !hoveringObjectChanged && this._isUp()) {
          if (cursorTarget)
            cursorTarget.onUp(this.hoveringObject, this);
          this.globalTarget.onUp(this.hoveringObject, this);
        } else if (this.isUpWithNoDown || hoveringObjectChanged && this._isUp()) {
          if (cursorTarget)
            cursorTarget.onUpWithNoDown(this.hoveringObject, this);
          this.globalTarget.onUpWithNoDown(this.hoveringObject, this);
        }
      }
      this.prevHitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(rayHit.locations[0], this.prevHitLocationLocalToTarget);
    } else if (this.hoveringObject && (forceUnhover || rayHit.hitCount == 0)) {
      let cursorTarget = this.hoveringObject.pp_getComponent(CursorTarget);
      if (cursorTarget)
        cursorTarget.onUnhover(this.hoveringObject, this);
      this.globalTarget.onUnhover(this.hoveringObject, this);
      this.hoveringObject = null;
      if (this.styleCursor)
        document.body.style.cursor = "default";
    }
    if (this.hoveringObject) {
      this.lastIsDown = this.isDown;
    } else {
      this.isDown = false;
      this.lastIsDown = false;
    }
    this.isUpWithNoDown = false;
  };
  Cursor.prototype.setupVREvents = function setupVREvents(s) {
    this.session = s;
    let onSessionEnd = function(e) {
      this.session = null;
    }.bind(this);
    s.addEventListener("end", onSessionEnd);
    let onSelect = this.onSelect.bind(this);
    s.addEventListener("select", onSelect);
    let onSelectStart = this.onSelectStart.bind(this);
    s.addEventListener("selectstart", onSelectStart);
    let onSelectEnd = this.onSelectEnd.bind(this);
    s.addEventListener("selectend", onSelectEnd);
    this.onDestroyCallbacks.push(() => {
      if (!this.session)
        return;
      s.removeEventListener("end", onSessionEnd);
      s.removeEventListener("select", onSelect);
      s.removeEventListener("selectstart", onSelectStart);
      s.removeEventListener("selectend", onSelectEnd);
    });
    this.onViewportResize();
  };
  Cursor.prototype.onSelect = function onSelect(e) {
  };
  Cursor.prototype.onSelectStart = function onSelectStart(e) {
    if (this.active) {
      this.arTouchDown = true;
      if (e.inputSource.handedness == this.handedness) {
        this.isDown = true;
      }
    }
    if (e.inputSource.handedness == this.handedness) {
      this.isRealDown = true;
    }
  };
  Cursor.prototype.onSelectEnd = function onSelectEnd(e) {
    if (this.active) {
      this.arTouchDown = false;
      if (e.inputSource.handedness == this.handedness) {
        if (!this.isDown) {
          this.isUpWithNoDown = true;
        }
        this.isDown = false;
      }
    }
    if (e.inputSource.handedness == this.handedness) {
      this.isRealDown = false;
    }
  };
  Cursor.prototype.onPointerMove = function onPointerMove(e) {
    if (this.active) {
      if (this.pointerId != null && this.pointerId != e.pointerId)
        return;
      let bounds = document.body.getBoundingClientRect();
      let rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
      this.hoverBehaviour(rayHit, false);
      if (this.hoveringObject != null) {
        this.pointerId = e.pointerId;
      } else {
        this.pointerId = null;
      }
    }
  };
  Cursor.prototype.onClick = function onClick(e) {
  };
  Cursor.prototype.onPointerDown = function onPointerDown(e) {
    if (this.pointerId != null && this.pointerId != e.pointerId || e.button !== 0)
      return;
    if (this.active) {
      let bounds = document.body.getBoundingClientRect();
      let rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
      this.isDown = true;
      this.isRealDown = true;
      this.hoverBehaviour(rayHit, false);
      if (this.hoveringObject != null) {
        this.pointerId = e.pointerId;
      } else {
        this.pointerId = null;
      }
    } else {
      this.isRealDown = true;
    }
  };
  Cursor.prototype.onPointerUp = function onPointerUp(e) {
    if (this.pointerId != null && this.pointerId != e.pointerId || e.button !== 0)
      return;
    if (this.active) {
      let bounds = document.body.getBoundingClientRect();
      let rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
      if (!this.isDown) {
        this.isUpWithNoDown = true;
      }
      this.isDown = false;
      this.isRealDown = false;
      this.hoverBehaviour(rayHit, false);
      if (this.hoveringObject != null) {
        this.pointerId = e.pointerId;
      } else {
        this.pointerId = null;
      }
    } else {
      this.isRealDown = false;
    }
  };
  Cursor.prototype.updateMousePos = function updateMousePos(clientX, clientY, w, h) {
    this.lastClientX = clientX;
    this.lastClientY = clientY;
    this.lastWidth = w;
    this.lastHeight = h;
    let left = clientX / w;
    let top = clientY / h;
    this.direction.vec3_set(left * 2 - 1, -top * 2 + 1, -1);
    return this.updateDirection();
  };
  Cursor.prototype.updateDirection = function() {
    let transformWorld = quat2_create();
    return function updateDirection() {
      this.object.pp_getPosition(this.origin);
      this.direction.vec3_transformMat4(this.projectionMatrix, this.direction);
      this.direction.vec3_normalize(this.direction);
      this.direction.vec3_transformQuat(this.object.pp_getTransformQuat(transformWorld), this.direction);
      let rayHit = this.rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(this.origin, this.direction, this.collisionMask) : this.engine.physics.rayCast(this.origin, this.direction, this.collisionMask, this.maxDistance);
      if (rayHit.hitCount > 0) {
        this.cursorPos.set(rayHit.locations[0]);
      } else {
        this.cursorPos.fill(0);
      }
      return rayHit;
    };
  }();
  Cursor.prototype.onDeactivate = function onDeactivate() {
    if (this.hoveringObject) {
      let cursorTarget = this.hoveringObject.pp_getComponent(CursorTarget);
      if (cursorTarget)
        cursorTarget.onUnhover(this.hoveringObject, this);
      this.globalTarget.onUnhover(this.hoveringObject, this);
    }
    this.hoveringObject = null;
    if (this.styleCursor)
      document.body.style.cursor = "default";
    this.isDown = false;
    this.lastIsDown = false;
    this.isUpWithNoDown = false;
    this._setCursorVisibility(false);
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
    }
    this.pointerId = null;
    this.lastClientX = null;
    this.lastClientY = null;
    this.lastWidth = null;
    this.lastHeight = null;
  };
  Cursor.prototype.onActivate = function onActivate() {
    this.showRay = true;
    this.isDown = false;
    this.lastIsDown = false;
    this.isUpWithNoDown = false;
  };
  Cursor.prototype.onDestroy = function onDestroy() {
    for (let f of this.onDestroyCallbacks)
      f();
  };
  Cursor.prototype.setViewComponent = function setViewComponent(viewComponent) {
    this.viewComponent = viewComponent;
    if (this.viewComponent != null) {
      let onClick = this.onClick.bind(this);
      this.engine.canvas.addEventListener("click", onClick);
      let onPointerDown = this.onPointerDown.bind(this);
      this.engine.canvas.addEventListener("pointerdown", onPointerDown);
      let onPointerMove = this.onPointerMove.bind(this);
      this.engine.canvas.addEventListener("pointermove", onPointerMove);
      let onPointerUp = this.onPointerUp.bind(this);
      this.engine.canvas.addEventListener("pointerup", onPointerUp);
      let onPointerLeave = this.onPointerLeave.bind(this);
      this.engine.canvas.addEventListener("pointerleave", onPointerLeave);
      this.projectionMatrix = mat4_create();
      this.viewComponent.projectionMatrix.mat4_invert(this.projectionMatrix);
      let onViewportResize = this.onViewportResize.bind(this);
      window.addEventListener("resize", onViewportResize);
      this.onDestroyCallbacks.push(() => {
        this.engine.canvas.removeEventListener("click", onClick);
        this.engine.canvas.removeEventListener("pointerdown", onPointerDown);
        this.engine.canvas.removeEventListener("pointermove", onPointerMove);
        this.engine.canvas.removeEventListener("pointerup", onPointerUp);
        this.engine.canvas.removeEventListener("pointerleave", onPointerLeave);
        window.removeEventListener("resize", onViewportResize);
      });
    }
  };
  Cursor.prototype.onPointerLeave = function onPointerLeave(e) {
    if (this.pointerId == null || this.pointerId == e.pointerId) {
      if (this.active) {
        this.hoverBehaviour(null, false, true);
      }
      this.pointerId = null;
      this.lastClientX = null;
      this.lastClientY = null;
      this.lastWidth = null;
      this.lastHeight = null;
    }
  };
  Cursor.prototype._isDown = function _isDown() {
    return this.isDown !== this.lastIsDown && this.isDown;
  };
  Cursor.prototype._isUp = function _isUp() {
    return this.isDown !== this.lastIsDown && !this.isDown;
  };
  Cursor.prototype._isMoving = function() {
    let hitLocationLocalToTarget = vec3_create2();
    return function _isMoving(hitLocation) {
      let isMoving = false;
      hitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, hitLocationLocalToTarget);
      if (!hitLocationLocalToTarget.vec_equals(this.prevHitLocationLocalToTarget, 1e-4)) {
        isMoving = true;
      }
      return isMoving;
    };
  }();
  Object.defineProperty(Cursor.prototype, "setViewComponent", { enumerable: false });
  Object.defineProperty(Cursor.prototype, "onPointerLeave", { enumerable: false });
  Object.defineProperty(Cursor.prototype, "_isDown", { enumerable: false });
  Object.defineProperty(Cursor.prototype, "_isMoving", { enumerable: false });
  Object.defineProperty(Cursor.prototype, "_isUp", { enumerable: false });
}

// js/pp/plugin/wl/mods/components/cursor_target_component_mod.js
import { CursorTarget as CursorTarget2 } from "@wonderlandengine/components";
function initCursorTargetComponentMod() {
  initCursorTargetComponentModPrototype();
}
function initCursorTargetComponentModPrototype() {
  CursorTarget2.prototype.init = function init() {
    this.hoverFunctions = [];
    this.unHoverFunctions = [];
    this.clickFunctions = [];
    this.doubleClickFunctions = [];
    this.tripleClickFunctions = [];
    this.moveFunctions = [];
    this.downFunctions = [];
    this.upFunctions = [];
    this.downOnHoverFunctions = [];
    this.upWithNoDownFunctions = [];
    this.isSurface = false;
  };
  CursorTarget2.prototype.onHover = function onHover(object, cursor) {
    for (let f of this.hoverFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.onUnhover = function onUnhover(object, cursor) {
    for (let f of this.unHoverFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.onClick = function onClick(object, cursor) {
    for (let f of this.clickFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.onMove = function onMove(object, cursor) {
    for (let f of this.moveFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.onDown = function onDown(object, cursor) {
    for (let f of this.downFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.onUp = function onUp(object, cursor) {
    for (let f of this.upFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.addHoverFunction = function addHoverFunction(f) {
    this._validateCallback(f);
    this.hoverFunctions.push(f);
  };
  CursorTarget2.prototype.removeHoverFunction = function removeHoverFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.hoverFunctions, f);
  };
  CursorTarget2.prototype.addUnHoverFunction = function addUnHoverFunction(f) {
    this._validateCallback(f);
    this.unHoverFunctions.push(f);
  };
  CursorTarget2.prototype.removeUnHoverFunction = function removeUnHoverFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.unHoverFunctions, f);
  };
  CursorTarget2.prototype.addClickFunction = function addClickFunction(f) {
    this._validateCallback(f);
    this.clickFunctions.push(f);
  };
  CursorTarget2.prototype.removeClickFunction = function removeClickFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.clickFunctions, f);
  };
  CursorTarget2.prototype.addMoveFunction = function addMoveFunction(f) {
    this._validateCallback(f);
    this.moveFunctions.push(f);
  };
  CursorTarget2.prototype.removeMoveFunction = function removeMoveFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.moveFunctions, f);
  };
  CursorTarget2.prototype.addDownFunction = function addDownFunction(f) {
    this._validateCallback(f);
    this.downFunctions.push(f);
  };
  CursorTarget2.prototype.removeDownFunction = function removeDownFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.downFunctions, f);
  };
  CursorTarget2.prototype.addUpFunction = function addUpFunction(f) {
    this._validateCallback(f);
    this.upFunctions.push(f);
  };
  CursorTarget2.prototype.removeUpFunction = function removeUpFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.upFunctions, f);
  };
  CursorTarget2.prototype._removeItemOnce = function _removeItemOnce(arr, value) {
    let index = arr.indexOf(value);
    if (index > -1)
      arr.splice(index, 1);
    return arr;
  };
  CursorTarget2.prototype._validateCallback = function _validateCallback(f) {
    if (typeof f !== "function") {
      throw new TypeError(this.object.pp_getName() + ".cursor-target: Argument needs to be a function");
    }
  };
  CursorTarget2.prototype.start = function start() {
  };
  CursorTarget2.prototype.update = function update(dt) {
  };
  CursorTarget2.prototype.onActivate = function onActivate() {
  };
  CursorTarget2.prototype.onDeactivate = function onDeactivate() {
  };
  CursorTarget2.prototype.onDestroy = function onDestroy() {
  };
  CursorTarget2.prototype.onDoubleClick = function onDoubleClick(object, cursor) {
    for (let f of this.doubleClickFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.addDoubleClickFunction = function addDoubleClickFunction(f) {
    this._validateCallback(f);
    this.doubleClickFunctions.push(f);
  };
  CursorTarget2.prototype.removeDoubleClickFunction = function removeDoubleClickFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.doubleClickFunctions, f);
  };
  CursorTarget2.prototype.onTripleClick = function onTripleClick(object, cursor) {
    for (let f of this.tripleClickFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.addTripleClickFunction = function addTripleClickFunction(f) {
    this._validateCallback(f);
    this.tripleClickFunctions.push(f);
  };
  CursorTarget2.prototype.removeTripleClickFunction = function removeTripleClickFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.tripleClickFunctions, f);
  };
  CursorTarget2.prototype.onDownOnHover = function onDownOnHover(object, cursor) {
    for (let f of this.downOnHoverFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.addDownOnHoverFunction = function addDownOnHoverFunction(f) {
    this._validateCallback(f);
    this.downOnHoverFunctions.push(f);
  };
  CursorTarget2.prototype.removeDownOnHoverFunction = function removeDownOnHoverFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.downOnHoverFunctions, f);
  };
  CursorTarget2.prototype.onUpWithNoDown = function onUpWithNoDown(object, cursor) {
    for (let f of this.upWithNoDownFunctions)
      f(object, cursor);
  };
  CursorTarget2.prototype.addUpWithNoDownFunction = function addUpWithNoDownFunction(f) {
    this._validateCallback(f);
    this.upWithNoDownFunctions.push(f);
  };
  CursorTarget2.prototype.removeUpWithNoDownFunction = function removeUpWithNoDownFunction(f) {
    this._validateCallback(f);
    this._removeItemOnce(this.upWithNoDownFunctions, f);
  };
  Object.defineProperty(CursorTarget2.prototype, "start", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "update", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onActivate", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onDeactivate", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onDestroy", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onDoubleClick", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "addDoubleClickFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "removeDoubleClickFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onTripleClick", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "addTripleClickFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "removeTripleClickFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onDownOnHover", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "addDownOnHoverFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "removeDownOnHoverFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "onUpWithNoDown", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "addUpWithNoDownFunction", { enumerable: false });
  Object.defineProperty(CursorTarget2.prototype, "removeUpWithNoDownFunction", { enumerable: false });
}

// js/pp/plugin/wl/mods/components/mouse_look_component_mod.js
import { MouseLookComponent } from "@wonderlandengine/components";

// js/pp/cauldron/cauldron/timer.js
var Timer = class {
  constructor(duration, autoStart = true) {
    this._myDuration = duration;
    this._myOnEndCallbacks = /* @__PURE__ */ new Map();
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
    if (autoStart) {
      this.start();
    } else {
      this.reset();
    }
  }
  start(duration = null) {
    this.reset(duration);
    this._myStarted = true;
  }
  end() {
    this._done();
  }
  reset(duration = null) {
    if (duration != null) {
      this._myDuration = Math.max(0, duration);
    }
    this._myTimeLeft = this._myDuration;
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
  }
  update(dt) {
    this._myJustDone = false;
    if (this.isRunning()) {
      this._myTimeLeft = Math.max(0, this._myTimeLeft - dt);
      if (this._myTimeLeft == 0) {
        this._done();
      }
    }
  }
  isDone() {
    return this._myDone;
  }
  isJustDone() {
    return this._myJustDone;
  }
  isStarted() {
    return this._myStarted;
  }
  isRunning() {
    return this.isStarted() && !this.isDone();
  }
  getDuration() {
    return this._myDuration;
  }
  setDuration(duration) {
    this._myDuration = Math.max(0, duration);
  }
  getTimeLeft() {
    return this._myTimeLeft;
  }
  getPercentage() {
    let percentage = 1;
    if (this._myTimeLeft > 0 && this._myDuration > 0) {
      percentage = (this._myDuration - this._myTimeLeft) / this._myDuration;
    }
    return Math.pp_clamp(percentage, 0, 1);
  }
  setPercentage(percentage) {
    if (this.isRunning()) {
      let durationPercentage = Math.pp_clamp(1 - percentage, 0, 1);
      this._myTimeLeft = this._myDuration * durationPercentage;
    }
  }
  onEnd(callback, id = null) {
    this._myOnEndCallbacks.set(id, callback);
  }
  unregisterOnEnd(id = null) {
    this._myOnEndCallbacks.delete(id);
  }
  _done() {
    this._myTimeLeft = 0;
    this._myDone = true;
    this._myJustDone = true;
    if (this._myOnEndCallbacks.size > 0) {
      for (let callback of this._myOnEndCallbacks.values()) {
        callback();
      }
    }
  }
};

// js/pp/plugin/wl/mods/components/mouse_look_component_mod.js
function initMouseLookComponentMod() {
  initMouseLookComponentModPrototype();
}
function initMouseLookComponentModPrototype() {
  MouseLookComponent.prototype.init = function init() {
    this.pointerId = null;
    this.prevMoveEvent = null;
    this.resetMovingDelay = 0.15;
    this.resetMovingTimer = new Timer(this.resetMovingDelay, false);
    this.isMoving = false;
    document.body.addEventListener("pointermove", this._onMove.bind(this));
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex == 2) {
        this.engine.canvas.addEventListener("contextmenu", function(event) {
          event.preventDefault();
        }, false);
      }
      this.engine.canvas.addEventListener("pointerdown", function(event) {
        if (this.pointerId != null)
          return;
        if (!this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.pointerId = event.pointerId;
            this.mouseDown = true;
            document.body.style.cursor = "grabbing";
            if (event.button == 1) {
              event.preventDefault();
              return false;
            }
          }
        }
      }.bind(this));
      document.body.addEventListener("pointerup", function(event) {
        if (event.pointerId != this.pointerId)
          return;
        if (this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.mouseDown = false;
            document.body.style.cursor = "initial";
          }
        }
      }.bind(this));
    }
    document.body.addEventListener("pointerleave", function(event) {
      if (event.pointerId != this.pointerId)
        return;
      this.pointerId = null;
      this.prevMoveEvent = null;
      if (this.mouseDown) {
        this.mouseDown = false;
        document.body.style.cursor = "initial";
      }
    }.bind(this));
  };
  MouseLookComponent.prototype.update = function update(dt) {
    if (this.resetMovingTimer.isRunning()) {
      this.resetMovingTimer.update(dt);
      if (this.resetMovingTimer.isDone()) {
        this.resetMovingTimer.reset();
        this.isMoving = false;
      }
    }
    if (!this.isMoving) {
      if (!this.requireMouseDown || !this.mouseDown) {
        this.pointerId = null;
      }
      this.prevMoveEvent = null;
    }
  };
  MouseLookComponent.prototype._onMove = function() {
    let viewForward = vec3_create2();
    let viewUp = vec3_create2();
    let referenceUp = vec3_create2();
    let referenceUpNegate = vec3_create2();
    let referenceRight = vec3_create2();
    let newUp = vec3_create2();
    return function _onMove(event) {
      if (this.pointerId != null && event.pointerId != this.pointerId)
        return;
      if (this.active && (this.mouseDown || !this.requireMouseDown)) {
        viewForward = this.object.pp_getBackward(viewForward);
        viewUp = this.object.pp_getUp(viewUp);
        referenceUp.vec3_set(0, 1, 0);
        if (this.object.pp_getParent() != null) {
          referenceUp = this.object.pp_getParent().pp_getUp(referenceUp);
        }
        referenceRight = viewForward.vec3_cross(referenceUp, referenceRight);
        let minAngle = 1;
        if (viewForward.vec3_angle(referenceUp) < minAngle) {
          referenceRight = viewUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
        } else if (viewForward.vec3_angle(referenceUp.vec3_negate(referenceUpNegate)) < minAngle) {
          referenceRight = viewUp.vec3_cross(referenceUp, referenceRight);
        } else if (!viewUp.vec3_isConcordant(referenceUp)) {
          referenceRight.vec3_negate(referenceRight);
        }
        referenceRight.vec3_normalize(referenceRight);
        let movementX = event.movementX;
        let movementY = event.movementY;
        if (movementX == null || movementY == null) {
          if (this.prevMoveEvent != null) {
            movementX = event.pageX - this.prevMoveEvent.pageX;
            movementY = event.pageY - this.prevMoveEvent.pageY;
          } else {
            movementX = 0;
            movementY = 0;
          }
        }
        this.rotationX = -this.sensitity * movementX;
        this.rotationY = -this.sensitity * movementY;
        this.object.pp_rotateAxis(this.rotationY, referenceRight);
        let maxVerticalAngle = 90 - 1e-3;
        newUp = this.object.pp_getUp(newUp);
        let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
        if (Math.abs(angleWithUp) > maxVerticalAngle) {
          let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
          this.object.pp_rotateAxis(fixAngle, referenceRight);
        }
        this.object.pp_rotateAxis(this.rotationX, referenceUp);
        this.prevMoveEvent = event;
        this.pointerId = event.pointerId;
        this.resetMovingTimer.start(this.resetMovingDelay);
        this.isMoving = true;
      }
    };
  }();
  Object.defineProperty(MouseLookComponent.prototype, "update", { enumerable: false });
  Object.defineProperty(MouseLookComponent.prototype, "_onMove", { enumerable: false });
}

// js/pp/plugin/wl/mods/components/init_component_mods.js
function initComponentMods() {
  initCursorComponentMod();
  initCursorTargetComponentMod();
  initMouseLookComponentMod();
  initComponentCloneMod();
}

// js/pp/plugin/wl/mods/init_wl_mods.js
function initWLMods() {
  initComponentMods();
}

// js/pp/plugin/wl/init_wl_plugins.js
function initWLPlugins(engine2) {
  initWLExtensions(engine2);
  initWLMods();
}

// js/pp/plugin/init_plugins.js
function initPlugins(engine2) {
  initJSPlugins();
  initWLPlugins(engine2);
}

// js/pp/cauldron/wl/register_wl_components.js
import { ARCamera8thwall, Cursor as Cursor2, CursorTarget as CursorTarget3, DebugObject, DeviceOrientationLook, FingerCursor, FixedFoveation, HandTracking, HitTestLocation, HowlerAudioListener, HowlerAudioSource, ImageTexture, MouseLookComponent as MouseLookComponent2, PlayerHeight, TargetFramerate, TeleportComponent, Trail, TwoJointIkSolver, VideoTexture, VrModeActiveSwitch, Vrm, WasdControlsComponent } from "@wonderlandengine/components";
function registerWLComponents(engine2) {
  engine2.registerComponent(ARCamera8thwall, Cursor2, CursorTarget3, DebugObject, DeviceOrientationLook, FingerCursor, FixedFoveation, HandTracking, HitTestLocation, HowlerAudioListener, HowlerAudioSource, ImageTexture, MouseLookComponent2, PlayerHeight, TargetFramerate, TeleportComponent, Trail, TwoJointIkSolver, VideoTexture, VrModeActiveSwitch, Vrm, WasdControlsComponent);
}

// js/pp/pp/register_pp_components.js
function registerPPComponents(engine2) {
  engine2.registerComponent(AddPPToWindowComponent, AddWLToWindowComponent, AdjustHierarchyPhysXScaleComponent, AudioManagerComponent, BenchmarkMaxPhysXComponent, BenchmarkMaxVisibleTrianglesComponent, CADisplayLeaderboardComponent, CharacterCollisionSystemComponent, CharacterControllerComponent, ClearConsoleOnXRSessionStartComponent, ConsoleVRToolComponent, CopyHandTransformComponent, CopyHeadTransformComponent, CopyPlayerPivotTransformComponent, CopyPlayerTransformComponent, DebugArrayFunctionsPerformanceAnalyzerComponent, DebugFunctionsPerformanceAnalyzerComponent, DebugManagerComponent, DebugPPFunctionsPerformanceAnalyzerComponent, DebugTransformComponent, DebugWLComponentsFunctionsPerformanceAnalyzerComponent, DebugWLFunctionsPerformanceAnalyzerComponent, EasyLightAttenuationComponent, EasyLightColorComponent, EasyMeshAmbientFactorComponent, EasyMeshColorComponent, EasyScaleComponent, EasySetTuneTargeetGrabComponent, EasySetTuneTargetChildNumberComponent, EasyTextColorComponent, EasyTransformComponent, EasyTuneImportVariablesComponent, EasyTuneToolComponent, EnableDebugsComponent, EnableToolsComponent, FingerCursorComponent, GamepadControlSchemeComponent, GamepadMeshAnimatorComponent, GetDefaultResourcesComponent, GetPlayerObjectsComponent, GlobalGravityComponent, GrabbableComponent, GrabberHandComponent, InitConsoleVRComponent, InitEasyTuneVariablesComponent, InputManagerComponent, MuteEverythingComponent, PPGatewayComponent, PlayerCharacterControllerComponent, PlayerHandCharacterControllerComponent, PlayerHeadCharacterControllerComponent, PlayerHeadControllerComponent, PlayerLocomotionComponent, PlayerLocomotionGravityComponent, PlayerLocomotionRotateComponent, PlayerLocomotionSmoothComponent, PlayerLocomotionTeleportComponent, PlayerViewOcclusionComponent, SetActiveComponent, SetHandLocalTransformComponent, SetHeadLocalTransformComponent, SetHeadNonVRLocalTransformComponent, SetHeadVRLocalTransformComponent, SetPlayerHeightComponent, SetTrackedHandJointLocalTransformComponent, ShowFPSComponent, SpatialAudioListenerComponent, SwitchHandObjectComponent, ToolCursorComponent, TrackedHandDrawAllJointsComponent, TrackedHandDrawJointComponent, TrackedHandDrawSkinComponent, VirtualGamepadComponent, VisualManagerComponent);
}

// js/pp/pp/init_pp.js
function initPP(engine2) {
  registerWLComponents(engine2);
  registerPPComponents(engine2);
  initEngine(engine2);
  initPlugins(engine2);
}

// js/pp/pp/player_objects.js
var PlayerObjects = class {
  constructor() {
    this.myPlayer = null;
    this.myPlayerPivot = null;
    this.myCameraNonVR = null;
    this.myHeadNonVR = null;
    this.myHeadVR = null;
    this.myHead = null;
    this.myEyeLeft = null;
    this.myEyeRight = null;
    this.myEyes = [];
    this.myHandLeft = null;
    this.myHandRight = null;
    this.myHands = [];
  }
};

// js/pp/pp/player_objects_global.js
var _myPlayerObjectsContainer = /* @__PURE__ */ new WeakMap();
function getPlayerObjects2(engine2 = getMainEngine2()) {
  return _myPlayerObjectsContainer.get(engine2);
}
function setPlayerObjects(playerObjects, engine2 = getMainEngine2()) {
  _myPlayerObjectsContainer.set(engine2, playerObjects);
}
function removePlayerObjects(engine2 = getMainEngine2()) {
  _myPlayerObjectsContainer.delete(engine2);
}
function hasPlayerObjects(engine2 = getMainEngine2()) {
  return _myPlayerObjectsContainer.has(engine2);
}

// js/pp/pp/default_resources.js
var DefaultResources = class {
  constructor() {
    this.myMeshes = new DefaultResourcesMeshes();
    this.myMaterials = new DefaultResourcesMaterials();
  }
};
var DefaultResourcesMeshes = class {
  constructor() {
    this.myPlane = null;
    this.myCube = null;
    this.mySphere = null;
    this.myCone = null;
    this.myCylinder = null;
    this.myCircle = null;
    this.myInvertedCube = null;
    this.myInvertedSphere = null;
    this.myInvertedCone = null;
    this.myInvertedCylinder = null;
  }
};
var DefaultResourcesMaterials = class {
  constructor() {
    this.myFlatOpaque = null;
    this.myFlatTransparentNoDepth = null;
    this.myPhongOpaque = null;
    this.myText = null;
  }
};

// js/pp/pp/default_resources_global.js
var _myDefaultResourcesContainer = /* @__PURE__ */ new WeakMap();
function getDefaultResources(engine2 = getMainEngine2()) {
  return _myDefaultResourcesContainer.get(engine2);
}
function setDefaultResources(defaultResources, engine2 = getMainEngine2()) {
  _myDefaultResourcesContainer.set(engine2, defaultResources);
}
function removeDefaultResources(engine2 = getMainEngine2()) {
  _myDefaultResourcesContainer.delete(engine2);
}
function hasDefaultResources(engine2 = getMainEngine2()) {
  return _myDefaultResourcesContainer.has(engine2);
}

// js/pp/pp/components/pp_gateway_component.js
import { Component as Component12, Property as Property12 } from "@wonderlandengine/api";

// js/pp/pp/components/add_pp_to_window_component.js
import { Component, Property } from "@wonderlandengine/api";
var AddPPToWindowComponent = class extends Component {
  init() {
    if (this._myAdd) {
      window.PP = {};
      this._addProperties(pp_exports);
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        window.PP[propertyName] = object[propertyName];
      }
    }
  }
};
__publicField(AddPPToWindowComponent, "TypeName", "pp-add-pp-to-window");
__publicField(AddPPToWindowComponent, "Properties", {
  _myAdd: Property.bool(true)
});

// js/pp/audio/components/audio_manager_component.js
import { Component as Component2, Property as Property2 } from "@wonderlandengine/api";

// js/pp/audio/audio_manager.js
import { Howler as Howler2 } from "howler";

// js/pp/audio/audio_player.js
import { Howl } from "howler";

// js/pp/audio/audio_setup.js
var AudioSetup = class {
  constructor(audioFilePath = null) {
    this.myAudioFilePath = audioFilePath ? audioFilePath.slice(0) : null;
    this.myLoop = false;
    this.myAutoplay = false;
    this.myVolume = 1;
    this._myRate = 1;
    this.myPool = 5;
    this.myPreload = true;
    this.myPreventPlayWhenAudioContextNotRunning = false;
    this.myPosition = null;
    this.mySpatial = true;
    this.myReferenceDistance = 1;
  }
  clone() {
    let audioSetup = new AudioSetup();
    audioSetup.myAudioFilePath = this.myAudioFilePath.slice(0);
    audioSetup.myLoop = this.myLoop;
    audioSetup.myAutoplay = this.myAutoplay;
    audioSetup.myVolume = this.myVolume;
    audioSetup.myPitch = this.myPitch;
    audioSetup.myRate = this.myRate;
    audioSetup.myPool = this.myPool;
    audioSetup.myPreload = this.myPreload;
    audioSetup.myPreventPlayWhenAudioContextNotRunning = this.myPreventPlayWhenAudioContextNotRunning;
    if (this.myPosition != null) {
      audioSetup.myPosition = this.myPosition.vec3_clone();
    } else {
      audioSetup.myPosition = null;
    }
    audioSetup.mySpatial = this.mySpatial;
    audioSetup.myReferenceDistance = this.myReferenceDistance;
    return audioSetup;
  }
  get myPitch() {
    return this._myRate;
  }
  get myRate() {
    return this._myRate;
  }
  set myPitch(pitch) {
    this._myRate = pitch;
  }
  set myRate(rate) {
    this._myRate = rate;
  }
};

// js/pp/audio/audio_player.js
var AudioEvent = {
  END: "end",
  STOP: "stop",
  LOAD: "load",
  LOAD_ERROR: "loaderror",
  PLAY: "play",
  PLAY_ERROR: "playerror",
  PAUSE: "pause",
  MUTE: "mute",
  VOLUME: "volume",
  RATE: "rate",
  SEEK: "seek",
  FADE: "fade",
  UNLOCK: "unlock"
};
var AudioPlayer = class {
  constructor(audioSetupOrAudioFilePath, createAudio = true) {
    if (audioSetupOrAudioFilePath == null) {
      this._myAudioSetup = new AudioSetup();
    } else if (typeof audioSetupOrAudioFilePath === "string") {
      this._myAudioSetup = new AudioSetup(audioSetupOrAudioFilePath);
    } else {
      this._myAudioSetup = audioSetupOrAudioFilePath.clone();
    }
    this._myAudio = null;
    if (createAudio) {
      this._myAudio = new Howl({
        src: [this._myAudioSetup.myAudioFilePath],
        loop: this._myAudioSetup.myLoop,
        volume: this._myAudioSetup.myVolume,
        autoplay: this._myAudioSetup.myAutoplay,
        rate: this._myAudioSetup.myRate,
        pool: this._myAudioSetup.myPool,
        pos: this._myAudioSetup.mySpatial ? this._myAudioSetup.myPosition : null,
        refDistance: this._myAudioSetup.myReferenceDistance,
        preload: this._myAudioSetup.myPreload
      });
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
    }
    this._myLastAudioID = null;
    this._myCallbacks = /* @__PURE__ */ new Map();
    for (let eventKey in AudioEvent) {
      this._myCallbacks.set(AudioEvent[eventKey], /* @__PURE__ */ new Map());
    }
    if (createAudio) {
      this._addListeners();
    }
  }
  isValid() {
    return this._myAudio != null;
  }
  play() {
    if (Howler.state != "running" && this._myAudioSetup.myPreventPlayWhenAudioContextNotRunning) {
      return false;
    }
    let audioID = this._myAudio.play();
    if (audioID != null) {
      this._myLastAudioID = audioID;
      this.updatePosition(this._myAudioSetup.myPosition, true);
      this.updatePitch(this._myAudioSetup.myPitch, true);
      this.updateVolume(this._myAudioSetup.myVolume, true);
    }
    return audioID != null;
  }
  stop() {
    this._myAudio.stop();
  }
  pause() {
    this._myAudio.pause();
  }
  resume() {
    this._myAudio.play();
  }
  isPlaying(checkOnlyLast = false) {
    let isPlaying = false;
    if (checkOnlyLast) {
      isPlaying = this._myAudio.playing(this._myLastAudioID);
    } else {
      isPlaying = this._myAudio.playing();
    }
    return isPlaying;
  }
  isLoaded() {
    return this._myAudio.state() == "loaded";
  }
  fade(fromVolume, toVolume, duration, updateOnlyLast = false) {
    this.setVolume(toVolume);
    if (updateOnlyLast) {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3, this._myLastAudioID);
    } else {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3);
    }
  }
  updatePosition(position, updateOnlyLast = false) {
    this.setPosition(position);
    if (this._myAudioSetup.mySpatial && position) {
      if (updateOnlyLast) {
        this._myAudio.pos(position[0], position[1], position[2], this._myLastAudioID);
      } else {
        this._myAudio.pos(position[0], position[1], position[2]);
      }
    }
  }
  updatePitch(pitch, updateOnlyLast = false) {
    this.updateRate(pitch, updateOnlyLast);
  }
  updateRate(rate, updateOnlyLast = false) {
    this.setRate(rate);
    if (rate != null) {
      if (updateOnlyLast) {
        this._myAudio.rate(rate, this._myLastAudioID);
      } else {
        this._myAudio.rate(rate);
      }
    }
  }
  updateVolume(volume, updateOnlyLast = false) {
    this.setVolume(volume);
    if (volume != null) {
      if (updateOnlyLast) {
        this._myAudio.volume(volume, this._myLastAudioID);
      } else {
        this._myAudio.volume(volume);
      }
    }
  }
  setSpatial(spatial) {
    this._myAudioSetup.mySpatial = spatial;
  }
  setPosition(position) {
    this._myAudioSetup.myPosition = position;
  }
  setPitch(pitch) {
    this._myAudioSetup.myPitch = pitch;
  }
  setRate(rate) {
    this._myAudioSetup.myRate = rate;
  }
  setVolume(volume) {
    this._myAudioSetup.myVolume = volume;
  }
  getDuration() {
    return this._myAudio.duration();
  }
  getVolume() {
    return this._myAudioSetup.myVolume;
  }
  getPitch() {
    return this._myAudioSetup.myPitch;
  }
  getRate() {
    return this._myAudioSetup.myRate;
  }
  registerAudioEventListener(audioEvent, listenerID, callback) {
    this._myCallbacks.get(audioEvent).set(listenerID, callback);
  }
  unregisterAudioEventListener(audioEvent, listenerID) {
    this._myCallbacks.get(audioEvent).delete(listenerID);
  }
  _addListeners() {
    if (this._myAudio != null) {
      for (let eventKey in AudioEvent) {
        let event = AudioEvent[eventKey];
        this._myAudio.on(event, function(audioID) {
          let callbacks = this._myCallbacks.get(event);
          for (let callback of callbacks.values()) {
            callback(audioID);
          }
        }.bind(this));
      }
    }
  }
};

// js/pp/audio/audio_manager.js
var AudioManager = class {
  constructor() {
    this._myAudioSetups = /* @__PURE__ */ new Map();
  }
  createAudioPlayer(audioSetupID) {
    let audioSetup = this.getAudioSetup(audioSetupID);
    if (audioSetup != null) {
      return new AudioPlayer(this.getAudioSetup(audioSetupID));
    }
    return null;
  }
  getAudioSetup(id) {
    return this._myAudioSetups.get(id);
  }
  addAudioSetup(id, audioSetup, preload = true) {
    this._myAudioSetups.set(id, audioSetup);
    if (preload) {
      this.createAudioPlayer(id);
    }
  }
  removeAudioSetup(id) {
    this._myAudioSetups.delete(id);
  }
  setVolume(volume) {
    Howler2.volume(volume);
  }
  setMute(mute) {
    Howler2.mute(mute);
  }
  stop() {
    Howler2.stop();
  }
};

// js/pp/audio/audio_manager_global.js
var _myAudioManagers = /* @__PURE__ */ new WeakMap();
function getAudioManager(engine2 = getMainEngine2()) {
  return _myAudioManagers.get(engine2);
}
function setAudioManager(audioManager, engine2 = getMainEngine2()) {
  _myAudioManagers.set(engine2, audioManager);
}
function removeAudioManager(engine2 = getMainEngine2()) {
  _myAudioManagers.delete(engine2);
}
function hasAudioManager(engine2 = getMainEngine2()) {
  return _myAudioManagers.has(engine2);
}

// js/pp/audio/components/audio_manager_component.js
var AudioManagerComponent = class extends Component2 {
  init() {
    this._myAudioManager = null;
    if (!hasAudioManager(this.engine)) {
      this._myAudioManager = new AudioManager();
      setAudioManager(this._myAudioManager, this.engine);
    }
  }
  onDestroy() {
    if (this._myAudioManager != null && getAudioManager(this.engine) == this._myAudioManager) {
      removeAudioManager(this.engine);
    }
  }
};
__publicField(AudioManagerComponent, "TypeName", "pp-audio-manager");
__publicField(AudioManagerComponent, "Properties", {});

// js/pp/cauldron/visual/components/visual_manager_component.js
import { Component as Component3, Property as Property3 } from "@wonderlandengine/api";

// js/pp/cauldron/visual/visual_data.js
var VisualData = class {
  constructor() {
    this.myRootObject = null;
    this.myDefaultMaterials = new VisualDataMaterials();
  }
};
var VisualDataMaterials = class {
  constructor() {
    this.myMesh = null;
    this.myText = null;
    this.myRight = null;
    this.myUp = null;
    this.myForward = null;
    this.myRay = null;
    this.myHitNormal = null;
  }
};

// js/pp/cauldron/visual/visual_globals.js
var _myVisualDatas = /* @__PURE__ */ new WeakMap();
var _myVisualManagers = /* @__PURE__ */ new WeakMap();
function getVisualData(engine2 = getMainEngineinEngine()) {
  return _myVisualDatas.get(engine2);
}
function setVisualData(visualData, engine2 = getMainEngine2()) {
  _myVisualDatas.set(engine2, visualData);
}
function removeVisualData(engine2 = getMainEngine2()) {
  _myVisualDatas.delete(engine2);
}
function hasVisualData(engine2 = getMainEngine2()) {
  return _myVisualDatas.has(engine2);
}
function getVisualManager(engine2 = getMainEngine2()) {
  return _myVisualManagers.get(engine2);
}
function setVisualManager(visualManager, engine2 = getMainEngine2()) {
  _myVisualManagers.set(engine2, visualManager);
}
function removeVisualManager(engine2 = getMainEngine2()) {
  _myVisualManagers.delete(engine2);
}
function hasVisualManager(engine2 = getMainEngine2()) {
  return _myVisualManagers.has(engine2);
}

// js/pp/cauldron/cauldron/object_pool.js
var ObjectPoolParams = class {
  constructor() {
    this.myInitialPoolSize = 0;
    this.myAmountToAddWhenEmpty = 0;
    this.myPercentageToAddWhenEmpty = 0;
    this.myCloneParams = void 0;
    this.myOptimizeObjectsAllocation = true;
    this.myCloneCallback = void 0;
    this.mySetActiveCallback = void 0;
    this.myEqualCallback = void 0;
    this.myOptimizeObjectsAllocationCallback = void 0;
    this.myDebugLogActive = false;
  }
};
var ObjectPool = class {
  constructor(poolObject, objectPoolParams) {
    this._myObjectPoolParams = objectPoolParams;
    this._myPrototype = this._clone(poolObject);
    this._myAvailableObjects = [];
    this._myBusyObjects = [];
    this._addToPool(objectPoolParams.myInitialPoolSize, false);
  }
  get() {
    let object = this._myAvailableObjects.shift();
    if (object == null) {
      let amountToAdd = Math.ceil(this._myBusyObjects.length * this._myObjectPoolParams.myPercentageToAddWhenEmpty);
      amountToAdd += this._myObjectPoolParams.myAmountToAddWhenEmpty;
      this._addToPool(amountToAdd, this._myObjectPoolParams.myDebugLogActive);
      object = this._myAvailableObjects.shift();
    }
    if (object != null) {
      this._myBusyObjects.push(object);
    }
    return object;
  }
  release(object) {
    let released = this._myBusyObjects.pp_remove(this._equals.bind(this, object));
    if (released) {
      this._setActive(released, false);
      this._myAvailableObjects.push(released);
    }
  }
  increase(amount) {
    this._addToPool(amount, false);
  }
  increasePercentage(percentage) {
    let amount = Math.ceil(this.getSize() * percentage);
    this._addToPool(amount, false);
  }
  getSize() {
    return this._myBusyObjects.length + this._myAvailableObjects.length;
  }
  getAvailableSize() {
    return this._myAvailableObjects.length;
  }
  getBusySize() {
    return this._myAvailableObjects.length;
  }
  _addToPool(size, log) {
    if (size <= 0) {
      return;
    }
    if (this._myObjectPoolParams.myOptimizeObjectsAllocation) {
      if (this._myObjectPoolParams.myOptimizeObjectsAllocationCallback) {
        this._myObjectPoolParams.myOptimizeObjectsAllocationCallback(this._myPrototype, size);
      } else if (this._myPrototype.pp_reserveObjects != null) {
        this._myPrototype.pp_reserveObjects(size);
      }
    }
    for (let i = 0; i < size; i++) {
      this._myAvailableObjects.push(this._clone(this._myPrototype));
    }
    if (log) {
      console.warn("Added new elements to the pool:", size);
    }
  }
  _clone(object) {
    let clone = null;
    if (this._myObjectPoolParams.myCloneCallback != null) {
      clone = this._myObjectPoolParams.myCloneCallback(object, this._myObjectPoolParams.myCloneParams);
    } else if (object.pp_clone != null) {
      clone = object.pp_clone(this._myObjectPoolParams.myCloneParams);
    } else if (object.clone != null) {
      clone = object.clone(this._myObjectPoolParams.myCloneParams);
    }
    if (clone == null) {
      console.error("Object not cloneable, pool will return null");
    } else {
      this._setActive(clone, false);
    }
    return clone;
  }
  _setActive(object, active) {
    if (this._myObjectPoolParams.mySetActiveCallback != null) {
      this._myObjectPoolParams.mySetActiveCallback(object, active);
    } else if (object.pp_setActive != null) {
      object.pp_setActive(active);
    } else if (object.setActive != null) {
      object.setActive(active);
    }
  }
  _equals(first, second) {
    let equals = false;
    if (this._myObjectPoolParams.myEqualCallback != null) {
      equals = this._myObjectPoolParams.myEqualCallback(first, second);
    } else if (first.pp_equals != null) {
      equals = first.pp_equals(second);
    } else if (first.equals != null) {
      equals = first.equals(second);
    } else {
      equals = first == second;
    }
    return equals;
  }
};

// js/pp/cauldron/cauldron/object_pools_manager.js
var ObjectPoolsManager = class {
  constructor() {
    this._myPools = /* @__PURE__ */ new Map();
  }
  addPool(poolID, poolObject, objectPoolParams = new ObjectPoolParams()) {
    if (!this._myPools.has(poolID)) {
      let pool = new ObjectPool(poolObject, objectPoolParams);
      this._myPools.set(poolID, pool);
    } else {
      console.error("Pool already created with this ID");
    }
  }
  increasePool(poolID, amount) {
    let pool = this._myPools.get(poolID);
    if (pool) {
      pool.increase(amount);
    }
  }
  increasePoolPercentage(poolID, percentage) {
    let pool = this._myPools.get(poolID);
    if (pool) {
      pool.increasePercentage(percentage);
    }
  }
  getPool(poolID) {
    return this._myPools.get(poolID);
  }
  hasPool(poolID) {
    return this._myPools.has(poolID);
  }
  getObject(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).get();
    }
    return null;
  }
  releaseObject(poolIDOrObject, object) {
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        pool.release(poolIDOrObject);
      }
    } else {
      this._myPools.get(poolIDOrObject).release(object);
    }
  }
};

// js/pp/cauldron/visual/elements/visual_element_types.js
var VisualElementType = {
  MESH: 0,
  LINE: 1,
  POINT: 2,
  TEXT: 3,
  ARROW: 4,
  TRANSFORM: 5,
  RAYCAST: 6,
  TORUS: 7
};

// js/pp/cauldron/visual/elements/visual_line.js
import { MeshComponent as MeshComponent3 } from "@wonderlandengine/api";
var VisualLineParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myStart = vec3_create2();
    this.myDirection = vec3_create2(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.LINE;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  copy(other2) {
  }
};
var VisualLine = class {
  constructor(params = new VisualLineParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myLineRootObject = null;
    this._myLineObject = null;
    this._myLineMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myLineRootObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _build() {
    this._myLineRootObject = this._myParams.myParent.pp_getEngine().scene.pp_addObject();
    this._myLineObject = this._myLineRootObject.pp_addObject();
    this._myLineMeshComponent = this._myLineObject.pp_addComponent(MeshComponent3);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualLineParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualLine(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
  _refresh() {
  }
};
VisualLine.prototype._refresh = function() {
  let scaleLine = vec3_create2();
  let translateLine = vec3_create2();
  let forward = vec3_create2(0, 1, 0);
  return function _refresh() {
    this._myLineRootObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myIsLocal) {
      this._myLineRootObject.pp_setPositionLocal(this._myParams.myStart);
    } else {
      this._myLineRootObject.pp_setPosition(this._myParams.myStart);
    }
    scaleLine.vec3_set(this._myParams.myThickness / 2, this._myParams.myLength / 2, this._myParams.myThickness / 2);
    if (this._myParams.myIsLocal) {
      this._myLineObject.pp_setScaleLocal(scaleLine);
    } else {
      this._myLineObject.pp_setScale(scaleLine);
    }
    if (this._myParams.myIsLocal) {
      this._myLineObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myLineObject.pp_setUp(this._myParams.myDirection, forward);
    }
    this._myLineObject.pp_resetPositionLocal();
    translateLine.vec3_set(0, this._myParams.myLength / 2, 0);
    this._myLineObject.pp_translateObject(translateLine);
    if (this._myParams.myMesh != null) {
      this._myLineMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myLineMeshComponent.mesh = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMeshes.myCylinder;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myLineMeshComponent.material = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMaterials.myFlatOpaque.clone();
        }
        this._myLineMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myLineMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualLineParams.prototype.copy = function copy(other2) {
  this.myStart.vec3_copy(other2.myStart);
  this.myDirection.vec3_copy(other2.myDirection);
  this.myLength = other2.myLength;
  this.myThickness = other2.myThickness;
  this.myMesh = other2.myMesh;
  if (other2.myMaterial != null) {
    this.myMaterial = other2.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other2.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other2.myColor);
    } else {
      this.myColor = other2.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/elements/visual_arrow.js
import { MeshComponent as MeshComponent4 } from "@wonderlandengine/api";
var VisualArrowParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myStart = vec3_create2();
    this.myDirection = vec3_create2(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myLineMesh = null;
    this.myArrowMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.ARROW;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  copy(other2) {
  }
};
var VisualArrow = class {
  constructor(params = new VisualArrowParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualLine = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualLine.setAutoRefresh(false);
    this._myArrowRootObject = null;
    this._myArrowObject = null;
    this._myArrowMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myVisualLine.setVisible(visible);
      this._myArrowRootObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualLine.forceRefresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualLine.update(dt);
  }
  _build() {
    this._myArrowRootObject = this._myParams.myParent.pp_getEngine().scene.pp_addObject();
    this._myArrowObject = this._myArrowRootObject.pp_addObject();
    this._myArrowMeshComponent = this._myArrowObject.pp_addComponent(MeshComponent4);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualArrowParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualArrow(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
  _refresh() {
  }
};
VisualArrow.prototype._refresh = function() {
  let end = vec3_create2();
  let translateRoot = vec3_create2();
  let scaleArrow = vec3_create2();
  let direction = vec3_create2();
  let forward = vec3_create2(0, 1, 0);
  return function _refresh() {
    this._myArrowRootObject.pp_setParent(this._myParams.myParent, false);
    this._myParams.myDirection.vec3_scale(Math.max(1e-3, this._myParams.myLength - this._myParams.myThickness * 4), end);
    end.vec3_add(this._myParams.myStart, end);
    if (this._myParams.myIsLocal) {
      this._myArrowRootObject.pp_setPositionLocal(end);
      this._myArrowRootObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myArrowRootObject.pp_setPosition(end);
      this._myArrowRootObject.pp_setUp(this._myParams.myDirection, forward);
    }
    translateRoot.vec3_set(0, this._myParams.myThickness * 2 - 1e-5, 0);
    this._myArrowRootObject.pp_translateObject(translateRoot);
    scaleArrow.vec3_set(this._myParams.myThickness * 1.25, this._myParams.myThickness * 2, this._myParams.myThickness * 1.25);
    if (this._myParams.myIsLocal) {
      this._myArrowObject.pp_setScaleLocal(scaleArrow);
    } else {
      this._myArrowObject.pp_setScale(scaleArrow);
    }
    if (this._myParams.myArrowMesh != null) {
      this._myArrowMeshComponent.mesh = this._myParams.myArrowMesh;
    } else {
      this._myArrowMeshComponent.mesh = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMeshes.myCone;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myArrowMeshComponent.material = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMaterials.myFlatOpaque.clone();
        }
        this._myArrowMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myArrowMeshComponent.material = this._myParams.myMaterial;
    }
    direction = end.vec3_sub(this._myParams.myStart, direction);
    let visualLineParams = this._myVisualLine.getParams();
    visualLineParams.myStart.vec3_copy(this._myParams.myStart);
    visualLineParams.myDirection = direction.vec3_normalize(visualLineParams.myDirection);
    visualLineParams.myLength = direction.vec3_length();
    visualLineParams.myThickness = this._myParams.myThickness;
    visualLineParams.myMesh = this._myParams.myLineMesh;
    visualLineParams.myMaterial = this._myArrowMeshComponent.material;
    visualLineParams.myParent = this._myParams.myParent;
    visualLineParams.myIsLocal = this._myParams.myIsLocal;
    this._myVisualLine.paramsUpdated();
  };
}();
VisualArrowParams.prototype.copy = function copy2(other2) {
  this.myStart.vec3_copy(other2.myStart);
  this.myDirection.vec3_copy(other2.myDirection);
  this.myLength = other2.myLength;
  this.myThickness = other2.myThickness;
  this.myArrowMesh = other2.myArrowMesh;
  this.myLineMesh = other2.myLineMesh;
  if (other2.myMaterial != null) {
    this.myMaterial = other2.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other2.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other2.myColor);
    } else {
      this.myColor = other2.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/elements/visual_mesh.js
import { MeshComponent as MeshComponent5 } from "@wonderlandengine/api";
var VisualMeshParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myTransform = mat4_create();
    this.myMesh = null;
    this.myMaterial = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.MESH;
  }
  copy(other2) {
  }
};
var VisualMesh = class {
  constructor(params = new VisualMeshParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myMeshObject = null;
    this._myMeshComponent = null;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myMeshObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _refresh() {
    this._myMeshObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myIsLocal) {
      this._myMeshObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myMeshObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myMesh == null) {
      this._myMeshComponent.mesh = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMeshes.mySphere;
    } else {
      this._myMeshComponent.mesh = this._myParams.myMesh;
    }
    if (this._myParams.myMaterial == null) {
      this._myMeshComponent.material = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
    } else {
      this._myMeshComponent.material = this._myParams.myMaterial;
    }
  }
  _build() {
    this._myMeshObject = this._myParams.myParent.pp_getEngine().scene.pp_addObject();
    this._myMeshComponent = this._myMeshObject.pp_addComponent(MeshComponent5);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualMeshParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualMesh(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
};
VisualMeshParams.prototype.copy = function copy3(other2) {
  this.myTransform.pp_copy(other2.myTransform);
  if (other2.myMesh != null) {
    this.myMesh = other2.myMesh;
  } else {
    this.myMesh = null;
  }
  if (other2.myMaterial != null) {
    this.myMaterial = other2.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/elements/visual_point.js
import { MeshComponent as MeshComponent6 } from "@wonderlandengine/api";
var VisualPointParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myPosition = vec3_create2();
    this.myRadius = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.POINT;
  }
  copy(other2) {
  }
};
var VisualPoint = class {
  constructor(params = new VisualPointParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myPointObject = null;
    this._myPointMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myPointObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _build() {
    this._myPointObject = this._myParams.myParent.pp_getEngine().scene.pp_addObject();
    this._myPointMeshComponent = this._myPointObject.pp_addComponent(MeshComponent6);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualPointParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualPoint(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
  _refresh() {
  }
};
VisualPoint.prototype._refresh = function() {
  let rotation = vec3_create2(0, 0, 0);
  return function _refresh() {
    this._myPointObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myIsLocal) {
      this._myPointObject.pp_setPositionLocal(this._myParams.myPosition);
      this._myPointObject.pp_setRotationLocal(rotation);
      this._myPointObject.pp_setScaleLocal(this._myParams.myRadius);
    } else {
      this._myPointObject.pp_setPosition(this._myParams.myPosition);
      this._myPointObject.pp_setRotation(rotation);
      this._myPointObject.pp_setScale(this._myParams.myRadius);
    }
    if (this._myParams.myMesh != null) {
      this._myPointMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myPointMeshComponent.mesh = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMeshes.mySphere;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myPointMeshComponent.material = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMaterials.myFlatOpaque.clone();
        }
        this._myPointMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myPointMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualPointParams.prototype.copy = function copy4(other2) {
  this.myPosition.vec3_copy(other2.myPosition);
  this.myRadius = other2.myRadius;
  this.myMesh = other2.myMesh;
  if (other2.myMaterial != null) {
    this.myMaterial = other2.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other2.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other2.myColor);
    } else {
      this.myColor = other2.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/physics/physics_utils.js
var _myLayerFlagsNames = ["0", "1", "2", "3", "4", "5", "6", "7"];
function setLayerFlagsNames(layerFlagsNames) {
  _myLayerFlagsNames = layerFlagsNames;
}
function getLayerFlagsNames() {
  return _myLayerFlagsNames;
}
var raycast = function() {
  let isInsideSubVector = vec3_create2();
  let invertedRaycastDirection = vec3_create2();
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  return function raycast2(raycastSetup, raycastResults = new RaycastResults()) {
    let internalRaycastResults = raycastSetup.myPhysics.rayCast(raycastSetup.myOrigin, raycastSetup.myDirection, raycastSetup.myBlockLayerFlags.getMask(), raycastSetup.myDistance);
    if (raycastResults.myRaycastSetup == null) {
      raycastResults.myRaycastSetup = new RaycastSetup(raycastSetup.myPhysics);
    }
    raycastResults.myRaycastSetup.copy(raycastSetup);
    let currentValidHitIndex = 0;
    let validHitsCount = 0;
    let hitCount = internalRaycastResults.hitCount;
    if (hitCount != 0) {
      let objects = null;
      let distances = null;
      let locations = null;
      let normals = null;
      invertedRaycastDirection = raycastSetup.myDirection.vec3_negate(invertedRaycastDirection);
      for (let i = 0; i < hitCount; i++) {
        if (raycastSetup.myObjectsToIgnore.length != 0) {
          if (objects == null) {
            objects = internalRaycastResults.objects;
          }
          if (raycastSetup.myObjectsToIgnore.pp_hasEqual(objects[i], objectsEqualCallback)) {
            continue;
          }
        }
        if (distances == null) {
          distances = internalRaycastResults.distances;
        }
        let isHitInsideCollision = distances[i] == 0;
        if (isHitInsideCollision) {
          if (locations == null) {
            locations = internalRaycastResults.locations;
          }
          isHitInsideCollision &&= raycastSetup.myOrigin.vec3_sub(locations[i], isInsideSubVector).vec3_isZero(Math.PP_EPSILON);
          if (isHitInsideCollision) {
            if (!normals) {
              normals = internalRaycastResults.normals;
            }
            isHitInsideCollision &&= invertedRaycastDirection.vec3_equals(normals[i], Math.PP_EPSILON_DEGREES);
          }
        }
        if (!raycastSetup.myIgnoreHitsInsideCollision || !isHitInsideCollision) {
          let hit = null;
          if (currentValidHitIndex < raycastResults.myHits.length) {
            hit = raycastResults.myHits[currentValidHitIndex];
          } else if (raycastResults._myUnusedHits != null && raycastResults._myUnusedHits.length > 0) {
            hit = raycastResults._myUnusedHits.pop();
            raycastResults.myHits.push(hit);
          } else {
            hit = new RaycastHit();
            raycastResults.myHits.push(hit);
          }
          if (objects == null) {
            objects = internalRaycastResults.objects;
          }
          if (locations == null) {
            locations = internalRaycastResults.locations;
          }
          if (normals == null) {
            normals = internalRaycastResults.normals;
          }
          hit.myPosition.vec3_copy(locations[i]);
          hit.myNormal.vec3_copy(normals[i]);
          hit.myDistance = distances[i];
          hit.myObject = objects[i];
          hit.myIsInsideCollision = isHitInsideCollision;
          validHitsCount++;
          currentValidHitIndex++;
        }
      }
    }
    if (raycastResults.myHits.length > validHitsCount) {
      if (raycastResults._myUnusedHits == null) {
        raycastResults._myUnusedHits = [];
      }
      let hitsToRemove = raycastResults.myHits.length - validHitsCount;
      for (let i = 0; i < hitsToRemove; i++) {
        raycastResults._myUnusedHits.push(raycastResults.myHits.pop());
      }
    }
    return raycastResults;
  };
}();
var PhysicsUtils = {
  setLayerFlagsNames,
  getLayerFlagsNames,
  raycast
};

// js/pp/cauldron/physics/physics_layer_flags.js
var PhysicsLayerFlags = class {
  constructor() {
    this._myLayerMask = 0;
  }
  setFlagActive(indexOrName, active) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      if (active) {
        this._myLayerMask = this._myLayerMask | mask;
      } else {
        this._myLayerMask = this._myLayerMask & ~mask;
      }
    }
  }
  isFlagActive(indexOrName) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    let isActive = false;
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      isActive = !!(this._myLayerMask & mask);
    }
    return isActive;
  }
  setAllFlagsActive(active) {
    if (!active) {
      this._myLayerMask = 0;
    } else {
      this._myLayerMask = Math.pow(2, PhysicsUtils.getLayerFlagsNames().length) - 1;
    }
  }
  add(layerFlags) {
    this._myLayerMask = this._myLayerMask | layerFlags.getMask();
  }
  remove(layerFlags) {
    this._myLayerMask = this._myLayerMask & ~layerFlags.getMask();
  }
  intersect(layerFlags) {
    this._myLayerMask = this._myLayerMask & layerFlags.getMask();
  }
  copy(layerFlags) {
    this._myLayerMask = layerFlags._myLayerMask;
  }
  getMask() {
    return this._myLayerMask;
  }
  setMask(layerMask) {
    this._myLayerMask = layerMask;
  }
};

// js/pp/cauldron/physics/physics_raycast_data.js
var RaycastSetup = class {
  constructor(physics = getMainEngine2() != null ? getMainEngine2().physics : null) {
    this.myOrigin = vec3_create2();
    this.myDirection = vec3_create2();
    this.myDistance = 0;
    this.myBlockLayerFlags = new PhysicsLayerFlags();
    this.myObjectsToIgnore = [];
    this.myIgnoreHitsInsideCollision = false;
    this.myPhysics = physics;
  }
  copy(setup) {
    this.myOrigin.vec3_copy(setup.myOrigin);
    this.myDirection.vec3_copy(setup.myDirection);
    this.myDistance = setup.myDistance;
    this.myBlockLayerFlags.copy(setup.myBlockLayerFlags);
    this.myObjectsToIgnore.pp_copy(setup.myObjectsToIgnore);
    this.myIgnoreHitsInsideCollision = setup.myIgnoreHitsInsideCollision;
    this.myPhysics = setup.myPhysics;
  }
  reset() {
    this.myOrigin.vec3_zero();
    this.myDirection.vec3_zero();
    this.myDistance = 0;
    this.myBlockLayerFlags.setAllFlagsActive(false);
    this.myObjectsToIgnore.pp_clear();
    this.myIgnoreHitsInsideCollision = false;
  }
};
var RaycastResults = class {
  constructor() {
    this.myRaycastSetup = null;
    this.myHits = [];
    this._myUnusedHits = null;
  }
  isColliding(ignoreHitsInsideCollision = false) {
    return ignoreHitsInsideCollision ? this.getFirstHitOutsideCollision() != null : this.myHits.length > 0;
  }
  getFirstHitInsideCollision() {
    let firstHit = null;
    for (let hit of this.myHits) {
      if (hit.myIsInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getFirstHitOutsideCollision() {
    let firstHit = null;
    for (let hit of this.myHits) {
      if (!hit.myIsInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getHitsInsideCollision() {
    let hits = [];
    for (let hit of this.myHits) {
      if (hit.myIsInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  getHitsOutsideCollision() {
    let hits = [];
    for (let hit of this.myHits) {
      if (!hit.myIsInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  removeHit(hitIndex) {
    let removedHit = this.myHits.pp_removeIndex(hitIndex);
    if (removedHit != null) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      this._myUnusedHits.push(removedHit);
    }
    return removedHit;
  }
  removeAllHits() {
    if (this._myUnusedHits == null) {
      this._myUnusedHits = [];
    }
    this._myUnusedHits.push(...this.myHits);
    this.myHits.pp_clear();
  }
  copy(result2) {
  }
  reset() {
    if (this.myRaycastSetup != null) {
      this.myRaycastSetup.reset();
    }
    this.removeAllHits();
  }
};
var RaycastHit = class {
  constructor() {
    this.myPosition = vec3_create2();
    this.myNormal = vec3_create2();
    this.myDistance = 0;
    this.myObject = null;
    this.myIsInsideCollision = false;
  }
  isValid() {
    return this.myObject != null;
  }
  copy(hit) {
    this.myPosition.vec3_copy(hit.myPosition);
    this.myNormal.vec3_copy(hit.myNormal);
    this.myDistance = hit.myDistance;
    this.myObject = hit.myObject;
    this.myIsInsideCollision = hit.myIsInsideCollision;
  }
  reset() {
    this.myPosition.vec3_zero();
    this.myNormal.vec3_zero();
    this.myDistance = 0;
    this.myObject = null;
    this.myIsInsideCollision = false;
  }
};
RaycastResults.prototype.copy = function() {
  let copyHitCallback = function(currentElement, elementToCopy) {
    if (currentElement == null) {
      currentElement = new RaycastHit();
    }
    currentElement.copy(elementToCopy);
    return currentElement;
  };
  return function copy28(result2) {
    if (result2.myRaycastSetup == null) {
      this.myRaycastSetup = null;
    } else {
      if (this.myRaycastSetup == null) {
        this.myRaycastSetup = new RaycastSetup(result2.myRaycastSetup.myPhysics);
      }
      this.myRaycastSetup.copy(result2.myRaycastSetup);
    }
    if (this.myHits.length > result2.myHits.length) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      for (let i = 0; i < this.myHits.length - result2.myHits.length; i++) {
        this._myUnusedHits.push(this.myHits.pop());
      }
    } else if (this.myHits.length < result2.myHits.length) {
      if (this._myUnusedHits != null) {
        let length2 = Math.min(this._myUnusedHits.length, result2.myHits.length - this.myHits.length);
        for (let i = 0; i < length2; i++) {
          this.myHits.push(this._myUnusedHits.pop());
        }
      }
    }
    this.myHits.pp_copy(result2.myHits, copyHitCallback);
  };
}();

// js/pp/cauldron/visual/elements/visual_raycast.js
var VisualRaycastParams = class {
  constructor(engine2 = getMainEngine2()) {
    this._myRaycastResults = new RaycastResults();
    this.myHitNormalLength = 0.2;
    this.myThickness = 5e-3;
    this.myShowOnlyFirstHit = true;
    this.myRayMaterial = null;
    this.myHitNormalMaterial = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.RAYCAST;
  }
  get myRaycastResults() {
    return this._myRaycastResults;
  }
  set myRaycastResults(result2) {
    this._myRaycastResults.copy(result2);
  }
  copy(other2) {
  }
};
var VisualRaycast = class {
  constructor(params = new VisualRaycastParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualRaycast = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRaycast.setAutoRefresh(false);
    this._myVisualRaycastHitList = [];
    this._addVisualRaycastHit();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVisible) {
        if (this._myParams.myRaycastResults.myRaycastSetup != null) {
          this._myVisualRaycast.setVisible(true);
        }
        if (this._myParams.myRaycastResults.myHits.length > 0) {
          let hitsToShow = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
          for (let i = 0; i < hitsToShow; i++) {
            let visualRaycastHit = this._myVisualRaycastHitList[i];
            visualRaycastHit.setVisible(true);
          }
        }
      } else {
        this._myVisualRaycast.setVisible(false);
        for (let visualRaycastHit of this._myVisualRaycastHitList) {
          visualRaycastHit.setVisible(false);
        }
      }
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualRaycast.forceRefresh();
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let hitsToRefresh = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
      for (let i = 0; i < hitsToRefresh; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        visualRaycastHit.forceRefresh();
      }
    }
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualRaycast.update(dt);
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.update(dt);
    }
  }
  _refresh() {
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.setVisible(false);
    }
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let raycastDistance = this._myParams.myShowOnlyFirstHit ? this._myParams.myRaycastResults.myHits.pp_first().myDistance : this._myParams.myRaycastResults.myHits.pp_last().myDistance;
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myDirection);
        visualRaycastParams.myLength = raycastDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myIsLocal = this._myParams.myIsLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
      let hitsToShow = this._myParams.myShowOnlyFirstHit ? 1 : this._myParams.myRaycastResults.myHits.length;
      while (hitsToShow > this._myVisualRaycastHitList.length) {
        this._addVisualRaycastHit();
      }
      for (let i = 0; i < hitsToShow; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        {
          let visualRaycastHitParams = visualRaycastHit.getParams();
          visualRaycastHitParams.myStart.vec3_copy(this._myParams.myRaycastResults.myHits[i].myPosition);
          visualRaycastHitParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myHits[i].myNormal);
          visualRaycastHitParams.myLength = this._myParams.myHitNormalLength;
          visualRaycastHitParams.myThickness = this._myParams.myThickness;
          if (this._myParams.myHitNormalMaterial == null) {
            visualRaycastHitParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myHitNormal;
          } else {
            visualRaycastHitParams.myMaterial = this._myParams.myHitNormalMaterial;
          }
          visualRaycastHitParams.myParent = this._myParams.myParent;
          visualRaycastHitParams.myIsLocal = this._myParams.myIsLocal;
          visualRaycastHit.paramsUpdated();
          visualRaycastHit.setVisible(this._myVisible);
        }
      }
    } else if (this._myParams.myRaycastResults.myRaycastSetup != null) {
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myDirection);
        visualRaycastParams.myLength = this._myParams.myRaycastResults.myRaycastSetup.myDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myIsLocal = this._myParams.myIsLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
    } else {
      this._myVisualRaycast.setVisible(false);
    }
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualRaycastParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualRaycast(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
  _addVisualRaycastHit() {
    let visualRaycastHit = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    visualRaycastHit.setAutoRefresh(false);
    visualRaycastHit.setVisible(false);
    this._myVisualRaycastHitList.push(visualRaycastHit);
  }
};
VisualRaycastParams.prototype.copy = function copy5(other2) {
  this.myRaycastResults = other2.myRaycastResults;
  this.myHitNormalLength = other2.myHitNormalLength;
  this.myThickness = other2.myThickness;
  this.myShowOnlyFirstHit = other2.myShowOnlyFirstHit;
  if (other2.myRayMaterial != null) {
    this.myRayMaterial = other2.myRayMaterial.clone();
  } else {
    this.myRayMaterial = null;
  }
  if (other2.myHitNormalMaterial != null) {
    this.myHitNormalMaterial = other2.myHitNormalMaterial.clone();
  } else {
    this.myHitNormalMaterial = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/elements/visual_text.js
import { Alignment, Justification, TextComponent as TextComponent3 } from "@wonderlandengine/api";
var VisualTextParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myText = "";
    this.myAlignment = Alignment.Center;
    this.myJustification = Justification.Middle;
    this.myTransform = mat4_create();
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.TEXT;
  }
  copy(other2) {
  }
};
var VisualText = class {
  constructor(params = new VisualTextParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myTextObject = null;
    this._myTextComponent = null;
    this._myTextMaterial = null;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myTextObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _refresh() {
    this._myTextObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myIsLocal) {
      this._myTextObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTextObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myTextComponent.material = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myText;
      } else {
        if (this._myTextMaterial == null) {
          this._myTextMaterial = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMaterials.myText.clone();
        }
        this._myTextComponent.material = this._myTextMaterial;
        this._myTextMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myTextComponent.material = this._myParams.myMaterial;
    }
    this._myTextComponent.text = this._myParams.myText;
    this._myTextComponent.alignment = this._myParams.myAlignment;
    this._myTextComponent.justification = this._myParams.myJustification;
    this._myDirty = false;
  }
  _build() {
    this._myTextObject = this._myParams.myParent.pp_getEngine().scene.pp_addObject();
    this._myTextComponent = this._myTextObject.pp_addComponent(TextComponent3);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualTextParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualText(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
};
VisualTextParams.prototype.copy = function copy6(other2) {
  this.myText = other2.myText;
  this.myAlignment = other2.myAlignment;
  this.myJustification = other2.myJustification;
  this.myTransform.mat4_copy(other2.myTransform);
  if (other2.myMaterial != null) {
    this.myMaterial = other2.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other2.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other2.myColor);
    } else {
      this.myColor = other2.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/elements/visual_torus.js
var VisualTorusParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myTransform = mat4_create();
    this.myRadius = 0;
    this.mySegmentsAmount = 12;
    this.mySegmentThickness = 0.05;
    this.mySegmentMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.TORUS;
  }
  copy(other2) {
  }
};
var VisualTorus = class {
  constructor(params = new VisualTorusParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myTorusRootObject = null;
    this._myVisualSegmentList = [];
    this._myFlatOpaqueMaterial = null;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVisible) {
        let segmentToShow = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
        for (let i = 0; i < segmentToShow; i++) {
          let visualSegment = this._myVisualSegmentList[i];
          visualSegment.setVisible(true);
        }
      } else {
        for (let visualSegment of this._myVisualSegmentList) {
          visualSegment.setVisible(false);
        }
      }
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    let segmentToRefresh = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
    for (let i = 0; i < segmentToRefresh; i++) {
      let visualSegment = this._myVisualSegmentList[i];
      visualSegment.forceRefresh();
    }
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.update(dt);
    }
  }
  _build() {
    this._myTorusRootObject = this._myParams.myParent.pp_getEngine().scene.pp_addObject();
    this._fillSegmentList();
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  _fillSegmentList() {
    while (this._myVisualSegmentList.length < this._myParams.mySegmentsAmount) {
      let visualSegment = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
      visualSegment.setAutoRefresh(false);
      visualSegment.setVisible(false);
      visualSegment.getParams().myParent = this._myTorusRootObject;
      visualSegment.getParams().myIsLocal = true;
      this._myVisualSegmentList.push(visualSegment);
    }
  }
  clone() {
    let clonedParams = new VisualTorusParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualTorus(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
  _refresh() {
  }
};
VisualTorus.prototype._refresh = function() {
  let segmentStart = vec3_create2();
  let segmentEnd = vec3_create2();
  let segmentDirection = vec3_create2();
  let fixedSegmentStart = vec3_create2();
  let fixedSegmentEnd = vec3_create2();
  let up = vec3_create2(0, 1, 0);
  return function _refresh() {
    this._fillSegmentList();
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.setVisible(false);
    }
    this._myTorusRootObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myIsLocal) {
      this._myTorusRootObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTorusRootObject.pp_setTransform(this._myParams.myTransform);
    }
    let sliceAngle = 2 * Math.PI / this._myParams.mySegmentsAmount;
    segmentStart.vec3_set(this._myParams.myRadius, 0, 0);
    for (let i = 0; i < this._myParams.mySegmentsAmount; i++) {
      segmentEnd = segmentStart.vec3_rotateAxisRadians(sliceAngle, up, segmentEnd);
      segmentDirection = segmentEnd.vec3_sub(segmentStart, segmentDirection).vec3_normalize(segmentDirection);
      let extraLength = Math.tan(sliceAngle / 2) * this._myParams.mySegmentThickness / 2;
      fixedSegmentStart = segmentStart.vec3_sub(segmentDirection.vec3_scale(extraLength, fixedSegmentStart), fixedSegmentStart);
      fixedSegmentEnd = segmentEnd.vec3_add(segmentDirection.vec3_scale(extraLength, fixedSegmentEnd), fixedSegmentEnd);
      let visualSegment = this._myVisualSegmentList[i];
      let visualSegmentParams = visualSegment.getParams();
      visualSegmentParams.setStartEnd(fixedSegmentStart, fixedSegmentEnd);
      visualSegmentParams.myThickness = this._myParams.mySegmentThickness;
      visualSegmentParams.myMesh = this._myParams.mySegmentMesh;
      if (this._myParams.myMaterial == null) {
        if (this._myParams.myColor == null) {
          visualSegmentParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
        } else {
          if (this._myFlatOpaqueMaterial == null) {
            this._myFlatOpaqueMaterial = getDefaultResources(this._myParams.myParent.pp_getEngine()).myMaterials.myFlatOpaque.clone();
          }
          visualSegmentParams.myMaterial = this._myFlatOpaqueMaterial;
          this._myFlatOpaqueMaterial.color = this._myParams.myColor;
        }
      } else {
        visualSegmentParams.myMaterial = this._myParams.myMaterial;
      }
      visualSegment.paramsUpdated();
      visualSegment.setVisible(this._myVisible);
      segmentStart.vec3_copy(segmentEnd);
    }
  };
}();
VisualTorusParams.prototype.copy = function copy7(other2) {
  this.myRadius = other2.myRadius;
  this.mySegmentsAmount = other2.mySegmentsAmount;
  this.mySegmentThickness = other2.mySegmentThickness;
  this.myTransform.mat4_copy(other2.myTransform);
  this.mySegmentMesh = other2.mySegmentMesh;
  if (other2.myMaterial != null) {
    this.myMaterial = other2.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other2.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other2.myColor);
    } else {
      this.myColor = other2.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/elements/visual_transform.js
var VisualTransformParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myTransform = mat4_create();
    this.myLength = 0.2;
    this.myThickness = 5e-3;
    this.myForwardMaterial = null;
    this.myUpMaterial = null;
    this.myRightMaterial = null;
    this.myParent = getVisualData(engine2).myRootObject;
    this.myIsLocal = false;
    this.myType = VisualElementType.TRANSFORM;
  }
  copy(other2) {
  }
};
var VisualTransform = class {
  constructor(params = new VisualTransformParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualRight = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualUp = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualForward = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRight.setAutoRefresh(false);
    this._myVisualUp.setAutoRefresh(false);
    this._myVisualForward.setAutoRefresh(false);
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myVisualRight.setVisible(visible);
      this._myVisualUp.setVisible(visible);
      this._myVisualForward.setVisible(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualRight.forceRefresh();
    this._myVisualUp.forceRefresh();
    this._myVisualForward.forceRefresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualRight.update(dt);
    this._myVisualUp.update(dt);
    this._myVisualForward.update(dt);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualTransformParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone = new VisualTransform(clonedParams);
    clone.setAutoRefresh(this._myAutoRefresh);
    clone.setVisible(this._myVisible);
    clone._myDirty = this._myDirty;
    return clone;
  }
  _refresh() {
  }
};
VisualTransform.prototype._refresh = function() {
  let axes = [vec3_create2(), vec3_create2(), vec3_create2()];
  let scale = vec3_create2();
  let position = vec3_create2();
  return function _refresh() {
    axes = this._myParams.myTransform.mat4_getAxes(axes);
    scale = this._myParams.myTransform.mat4_getScale(scale);
    let maxValue = 0;
    for (let value of scale) {
      maxValue = Math.max(value, maxValue);
    }
    if (maxValue == 0) {
      scale[0] = 1;
      scale[1] = 1;
      scale[2] = 1;
    } else {
      scale[0] = scale[0] / maxValue;
      scale[1] = scale[1] / maxValue;
      scale[2] = scale[2] / maxValue;
    }
    position = this._myParams.myTransform.mat4_getPosition(position);
    {
      let visualArrowParams = this._myVisualRight.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[0].vec3_negate(visualArrowParams.myDirection).vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale[0], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myRightMaterial == null) {
        visualArrowParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRight;
      } else {
        visualArrowParams.myMaterial = this._myParams.myRightMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myIsLocal = this._myParams.myIsLocal;
      this._myVisualRight.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualUp.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[1].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale[1], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myUpMaterial == null) {
        visualArrowParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myUp;
      } else {
        visualArrowParams.myMaterial = this._myParams.myUpMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myIsLocal = this._myParams.myIsLocal;
      this._myVisualUp.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualForward.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[2].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale[2], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myForwardMaterial == null) {
        visualArrowParams.myMaterial = getVisualData(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myForward;
      } else {
        visualArrowParams.myMaterial = this._myParams.myForwardMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myIsLocal = this._myParams.myIsLocal;
      this._myVisualForward.paramsUpdated();
    }
  };
}();
VisualTransformParams.prototype.copy = function copy8(other2) {
  this.myTransform.mat4_copy(other2.myTransform);
  this.myLength = other2.myLength;
  this.myThickness = other2.myThickness;
  if (other2.myRightMaterial != null) {
    this.myRightMaterial = other2.myRightMaterial.clone();
  } else {
    this.myRightMaterial = null;
  }
  if (other2.myUpMaterial != null) {
    this.myUpMaterial = other2.myUpMaterial.clone();
  } else {
    this.myUpMaterial = null;
  }
  if (other2.myForwardMaterial != null) {
    this.myForwardMaterial = other2.myForwardMaterial.clone();
  } else {
    this.myForwardMaterial = null;
  }
  this.myParent = other2.myParent;
  this.myIsLocal = other2.myIsLocal;
  this.myType = other2.myType;
};

// js/pp/cauldron/visual/visual_manager.js
var VisualManager = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
    this._myVisualElementPrototypeCreationCallbacks = /* @__PURE__ */ new Map();
    this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
    this._myVisualElementLastID = 0;
    this._myVisualElementsPool = new ObjectPoolsManager();
    this._myVisualElementsToShow = [];
    this._myActive = true;
    this._addStandardVisualElementTypes();
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (!this._myActive) {
        this.clearDraw();
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
  }
  update(dt) {
    if (this._myActive) {
      this._updateDraw(dt);
    }
  }
  draw(visualElementParams, lifetimeSeconds = 0, idToReuse = null) {
    if (!this._myActive) {
      return 0;
    }
    let visualElement = null;
    let idReused = false;
    if (idToReuse != null) {
      if (this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
        let visualElements2 = this._myVisualElementsTypeMap.get(visualElementParams.myType);
        if (visualElements2.has(idToReuse)) {
          visualElement = visualElements2.get(idToReuse)[0];
          visualElement.copyParams(visualElementParams);
          visualElement.setVisible(false);
          idReused = true;
        }
      }
    }
    if (visualElement == null) {
      visualElement = this._getVisualElement(visualElementParams);
    }
    if (visualElement == null) {
      console.error("Couldn't create the requested visual element");
      return null;
    }
    if (!this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
      this._myVisualElementsTypeMap.set(visualElementParams.myType, /* @__PURE__ */ new Map());
    }
    let visualElements = this._myVisualElementsTypeMap.get(visualElementParams.myType);
    let elementID = null;
    if (!idReused) {
      elementID = this._myVisualElementLastID + 1;
      this._myVisualElementLastID = elementID;
      visualElements.set(elementID, [visualElement, new Timer(lifetimeSeconds, lifetimeSeconds != null)]);
    } else {
      elementID = idToReuse;
      let visualElementPair = visualElements.get(elementID);
      visualElementPair[0] = visualElement;
      visualElementPair[1].reset(lifetimeSeconds);
      if (lifetimeSeconds != null) {
        visualElementPair[1].start();
      }
    }
    this._myVisualElementsToShow.push(visualElement);
    return elementID;
  }
  getDraw(elementID) {
    let visualElement = null;
    for (let visualElements of this._myVisualElementsTypeMap.values()) {
      if (visualElements.has(elementID)) {
        let visualElementPair = visualElements.get(elementID);
        visualElement = visualElementPair[0];
        break;
      }
    }
    return visualElement;
  }
  clearDraw(elementID = null) {
    if (elementID == null) {
      for (let visualElements of this._myVisualElementsTypeMap.values()) {
        for (let visualElement of visualElements.values()) {
          this._myVisualElementsPool.releaseObject(visualElement[0].getParams().myType, visualElement[0]);
        }
      }
      this._myVisualElementsToShow = [];
      this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
      this._myVisualElementLastID = 0;
    } else {
      for (let visualElements of this._myVisualElementsTypeMap.values()) {
        if (visualElements.has(elementID)) {
          let visualElementPair = visualElements.get(elementID);
          this._myVisualElementsPool.releaseObject(visualElementPair[0].getParams().myType, visualElementPair[0]);
          visualElements.delete(elementID);
          this._myVisualElementsToShow.pp_removeEqual(visualElementPair[0]);
          break;
        }
      }
    }
  }
  allocateDraw(visualElementType, amount) {
    if (!this._myVisualElementsPool.hasPool(visualElementType)) {
      this._addVisualElementTypeToPool(visualElementType);
    }
    let pool = this._myVisualElementsPool.getPool(visualElementType);
    let difference = pool.getAvailableSize() - amount;
    if (difference < 0) {
      pool.increase(-difference);
    }
  }
  addVisualElementType(visualElementType, visuaElementPrototypeCreationCallback) {
    this._myVisualElementPrototypeCreationCallbacks.set(visualElementType, visuaElementPrototypeCreationCallback);
  }
  removeVisualElementType(visualElementType) {
    this._myVisualElementPrototypeCreationCallbacks.delete(visualElementType);
  }
  _updateDraw(dt) {
    for (let visualElement of this._myVisualElementsToShow) {
      visualElement.setVisible(true);
    }
    this._myVisualElementsToShow = [];
    for (let visualElements of this._myVisualElementsTypeMap.values()) {
      let idsToRemove = [];
      for (let visualElementsEntry of visualElements.entries()) {
        let visualElement = visualElementsEntry[1];
        if (visualElement[1].isDone()) {
          this._myVisualElementsPool.releaseObject(visualElement[0].getParams().myType, visualElement[0]);
          idsToRemove.push(visualElementsEntry[0]);
        }
        visualElement[1].update(dt);
      }
      for (let id of idsToRemove) {
        visualElements.delete(id);
      }
    }
  }
  _getVisualElement(params) {
    let element = null;
    if (!this._myVisualElementsPool.hasPool(params.myType)) {
      this._addVisualElementTypeToPool(params.myType);
    }
    element = this._myVisualElementsPool.getObject(params.myType);
    if (element != null) {
      element.copyParams(params);
    }
    return element;
  }
  _addVisualElementTypeToPool(type2) {
    let objectPoolParams = new ObjectPoolParams();
    objectPoolParams.myInitialPoolSize = 10;
    objectPoolParams.myAmountToAddWhenEmpty = 0;
    objectPoolParams.myPercentageToAddWhenEmpty = 0.5;
    objectPoolParams.mySetActiveCallback = function(object, active) {
      object.setVisible(active);
    };
    let visualElementPrototype = null;
    if (this._myVisualElementPrototypeCreationCallbacks.has(type2)) {
      visualElementPrototype = this._myVisualElementPrototypeCreationCallbacks.get(type2)();
    }
    if (visualElementPrototype != null) {
      visualElementPrototype.setVisible(false);
      visualElementPrototype.setAutoRefresh(true);
      this._myVisualElementsPool.addPool(type2, visualElementPrototype, objectPoolParams);
    } else {
      console.error("Visual element type not supported");
    }
  }
  _addStandardVisualElementTypes() {
    this.addVisualElementType(VisualElementType.LINE, () => new VisualLine(new VisualLineParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.MESH, () => new VisualMesh(new VisualMeshParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.POINT, () => new VisualPoint(new VisualPointParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.ARROW, () => new VisualArrow(new VisualArrowParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TEXT, () => new VisualText(new VisualTextParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TRANSFORM, () => new VisualTransform(new VisualTransformParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.RAYCAST, () => new VisualRaycast(new VisualRaycastParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TORUS, () => new VisualTorus(new VisualTorusParams(this._myEngine)));
  }
};

// js/pp/cauldron/visual/components/visual_manager_component.js
var VisualManagerComponent = class extends Component3 {
  init() {
    this._myVisualManager = null;
    if (!hasVisualManager(this.engine)) {
      this._myVisualManager = new VisualManager(this.engine);
      setVisualManager(this._myVisualManager, this.engine);
    }
    if (!hasVisualData(this.engine)) {
      this._myVisualData = new VisualData();
      this._myVisualData.myRootObject = this.engine.scene.pp_addObject();
      setVisualData(this._myVisualData, this.engine);
    }
  }
  start() {
    if (this._myVisualData != null) {
      this._myVisualData.myDefaultMaterials.myMesh = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      this._myVisualData.myDefaultMaterials.myText = getDefaultResources(this.engine).myMaterials.myText.clone();
      this._myVisualData.myDefaultMaterials.myRight = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      this._myVisualData.myDefaultMaterials.myRight.color = vec4_create2(1, 0, 0, 1);
      this._myVisualData.myDefaultMaterials.myUp = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      this._myVisualData.myDefaultMaterials.myUp.color = vec4_create2(0, 1, 0, 1);
      this._myVisualData.myDefaultMaterials.myForward = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      this._myVisualData.myDefaultMaterials.myForward.color = vec4_create2(0, 0, 1, 1);
      this._myVisualData.myDefaultMaterials.myRay = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      this._myVisualData.myDefaultMaterials.myRay.color = vec4_create2(0, 1, 0, 1);
      this._myVisualData.myDefaultMaterials.myHitNormal = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      this._myVisualData.myDefaultMaterials.myHitNormal.color = vec4_create2(1, 0, 0, 1);
    }
    if (this.myVisualManager != null) {
      this.myVisualManager.start();
    }
  }
  update(dt) {
    if (this.myVisualManager != null) {
      this.myVisualManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myVisualManager != null && getVisualManager(this.engine) == this._myVisualManager) {
      removeVisualManager(this.engine);
    }
    if (this._myVisualData != null && getVisualData(this.engine) == this._myVisualData) {
      removeVisualData(this.engine);
    }
  }
};
__publicField(VisualManagerComponent, "TypeName", "pp-visual-manager");
__publicField(VisualManagerComponent, "Properties", {});

// js/pp/cauldron/wl/components/add_wl_to_window_component.js
import { Component as Component4, Property as Property4 } from "@wonderlandengine/api";
import * as WLAPI from "@wonderlandengine/api";
import * as WLComponents from "@wonderlandengine/components";
var AddWLToWindowComponent = class extends Component4 {
  init() {
    if (this._myAdd) {
      window.WL = {};
      this._addProperties(WLAPI);
      this._addProperties(WLComponents);
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        window.WL[propertyName] = object[propertyName];
      }
    }
  }
};
__publicField(AddWLToWindowComponent, "TypeName", "pp-add-wl-to-window");
__publicField(AddWLToWindowComponent, "Properties", {
  _myAdd: Property4.bool(true)
});

// js/pp/debug/components/debug_manager_component.js
import { Component as Component5, Property as Property5 } from "@wonderlandengine/api";

// js/pp/debug/debug_globals.js
var _myDebugManagers = /* @__PURE__ */ new WeakMap();
var _myDebugEnableds = /* @__PURE__ */ new WeakMap();
function getDebugManager(engine2 = getMainEngine2()) {
  return _myDebugManagers.get(engine2);
}
function setDebugManager(debugManager, engine2 = getMainEngine2()) {
  _myDebugManagers.set(engine2, debugManager);
}
function removeDebugManager(engine2 = getMainEngine2()) {
  _myDebugManagers.delete(engine2);
}
function hasDebugManager(engine2 = getMainEngine2()) {
  return _myDebugManagers.has(engine2);
}
function getDebugVisualManager2(engine2 = getMainEngine2()) {
  let debugManager = getDebugManager(engine2);
  if (debugManager != null) {
    return debugManager.getDebugVisualManager();
  }
  return null;
}
function isDebugEnabled(engine2 = getMainEngine2()) {
  return _myDebugEnableds.get(engine2);
}
function setDebugEnabled(debugEnabled, engine2 = getMainEngine2()) {
  _myDebugEnableds.set(engine2, debugEnabled);
}
function removeDebugEnabled(engine2 = getMainEngine2()) {
  _myDebugEnableds.delete(engine2);
}
function hasDebugEnabled(engine2 = getMainEngine2()) {
  return _myDebugEnableds.has(engine2);
}

// js/pp/debug/debug_visual_manager.js
import { Alignment as Alignment2, Justification as Justification2 } from "@wonderlandengine/api";
var DebugVisualManager = class extends VisualManager {
  constructor(engine2) {
    super(engine2);
  }
  drawLine(lifetimeSeconds, start, direction, length2, color = vec4_create2(0, 1, 0, 1), thickness = 5e-3) {
    if (this.isActive()) {
      let visualParams = new VisualLineParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction);
      visualParams.myLength = length2;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create2();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawLineEnd(lifetimeSeconds, start, end, color = vec4_create2(0, 1, 0, 1), thickness = 5e-3) {
  }
  drawArrow(lifetimeSeconds, start, direction, length2, color = vec4_create2(0, 1, 0, 1), thickness = 5e-3) {
    if (this.isActive()) {
      let visualParams = new VisualArrowParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction);
      visualParams.myLength = length2;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create2();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawArrowEnd(lifetimeSeconds, start, end, color = vec4_create2(0, 1, 0, 1), thickness = 5e-3) {
  }
  drawPoint(lifetimeSeconds, position, color = vec4_create2(0, 1, 0, 1), radius = 5e-3) {
    if (this.isActive()) {
      let visualParams = new VisualPointParams(this._myEngine);
      visualParams.myPosition.vec3_copy(position);
      visualParams.myRadius = radius;
      visualParams.myColor = vec4_create2();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawText(lifetimeSeconds, text, transform, color = vec4_create2(0, 1, 0, 1), alignment = Alignment2.Center, justification = Justification2.Middle) {
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myJustification = justification;
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myColor = vec4_create2();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawRaycast(lifetimeSeconds, raycastResult2, showOnlyFirstHit = true, hitNormalLength = 0.2, thickness = 5e-3) {
    if (this.isActive()) {
      let visualParams = new VisualRaycastParams(this._myEngine);
      visualParams.myRaycastResults = raycastResult2;
      visualParams.myShowOnlyFirstHit = showOnlyFirstHit;
      visualParams.myHitNormalLength = hitNormalLength;
      visualParams.myThickness = thickness;
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawTransform(lifetimeSeconds, transform, length2 = 0.2, thickness = 5e-3) {
    if (this.isActive()) {
      let visualParams = new VisualTransformParams(this._myEngine);
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myLength = length2;
      visualParams.myThickness = thickness;
      this.draw(visualParams, lifetimeSeconds);
    }
  }
};
DebugVisualManager.prototype.drawLineEnd = function() {
  let direction = vec3_create2();
  return function drawLineEnd(lifetimeSeconds, start, end, color = vec4_create2(0, 1, 0, 1), thickness = 5e-3) {
    if (this.isActive()) {
      direction = end.vec3_sub(start, direction);
      length = direction.vec3_length();
      direction.vec3_normalize(direction);
      this.drawLine(lifetimeSeconds, start, direction, length, color, thickness);
    }
  };
}();
DebugVisualManager.prototype.drawArrowEnd = function() {
  let direction = vec3_create2();
  return function drawArrowEnd(lifetimeSeconds, start, end, color = vec4_create2(0, 1, 0, 1), thickness = 5e-3) {
    if (this.isActive()) {
      direction = end.vec3_sub(start, direction);
      length = direction.vec3_length();
      direction.vec3_normalize(direction);
      this.drawArrow(lifetimeSeconds, start, direction, length, color, thickness);
    }
  };
}();

// js/pp/debug/debug_manager.js
var DebugManager = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
    this._myDebugVisualManager = new DebugVisualManager(this._myEngine);
  }
  getDebugVisualManager() {
    return this._myDebugVisualManager;
  }
  start() {
    this._myDebugVisualManager.start();
  }
  update(dt) {
    this._myDebugVisualManager.setActive(isDebugEnabled(this._myEngine));
    this._myDebugVisualManager.update(dt);
  }
};

// js/pp/debug/components/debug_manager_component.js
var DebugManagerComponent = class extends Component5 {
  init() {
    this._myDebugManager = null;
    if (!hasDebugManager(this.engine)) {
      this._myDebugManager = new DebugManager(this.engine);
      setDebugManager(this._myDebugManager, this.engine);
    }
  }
  start() {
    if (this._myDebugManager != null) {
      this._myDebugManager.start();
    }
  }
  update(dt) {
    if (this._myDebugManager != null) {
      this._myDebugManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myDebugManager != null && getDebugManager(this.engine) == this._myDebugManager) {
      removeDebugManager(this.engine);
    }
  }
};
__publicField(DebugManagerComponent, "TypeName", "pp-debug-manager");
__publicField(DebugManagerComponent, "Properties", {});

// js/pp/input/cauldron/components/input_manager_component.js
import { Component as Component6, Property as Property6 } from "@wonderlandengine/api";

// js/pp/input/pose/base_pose.js
var BasePoseParams2 = class {
  constructor(engine2 = getMainEngine2()) {
    this.myReferenceObject = null;
    this.myFixForward = true;
    this.myForceEmulatedVelocities = false;
    this.myUpdateOnViewReset = false;
    this.myEngine = engine2;
  }
};
var BasePose = class {
  constructor(basePoseParams = new BasePoseParams2()) {
    this._myFixForward = basePoseParams.myFixForward;
    this._myForceEmulatedVelocities = basePoseParams.myForceEmulatedVelocities;
    this._myUpdateOnViewReset = basePoseParams.myUpdateOnViewReset;
    this._myReferenceSpace = null;
    this._myReferenceObject = basePoseParams.myReferenceObject;
    this._myEngine = basePoseParams.myEngine;
    this._myPosition = vec3_create2();
    this._myRotationQuat = quat2_create();
    this._myPrevPosition = vec3_create2();
    this._myPrevRotationQuat = quat_create();
    this._myLinearVelocity = vec3_create2();
    this._myAngularVelocityRadians = vec3_create2();
    this._myIsValid = false;
    this._myIsLinearVelocityEmulated = true;
    this._myIsAngularVelocityEmulated = true;
    this._myPoseUpdatedCallbacks = /* @__PURE__ */ new Map();
  }
  getEngine() {
    return this._myEngine;
  }
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setFixForward(fixForward) {
    this._myFixForward = fixForward;
  }
  isFixForward() {
    return this._myFixForward;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  setUpdateOnViewReset(updateOnViewReset) {
    this._myUpdateOnViewReset = updateOnViewReset;
  }
  isUpdateOnViewReset() {
    return this._myUpdateOnViewReset;
  }
  getReferenceSpace() {
    return this._myReferenceSpace;
  }
  getPosition() {
  }
  getRotation() {
    return this.getRotationDegrees();
  }
  getRotationDegrees() {
    return this.getRotationQuat().quat_toDegrees();
  }
  getRotationRadians() {
    return this.getRotationQuat().quat_toRadians();
  }
  getRotationQuat() {
  }
  getTransform() {
    return this.getTransformMatrix();
  }
  getTransformMatrix() {
  }
  getTransformQuat() {
  }
  getLinearVelocity() {
  }
  getAngularVelocity() {
    return this.getAngularVelocityDegrees();
  }
  getAngularVelocityDegrees() {
  }
  getAngularVelocityRadians() {
  }
  isValid() {
    return this._myIsValid;
  }
  isLinearVelocityEmulated() {
    return this._myIsLinearVelocityEmulated;
  }
  isAngularVelocityEmulated() {
    return this._myIsAngularVelocityEmulated;
  }
  registerPoseUpdatedEventListener(id, callback) {
    this._myPoseUpdatedCallbacks.set(id, callback);
  }
  unregisterPoseUpdatedEventListener(id) {
    this._myPoseUpdatedCallbacks.delete(id);
  }
  start() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myEngine);
  }
  update(dt) {
    this._update(dt, true);
  }
  _isReadyToGetPose() {
    return true;
  }
  _getPose(xrFrame) {
    return null;
  }
  _updateHook(dt, updateVelocity, xrPose) {
  }
  _onXRSessionStartHook(manualCall, session) {
  }
  _onXRSessionEndHook() {
  }
  _onViewResetHook() {
  }
  _update(dt, updateVelocity) {
    this._myPrevPosition.vec3_copy(this._myPosition);
    this._myPrevRotationQuat.quat_copy(this._myRotationQuat);
    let xrFrame = XRUtils.getFrame(this._myEngine);
    if (xrFrame && this._isReadyToGetPose()) {
      let xrPose = null;
      try {
        xrPose = this._getPose(xrFrame);
      } catch (error) {
      }
      if (xrPose) {
        this._myPosition[0] = xrPose.transform.position.x;
        this._myPosition[1] = xrPose.transform.position.y;
        this._myPosition[2] = xrPose.transform.position.z;
        this._myRotationQuat[0] = xrPose.transform.orientation.x;
        this._myRotationQuat[1] = xrPose.transform.orientation.y;
        this._myRotationQuat[2] = xrPose.transform.orientation.z;
        this._myRotationQuat[3] = xrPose.transform.orientation.w;
        this._myRotationQuat.quat_normalize(this._myRotationQuat);
        if (updateVelocity) {
          if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
            this._myLinearVelocity[0] = xrPose.linearVelocity.x;
            this._myLinearVelocity[1] = xrPose.linearVelocity.y;
            this._myLinearVelocity[2] = xrPose.linearVelocity.z;
            this._myIsLinearVelocityEmulated = false;
          } else {
            this._computeEmulatedLinearVelocity(dt);
            this._myIsLinearVelocityEmulated = true;
          }
          if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
            this._myAngularVelocityRadians[0] = xrPose.angularVelocity.x;
            this._myAngularVelocityRadians[1] = xrPose.angularVelocity.y;
            this._myAngularVelocityRadians[2] = xrPose.angularVelocity.z;
            this._myIsAngularVelocityEmulated = false;
          } else {
            this._computeEmulatedAngularVelocity(dt);
            this._myIsAngularVelocityEmulated = true;
          }
        }
        this._myIsValid = true;
      } else {
        if (updateVelocity) {
          this._myLinearVelocity[0] = 0;
          this._myLinearVelocity[1] = 0;
          this._myLinearVelocity[2] = 0;
          this._myAngularVelocityRadians[0] = 0;
          this._myAngularVelocityRadians[1] = 0;
          this._myAngularVelocityRadians[2] = 0;
        }
        this._myIsValid = false;
        this._myIsLinearVelocityEmulated = true;
        this._myIsAngularVelocityEmulated = true;
      }
      this._updateHook(dt, updateVelocity, xrPose);
    } else {
      if (updateVelocity) {
        this._myLinearVelocity[0] = 0;
        this._myLinearVelocity[1] = 0;
        this._myLinearVelocity[2] = 0;
        this._myAngularVelocityRadians[0] = 0;
        this._myAngularVelocityRadians[1] = 0;
        this._myAngularVelocityRadians[2] = 0;
      }
      this._myIsValid = false;
      this._myIsLinearVelocityEmulated = true;
      this._myIsAngularVelocityEmulated = true;
      this._updateHook(dt, updateVelocity, null);
    }
    this._myPoseUpdatedCallbacks.forEach(function(callback) {
      callback(this);
    }.bind(this));
  }
  _computeEmulatedLinearVelocity(dt) {
    if (dt > 0) {
      this._myPosition.vec3_sub(this._myPrevPosition, this._myLinearVelocity);
      this._myLinearVelocity.vec3_scale(1 / dt, this._myLinearVelocity);
    } else {
      this._myLinearVelocity[0] = 0;
      this._myLinearVelocity[1] = 0;
      this._myLinearVelocity[2] = 0;
    }
  }
  _onXRSessionStart(manualCall, session) {
    session.requestReferenceSpace(XRUtils.getReferenceSpaceType(this._myEngine)).then(function(referenceSpace) {
      this._myReferenceSpace = referenceSpace;
      if (referenceSpace.addEventListener != null) {
        referenceSpace.addEventListener("reset", this._onViewReset.bind(this));
      }
    }.bind(this));
    this._onXRSessionStartHook(manualCall, session);
  }
  _onXRSessionEnd() {
    this._onXRSessionEndHook();
    this._myReferenceSpace = null;
  }
  _onViewReset() {
    if (this._myUpdateOnViewReset) {
      this._update(0, false);
    }
    this._onViewResetHook();
  }
  _computeEmulatedAngularVelocity() {
  }
};
BasePose.prototype.getPosition = function() {
  let position = vec3_create2();
  let transform = mat4_create();
  return function getPosition() {
    if (this._myReferenceObject == null) {
      return this._myPosition;
    }
    return this._myPosition.vec3_convertPositionToWorld(this._myReferenceObject.pp_getTransform(transform), position);
  };
}();
BasePose.prototype.getRotationQuat = function() {
  let rotationQuat = quat_create();
  let playerRotationQuat = quat_create();
  let up = vec3_create2();
  return function getRotationQuat() {
    rotationQuat.quat_copy(this._myRotationQuat);
    if (this._myFixForward) {
      rotationQuat.quat_rotateAxisRadians(Math.PI, rotationQuat.quat_getUp(up), rotationQuat);
    }
    if (this._myReferenceObject == null) {
      return rotationQuat;
    }
    return rotationQuat.quat_toWorld(this._myReferenceObject.pp_getRotationQuat(playerRotationQuat), rotationQuat);
  };
}();
BasePose.prototype.getTransformMatrix = function() {
  let transform = mat4_create();
  return function getTransformMatrix() {
    return this.getTransformQuat().quat2_toMatrix(transform);
  };
}();
BasePose.prototype.getTransformQuat = function() {
  let transformQuat = quat2_create();
  let playerTransformQuat = quat2_create();
  return function getTransformQuat() {
    transformQuat.quat2_setPositionRotationQuat(this._myPosition, this.getRotationQuat());
    if (this._myReferenceObject == null) {
      return transformQuat;
    }
    return transformQuat.quat_toWorld(this._myReferenceObject.pp_getTransformQuat(playerTransformQuat), transformQuat);
  };
}();
BasePose.prototype.getLinearVelocity = function() {
  let position = vec3_create2();
  let transform = mat4_create();
  return function getLinearVelocity() {
    if (this._myReferenceObject == null) {
      return this._myLinearVelocity;
    }
    return this._myLinearVelocity.vec3_convertDirectionToWorld(this._myReferenceObject.pp_getTransform(transform), position);
  };
}();
BasePose.prototype.getAngularVelocityDegrees = function() {
  let rotationDegrees = vec3_create2();
  return function getAngularVelocityDegrees() {
    this.getAngularVelocityRadians().vec3_toDegrees(rotationDegrees);
  };
}();
BasePose.prototype.getAngularVelocityRadians = function() {
  let rotationRadians = vec3_create2();
  let transform = mat4_create();
  return function getAngularVelocityRadians() {
    if (this._myReferenceObject == null) {
      return this._myAngularVelocityRadians;
    }
    return this._myAngularVelocityRadians.vec3_convertDirectionToWorld(this._myReferenceObject.pp_getTransform(transform), rotationRadians);
  };
}();
BasePose.prototype._computeEmulatedAngularVelocity = function() {
  let rotationRadians = vec3_create2();
  let prevRotationRadians = vec3_create2();
  return function _computeEmulatedAngularVelocity(dt) {
    if (dt > 0) {
      rotationRadians = this._myRotationQuat.quat_toRadians(rotationRadians);
      prevRotationRadians = this._myPrevRotationQuat.quat_toRadians(prevRotationRadians);
      rotationRadians.vec3_sub(prevRotationRadians, this._myAngularVelocityRadians);
      this._myAngularVelocityRadians.vec3_scale(1 / dt, this._myAngularVelocityRadians);
    } else {
      this._myAngularVelocityRadians[0] = 0;
      this._myAngularVelocityRadians[1] = 0;
      this._myAngularVelocityRadians[2] = 0;
    }
  };
}();

// js/pp/input/pose/hand_pose.js
var HandPoseParams = class extends BasePoseParams2 {
  constructor(engine2) {
    super(engine2);
    this.myFixTrackedHandRotation = true;
  }
};
var HandPose = class extends BasePose {
  constructor(handedness, handPoseParams = new HandPoseParams()) {
    super(handPoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myFixTrackedHandRotation = handPoseParams.myFixTrackedHandRotation;
    this._myIsTrackedHand = false;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getInputSource() {
    return this._myInputSource;
  }
  getInputSourceType() {
    if (this._myInputSource == null) {
      return null;
    }
    return InputUtils.getInputSourceType(this._myInputSource);
  }
  isFixTrackedHandRotation() {
    return this._myFixTrackedHandRotation;
  }
  setFixTrackedHandRotation(fixTrackedHandRotation) {
    this.myFixTrackedHandRotation = fixTrackedHandRotation;
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getPose(this._myInputSource.gripSpace, this._myReferenceSpace);
  }
  _onXRSessionStartHook(manualCall, session) {
    session.addEventListener("inputsourceschange", function(event) {
      if (event.removed) {
        for (let item of event.removed) {
          if (item == this._myInputSource) {
            this._myInputSource = null;
          }
        }
      }
      if (event.added) {
        for (let item of event.added) {
          if (item.handedness == this._myHandedness) {
            this._myInputSource = item;
            this._myIsTrackedHand = InputUtils.getInputSourceType(this._myInputSource) == InputSourceType.TRACKED_HAND;
          }
        }
      }
    }.bind(this));
    if (manualCall && this._myInputSource == null && session.inputSources) {
      for (let item of session.inputSources) {
        if (item.handedness == this._myHandedness) {
          this._myInputSource = item;
          this._myIsTrackedHand = InputUtils.getInputSourceType(this._myInputSource) == InputSourceType.TRACKED_HAND;
        }
      }
    }
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
  }
};
HandPose.prototype.getRotationQuat = function() {
  let rotationQuat = quat_create();
  let playerRotationQuat = quat_create();
  let up = vec3_create2();
  let right = vec3_create2();
  let forward = vec3_create2();
  return function getRotationQuat() {
    rotationQuat.quat_copy(this._myRotationQuat);
    if (this._myFixForward) {
      rotationQuat.quat_rotateAxisRadians(Math.PI, rotationQuat.quat_getUp(up), rotationQuat);
    }
    if (this._myFixTrackedHandRotation && this._myIsTrackedHand) {
      rotationQuat.quat_rotateAxis(-60, rotationQuat.quat_getRight(right), rotationQuat);
      let forwardRotation = 20;
      forwardRotation = this._myHandedness == Handedness.LEFT ? forwardRotation : -forwardRotation;
      rotationQuat.quat_rotateAxis(forwardRotation, rotationQuat.quat_getForward(forward), rotationQuat);
    }
    if (this._myReferenceObject == null) {
      return rotationQuat;
    }
    return rotationQuat.quat_toWorld(this._myReferenceObject.pp_getRotationQuat(playerRotationQuat), rotationQuat);
  };
}();

// js/pp/input/gamepad/gamepad_buttons.js
var GamepadButtonID = {
  SELECT: 0,
  SQUEEZE: 1,
  TOUCHPAD: 2,
  THUMBSTICK: 3,
  BOTTOM_BUTTON: 4,
  TOP_BUTTON: 5,
  THUMB_REST: 6
};
var GamepadButtonEvent = {
  PRESS_START: 0,
  PRESS_END: 1,
  PRESSED: 2,
  NOT_PRESSED: 3,
  TOUCH_START: 4,
  TOUCH_END: 5,
  TOUCHED: 6,
  NOT_TOUCHED: 7,
  VALUE_CHANGED: 8,
  ALWAYS: 9
};
var GamepadAxesID = {
  THUMBSTICK: 0
};
var GamepadAxesEvent = {
  X_CHANGED: 0,
  Y_CHANGED: 1,
  AXES_CHANGED: 2,
  ALWAYS: 3
};
var GamepadButtonInfo = class {
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
    this.myIsPressed = false;
    this.myPrevIsPressed = false;
    this.myIsTouched = false;
    this.myPrevIsTouched = false;
    this.myValue = 0;
    this.myPrevValue = 0;
    this.myTimePressed = 0;
    this.myPrevTimePressed = 0;
    this.myTimeNotPressed = 0;
    this.myPrevTimeNotPressed = 0;
    this.myTimeTouched = 0;
    this.myPrevTimeTouched = 0;
    this.myTimeNotTouched = 0;
    this.myPrevTimeNotTouched = 0;
    this.myMultiplePressStartCount = 0;
    this.myPrevMultiplePressStartCount = 0;
    this.myMultiplePressEndCount = 0;
    this.myPrevMultiplePressEndCount = 0;
    this.myMultipleTouchStartCount = 0;
    this.myPrevMultipleTouchStartCount = 0;
    this.myMultipleTouchEndCount = 0;
    this.myPrevMultipleTouchEndCount = 0;
  }
  getID() {
    return this.myID;
  }
  getHandedness() {
    return this.myHandedness;
  }
  getValue() {
    return this.myValue;
  }
  isPressed() {
    return this.myIsPressed;
  }
  isTouched() {
    return this.myIsTouched;
  }
  isPressStart(multiplePressCount = null) {
    return this.myIsPressed && !this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressStartCount == multiplePressCount);
  }
  isPressEnd(multiplePressCount = null) {
    return !this.myIsPressed && this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressEndCount == multiplePressCount);
  }
  isTouchStart(multipleTouchCount = null) {
    return this.myIsTouched && !this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchStartCount == multipleTouchCount);
  }
  isTouchEnd(multipleTouchCount = null) {
    return !this.myIsTouched && this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchEndCount == multipleTouchCount);
  }
  clone() {
    let value = new GamepadButtonInfo(this.myID, this.myHandedness);
    value.myIsPressed = this.myIsPressed;
    value.myPrevIsPressed = this.myPrevIsPressed;
    value.myIsTouched = this.myIsTouched;
    value.myPrevIsTouched = this.myPrevIsTouched;
    value.myValue = this.myValue;
    value.myPrevValue = this.myPrevValue;
    value.myTimePressed = this.myTimePressed;
    value.myPrevTimePressed = this.myPrevTimePressed;
    value.myTimeNotPressed = this.myTimeNotPressed;
    value.myPrevTimeNotPressed = this.myPrevTimeNotPressed;
    value.myTimeTouched = this.myTimeTouched;
    value.myPrevTimeTouched = this.myPrevTimeTouched;
    value.myTimeNotTouched = this.myTimeNotTouched;
    value.myPrevTimeNotTouched = this.myPrevTimeNotTouched;
    value.myMultiplePressStartCount = this.myMultiplePressStartCount;
    value.myPrevMultiplePressStartCount = this.myPrevMultiplePressStartCount;
    value.myMultiplePressEndCount = this.myMultiplePressEndCount;
    value.myPrevMultiplePressEndCount = this.myPrevMultiplePressEndCount;
    value.myMultipleTouchStartCount = this.myMultipleTouchStartCount;
    value.myPrevMultipleTouchStartCount = this.myPrevMultipleTouchStartCount;
    value.myMultipleTouchEndCount = this.myMultipleTouchEndCount;
    value.myPrevMultipleTouchEndCount = this.myPrevMultipleTouchEndCount;
    return value;
  }
};
var GamepadAxesInfo = class {
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
    this.myAxes = vec2_create(0, 0);
    this.myPrevAxes = vec2_create(0, 0);
  }
  getID() {
    return this.myID;
  }
  getAxes() {
    return this.myAxes;
  }
  getHandedness() {
    return this.myHandedness;
  }
  clone() {
    let value = new GamepadAxesInfo(this.myID, this.myHandedness);
    value.myAxes.vec2_copy(this.myAxes);
    value.myPrevAxes.vec2_copy(this.myPrevAxes);
    return value;
  }
};
var GamepadPulseInfo = class {
  constructor() {
    this.myIntensity = 0;
    this.myDuration = 0;
    this.myIsDevicePulsing = false;
  }
  clone() {
    let value = new GamepadPulseInfo();
    value.myIntensity = this.myIntensity;
    value.myDuration = this.myDuration;
    value.myIsDevicePulsing = this.myIsDevicePulsing;
    return value;
  }
};

// js/pp/input/gamepad/gamepad_cores/gamepad_core.js
var GamepadCore = class {
  constructor(handPose) {
    this._myHandPose = handPose;
    this._myManageHandPose = false;
  }
  getHandedness() {
    return this.getHandPose().getHandedness();
  }
  getHandPose() {
    return this._myHandPose;
  }
  getEngine() {
    return this.getHandPose().getEngine();
  }
  isGamepadCoreActive() {
    return true;
  }
  setManageHandPose(manageHandPose) {
    this._myManageHandPose = manageHandPose;
  }
  isManagingHandPose() {
    return this._myManageHandPose;
  }
  start() {
    if (this.getHandPose() && this._myManageHandPose) {
      this.getHandPose().start();
    }
    this._startHook();
  }
  preUpdate(dt) {
    if (this.getHandPose() && this._myManageHandPose) {
      this.getHandPose().update(dt);
    }
    this._preUpdateHook(dt);
  }
  postUpdate(dt) {
    this._postUpdateHook(dt);
  }
  getButtonData(buttonID) {
    let buttonData = this._createButtonData();
    return buttonData;
  }
  getAxesData(axesID) {
    let axesData = this._createAxesData();
    return axesData;
  }
  getHapticActuators() {
    let hapticActuators = [];
    return hapticActuators;
  }
  _startHook() {
  }
  _preUpdateHook(dt) {
  }
  _postUpdateHook(dt) {
  }
  _createButtonData() {
    return { myIsPressed: false, myIsTouched: false, myValue: 0 };
  }
  _createAxesData() {
    return vec2_create(0, 0);
  }
};

// js/pp/input/gamepad/gamepad_cores/classic_gamepad_core.js
var ClassicGamepadCore = class extends GamepadCore {
  constructor(gamepadIndex, handPose) {
    super(handPose);
    this._myGamepadIndex = gamepadIndex;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    let classicGamepad = this._getClassicGamepad();
    return classicGamepad != null && (classicGamepad.connected == null || classicGamepad.connected);
  }
  getButtonData(buttonID) {
    this._myButtonData.myIsPressed = false;
    this._myButtonData.myIsTouched = false;
    this._myButtonData.myValue = 0;
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      let button = null;
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[4];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[6];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[10];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[13];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[12];
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[5];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[7];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[11];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[0];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[3];
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      }
      if (button != null) {
        this._myButtonData.myIsPressed = button.pressed;
        this._myButtonData.myIsTouched = button.touched;
        this._myButtonData.myValue = button.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        this._myAxesData[0] = classicGamepad.axes[0];
        this._myAxesData[1] = classicGamepad.axes[1];
      } else {
        this._myAxesData[0] = classicGamepad.axes[2];
        this._myAxesData[1] = classicGamepad.axes[3];
      }
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (classicGamepad.hapticActuators != null && classicGamepad.hapticActuators.length > 0) {
        this._myHapticActuators.push(...classicGamepad.hapticActuators);
      }
      if (classicGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(classicGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  _getClassicGamepad() {
    let classicGamepad = null;
    let gamepads = navigator.getGamepads();
    if (this._myGamepadIndex != null) {
      if (this._myGamepadIndex < gamepads.length) {
        classicGamepad = gamepads[this._myGamepadIndex];
      }
    } else {
      for (let gamepad of gamepads) {
        if (gamepad != null && (gamepad.connected == null || gamepad.connected)) {
          classicGamepad = gamepad;
          break;
        }
      }
    }
    return classicGamepad;
  }
};

// js/pp/input/cauldron/input_globals.js
var _myInputManagers = /* @__PURE__ */ new WeakMap();
function getInputManager(engine2 = getMainEngine2()) {
  return _myInputManagers.get(engine2);
}
function setInputManager(inputManager, engine2 = getMainEngine2()) {
  _myInputManagers.set(engine2, inputManager);
}
function removeInputManager(engine2 = getMainEngine2()) {
  _myInputManagers.delete(engine2);
}
function hasInputManager(engine2 = getMainEngine2()) {
  return _myInputManagers.has(engine2);
}
function getMouse(engine2 = getMainEngine2()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getMouse();
  }
  return null;
}
function getKeyboard(engine2 = getMainEngine2()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getKeyboard();
  }
  return null;
}
function getGamepadsManager(engine2 = getMainEngine2()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager();
  }
  return null;
}
function getGamepads(engine2 = getMainEngine2()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepads();
  }
  return null;
}
function getLeftGamepad(engine2 = getMainEngine2()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getLeftGamepad();
  }
  return null;
}
function getRightGamepad(engine2 = getMainEngine2()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getRightGamepad();
  }
  return null;
}

// js/pp/input/cauldron/keyboard.js
var KeyID = {
  _0: "0",
  _1: "1",
  _2: "2",
  _3: "3",
  _4: "4",
  _5: "5",
  _6: "6",
  _7: "7",
  _8: "8",
  _9: "9",
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  E: "E",
  F: "F",
  G: "G",
  H: "H",
  I: "I",
  J: "J",
  K: "K",
  L: "L",
  M: "M",
  N: "N",
  O: "O",
  P: "P",
  Q: "Q",
  R: "R",
  S: "S",
  T: "T",
  U: "U",
  V: "V",
  W: "W",
  X: "X",
  Y: "Y",
  Z: "Z",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  e: "e",
  f: "f",
  g: "g",
  h: "h",
  i: "i",
  j: "j",
  k: "k",
  l: "l",
  m: "m",
  n: "n",
  o: "o",
  p: "p",
  q: "q",
  r: "r",
  s: "s",
  t: "t",
  u: "u",
  v: "v",
  w: "w",
  x: "x",
  y: "y",
  z: "z",
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  SPACE: " ",
  ENTER: "Enter",
  BACKSPACE: "Backspace",
  ESC: "Escape",
  SHIFT_LEFT: "ShiftLeft",
  SHIFT_RIGHT: "ShiftRight",
  CONTROL_LEFT: "ControlLeft",
  CONTROL_RIGHT: "ControlRight",
  ALT_LEFT: "AltLeft",
  ALT_RIGHT: "AltRight"
};
var Keyboard = class {
  constructor() {
    this._myKeyInfos = /* @__PURE__ */ new Map();
    for (let key in KeyID) {
      this.addKey(KeyID[key]);
    }
  }
  isKeyPressed(keyID) {
    let isPressed = false;
    if (this._myKeyInfos.has(keyID)) {
      isPressed = this._myKeyInfos.get(keyID).myIsPressed;
    }
    return isPressed;
  }
  isKeyPressStart(keyID) {
    let isPressStart = false;
    if (this._myKeyInfos.has(keyID)) {
      isPressStart = this._myKeyInfos.get(keyID).myIsPressStart;
    }
    return isPressStart;
  }
  isKeyPressEnd(keyID) {
    let isPressEnd = false;
    if (this._myKeyInfos.has(keyID)) {
      isPressEnd = this._myKeyInfos.get(keyID).myIsPressEnd;
    }
    return isPressEnd;
  }
  addKey(keyID) {
    this._myKeyInfos.set(keyID, this._createKeyInfo());
  }
  start() {
    window.addEventListener("keydown", this._keyDown.bind(this));
    window.addEventListener("keyup", this._keyUp.bind(this));
  }
  update(dt) {
    if (!document.hasFocus()) {
      for (let keyInfo of this._myKeyInfos.values()) {
        if (keyInfo.myIsPressed) {
          keyInfo.myIsPressed = false;
          keyInfo.myIsPressEndToProcess = true;
        }
      }
    }
    for (let keyInfo of this._myKeyInfos.values()) {
      keyInfo.myIsPressStart = keyInfo.myIsPressStartToProcess;
      keyInfo.myIsPressEnd = keyInfo.myIsPressEndToProcess;
      keyInfo.myIsPressStartToProcess = false;
      keyInfo.myIsPressEndToProcess = false;
    }
  }
  _keyDown(event) {
    this._keyPressedChanged(event.key, true);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, true);
    }
  }
  _keyUp(event) {
    this._keyPressedChanged(event.key, false);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, false);
    }
  }
  _keyPressedChanged(keyID, isPressed) {
    if (this._myKeyInfos.has(keyID)) {
      let keyInfo = this._myKeyInfos.get(keyID);
      if (isPressed) {
        keyInfo.myIsPressed = true;
        keyInfo.myIsPressStartToProcess = true;
      } else {
        keyInfo.myIsPressed = false;
        keyInfo.myIsPressEndToProcess = true;
      }
    }
  }
  _createKeyInfo() {
    return { myIsPressed: false, myIsPressStart: false, myIsPressStartToProcess: false, myIsPressEnd: false, myIsPressEndToProcess: false };
  }
};

// js/pp/input/gamepad/gamepad_cores/keyboard_gamepad_core.js
var KeyboardGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return true;
  }
  getButtonData(buttonID) {
    this._myButtonData.myIsPressed = false;
    this._myButtonData.myIsTouched = false;
    this._myButtonData.myValue = 0;
    let keyboard = getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.E) || keyboard.isKeyPressed(KeyID.e);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.Q) || keyboard.isKeyPressed(KeyID.q);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.X) || keyboard.isKeyPressed(KeyID.x);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.R) || keyboard.isKeyPressed(KeyID.r);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.C) || keyboard.isKeyPressed(KeyID.c);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.F) || keyboard.isKeyPressed(KeyID.f);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.V) || keyboard.isKeyPressed(KeyID.v);
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.U) || keyboard.isKeyPressed(KeyID.u);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.O) || keyboard.isKeyPressed(KeyID.o);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.M) || keyboard.isKeyPressed(KeyID.m);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.Y) || keyboard.isKeyPressed(KeyID.y);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.N) || keyboard.isKeyPressed(KeyID.n);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.H) || keyboard.isKeyPressed(KeyID.h);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myIsPressed = keyboard.isKeyPressed(KeyID.B) || keyboard.isKeyPressed(KeyID.b);
            break;
        }
      }
    }
    if (this._myButtonData.myIsPressed) {
      this._myButtonData.myIsTouched = true;
      this._myButtonData.myValue = 1;
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    let keyboard = getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        if (keyboard.isKeyPressed(KeyID.W) || keyboard.isKeyPressed(KeyID.w))
          this._myAxesData[1] += 1;
        if (keyboard.isKeyPressed(KeyID.S) || keyboard.isKeyPressed(KeyID.s))
          this._myAxesData[1] += -1;
        if (keyboard.isKeyPressed(KeyID.D) || keyboard.isKeyPressed(KeyID.d))
          this._myAxesData[0] += 1;
        if (keyboard.isKeyPressed(KeyID.A) || keyboard.isKeyPressed(KeyID.a))
          this._myAxesData[0] += -1;
      } else {
        if (keyboard.isKeyPressed(KeyID.I) || keyboard.isKeyPressed(KeyID.i) || keyboard.isKeyPressed(KeyID.UP))
          this._myAxesData[1] += 1;
        if (keyboard.isKeyPressed(KeyID.K) || keyboard.isKeyPressed(KeyID.k) || keyboard.isKeyPressed(KeyID.DOWN))
          this._myAxesData[1] += -1;
        if (keyboard.isKeyPressed(KeyID.L) || keyboard.isKeyPressed(KeyID.l) || keyboard.isKeyPressed(KeyID.RIGHT))
          this._myAxesData[0] += 1;
        if (keyboard.isKeyPressed(KeyID.J) || keyboard.isKeyPressed(KeyID.j) || keyboard.isKeyPressed(KeyID.LEFT))
          this._myAxesData[0] += -1;
      }
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// js/pp/input/gamepad/gamepad_cores/xr_gamepad_core.js
var XRGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._mySelectPressed = false;
    this._mySqueezePressed = false;
    this._myIsXRSessionActive = false;
    this._myInputSource = null;
    this._myGamepad = null;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this._myIsXRSessionActive && this._myGamepad != null && (this._myGamepad.connected == null || this._myGamepad.connected);
  }
  _startHook() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.getEngine());
  }
  _preUpdateHook(dt) {
    this._myInputSource = this.getHandPose().getInputSource();
    if (this._myInputSource != null) {
      this._myGamepad = this._myInputSource.gamepad;
    } else {
      this._myGamepad = null;
    }
  }
  getButtonData(buttonID) {
    this._myButtonData.myIsPressed = false;
    this._myButtonData.myIsTouched = false;
    this._myButtonData.myValue = 0;
    if (this.isGamepadCoreActive()) {
      if (buttonID < this._myGamepad.buttons.length) {
        let gamepadButton = this._myGamepad.buttons[buttonID];
        if (buttonID != GamepadButtonID.SELECT && buttonID != GamepadButtonID.SQUEEZE) {
          this._myButtonData.myIsPressed = gamepadButton.pressed;
        } else {
          this._myButtonData.myIsPressed = this._getSpecialButtonPressed(buttonID);
        }
        this._myButtonData.myIsTouched = gamepadButton.touched;
        this._myButtonData.myValue = gamepadButton.value;
      } else if (buttonID == GamepadButtonID.TOP_BUTTON && this._myGamepad.buttons.length >= 3) {
        let touchButton = this._myGamepad.buttons[2];
        this._myButtonData.myIsPressed = touchButton.pressed;
        this._myButtonData.myIsTouched = touchButton.touched;
        this._myButtonData.myValue = touchButton.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    if (this.isGamepadCoreActive()) {
      let internalAxes = this._myGamepad.axes;
      if (internalAxes.length == 4) {
        if (Math.abs(internalAxes[0]) > Math.abs(internalAxes[2])) {
          this._myAxesData[0] = internalAxes[0];
        } else {
          this._myAxesData[0] = internalAxes[2];
        }
        if (Math.abs(internalAxes[1]) > Math.abs(internalAxes[3])) {
          this._myAxesData[1] = internalAxes[1];
        } else {
          this._myAxesData[1] = internalAxes[3];
        }
      } else if (internalAxes.length == 2) {
        this._myAxesData[0] = internalAxes[0];
        this._myAxesData[1] = internalAxes[1];
      }
      this._myAxesData[1] = -this._myAxesData[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    if (this.isGamepadCoreActive()) {
      if (this._myGamepad.hapticActuators != null && this._myGamepad.hapticActuators.length > 0) {
        this._myHapticActuators.push(...this._myGamepad.hapticActuators);
      }
      if (this._myGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(this._myGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  _getSpecialButtonPressed(buttonID) {
    let isPressed = false;
    if (this.isGamepadCoreActive()) {
      if (buttonID == GamepadButtonID.SELECT) {
        isPressed = this._mySelectPressed;
      } else if (buttonID == GamepadButtonID.SQUEEZE) {
        isPressed = this._mySqueezePressed;
      }
    }
    return isPressed;
  }
  _onXRSessionStart(session) {
    session.addEventListener("selectstart", this._selectStart.bind(this));
    session.addEventListener("selectend", this._selectEnd.bind(this));
    session.addEventListener("squeezestart", this._squeezeStart.bind(this));
    session.addEventListener("squeezeend", this._squeezeEnd.bind(this));
    this._myIsXRSessionActive = true;
  }
  _onXRSessionEnd(session) {
    this._myIsXRSessionActive = false;
  }
  _selectStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = true;
    }
  }
  _selectEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = false;
    }
  }
  _squeezeStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = true;
    }
  }
  _squeezeEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = false;
    }
  }
};

// js/pp/input/gamepad/base_gamepad.js
var BaseGamepad = class {
  constructor(handedness) {
    this._myHandedness = handedness;
    this._myButtonInfos = [];
    for (let key in GamepadButtonID) {
      this._myButtonInfos[GamepadButtonID[key]] = new GamepadButtonInfo(GamepadButtonID[key], this._myHandedness);
    }
    this._myAxesInfos = [];
    for (let key in GamepadAxesID) {
      this._myAxesInfos[GamepadAxesID[key]] = new GamepadAxesInfo(GamepadAxesID[key], this._myHandedness);
    }
    this._myButtonCallbacks = [];
    for (let key in GamepadButtonID) {
      this._myButtonCallbacks[GamepadButtonID[key]] = [];
      for (let eventKey in GamepadButtonEvent) {
        this._myButtonCallbacks[GamepadButtonID[key]][GamepadButtonEvent[eventKey]] = /* @__PURE__ */ new Map();
      }
    }
    this._myAxesCallbacks = [];
    for (let key in GamepadAxesID) {
      this._myAxesCallbacks[GamepadAxesID[key]] = [];
      for (let eventKey in GamepadAxesEvent) {
        this._myAxesCallbacks[GamepadAxesID[key]][GamepadAxesEvent[eventKey]] = /* @__PURE__ */ new Map();
      }
    }
    this._myPulseInfo = new GamepadPulseInfo();
    this._myMultiplePressMaxDelay = 0.4;
    this._myMultipleTouchMaxDelay = 0.4;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getButtonInfo(buttonID) {
    return this._myButtonInfos[buttonID];
  }
  registerButtonEventListener(buttonID, buttonEvent, id, callback) {
    this._myButtonCallbacks[buttonID][buttonEvent].set(id, callback);
  }
  unregisterButtonEventListener(buttonID, buttonEvent, id) {
    this._myButtonCallbacks[buttonID][buttonEvent].delete(id);
  }
  getAxesInfo(axesID) {
    return this._myAxesInfos[axesID];
  }
  registerAxesEventListener(axesID, axesEvent, id, callback) {
    this._myAxesCallbacks[axesID][axesEvent].set(id, callback);
  }
  unregisterAxesEventListener(axesID, axesEvent, id) {
    this._myAxesCallbacks[axesID][axesEvent].delete(id);
  }
  pulse(intensity, duration = 0) {
    this._myPulseInfo.myIntensity = Math.pp_clamp(intensity, 0, 1);
    this._myPulseInfo.myDuration = Math.max(duration, 0);
  }
  stopPulse() {
    this._myPulseInfo.myIntensity = 0;
    this._myPulseInfo.myDuration = 0;
  }
  isPulsing() {
    return this._myPulseInfo.myIntensity > 0 || this._myPulseInfo.myDuration > 0;
  }
  getPulseInfo() {
    return this._myPulseInfo;
  }
  getMultiplePressMaxDelay() {
    return this._myMultiplePressMaxDelay;
  }
  setMultiplePressMaxDelay(maxDelay) {
    this._myMultiplePressMaxDelay = maxDelay;
  }
  getMultipleTouchMaxDelay() {
    return this._myMultipleTouchMaxDelay;
  }
  setMultipleTouchMaxDelay(maxDelay) {
    this._myMultipleTouchMaxDelay = maxDelay;
  }
  getHandPose() {
    return null;
  }
  _start() {
  }
  _preUpdate(dt) {
  }
  _postUpdate(dt) {
  }
  _getButtonData(buttonID) {
    let buttonData = this._createButtonData();
    return buttonData;
  }
  _getAxesData(axesID) {
    let axesData = this._createAxesData();
    return axesData;
  }
  _getHapticActuators() {
    let hapticActuator = [];
    return hapticActuator;
  }
  start() {
    this._start();
  }
  update(dt) {
    this._preUpdate(dt);
    this._preUpdateButtonInfos();
    this._updateButtonInfos();
    this._postUpdateButtonInfos(dt);
    this._preUpdateAxesInfos();
    this._updateAxesInfos();
    this._postUpdateAxesInfos();
    this._updatePulse(dt);
    this._postUpdate(dt);
  }
  _preUpdateButtonInfos() {
    this._myButtonInfos.forEach(function(item) {
      item.myPrevIsPressed = item.myIsPressed;
      item.myPrevIsTouched = item.myIsTouched;
      item.myPrevValue = item.myValue;
    });
  }
  _updateButtonInfos() {
    this._updateSingleButtonInfo(GamepadButtonID.SELECT);
    this._updateSingleButtonInfo(GamepadButtonID.SQUEEZE);
    this._updateSingleButtonInfo(GamepadButtonID.TOUCHPAD);
    this._updateSingleButtonInfo(GamepadButtonID.THUMBSTICK);
    this._updateSingleButtonInfo(GamepadButtonID.BOTTOM_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.TOP_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.THUMB_REST);
  }
  _updateSingleButtonInfo(buttonID) {
    let buttonInfo = this._myButtonInfos[buttonID];
    let buttonData = this._getButtonData(buttonID);
    buttonInfo.myIsPressed = buttonData.myIsPressed;
    buttonInfo.myIsTouched = buttonData.myIsTouched;
    buttonInfo.myValue = buttonData.myValue;
  }
  _postUpdateButtonInfos(dt) {
    this._myButtonInfos.forEach(function(item) {
      if (item.myIsPressed) {
        item.myTimePressed += dt;
        if (!item.myPrevIsPressed) {
          item.myMultiplePressStartCount += 1;
          item.myPrevTimeNotPressed = item.myTimeNotPressed;
          item.myTimeNotPressed = 0;
        }
        if (item.myPrevTimeNotPressed + item.myTimePressed > this._myMultiplePressMaxDelay && item.myMultiplePressEndCount > 0) {
          item.myPrevMultiplePressEndCount = item.myMultiplePressEndCount;
          item.myMultiplePressEndCount = 0;
        }
        if (item.myTimePressed > this._myMultiplePressMaxDelay && item.myMultiplePressStartCount > 0) {
          item.myPrevMultiplePressStartCount = item.myMultiplePressStartCount;
          item.myMultiplePressStartCount = 0;
        }
      } else {
        item.myTimeNotPressed += dt;
        if (item.myPrevIsPressed) {
          item.myMultiplePressEndCount += 1;
          item.myPrevTimePressed = item.myTimePressed;
          item.myTimePressed = 0;
        }
        if (item.myPrevTimePressed + item.myTimeNotPressed > this._myMultiplePressMaxDelay && item.myMultiplePressStartCount > 0) {
          item.myPrevMultiplePressStartCount = item.myMultiplePressStartCount;
          item.myMultiplePressStartCount = 0;
        }
        if (item.myTimeNotPressed > this._myMultiplePressMaxDelay && item.myMultiplePressEndCount > 0) {
          item.myPrevMultiplePressEndCount = item.myMultiplePressEndCount;
          item.myMultiplePressEndCount = 0;
        }
      }
      if (item.myIsTouched) {
        item.myTimeTouched += dt;
        if (!item.myPrevIsTouched) {
          item.myMultipleTouchStartCount += 1;
          item.myPrevTimeNotTouched = item.myTimeNotTouched;
          item.myTimeNotTouched = 0;
        }
        if (item.myPrevTimeNotTouched + item.myTimeTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchEndCount > 0) {
          item.myPrevMultipleTouchEndCount = item.myMultipleTouchEndCount;
          item.myMultipleTouchEndCount = 0;
        }
        if (item.myTimeTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchStartCount > 0) {
          item.myPrevMultipleTouchStartCount = item.myMultipleTouchStartCount;
          item.myMultipleTouchStartCount = 0;
        }
      } else {
        item.myTimeNotTouched += dt;
        if (item.myPrevIsTouched) {
          item.myMultipleTouchEndCount += 1;
          item.myPrevTimeTouched = item.myTimeTouched;
          item.myTimeTouched = 0;
        }
        if (item.myPrevTimeTouched + item.myTimeNotTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchStartCount > 0) {
          item.myPrevMultipleTouchStartCount = item.myMultipleTouchStartCount;
          item.myMultipleTouchStartCount = 0;
        }
        if (item.myTimeNotTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchEndCount > 0) {
          item.myPrevMultipleTouchEndCount = item.myMultipleTouchEndCount;
          item.myMultipleTouchEndCount = 0;
        }
      }
    }.bind(this));
    for (let key in GamepadButtonID) {
      let buttonInfo = this._myButtonInfos[GamepadButtonID[key]];
      let buttonCallbacks = this._myButtonCallbacks[GamepadButtonID[key]];
      if (buttonInfo.myIsPressed && !buttonInfo.myPrevIsPressed) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.PRESS_START];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      if (!buttonInfo.myIsPressed && buttonInfo.myPrevIsPressed) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.PRESS_END];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      if (buttonInfo.myIsPressed) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.PRESSED];
        this._triggerCallbacks(callbacks2, buttonInfo);
      } else {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.NOT_PRESSED];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      if (buttonInfo.myIsTouched && !buttonInfo.myPrevIsTouched) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.TOUCH_START];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      if (!buttonInfo.myIsTouched && buttonInfo.myPrevIsTouched) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.TOUCH_END];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      if (buttonInfo.myIsTouched) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.TOUCHED];
        this._triggerCallbacks(callbacks2, buttonInfo);
      } else {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.NOT_TOUCHED];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      if (buttonInfo.myValue != buttonInfo.myPrevValue) {
        let callbacks2 = buttonCallbacks[GamepadButtonEvent.VALUE_CHANGED];
        this._triggerCallbacks(callbacks2, buttonInfo);
      }
      let callbacks = buttonCallbacks[GamepadButtonEvent.ALWAYS];
      this._triggerCallbacks(callbacks, buttonInfo);
    }
    this._mySelectStart = false;
    this._mySelectEnd = false;
    this._mySqueezeStart = false;
    this._mySqueezeEnd = false;
  }
  _preUpdateAxesInfos() {
    this._myAxesInfos.forEach(function(item) {
      item.myPrevAxes[0] = item.myAxes[0];
      item.myPrevAxes[1] = item.myAxes[1];
    });
  }
  _updateAxesInfos() {
    this._updateSingleAxesInfo(GamepadAxesID.THUMBSTICK);
  }
  _updateSingleAxesInfo(axesID) {
    let axesInfo = this._myAxesInfos[axesID];
    let axesData = this._getAxesData(axesID);
    axesInfo.myAxes[0] = axesData[0];
    axesInfo.myAxes[1] = axesData[1];
  }
  _postUpdateAxesInfos() {
    for (let key in GamepadAxesID) {
      let axesInfo = this._myAxesInfos[GamepadAxesID[key]];
      let axesCallbacks = this._myAxesCallbacks[GamepadAxesID[key]];
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0]) {
        let callbacks2 = axesCallbacks[GamepadAxesEvent.X_CHANGED];
        this._triggerCallbacks(callbacks2, axesInfo);
      }
      if (axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        let callbacks2 = axesCallbacks[GamepadAxesEvent.Y_CHANGED];
        this._triggerCallbacks(callbacks2, axesInfo);
      }
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0] || axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        let callbacks2 = axesCallbacks[GamepadAxesEvent.AXES_CHANGED];
        this._triggerCallbacks(callbacks2, axesInfo);
      }
      let callbacks = axesCallbacks[GamepadAxesEvent.ALWAYS];
      this._triggerCallbacks(callbacks, axesInfo);
    }
  }
  _updatePulse(dt) {
    if (this._myPulseInfo.myIsDevicePulsing || this._myPulseInfo.myIntensity > 0) {
      let hapticActuators = this._getHapticActuators();
      if (hapticActuators.length > 0) {
        if (this._myPulseInfo.myIntensity > 0) {
          for (let hapticActuator of hapticActuators) {
            hapticActuator.pulse(this._myPulseInfo.myIntensity, 1e3);
          }
          this._myPulseInfo.myIsDevicePulsing = true;
        } else if (this._myPulseInfo.myIsDevicePulsing) {
          for (let hapticActuator of hapticActuators) {
            hapticActuator.reset();
          }
          this._myPulseInfo.myIsDevicePulsing = false;
        }
      } else {
        this._myPulseInfo.myIsDevicePulsing = false;
      }
    }
    this._myPulseInfo.myDuration -= dt;
    if (this._myPulseInfo.myDuration <= 0) {
      this._myPulseInfo.myIntensity = 0;
      this._myPulseInfo.myDuration = 0;
    }
  }
  _triggerCallbacks(callbacks, info) {
    for (let callback of callbacks.values()) {
      callback(info, this);
    }
  }
  _createButtonData() {
    return { myIsPressed: false, myIsTouched: false, myValue: 0 };
  }
  _createAxesData() {
    return vec2_create(0, 0);
  }
};

// js/pp/input/gamepad/universal_gamepad.js
var UniversalGamepad = class extends BaseGamepad {
  constructor(handedness) {
    super(handedness);
    this._myGamepadCores = /* @__PURE__ */ new Map();
    this._myStarted = false;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  addGamepadCore(id, gamepadCore) {
    if (gamepadCore.getHandedness() == this.getHandedness()) {
      this._myGamepadCores.set(id, gamepadCore);
      if (this._myStarted) {
        gamepadCore.start();
      }
    }
  }
  getGamepadCore(id) {
    return this._myGamepadCores.get(id);
  }
  removeGamepadCore(id) {
    let gamepadCore = this._myGamepadCores.get(id);
    if (gamepadCore) {
      this._myGamepadCores.delete(id);
    }
  }
  removeAllGamepadCores() {
    for (let id of this._myGamepadCores.keys()) {
      this.removeGamepadCore(id);
    }
  }
  getHandPose() {
    let handPose = null;
    for (let core of this._myGamepadCores.values()) {
      if (core.isGamepadCoreActive()) {
        let currentCoreHandPose = core.getHandPose();
        if (handPose == null || currentCoreHandPose != null && currentCoreHandPose.isValid()) {
          handPose = currentCoreHandPose;
        }
      }
      if (handPose != null && handPose.isValid()) {
        break;
      }
    }
    return handPose;
  }
  _start() {
    for (let core of this._myGamepadCores.values()) {
      core.start();
    }
    this._myStarted = true;
  }
  _preUpdate(dt) {
    for (let core of this._myGamepadCores.values()) {
      core.preUpdate(dt);
    }
  }
  _postUpdate(dt) {
    for (let core of this._myGamepadCores.values()) {
      core.postUpdate(dt);
    }
  }
  _getButtonData(buttonID) {
    this._myButtonData.myIsPressed = false;
    this._myButtonData.myIsTouched = false;
    this._myButtonData.myValue = 0;
    for (let core of this._myGamepadCores.values()) {
      if (core.isGamepadCoreActive()) {
        let coreButtonData = core.getButtonData(buttonID);
        this._myButtonData.myIsPressed = this._myButtonData.myIsPressed || coreButtonData.myIsPressed;
        this._myButtonData.myIsTouched = this._myButtonData.myIsTouched || coreButtonData.myIsTouched;
        if (Math.abs(coreButtonData.myValue) > Math.abs(this._myButtonData.myValue)) {
          this._myButtonData.myValue = coreButtonData.myValue;
        }
      }
    }
    return this._myButtonData;
  }
  _getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    for (let core of this._myGamepadCores.values()) {
      if (core.isGamepadCoreActive()) {
        let coreAxesData = core.getAxesData(axesID);
        if (Math.abs(coreAxesData[0]) > Math.abs(this._myAxesData[0])) {
          this._myAxesData[0] = coreAxesData[0];
        }
        if (Math.abs(coreAxesData[1]) > Math.abs(this._myAxesData[1])) {
          this._myAxesData[1] = coreAxesData[1];
        }
      }
    }
    return this._myAxesData;
  }
  _getHapticActuators() {
    this._myHapticActuators.pp_clear();
    for (let core of this._myGamepadCores.values()) {
      if (core.isGamepadCoreActive()) {
        this._myHapticActuators.push(...core.getHapticActuators());
      }
    }
    return this._myHapticActuators;
  }
};

// js/pp/input/gamepad/cauldron/gamepads_manager.js
var GamepadsManager = class {
  constructor() {
    this._myLeftGamepad = new UniversalGamepad(Handedness.LEFT);
    this._myRightGamepad = new UniversalGamepad(Handedness.RIGHT);
  }
  start() {
    this._myLeftGamepad.start();
    this._myRightGamepad.start();
  }
  update(dt) {
    this._myLeftGamepad.update(dt);
    this._myRightGamepad.update(dt);
  }
  getLeftGamepad() {
    return this._myLeftGamepad;
  }
  getRightGamepad() {
    return this._myRightGamepad;
  }
  getGamepad(handedness) {
    let gamepad = null;
    switch (handedness) {
      case Handedness.LEFT:
        gamepad = this._myLeftGamepad;
        break;
      case Handedness.RIGHT:
        gamepad = this._myRightGamepad;
        break;
      default:
        gamepad = null;
    }
    return gamepad;
  }
  getGamepads() {
    let gamepads = [];
    gamepads[Handedness.LEFT] = this._myLeftGamepad;
    gamepads[Handedness.RIGHT] = this._myRightGamepad;
    return gamepads;
  }
};

// js/pp/input/cauldron/mouse.js
import { ViewComponent as ViewComponent2 } from "@wonderlandengine/api";
var MouseButtonID = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
var Mouse = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
    this._myButtonInfos = /* @__PURE__ */ new Map();
    for (let key in MouseButtonID) {
      this._myButtonInfos.set(MouseButtonID[key], this._createButtonInfo());
    }
    this._myPreventContextMenuCallback = this._preventContextMenu.bind(this);
    this._myPreventMiddleButtonScrollCallback = this._preventMiddleButtonScroll.bind(this);
    this._myInternalMousePosition = vec2_create();
    this._myScreenSize = vec2_create();
    this._updateScreenSize();
    this._myResetMovingDelay = 0.15;
    this._myResetMovingTimer = new Timer(this._myResetMovingDelay, false);
    this._myIsMoving = false;
    this._myIsInsideView = false;
    this._myIsValid = false;
    this._myPointerUpOnPointerLeave = true;
    this._myContextMenuActive = true;
    this._myMiddleButtonScrollActive = true;
    this._myPointerID = null;
    this._myLastValidPointerEvent = null;
    this._myPointerEventValidCallbacks = /* @__PURE__ */ new Map();
    this._myProjectionMatrixInverse = mat4_create();
    this._myRotationQuat = quat_create();
    this._myOriginWorld = vec3_create2();
    this._myDirectionWorld = vec3_create2();
  }
  start() {
    this._myOnPointerMoveCallback = this._onPointerAction.bind(this, this._onPointerMove.bind(this));
    document.body.addEventListener("pointermove", this._myOnPointerMoveCallback);
    this._myOnPointerDownCallback = this._onPointerAction.bind(this, this._onPointerDown.bind(this));
    document.body.addEventListener("pointerdown", this._myOnPointerDownCallback);
    this._myOnPointerUpCallback = this._onPointerAction.bind(this, this._onPointerUp.bind(this));
    document.body.addEventListener("pointerup", this._myOnPointerUpCallback);
    this._myOnPointerLeaveCallback = this._onPointerLeave.bind(this);
    document.body.addEventListener("pointerleave", this._myOnPointerLeaveCallback);
    this._myOnPointerEnterCallback = this._onPointerEnter.bind(this);
    document.body.addEventListener("pointerenter", this._myOnPointerEnterCallback);
    this._myOnMouseDownCallback = this._onMouseAction.bind(this, this._onPointerDown.bind(this));
    document.body.addEventListener("mousedown", this._myOnMouseDownCallback);
    this._myOnMouseUpCallback = this._onMouseAction.bind(this, this._onPointerUp.bind(this));
    document.body.addEventListener("mouseup", this._myOnMouseUpCallback);
  }
  update(dt) {
    if (this._myResetMovingTimer.isRunning()) {
      this._myResetMovingTimer.update(dt);
      if (this._myResetMovingTimer.isDone()) {
        this._myResetMovingTimer.reset();
        this._myIsMoving = false;
      }
    }
    for (let buttonInfo of this._myButtonInfos.values()) {
      buttonInfo.myIsPressStart = buttonInfo.myIsPressStartToProcess;
      buttonInfo.myIsPressEnd = buttonInfo.myIsPressEndToProcess;
      buttonInfo.myIsPressStartToProcess = false;
      buttonInfo.myIsPressEndToProcess = false;
    }
    this._updateScreenSize();
    if (!this.isAnyButtonPressed() && !this._myIsMoving) {
      this._myPointerID = null;
    }
    if (this._myLastValidPointerEvent != null) {
      let isLastValidPointerEventStillValid = this._isPointerEventValid(this._myLastValidPointerEvent);
      if (!isLastValidPointerEventStillValid) {
        if (this._myIsInsideView) {
          this._onPointerLeave(this._myLastValidPointerEvent);
        }
        this._myLastValidPointerEvent = null;
      }
    }
  }
  destroy() {
    document.body.removeEventListener("pointermove", this._myOnPointerMoveCallback);
    document.body.removeEventListener("pointerdown", this._myOnPointerDownCallback);
    document.body.removeEventListener("pointerup", this._myOnPointerUpCallback);
    document.body.removeEventListener("pointerleave", this._myOnPointerLeaveCallback);
    document.body.removeEventListener("pointerenter", this._myOnPointerEnterCallback);
    document.body.removeEventListener("mousedown", this._myOnMouseDownCallback);
    document.body.removeEventListener("mouseup", this._myOnMouseUpCallback);
    document.body.removeEventListener("contextmenu", this._myPreventContextMenuCallback);
    document.body.removeEventListener("mousedown", this._myPreventMiddleButtonScrollCallback);
  }
  isValid() {
    return this._myIsValid;
  }
  isButtonPressed(buttonID) {
    let isPressed = false;
    if (this._myButtonInfos.has(buttonID)) {
      isPressed = this._myButtonInfos.get(buttonID).myIsPressed;
    }
    return isPressed;
  }
  isAnyButtonPressed() {
    let isPressed = false;
    for (let buttonInfo of this._myButtonInfos.values()) {
      if (buttonInfo.myIsPressed) {
        isPressed = true;
        break;
      }
    }
    return isPressed;
  }
  isButtonPressStart(buttonID) {
    let isPressStart = false;
    if (this._myButtonInfos.has(buttonID)) {
      isPressStart = this._myButtonInfos.get(buttonID).myIsPressStart;
    }
    return isPressStart;
  }
  isButtonPressEnd(buttonID = null) {
    let isPressEnd = false;
    if (this._myButtonInfos.has(buttonID)) {
      isPressEnd = this._myButtonInfos.get(buttonID).myIsPressEnd;
    }
    return isPressEnd;
  }
  isMoving() {
    return this._myIsMoving;
  }
  isInsideView() {
    return this._myIsInsideView;
  }
  isTargetingRenderCanvas() {
    return this.isInsideView() && this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.target == this._myEngine.canvas;
  }
  raycastWorld(raycastSetup, raycastResults = new RaycastResults()) {
    this.getOriginWorld(raycastSetup.myOrigin);
    this.getDirectionWorld(raycastSetup.myDirection);
    raycastResults = PhysicsUtils.raycast(raycastSetup, raycastResults);
    return raycastResults;
  }
  getPositionScreen(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myInternalMousePosition[0];
    mousePosition[1] = this._myScreenSize[1] - 1 - this._myInternalMousePosition[1];
    return mousePosition;
  }
  getPositionScreenNormalized(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myScreenSize[0] == 0 ? 0 : this._myInternalMousePosition[0] / this._myScreenSize[0] * 2 - 1;
    mousePosition[1] = this._myScreenSize[1] == 0 ? 0 : (this._myScreenSize[1] - 1 - this._myInternalMousePosition[1]) / this._myScreenSize[1] * 2 - 1;
    return mousePosition;
  }
  getScreenSize() {
    return this._myScreenSize;
  }
  getPositionWorld(distanceFromCamera, out = vec3_create2()) {
    let originWorld = this.getOriginWorld(this._myOriginWorld);
    let directionWorld = this.getDirectionWorld(this._myDirectionWorld);
    out = originWorld.vec3_add(directionWorld.vec3_scale(distanceFromCamera, out), out);
    return out;
  }
  getOriginWorld(out = vec3_create2()) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      getPlayerObjects2(this._myEngine).myEyeLeft.pp_getPosition(out);
    } else {
      getPlayerObjects2(this._myEngine).myCameraNonVR.pp_getPosition(out);
    }
    return out;
  }
  getDirectionWorld(out = vec3_create2()) {
    let right = this._myInternalMousePosition[0] / this._myScreenSize[0];
    let up = this._myInternalMousePosition[1] / this._myScreenSize[1];
    let directionLocal = out;
    directionLocal.vec3_set(right * 2 - 1, -up * 2 + 1, -1);
    let projectionMatrixInvert = this._myProjectionMatrixInverse;
    if (XRUtils.isSessionActive(this._myEngine)) {
      projectionMatrixInvert = getPlayerObjects2(this._myEngine).myEyeLeft.pp_getComponent(ViewComponent2).projectionMatrix.mat4_invert(projectionMatrixInvert);
    } else {
      projectionMatrixInvert = getPlayerObjects2(this._myEngine).myCameraNonVR.pp_getComponent(ViewComponent2).projectionMatrix.mat4_invert(projectionMatrixInvert);
    }
    directionLocal.vec3_transformMat4(projectionMatrixInvert, directionLocal);
    directionLocal.vec3_normalize(directionLocal);
    let directionWorld = directionLocal;
    if (XRUtils.isSessionActive(this._myEngine)) {
      directionWorld = directionLocal.vec3_transformQuat(getPlayerObjects2(this._myEngine).myEyeLeft.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    } else {
      directionWorld = directionLocal.vec3_transformQuat(getPlayerObjects2(this._myEngine).myCameraNonVR.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    }
    directionWorld.vec3_normalize(directionWorld);
    return out;
  }
  setTouchValid(touchValid) {
    let callbackID = "pp_internal_touch_valid_callback";
    if (touchValid) {
      this.removePointerEventValidCallback(callbackID);
    } else {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.pointerType == "mouse";
      });
    }
  }
  setTargetOnlyRenderCanvas(targetOnlyRenderCanvas) {
    let callbackID = "pp_internal_target_only_render_canvas_callback";
    if (targetOnlyRenderCanvas) {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.target == this._myEngine.canvas;
      });
    } else {
      this.removePointerEventValidCallback(callbackID);
    }
  }
  getLastValidPointerEvent() {
    return this._myLastValidPointerEvent;
  }
  addPointerEventValidCallback(id, callback) {
    this._myPointerEventValidCallbacks.set(id, callback);
  }
  removePointerEventValidCallback(id) {
    this._myPointerEventValidCallbacks.delete(id);
  }
  isPointerUpOnPointerLeave() {
    return this._myPointerUpOnPointerLeave;
  }
  setPointerUpOnPointerLeave(pointerUpOnPointerLeave) {
    this._myPointerUpOnPointerLeave = pointerUpOnPointerLeave;
  }
  isContextMenuActive() {
    return this._myContextMenuActive;
  }
  setContextMenuActive(active) {
    if (this._myContextMenuActive != active) {
      if (active) {
        document.body.removeEventListener("contextmenu", this._myPreventContextMenuCallback);
      } else {
        document.body.addEventListener("contextmenu", this._myPreventContextMenuCallback, false);
      }
      this._myContextMenuActive = active;
    }
  }
  isMiddleButtonScrollActive() {
    return this._myMiddleButtonScrollActive;
  }
  setMiddleButtonScrollActive(active) {
    if (this._myMiddleButtonScrollActive != active) {
      if (active) {
        document.body.removeEventListener("mousedown", this._myPreventMiddleButtonScrollCallback);
      } else {
        document.body.addEventListener("mousedown", this._myPreventMiddleButtonScrollCallback, false);
      }
      this._myMiddleButtonScrollActive = active;
    }
  }
  setResetMovingDelay(delay) {
    this._myResetMovingDelay = delay;
  }
  getResetMovingDelay() {
    return this._myResetMovingDelay;
  }
  _onPointerAction(actionCallback, event) {
    if (!this._isPointerEventIDValid(event))
      return;
    if (!this._isPointerEventValid(event)) {
      if (this._myIsInsideView) {
        this._onPointerLeave(event);
      }
      return;
    }
    if (!this._myIsInsideView) {
      this._onPointerEnter(event);
    }
    actionCallback(event);
    this._updatePositionAndScreen(event);
    this._updatePointerData(event);
  }
  _onMouseAction(actionCallback, event) {
    if (!this._myIsInsideView)
      return;
    if (!this._isMouseAllowed())
      return;
    if (!this._isPointerEventIDValid(this._myLastValidPointerEvent))
      return;
    if (!this._isPointerEventValid(this._myLastValidPointerEvent))
      return;
    actionCallback(event);
  }
  _onPointerMove(event) {
    this._myResetMovingTimer.start(this._myResetMovingDelay);
    this._myIsMoving = true;
  }
  _onPointerDown(event) {
    let buttonInfo = this._myButtonInfos.get(event.button);
    if (!buttonInfo.myIsPressed) {
      buttonInfo.myIsPressed = true;
      buttonInfo.myIsPressStartToProcess = true;
    }
  }
  _onPointerUp(event) {
    let buttonInfo = this._myButtonInfos.get(event.button);
    if (buttonInfo.myIsPressed) {
      buttonInfo.myIsPressed = false;
      buttonInfo.myIsPressEndToProcess = true;
    }
  }
  _onPointerLeave(event) {
    if (!this._myIsInsideView || this._myLastValidPointerEvent == null || event.pointerId != this._myLastValidPointerEvent.pointerId)
      return;
    this._myIsInsideView = false;
    this._myIsMoving = false;
    if (this._myPointerUpOnPointerLeave) {
      for (let buttonInfo of this._myButtonInfos.values()) {
        if (buttonInfo.myIsPressed) {
          buttonInfo.myIsPressed = false;
          buttonInfo.myIsPressEndToProcess = true;
        }
      }
    }
    this._myPointerID = null;
  }
  _onPointerEnter(event) {
    if (this._myIsInsideView && this._myPointerID != null || !this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    this._myIsInsideView = true;
    this._updatePositionAndScreen(event);
    this._updatePointerData(event);
  }
  _preventContextMenu(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    event.preventDefault();
  }
  _preventMiddleButtonScroll(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    if (event.button == 1) {
      event.preventDefault();
      return false;
    }
  }
  _updatePositionAndScreen(event) {
    this._updateScreenSize();
    this._myInternalMousePosition[0] = event.clientX;
    this._myInternalMousePosition[1] = event.clientY;
    this._myIsValid = true;
  }
  _updateScreenSize() {
    let bounds = document.body.getBoundingClientRect();
    this._myScreenSize[0] = bounds.width;
    this._myScreenSize[1] = bounds.height;
  }
  _updatePointerData(event) {
    this._myPointerID = event.pointerId;
    this._myLastValidPointerEvent = event;
  }
  _isPointerEventIDValid(event) {
    if (event == null)
      return false;
    return this._myPointerID == null || this._myPointerID == event.pointerId;
  }
  _isPointerEventValid(event) {
    if (event == null)
      return false;
    let isValid = true;
    for (let callback of this._myPointerEventValidCallbacks.values()) {
      if (!callback(event)) {
        isValid = false;
        break;
      }
      ;
    }
    return isValid;
  }
  _isMouseAllowed() {
    return this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.pointerId == 1;
  }
  _createButtonInfo() {
    return { myIsPressed: false, myIsPressStart: false, myIsPressStartToProcess: false, myIsPressEnd: false, myIsPressEndToProcess: false };
  }
};

// js/pp/input/cauldron/input_manager.js
var InputManager = class {
  constructor(engine2 = getMainEngine2()) {
    this._myMouse = new Mouse(engine2);
    this._myKeyboard = new Keyboard();
    this._myGamepadsManager = new GamepadsManager(engine2);
  }
  start() {
    this._myMouse.start();
    this._myKeyboard.start();
    this._myGamepadsManager.start();
  }
  update(dt) {
    this._myMouse.update(dt);
    this._myKeyboard.update(dt);
    this._myGamepadsManager.update(dt);
  }
  getMouse() {
    return this._myMouse;
  }
  getKeyboard() {
    return this._myKeyboard;
  }
  getGamepadsManager() {
    return this._myGamepadsManager;
  }
};

// js/pp/input/cauldron/components/input_manager_component.js
var InputManagerComponent = class extends Component6 {
  init() {
    this._myInputManager = null;
    if (!hasInputManager(this.engine)) {
      this._myInputManager = new InputManager(this.engine);
      setInputManager(this._myInputManager, this.engine);
    }
  }
  start() {
    if (this._myInputManager != null) {
      this._myInputManager.start();
      this._setupMousePrevent();
      this._addGamepadCores();
    }
  }
  update(dt) {
    if (this._myInputManager != null) {
      this._myInputManager.update(dt);
    }
  }
  _setupMousePrevent() {
    if (this._myMousePreventContextMenu) {
      this._myInputManager.getMouse().setContextMenuActive(false);
    }
    if (this._myMousePreventMiddleButtonScroll) {
      this._myInputManager.getMouse().setMiddleButtonScrollActive(false);
    }
  }
  _addGamepadCores() {
    let handPoseParams = new HandPoseParams(this.engine);
    handPoseParams.myReferenceObject = getPlayerObjects2(this.engine).myPlayerPivot;
    handPoseParams.myFixForward = this._myGamepadFixForward;
    handPoseParams.myForceEmulatedVelocities = false;
    let leftHandPose = new HandPose(Handedness.LEFT, handPoseParams);
    let rightHandPose = new HandPose(Handedness.RIGHT, handPoseParams);
    let leftXRGamepadCore = new XRGamepadCore(leftHandPose);
    let rightXRGamepadCore = new XRGamepadCore(rightHandPose);
    leftXRGamepadCore.setManageHandPose(true);
    rightXRGamepadCore.setManageHandPose(true);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_xr_gamepad", leftXRGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_xr_gamepad", rightXRGamepadCore);
    let leftKeyboardGamepadCore = new KeyboardGamepadCore(leftHandPose);
    let rightKeyboardGamepadCore = new KeyboardGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_keyboard_gamepad", leftKeyboardGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_keyboard_gamepad", rightKeyboardGamepadCore);
    let leftClassicGamepadCore = new ClassicGamepadCore(null, leftHandPose);
    let rightClassicGamepadCore = new ClassicGamepadCore(null, rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_classic_gamepad", leftClassicGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_classic_gamepad", rightClassicGamepadCore);
  }
};
__publicField(InputManagerComponent, "TypeName", "pp-input-manager");
__publicField(InputManagerComponent, "Properties", {
  _myGamepadFixForward: Property6.bool(true),
  _myMousePreventContextMenu: Property6.bool(true),
  _myMousePreventMiddleButtonScroll: Property6.bool(true)
});

// js/pp/tool/cauldron/components/enable_tools_component.js
import { Component as Component7, Property as Property7 } from "@wonderlandengine/api";

// js/pp/tool/cauldron/tool_globals.js
var _myToolEnableds = /* @__PURE__ */ new WeakMap();
function isToolEnabled(engine2 = getMainEngine2()) {
  return _myToolEnableds.get(engine2);
}
function setToolEnabled(toolEnabled, engine2 = getMainEngine2()) {
  _myToolEnableds.set(engine2, toolEnabled);
}
function removeToolEnabled(engine2 = getMainEngine2()) {
  _myToolEnableds.delete(engine2);
}
function hasToolEnabled(engine2 = getMainEngine2()) {
  return _myToolEnableds.has(engine2);
}

// js/pp/tool/cauldron/components/enable_tools_component.js
var EnableToolsComponent = class extends Component7 {
  init() {
    this._myToolEnabled = null;
    if (!hasToolEnabled(this.engine)) {
      this._myToolEnabled = this._myEnable;
      setToolEnabled(this._myToolEnabled, this.engine);
    }
  }
  onDestroy() {
    if (this._myToolEnabled != null && isToolEnabled(this.engine) == this._myToolEnabled) {
      removeToolEnabled(this.engine);
    }
  }
};
__publicField(EnableToolsComponent, "TypeName", "pp-enable-tools");
__publicField(EnableToolsComponent, "Properties", {
  _myEnable: Property7.bool(true)
});

// js/pp/debug/components/enable_debugs_component.js
import { Component as Component8, Property as Property8 } from "@wonderlandengine/api";
var EnableDebugsComponent = class extends Component8 {
  init() {
    this._myDebugEnabled = null;
    if (!hasDebugEnabled(this.engine)) {
      this._myDebugEnabled = this._myEnable;
      setDebugEnabled(this._myDebugEnabled, this.engine);
    }
  }
  onDestroy() {
    if (this._myDebugEnabled != null && isDebugEnabled(this.engine) == this._myDebugEnabled) {
      removeDebugEnabled(this.engine);
    }
  }
};
__publicField(EnableDebugsComponent, "TypeName", "pp-enable-debugs");
__publicField(EnableDebugsComponent, "Properties", {
  _myEnable: Property8.bool(true)
});

// js/pp/pp/components/get_default_resources_component.js
import { Component as Component9, Property as Property9 } from "@wonderlandengine/api";
var GetDefaultResourcesComponent = class extends Component9 {
  init() {
    this._myDefaultResources = null;
    if (!hasDefaultResources(this.engine)) {
      this._myDefaultResources = new DefaultResources();
      this._myDefaultResources.myMeshes.myPlane = MeshUtils.cloneMesh(this._myPlane);
      this._myDefaultResources.myMeshes.myCube = MeshUtils.cloneMesh(this._myCube);
      this._myDefaultResources.myMeshes.mySphere = MeshUtils.cloneMesh(this._mySphere);
      this._myDefaultResources.myMeshes.myCone = MeshUtils.cloneMesh(this._myCone);
      this._myDefaultResources.myMeshes.myCylinder = MeshUtils.cloneMesh(this._myCylinder);
      this._myDefaultResources.myMeshes.myCircle = MeshUtils.cloneMesh(this._myCircle);
      this._myDefaultResources.myMeshes.myInvertedCube = MeshUtils.invertMesh(this._myCube);
      this._myDefaultResources.myMeshes.myInvertedSphere = MeshUtils.invertMesh(this._mySphere);
      this._myDefaultResources.myMeshes.myInvertedCone = MeshUtils.invertMesh(this._myCone);
      this._myDefaultResources.myMeshes.myInvertedCylinder = MeshUtils.invertMesh(this._myCylinder);
      if (this._myFlatOpaque != null) {
        this._myDefaultResources.myMaterials.myFlatOpaque = this._myFlatOpaque.clone();
      }
      if (this._myFlatTransparentNoDepth != null) {
        this._myDefaultResources.myMaterials.myFlatTransparentNoDepth = this._myFlatTransparentNoDepth.clone();
      }
      if (this._myPhongOpaque != null) {
        this._myDefaultResources.myMaterials.myPhongOpaque = this._myPhongOpaque.clone();
      }
      if (this._myText != null) {
        this._myDefaultResources.myMaterials.myText = this._myText.clone();
      }
      setDefaultResources(this._myDefaultResources, this.engine);
    }
  }
  onDestroy() {
    if (this._myDefaultResources != null && getDefaultResources(this.engine) == this._myDefaultResources) {
      removeDefaultResources(this.engine);
    }
  }
};
__publicField(GetDefaultResourcesComponent, "TypeName", "pp-get-default-resources");
__publicField(GetDefaultResourcesComponent, "Properties", {
  _myPlane: Property9.mesh(),
  _myCube: Property9.mesh(),
  _mySphere: Property9.mesh(),
  _myCone: Property9.mesh(),
  _myCylinder: Property9.mesh(),
  _myCircle: Property9.mesh(),
  _myFlatOpaque: Property9.material(),
  _myFlatTransparentNoDepth: Property9.material(),
  _myPhongOpaque: Property9.material(),
  _myText: Property9.material()
});

// js/pp/pp/components/get_player_objects_component.js
import { Component as Component10, Property as Property10 } from "@wonderlandengine/api";
var GetPlayerObjectsComponent = class extends Component10 {
  init() {
    this._myPlayerObjects = null;
    if (!hasPlayerObjects(this.engine)) {
      this._myPlayerObjects = new PlayerObjects();
      this._myPlayerObjects.myPlayer = this._myPlayer;
      this._myPlayerObjects.myPlayerPivot = this._myPlayerPivot;
      this._myPlayerObjects.myCameraNonVR = this._myCameraNonVR;
      this._myPlayerObjects.myHead = this._myHead;
      this._myPlayerObjects.myHeadNonVR = this._myHeadNonVR;
      this._myPlayerObjects.myHeadVR = this._myHeadVR;
      this._myPlayerObjects.myEyeLeft = this._myEyeLeft;
      this._myPlayerObjects.myEyeRight = this._myEyeRight;
      this._myPlayerObjects.myHandLeft = this._myHandLeft;
      this._myPlayerObjects.myHandRight = this._myHandRight;
      this._myPlayerObjects.myEyes = [];
      this._myPlayerObjects.myEyes[Handedness.LEFT] = this._myEyeLeft;
      this._myPlayerObjects.myEyes[Handedness.RIGHT] = this._myEyeRight;
      this._myPlayerObjects.myHands = [];
      this._myPlayerObjects.myHands[Handedness.LEFT] = this._myHandLeft;
      this._myPlayerObjects.myHands[Handedness.RIGHT] = this._myHandRight;
      if (this._myPlayerObjects.myPlayerPivot == null) {
        this._myPlayerObjects.myPlayerPivot = this._myPlayerObjects.myPlayer;
      }
      setPlayerObjects(this._myPlayerObjects, this.engine);
    }
  }
  onDestroy() {
    if (this._myPlayerObjects != null && getPlayerObjects2(this.engine) == this._myPlayerObjects) {
      removePlayerObjects(this.engine);
    }
  }
};
__publicField(GetPlayerObjectsComponent, "TypeName", "pp-get-player-objects");
__publicField(GetPlayerObjectsComponent, "Properties", {
  _myPlayer: Property10.object(),
  _myPlayerPivot: Property10.object(),
  _myCameraNonVR: Property10.object(),
  _myEyeLeft: Property10.object(),
  _myEyeRight: Property10.object(),
  _myHead: Property10.object(),
  _myHeadNonVR: Property10.object(),
  _myHeadVR: Property10.object(),
  _myHandLeft: Property10.object(),
  _myHandRight: Property10.object()
});

// js/pp/tool/easy_tune/components/init_easy_tune_variables_component.js
import { Component as Component11, Property as Property11 } from "@wonderlandengine/api";

// js/pp/tool/easy_tune/easy_tune_globals.js
var _myEasyTuneVariablesList = /* @__PURE__ */ new WeakMap();
var _myEasyTuneTargets = /* @__PURE__ */ new WeakMap();
function getEasyTuneVariables(engine2 = getMainEngine()) {
  return _myEasyTuneVariablesList.get(engine2);
}
function setEasyTuneVariables(easyTuneVariables, engine2 = getMainEngine()) {
  _myEasyTuneVariablesList.set(engine2, easyTuneVariables);
}
function removeEasyTuneVariables(engine2 = getMainEngine()) {
  _myEasyTuneVariablesList.delete(engine2);
}
function hasEasyTuneVariables(engine2 = getMainEngine()) {
  return _myEasyTuneVariablesList.has(engine2);
}
function getEasyTuneTarget(engine2 = getMainEngine()) {
  return _myEasyTuneTargets.get(engine2);
}
function setEasyTuneTarget(easyTuneTarget, engine2 = getMainEngine()) {
  _myEasyTuneTargets.set(engine2, easyTuneTarget);
}
function removeEasyTuneTarget(engine2 = getMainEngine()) {
  _myEasyTuneTargets.delete(engine2);
}
function hasEasyTuneTarget(engine2 = getMainEngine()) {
  return _myEasyTuneTargets.has(engine2);
}

// js/pp/tool/easy_tune/easy_tune_variables.js
var EasyTuneVariables = class {
  constructor() {
    this._myVariables = /* @__PURE__ */ new Map();
  }
  add(variable) {
    this._myVariables.set(variable.myName, variable);
  }
  remove(variableName) {
    this._myVariables.delete(variableName);
  }
  get(variableName) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      return variable.getValue();
    }
    return null;
  }
  set(variableName, value, resetDefaultValue = false) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      variable.setValue(value, resetDefaultValue);
    }
  }
  has(variableName) {
    return this._myVariables.has(variableName);
  }
  length() {
    return this._myVariables.size;
  }
  isActive(variableName) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      return variable.myIsActive;
    }
    return false;
  }
  getEasyTuneVariable(variableName) {
    return this._myVariables.get(variableName);
  }
  getEasyTuneVariablesList() {
    return Array.from(this._myVariables.values());
  }
  getEasyTuneVariablesNames() {
    return Array.from(this._myVariables.keys());
  }
  fromJSON(json, resetDefaultValue = false) {
    let objectJSON = JSON.parse(json);
    for (let variable of this._myVariables.values()) {
      let variableValueJSON = objectJSON[variable.myName];
      if (variableValueJSON !== void 0) {
        variable.fromJSON(variableValueJSON, resetDefaultValue);
      }
    }
  }
  toJSON() {
    let objectJSON = {};
    for (let variable of this._myVariables.values()) {
      objectJSON[variable.myName] = variable.toJSON();
    }
    return JSON.stringify(objectJSON);
  }
  registerValueChangedEventListener(variableName, callbackID, callback) {
    this._myVariables.get(variableName).registerValueChangedEventListener(callbackID, callback);
  }
  unregisterValueChangedEventListener(variableName, callbackID, callback) {
    this._myVariables.get(variableName).unregisterValueChangedEventListener(callbackID);
  }
};

// js/pp/tool/easy_tune/components/init_easy_tune_variables_component.js
var InitEasyTuneVariablesComponent = class extends Component11 {
  init() {
    this._myEasyTuneVariables = null;
    if (this._myInit) {
      if (!hasEasyTuneVariables(this.engine)) {
        this._myEasyTuneVariables = new EasyTuneVariables();
        setEasyTuneVariables(this._myEasyTuneVariables, this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myEasyTuneVariables != null && getEasyTuneVariables(this.engine) == this._myEasyTuneVariables) {
      removeEasyTuneVariables(this.engine);
    }
  }
};
__publicField(InitEasyTuneVariablesComponent, "TypeName", "pp-init-easy-tune-variables");
__publicField(InitEasyTuneVariablesComponent, "Properties", {
  _myInit: Property11.bool(true)
});

// js/pp/pp/components/pp_gateway_component.js
var PPGatewayComponent = class extends Component12 {
  init() {
    this._myEnableDebugsComponent = null;
    if (this._myEnableDebugs) {
      this._myEnableDebugsComponent = this.object.pp_addComponent(EnableDebugsComponent, false);
    }
    this._myEnableToolsComponent = null;
    if (this._myEnableTools) {
      this._myEnableToolsComponent = this.object.pp_addComponent(EnableToolsComponent, false);
    }
    this._myAddPPToWindowComponent = null;
    if (this._myAddPPToWindow) {
      this._myAddPPToWindowComponent = this.object.pp_addComponent(AddPPToWindowComponent, false);
    }
    this._myAddWLToWindowComponent = null;
    if (this._myAddWLToWindow) {
      this._myAddWLToWindowComponent = this.object.pp_addComponent(AddWLToWindowComponent, false);
    }
    this._myInitEasyTuneVariablesComponent = null;
    if (this._myInitEasyTuneVariables) {
      this._myInitEasyTuneVariablesComponent = this.object.pp_addComponent(InitEasyTuneVariablesComponent, false);
    }
    this._myInputManagerComponent = this.object.pp_addComponent(InputManagerComponent, this._getProperties(InputManagerComponent.Properties));
    this._myAudioManagerComponent = this.object.pp_addComponent(AudioManagerComponent, false);
    this._myVisualManagerComponent = this.object.pp_addComponent(VisualManagerComponent, false);
    this._myDebugManagerComponent = this.object.pp_addComponent(DebugManagerComponent, false);
    this._myGetDefaultResourcesComponent = this.object.pp_addComponent(GetDefaultResourcesComponent, this._getProperties(GetDefaultResourcesComponent.Properties));
    this._myGetPlayerObjectsComponent = this.object.pp_addComponent(GetPlayerObjectsComponent, this._getProperties(GetPlayerObjectsComponent.Properties));
  }
  start() {
    if (this._myEnableDebugsComponent != null) {
      this._myEnableDebugsComponent.active = true;
    }
    if (this._myEnableToolsComponent != null) {
      this._myEnableToolsComponent.active = true;
    }
    if (this._myAddPPToWindowComponent != null) {
      this._myAddPPToWindowComponent.active = true;
    }
    if (this._myAddWLToWindowComponent != null) {
      this._myAddWLToWindowComponent.active = true;
    }
    if (this._myInitEasyTuneVariablesComponent != null) {
      this._myInitEasyTuneVariablesComponent.active = true;
    }
    this._myInputManagerComponent.active = true;
    this._myAudioManagerComponent.active = true;
    this._myVisualManagerComponent.active = true;
    this._myDebugManagerComponent.active = true;
    this._myGetDefaultResourcesComponent.active = true;
    this._myGetPlayerObjectsComponent.active = true;
  }
  _getProperties(propertiesToGet, active = false) {
    let properties = {};
    properties["active"] = active;
    let propertyNames = Object.getOwnPropertyNames(propertiesToGet);
    for (let propertyName of propertyNames) {
      if (this[propertyName] != void 0) {
        properties[propertyName] = this[propertyName];
      }
    }
    return properties;
  }
};
__publicField(PPGatewayComponent, "TypeName", "pp-gateway");
__publicField(PPGatewayComponent, "Properties", {
  _myEnableDebugs: Property12.bool(true),
  _myEnableTools: Property12.bool(true),
  _myAddPPToWindow: Property12.bool(true),
  _myAddWLToWindow: Property12.bool(true),
  _myInitEasyTuneVariables: Property12.bool(true),
  ...InputManagerComponent.Properties,
  ...AudioManagerComponent.Properties,
  ...VisualManagerComponent.Properties,
  ...DebugManagerComponent.Properties,
  ...GetPlayerObjectsComponent.Properties,
  ...GetDefaultResourcesComponent.Properties
});

// js/pp/audio/audio_utils.js
import { Howler as Howler3 } from "howler";
function isAudioPlaybackBlocked() {
  let isBlocked = false;
  if (Howler3 != null && Howler3.state != "running") {
    isBlocked = true;
  }
  return isBlocked;
}
var AudioUtils = {
  isAudioPlaybackBlocked
};

// js/pp/audio/howler/howler_audio_player.js
var HowlerAudioPlayer = class extends AudioPlayer {
  constructor(howl, audioSetup = null) {
    super(audioSetup, false);
    this._myAudio = howl;
    if (audioSetup == null) {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudioSetup.myLoop = this._myAudio._loop;
      this._myAudioSetup.myAutoplay = this._myAudio._autoplay;
      this._myAudioSetup.myVolume = this._myAudio._volume;
      this._myAudioSetup.myRate = this._myAudio._rate;
      this._myAudioSetup.myPool = this._myAudio._pool;
      this._myAudioSetup.myPreload = this._myAudio._preload;
      this._myAudioSetup.myPosition = this._myAudio._pos != null ? this._myAudio._pos.vec3_clone() : null;
      this._myAudioSetup.mySpatial = this._myAudio._pos != null;
      this._myAudioSetup.myReferenceDistance = this._myAudio._pannerAttr.refDistance;
    } else {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudio.loop(this._myAudioSetup.myLoop);
      this._myAudio._autoplay = this._myAudioSetup.myAutoplay;
      this._myAudio.volume(this._myAudioSetup.myVolume);
      this._myAudio.rate(this._myAudioSetup.myRate);
      this._myAudio._pool = this._myAudioSetup.myPool;
      this._myAudio._preload = this._myAudioSetup.myPreload;
      this.updatePosition(this._myAudioSetup.myPosition);
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
      if (this._myAudioSetup.myAutoplay) {
        this._myAudio.play();
      }
    }
    this._addListeners();
  }
};

// js/pp/audio/components/mute_everything_component.js
import { Component as Component13, Property as Property13 } from "@wonderlandengine/api";
import { Howler as Howler4 } from "howler";
var MuteEverythingComponent = class extends Component13 {
  start() {
    Howler4.mute(true);
  }
};
__publicField(MuteEverythingComponent, "TypeName", "pp-mute-everything");
__publicField(MuteEverythingComponent, "Properties", {});

// js/pp/audio/components/spatial_audio_listener_component.js
import { Component as Component14, Property as Property14 } from "@wonderlandengine/api";
import { Howler as Howler5 } from "howler";
var SpatialAudioListenerComponent = class extends Component14 {
  init() {
    this._myOrigin = vec3_create2();
    this._myForward = vec3_create2();
    this._myUp = vec3_create2();
  }
  update(dt) {
    if (this._myActive == 0 || this._myActive == 1 && XRUtils.getSession(this.engine) || this._myActive == 2 && !XRUtils.getSession(this.engine)) {
      this.object.pp_getPosition(this._myOrigin);
      this.object.pp_getForward(this._myForward);
      this.object.pp_getUp(this._myUp);
      Howler5.pos(this._myOrigin[0], this._myOrigin[1], this._myOrigin[2]);
      Howler5.orientation(
        this._myForward[0],
        this._myForward[1],
        this._myForward[2],
        this._myUp[0],
        this._myUp[1],
        this._myUp[2]
      );
    }
  }
};
__publicField(SpatialAudioListenerComponent, "TypeName", "pp-spatial-audio-listener");
__publicField(SpatialAudioListenerComponent, "Properties", {
  _myActive: Property14.enum(["Always", "VR", "Non VR"], "Always")
});

// js/pp/cauldron/benchmarks/benchmark_max_physx_component.js
import { Component as Component15, PhysXComponent as PhysXComponent3, Property as Property15 } from "@wonderlandengine/api";

// js/pp/cauldron/physics/physics_collision_collector.js
import { CollisionEventType, PhysXComponent as PhysXComponent2 } from "@wonderlandengine/api";
var PhysicsCollisionCollector = class {
  constructor(physXComponent, isTrigger = false) {
    this._myPhysX = physXComponent;
    this._myIsTrigger = isTrigger;
    this._myCollisions = [];
    this._myCollisionsStart = [];
    this._myCollisionsEnd = [];
    this._myUpdateActive = false;
    this._myCollisionsStartToProcess = [];
    this._myCollisionsEndToProcess = [];
    this._myCollisionCallbackID = null;
    this._myIsActive = false;
    this.setActive(true);
    this._myDebugActive = false;
    this._myTriggerDesyncFixDelay = new Timer(0.1);
    this._myCollisionCallbacks = /* @__PURE__ */ new Map();
    this._myCollisionStartCallbacks = /* @__PURE__ */ new Map();
    this._myCollisionEndCallbacks = /* @__PURE__ */ new Map();
  }
  getPhysX() {
    return this._myPhysX;
  }
  getCollisions() {
    return this._myCollisions;
  }
  getCollisionsStart() {
    return this._myCollisionsStart;
  }
  getCollisionsEnd() {
    return this._myCollisionsEnd;
  }
  setActive(active) {
    if (this._myIsActive != active) {
      this._myIsActive = active;
      this._myCollisions = [];
      this._myCollisionsStart = [];
      this._myCollisionsEnd = [];
      this._myUpdateActive = false;
      this._myCollisionsStartToProcess = [];
      this._myCollisionsEndToProcess = [];
      if (this._myIsActive) {
        this._myCollisionCallbackID = this._myPhysX.onCollision(this._onCollision.bind(this));
      } else if (this._myCollisionCallbackID != null) {
        this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
        this._myCollisionCallbackID = null;
      }
    }
  }
  setUpdateActive(active) {
    this._myUpdateActive = active;
  }
  update(dt) {
    if (!this._myIsActive) {
      return;
    }
    this._myUpdateActive = true;
    this._myCollisionsStart = this._myCollisionsStartToProcess;
    this._myCollisionsStartToProcess = [];
    this._myCollisionsEnd = this._myCollisionsEndToProcess;
    this._myCollisionsEndToProcess = [];
    if (this._myIsTrigger) {
      this._triggerDesyncFix(dt);
    }
  }
  destroy() {
    if (this._myCollisionCallbackID != null) {
      this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
      this._myCollisionCallbackID = null;
    }
  }
  setDebugActive(active) {
    this._myDebugActive = active;
  }
  registerCollisionEventListener(callbackID, callback) {
    this._myCollisionCallbacks.set(callbackID, callback);
  }
  unregisterCollisionEventListener(callbackID) {
    this._myCollisionCallbacks.delete(callbackID);
  }
  registerCollisionStartEventListener(callbackID, callback) {
    this._myCollisionStartCallbacks.set(callbackID, callback);
  }
  unregisterCollisionStartEventListener(callbackID) {
    this._myCollisionStartCallbacks.delete(callbackID);
  }
  registerCollisionEndEventListener(callbackID, callback) {
    this._myCollisionEndCallbacks.set(callbackID, callback);
  }
  unregisterCollisionEndEventListener(callbackID) {
    this._myCollisionEndCallbacks.delete(callbackID);
  }
  _onCollision(type2, physXComponent) {
    if (type2 == CollisionEventType.Touch || type2 == CollisionEventType.TriggerTouch) {
      this._onCollisionStart(physXComponent);
    } else if (type2 == CollisionEventType.TouchLost || type2 == CollisionEventType.TriggerTouchLost) {
      this._onCollisionEnd(physXComponent);
    }
    if (this._myCollisionCallbacks.size > 0) {
      this._myCollisionCallbacks.forEach(function(callback) {
        callback(this._myPhysX, physXComponent, type2);
      });
    }
  }
  _onCollisionStart(physXComponent) {
    if (this._myDebugActive) {
      let objectFound = false;
      for (let object of this._myCollisions) {
        if (object.pp_equals(physXComponent.object)) {
          objectFound = true;
          break;
        }
      }
      if (objectFound) {
        console.error("Collision Start on object already collected");
      }
    }
    this._myCollisions.push(physXComponent.object);
    if (this._myUpdateActive) {
      this._myCollisionsStartToProcess.push(physXComponent.object);
      this._myCollisionsEndToProcess.pp_removeAll(function(element) {
        return element.pp_equals(physXComponent.object);
      });
    }
    if (this._myDebugActive) {
      console.log("Collision Start -", this._myCollisions.length);
    }
    if (this._myCollisionStartCallbacks.size > 0) {
      this._myCollisionStartCallbacks.forEach(function(callback) {
        callback(this._myPhysX, physXComponent, type);
      });
    }
  }
  _onCollisionEnd(physXComponent) {
    if (this._myDebugActive) {
      let objectFound = false;
      for (let object of this._myCollisions) {
        if (object.pp_equals(physXComponent.object)) {
          objectFound = true;
          break;
        }
      }
      if (!objectFound) {
        console.error("Collision End on object not collected");
      }
    }
    this._myCollisions.pp_removeAll(function(element) {
      return element.pp_equals(physXComponent.object);
    });
    if (this._myUpdateActive) {
      this._myCollisionsEndToProcess.push(physXComponent.object);
      this._myCollisionsStartToProcess.pp_removeAll(function(element) {
        return element.pp_equals(physXComponent.object);
      });
    }
    if (this._myDebugActive) {
      console.log("Collision End -", this._myCollisions.length);
    }
    if (this._myCollisionEndCallbacks.size > 0) {
      this._myCollisionEndCallbacks.forEach(function(callback) {
        callback(this._myPhysX, physXComponent, type);
      });
    }
  }
  _triggerDesyncFix(dt) {
    this._myTriggerDesyncFixDelay.update(dt);
    if (this._myTriggerDesyncFixDelay.isDone()) {
      this._myTriggerDesyncFixDelay.start();
      let collisionsToEnd = this._myCollisions.pp_findAll(function(element) {
        let physX = element.pp_getComponentSelf(PhysXComponent2);
        return physX == null || !physX.active;
      });
      if (collisionsToEnd.length > 0) {
        for (let collision of collisionsToEnd) {
          let physX = collision.pp_getComponentSelf(PhysXComponent2);
          if (physX) {
            this._onCollisionEnd(physX);
          } else {
            console.error("NO PHYSX, HOW?");
          }
        }
      }
    }
  }
};

// js/pp/cauldron/benchmarks/benchmark_max_physx_component.js
var BenchmarkMaxPhysXComponent = class extends Component15 {
  start() {
    this._myStarted = false;
    this._myPreStartTimer = new Timer(1);
  }
  _start() {
    this._myRootObject = this.object.pp_addObject();
    this._myRaycastSetup = new RaycastSetup(this.engine.physics);
    this._myRaycastResults = new RaycastResults();
    this._myStaticPhysXObjects = [];
    this._myStaticPhysXComponents = [];
    this._myStaticPhysXCollectors = [];
    this._myDynamicPhysXObjects = [];
    this._myDynamicPhysXComponents = [];
    this._myDynamicPhysXCollectors = [];
    this._myKinematicPhysXObjects = [];
    this._myKinematicPhysXComponents = [];
    this._myKinematicPhysXCollectors = [];
    this._spawnDome(true, false);
    this._spawnDome(false, false);
    this._spawnDome(false, true);
    this._myStartTimer = new Timer(1);
    this._myTimer = new Timer(0);
    this._myDebugTimer = new Timer(this._myVisualizeRaycastDelay);
    this._myLogActiveTimer = new Timer(1);
    this._myFPSHistory = [];
    for (let i = 0; i < 7; i++) {
      this._myFPSHistory.push(0);
    }
    this._myAddVelocityDelay = 10;
    this._myTranslateVec3 = vec3_create2();
    this._myRotateVec3 = vec3_create2();
    this._myStarted = true;
  }
  update(dt) {
    if (!this._myStarted) {
      this._myPreStartTimer.update(dt);
      if (this._myPreStartTimer.isDone()) {
        this._start();
      }
    } else {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._myTimer.update(dt);
        this._myDebugTimer.update(dt);
        this._myLogActiveTimer.update(dt);
        if (this._myTimer.isDone()) {
          this._myTimer.start();
          let debugActive = false;
          if (this._myDebugTimer.isDone()) {
            this._myDebugTimer.start();
            debugActive = true;
          }
          debugActive = debugActive && this._myVisualizeRaycast;
          this._raycastTest(debugActive);
        }
        this._myFPSHistory.pop();
        this._myFPSHistory.unshift(Math.round(1 / dt));
        if (this._myLogActive) {
          if (this._myLogActiveTimer.isDone()) {
            this._myLogActiveTimer.start();
            if (this._myClearConsoleBeforeLog) {
              console.clear();
            }
            console.log("Static PhysX Dome Size:", this._myStaticPhysXObjects.length);
            console.log("Dynamic PhysX Dome Size:", this._myDynamicPhysXObjects.length);
            console.log("Kinematic PhysX Dome Size:", this._myKinematicPhysXObjects.length);
            let staticCollisions = 0;
            for (let collector of this._myStaticPhysXCollectors) {
              staticCollisions += collector.getCollisions().length;
            }
            let dynamicCollisions = 0;
            for (let collector of this._myDynamicPhysXCollectors) {
              dynamicCollisions += collector.getCollisions().length;
            }
            let kinematicCollisions = 0;
            for (let collector of this._myKinematicPhysXCollectors) {
              kinematicCollisions += collector.getCollisions().length;
            }
            let totalCollisions = (staticCollisions + dynamicCollisions + kinematicCollisions) / 2;
            console.log("Current Collisions Count:", totalCollisions);
            console.log("Raycast Count:", this._myRaycastCount);
            console.log("FPS History:");
            let fpsString = "";
            for (let fps of this._myFPSHistory) {
              fpsString = fpsString.concat(fps, "\n");
            }
            console.log(fpsString);
          }
        }
      }
      if (this._myAddVelocityDelay > 0) {
        this._myAddVelocityDelay--;
        if (this._myAddVelocityDelay == 0) {
          for (let physX of this._myDynamicPhysXComponents) {
            physX.kinematic = false;
            let strength = 50;
            physX.linearVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
            physX.angularVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
          }
        }
      }
      for (let physX of this._myKinematicPhysXObjects) {
        let strength = 5 * dt;
        this._myTranslateVec3.vec3_set(Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength));
        physX.pp_translate(this._myTranslateVec3);
        let rotateStrength = 50 * dt;
        this._myRotateVec3.vec3_set(Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength));
        physX.pp_rotate(this._myRotateVec3);
      }
    }
  }
  _raycastTest(debugActive) {
    let raycastCount = this._myRaycastCount;
    let distance = 1e4;
    for (let i = 0; i < raycastCount; i++) {
      let origin = [Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign()];
      let direction = [Math.pp_random(-1, 1), Math.pp_random(-1, 1), Math.pp_random(-1, 1)];
      direction.vec3_normalize(direction);
      this._myRaycastSetup.myOrigin.vec3_copy(origin);
      this._myRaycastSetup.myDirection.vec3_copy(direction);
      this._myRaycastSetup.myDistance = distance;
      this._myRaycastSetup.myBlockLayerFlags.setAllFlagsActive();
      let raycastResults = PhysicsUtils.raycast(this._myRaycastSetup, this._myRaycastResults);
      if (debugActive) {
        getDebugVisualManager2(this.engine).drawRaycast(this._myDebugTimer.getDuration(), raycastResults, true, 5, 0.015);
      }
    }
  }
  _spawnDome(isStatic, isDynamic) {
    let maxCount = this._myStaticPhysXCount;
    let physXList = this._myStaticPhysXObjects;
    let cloves = Math.ceil(Math.sqrt(this._myStaticPhysXCount));
    if (!isStatic) {
      if (isDynamic) {
        cloves = Math.ceil(Math.sqrt(this._myDynamicPhysXCount));
        maxCount = this._myDynamicPhysXCount;
        physXList = this._myDynamicPhysXObjects;
      } else {
        cloves = Math.ceil(Math.sqrt(this._myKinematicPhysXCount));
        maxCount = this._myKinematicPhysXCount;
        physXList = this._myKinematicPhysXObjects;
      }
    }
    let angleForClove = Math.PI * 2 / cloves;
    let minDistance = Math.max(0, this._myStaticDomeSize - 20);
    let maxDistance = this._myStaticDomeSize + 20;
    if (!isStatic) {
      if (isDynamic) {
        minDistance = Math.max(0, this._myDynamicDomeSize - 20);
        maxDistance = this._myDynamicDomeSize + 20;
      } else {
        minDistance = Math.max(0, this._myKinematicDomeSize - 20);
        maxDistance = this._myKinematicDomeSize + 20;
      }
    }
    let minExtraRotation = 0;
    let maxExtraRotation = Math.pp_toRadians(10);
    let upDirection = vec3_create2(0, 1, 0);
    let horizontalDirection = vec3_create2(0, 0, -1);
    for (let i = 0; i < cloves / 2; i++) {
      let verticalDirection = vec3_create2(0, 1, 0);
      let rotationAxis = vec3_create2();
      horizontalDirection.vec3_cross(verticalDirection, rotationAxis);
      rotationAxis.vec3_normalize(rotationAxis);
      for (let j = 0; j < cloves; j++) {
        if (physXList.length < maxCount) {
          let distance = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance, physXDirection);
          this._addPhysX(physXDirection, isStatic, isDynamic);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
        if (physXList.length < maxCount) {
          let distance = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance, physXDirection);
          this._addPhysX(physXDirection, isStatic, isDynamic);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
      }
      horizontalDirection.vec3_rotateAxisRadians(angleForClove, upDirection, horizontalDirection);
    }
  }
  _addPhysX(physXDirection, isStatic, isDynamic) {
    let position = physXDirection;
    let scale = Math.pp_random(1, 10);
    let shape = Math.pp_randomPick(this.engine.Shape.Sphere, this.engine.Shape.Box);
    if (this._myUseConvexMesh) {
      shape = this.engine.Shape.ConvexMesh;
      scale *= this._myShapeScaleMultiplier;
    }
    let physX = this._myRootObject.pp_addObject();
    physX.pp_setPosition(position);
    let physXComponent = physX.pp_addComponent(PhysXComponent3, {
      "shape": shape,
      "shapeData": { index: this._myShapeIndex },
      "extents": vec3_create2(scale, scale, scale),
      "static": isStatic,
      "kinematic": !isDynamic,
      "mass": 1
    });
    if (isStatic) {
      this._myStaticPhysXObjects.push(physX);
      this._myStaticPhysXComponents.push(physXComponent);
      this._myStaticPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else if (isDynamic) {
      this._myDynamicPhysXObjects.push(physX);
      this._myDynamicPhysXComponents.push(physXComponent);
      this._myDynamicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else {
      this._myKinematicPhysXObjects.push(physX);
      this._myKinematicPhysXComponents.push(physXComponent);
      this._myKinematicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    }
  }
};
__publicField(BenchmarkMaxPhysXComponent, "TypeName", "pp-benchmark-max-physx");
__publicField(BenchmarkMaxPhysXComponent, "Properties", {
  _myStaticDomeSize: Property15.float(40),
  _myStaticPhysXCount: Property15.int(1e3),
  _myDynamicDomeSize: Property15.float(80),
  _myDynamicPhysXCount: Property15.int(250),
  _myKinematicDomeSize: Property15.float(120),
  _myKinematicPhysXCount: Property15.int(250),
  _myRaycastCount: Property15.int(100),
  _myVisualizeRaycast: Property15.bool(false),
  _myVisualizeRaycastDelay: Property15.float(0.5),
  _myUseConvexMesh: Property15.bool(false),
  _myShapeIndex: Property15.int(0),
  _myShapeScaleMultiplier: Property15.float(1),
  _myLogActive: Property15.bool(true),
  _myClearConsoleBeforeLog: Property15.bool(true)
});

// js/pp/cauldron/benchmarks/benchmark_max_visible_triangles_component.js
import { Component as Component17, MeshComponent as MeshComponent7, TextComponent as TextComponent4, Property as Property17 } from "@wonderlandengine/api";

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_transform_component.js
import { Component as Component16, Property as Property16 } from "@wonderlandengine/api";

// js/pp/tool/easy_tune/easy_tune_utils.js
var _mySetEasyTuneWidgetActiveVariableCallbacks = /* @__PURE__ */ new WeakMap();
var _myRefreshEasyTuneWidgetCallbacks = /* @__PURE__ */ new WeakMap();
function setEasyTuneWidgetActiveVariable(variableName, engine2 = getMainEngine2()) {
  if (_mySetEasyTuneWidgetActiveVariableCallbacks.has(engine2)) {
    for (let callback of _mySetEasyTuneWidgetActiveVariableCallbacks.get(engine2).values()) {
      callback(variableName);
    }
  }
}
function refreshEasyTuneWidget(engine2 = getMainEngine2()) {
  if (_myRefreshEasyTuneWidgetCallbacks.has(engine2)) {
    for (let callback of _myRefreshEasyTuneWidgetCallbacks.get(engine2).values()) {
      callback();
    }
  }
}
function importEasyTuneVariables(fileURL = null, resetVariablesDefaultValueOnImport = false, onSuccessCallback = null, onFailureCallback = null, engine2 = getMainEngine2()) {
  if (fileURL == null || fileURL.length == 0) {
    if (navigator.clipboard) {
      navigator.clipboard.readText().then(
        function(clipboard) {
          getEasyTuneVariables(engine2).fromJSON(clipboard, resetVariablesDefaultValueOnImport);
          refreshEasyTuneWidget(engine2);
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Imported from: clipboard");
          console.log(clipboard);
        },
        function() {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while importing the easy tune variables from: clipboard");
        }
      ).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from: clipboard");
        console.error(reason);
      });
    }
  } else {
    let replacedFileURL = _importExportEasyTuneVariablesReplaceFileURLParams(fileURL);
    fetch(replacedFileURL).then(
      function(response) {
        if (response.ok) {
          response.text().then(
            function(text) {
              getEasyTuneVariables(engine2).fromJSON(text, resetVariablesDefaultValueOnImport);
              refreshEasyTuneWidget(engine2);
              if (onSuccessCallback != null) {
                onSuccessCallback();
              }
              console.log("Easy Tune Variables Imported from:", replacedFileURL);
              console.log(text);
            },
            function(response2) {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
              console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
              console.error(response2);
            }
          );
        } else {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
          console.error(response);
        }
      },
      function(response) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
        console.error(response);
      }
    ).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
      console.error(reason);
    });
  }
  refreshEasyTuneWidget(engine2);
}
function exportEasyTuneVariables(fileURL = null, onSuccessCallback = null, onFailureCallback = null, engine2 = getMainEngine2()) {
  let jsonVariables = getEasyTuneVariables(engine2).toJSON();
  if (fileURL == null || fileURL.length == 0) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(jsonVariables).then(
        function() {
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Exported to: clipboard");
          console.log(jsonVariables);
        },
        function() {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while exporting the easy tune variables to: clipboard");
        }
      ).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to: clipboard");
        console.error(reason);
      });
    }
  } else {
    let replacedFileURL = _importExportEasyTuneVariablesReplaceFileURLParams(fileURL);
    fetch(replacedFileURL, {
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: jsonVariables
    }).then(
      function(response) {
        if (response.ok) {
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Exported to:", replacedFileURL);
          console.log(jsonVariables);
        } else {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
          console.error(response);
        }
      },
      function(response) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
        console.error(response);
      }
    ).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
      console.error(reason);
    });
  }
}
function addSetEasyTuneWidgetActiveVariableCallback(id, callback, engine2 = getMainEngine2()) {
  if (!_mySetEasyTuneWidgetActiveVariableCallbacks.has(engine2)) {
    _mySetEasyTuneWidgetActiveVariableCallbacks.set(engine2, /* @__PURE__ */ new Map());
  }
  _mySetEasyTuneWidgetActiveVariableCallbacks.get(engine2).set(id, callback);
}
function removeSetEasyTuneWidgetActiveVariableCallback(id, engine2 = getMainEngine2()) {
  if (_mySetEasyTuneWidgetActiveVariableCallbacks.has(engine2)) {
    _mySetEasyTuneWidgetActiveVariableCallbacks.get(engine2).delete(id);
  }
}
function addRefreshEasyTuneWidgetCallback(id, callback, engine2 = getMainEngine2()) {
  if (!_myRefreshEasyTuneWidgetCallbacks.has(engine2)) {
    _myRefreshEasyTuneWidgetCallbacks.set(engine2, /* @__PURE__ */ new Map());
  }
  _myRefreshEasyTuneWidgetCallbacks.get(engine2).set(id, callback);
}
function removeRefreshEasyTuneWidgetCallback(id, engine2 = getMainEngine2()) {
  if (_myRefreshEasyTuneWidgetCallbacks.has(engine2)) {
    _myRefreshEasyTuneWidgetCallbacks.get(engine2).delete(id);
  }
}
var EasyTuneUtils = {
  setEasyTuneWidgetActiveVariable,
  refreshEasyTuneWidget,
  importEasyTuneVariables,
  exportEasyTuneVariables,
  addSetEasyTuneWidgetActiveVariableCallback,
  removeSetEasyTuneWidgetActiveVariableCallback,
  addRefreshEasyTuneWidgetCallback,
  removeRefreshEasyTuneWidgetCallback
};
function _importExportEasyTuneVariablesReplaceFileURLParams(fileURL) {
  let params = fileURL.match(/\{.+?\}/g);
  if (params == null || params.length == 0) {
    return fileURL;
  }
  for (let i = 0; i < params.length; i++) {
    params[i] = params[i].replace("{", "");
    params[i] = params[i].replace("}", "");
  }
  let urlSearchParams = new URL(document.location).searchParams;
  let replacedFileURL = fileURL;
  for (let param of params) {
    let searchParamValue = urlSearchParams.get(param);
    if (searchParamValue != null) {
      replacedFileURL = replacedFileURL.replace("{" + param + "}", searchParamValue);
    }
  }
  return replacedFileURL;
}

// js/pp/tool/easy_tune/easy_tune_variable_types.js
var EasyTuneVariableType = {
  NONE: 0,
  NUMBER: 1,
  BOOL: 2,
  TRANSFORM: 3
};
var EasyTuneVariable = class {
  constructor(name, type2, engine2 = getMainEngine2()) {
    this.myName = name.slice(0);
    this.myType = type2;
    this.myValue = null;
    this.myDefaultValue = null;
    this.myIsActive = false;
    this._myValueChangedCallbacks = /* @__PURE__ */ new Map();
    this._myEngine = engine2;
  }
  getValue() {
    return this.myValue;
  }
  setValue(value, resetDefaultValue = false) {
    let oldValue = this.myValue;
    this.myValue = value;
    if (resetDefaultValue) {
      EasyTuneVariable.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshEasyTuneWidget(this._myEngine);
    if (oldValue != value) {
      this._triggerValueChangedCallback();
    }
  }
  setDefaultValue(value) {
    this.myDefaultValue = value;
  }
  fromJSON(valueJSON, resetDefaultValue = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue);
  }
  toJSON() {
    return JSON.stringify(this.getValue());
  }
  registerValueChangedEventListener(id, callback) {
    this._myValueChangedCallbacks.set(id, callback);
  }
  unregisterValueChangedEventListener(id) {
    this._myValueChangedCallbacks.delete(id);
  }
  _triggerValueChangedCallback() {
    if (this._myValueChangedCallbacks.size > 0) {
      this._myValueChangedCallbacks.forEach(function(callback) {
        callback(this.myName, this.getValue());
      }.bind(this));
    }
  }
};
var EasyTuneVariableArray = class extends EasyTuneVariable {
  constructor(name, type2, value, engine2) {
    super(name, type2, engine2);
    EasyTuneVariableArray.prototype.setValue.call(this, value, true);
  }
  getValue() {
    return this.myValue.pp_clone();
  }
  setValue(value, resetDefaultValue = false) {
    let oldValue = this.myValue;
    this.myValue = value.pp_clone();
    if (resetDefaultValue) {
      EasyTuneVariableArray.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshEasyTuneWidget(this._myEngine);
    if (oldValue == null || !oldValue.pp_equals(value)) {
      this._triggerValueChangedCallback();
    }
  }
  setDefaultValue(value) {
    this.myDefaultValue = value.pp_clone();
  }
};
var EasyTuneNumberArray = class extends EasyTuneVariableArray {
  constructor(name, value, stepPerSecond, decimalPlaces, min = null, max = null, editAllValuesTogether = false, engine2) {
    super(name, EasyTuneVariableType.NUMBER, value, engine2);
    this.myDecimalPlaces = decimalPlaces;
    this.myStepPerSecond = stepPerSecond;
    this.myDefaultStepPerSecond = this.myStepPerSecond;
    this.myMin = min;
    this.myMax = max;
    this.myEditAllValuesTogether = editAllValuesTogether;
    this._clampValue(true);
  }
  setMax(max) {
    this.myMax = max;
    this._clampValue(false);
  }
  setMin(min) {
    this.myMin = min;
    this._clampValue(false);
  }
  _clampValue(resetDefaultValue) {
    let clampedValue = this.myValue.vec_clamp(this.myMin, this.myMax);
    if (!resetDefaultValue) {
      let clampedDefaultValue = this.myDefaultValue.vec_clamp(this.myMin, this.myMax);
      let defaultValueChanged = !clampedDefaultValue.vec_equals(this.myDefaultValue, 1e-5);
      if (defaultValueChanged) {
        EasyTuneVariableArray.prototype.setDefaultValue.call(this, clampedDefaultValue);
      }
    }
    EasyTuneVariableArray.prototype.setValue.call(this, clampedValue, resetDefaultValue);
  }
};
var EasyTuneNumber = class extends EasyTuneNumberArray {
  constructor(name, value, stepPerSecond, decimalPlaces, min, max, engine2) {
    super(name, [value], stepPerSecond, decimalPlaces, min, max, engine2);
  }
  getValue() {
    return this.myValue[0];
  }
  setValue(value, resetDefaultValue = false) {
    super.setValue([value], resetDefaultValue);
  }
  setDefaultValue(value) {
    super.setDefaultValue([value]);
  }
};
var EasyTuneInt2 = class extends EasyTuneNumber {
  constructor(name, value, stepPerSecond, min, max, engine2) {
    super(name, value, stepPerSecond, 0, min, max, engine2);
  }
};
var EasyTuneIntArray = class extends EasyTuneNumberArray {
  constructor(name, value, stepPerSecond, min, max, editAllValuesTogether, engine2) {
    let tempValue = value.pp_clone();
    for (let i = 0; i < value.length; i++) {
      tempValue[i] = Math.round(tempValue[i]);
    }
    super(name, tempValue, stepPerSecond, 0, min != null ? Math.round(min) : null, max != null ? Math.round(max) : max, editAllValuesTogether, engine2);
  }
};
var EasyTuneBoolArray = class extends EasyTuneVariableArray {
  constructor(name, value, engine2) {
    super(name, EasyTuneVariableType.BOOL, value, engine2);
  }
};
var EasyTuneBool = class extends EasyTuneBoolArray {
  constructor(name, value, engine2) {
    super(name, [value], engine2);
  }
  getValue() {
    return this.myValue[0];
  }
  setValue(value, resetDefaultValue = false) {
    super.setValue([value], resetDefaultValue);
  }
  setDefaultValue(value) {
    super.setDefaultValue([value]);
  }
};
var EasyTuneTransform = class extends EasyTuneVariable {
  constructor(name, value, scaleAsOne = true, positionStepPerSecond = 1, rotationStepPerSecond = 50, scaleStepPerSecond = 1, engine2) {
    super(name, EasyTuneVariableType.TRANSFORM, engine2);
    this.myDecimalPlaces = 3;
    this.myPosition = value.mat4_getPosition();
    this.myRotation = value.mat4_getRotationDegrees();
    this.myScale = value.mat4_getScale();
    let decimalPlacesMultiplier = Math.pow(10, this.myDecimalPlaces);
    for (let i = 0; i < 3; i++) {
      this.myScale[i] = Math.max(this.myScale[i], 1 / decimalPlacesMultiplier);
    }
    this.myScaleAsOne = scaleAsOne;
    this.myPositionStepPerSecond = positionStepPerSecond;
    this.myRotationStepPerSecond = rotationStepPerSecond;
    this.myScaleStepPerSecond = scaleStepPerSecond;
    this.myDefaultPosition = this.myPosition.vec3_clone();
    this.myDefaultRotation = this.myRotation.vec3_clone();
    this.myDefaultScale = this.myScale.vec3_clone();
    this.myDefaultPositionStepPerSecond = this.myPositionStepPerSecond;
    this.myDefaultRotationStepPerSecond = this.myRotationStepPerSecond;
    this.myDefaultScaleStepPerSecond = this.myScaleStepPerSecond;
    this.myTransform = mat4_create();
    this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
    this.myTempTransform = mat4_create();
  }
  getValue() {
    this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
    return this.myTransform.pp_clone();
  }
  setValue(value, resetDefaultValue = false) {
    this.myTempTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
    value.mat4_getPosition(this.myPosition);
    value.mat4_getRotationDegrees(this.myRotation);
    value.mat4_getScale(this.myScale);
    this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
    if (resetDefaultValue) {
      EasyTuneTransform.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshEasyTuneWidget(this._myEngine);
    if (!this.myTempTransform.pp_equals(this.myTransform)) {
      this._triggerValueChangedCallback();
    }
  }
  setDefaultValue(value) {
    this.myDefaultPosition = value.mat4_getPosition();
    this.myDefaultRotation = value.mat4_getRotationDegrees();
    this.myDefaultScale = value.mat4_getScale();
  }
  fromJSON(valueJSON, resetDefaultValue = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue);
  }
  toJSON() {
    return this.getValue().vec_toString();
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_object_tuner.js
var EasyObjectTuner = class {
  constructor(object, variableName, setAsDefault, useTuneTarget, engine2 = getMainEngine2()) {
    this._myObject = object;
    this._myUseTuneTarget = useTuneTarget;
    this._mySetAsDefault = setAsDefault;
    this._myEasyObject = this._myObject;
    if (this._myUseTuneTarget) {
      this._myEasyObject = getEasyTuneTarget(engine2);
    }
    this._myPrevEasyObject = null;
    let variableNamePrefix = this._getVariableNamePrefix();
    if (variableName == "") {
      this._myEasyTuneVariableName = variableNamePrefix.concat(this._myObject.pp_getID());
    } else {
      this._myEasyTuneVariableName = variableNamePrefix.concat(variableName);
    }
    this._myEngine = engine2;
  }
  start() {
    let easyTuneVariable = this._createEasyTuneVariable(this._myEasyTuneVariableName);
    getEasyTuneVariables(this._myEngine).add(easyTuneVariable);
    if (this._mySetAsDefault) {
      EasyTuneUtils.setEasyTuneWidgetActiveVariable(this._myEasyTuneVariableName, this._myEngine);
    }
  }
  update(dt) {
    if (getEasyTuneVariables(this._myEngine).isActive(this._myEasyTuneVariableName)) {
      if (this._myUseTuneTarget) {
        this._myEasyObject = getEasyTuneTarget(engine);
      }
      if (this._myPrevEasyObject != this._myEasyObject) {
        this._myPrevEasyObject = this._myEasyObject;
        if (this._myEasyObject) {
          let value = this._getObjectValue(this._myEasyObject);
          getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value, true);
        } else {
          let value = this._getDefaultValue();
          getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value, true);
        }
      }
      if (this._myEasyObject) {
        this._updateObjectValue(this._myEasyObject, getEasyTuneVariables(this._myEngine).get(this._myEasyTuneVariableName));
      }
    }
  }
  updateVariableValue(value) {
    getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value);
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_transform.js
var EasyTransform = class extends EasyObjectTuner {
  constructor(isLocal, scaleAsOne, object, variableName, setAsDefault, useTuneTarget, engine2) {
    super(object, variableName, setAsDefault, useTuneTarget, engine2);
    this._myIsLocal = isLocal;
    this._myScaleAsOne = scaleAsOne;
  }
  _getVariableNamePrefix() {
    return "Transform ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneTransform(variableName, this._getDefaultValue(), this._myScaleAsOne);
  }
  _getObjectValue(object) {
    return this._myIsLocal ? object.pp_getTransformLocal() : object.pp_getTransform();
  }
  _getDefaultValue() {
    return mat4_create();
  }
  _updateObjectValue(object, value) {
    if (this._myIsLocal) {
      object.pp_setTransformLocal(value);
    } else {
      object.pp_setTransform(value);
    }
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_transform_component.js
var EasyTransformComponent = class extends Component16 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyTransform(this._myIsLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = targetObject.pp_addComponent(this.type, {
      "_myVariableName": this._myVariableName,
      "_mySetAsDefault": this._mySetAsDefault,
      "_myUseTuneTarget": this._myUseTuneTarget,
      "_myIsLocal": this._myIsLocal,
      "_myScaleAsOne": this._myScaleAsOne
    });
    clonedComponent.active = this.active;
    return clonedComponent;
  }
};
__publicField(EasyTransformComponent, "TypeName", "pp-easy-transform");
__publicField(EasyTransformComponent, "Properties", {
  _myVariableName: Property16.string(""),
  _mySetAsDefault: Property16.bool(false),
  _myUseTuneTarget: Property16.bool(false),
  _myIsLocal: Property16.bool(false),
  _myScaleAsOne: Property16.bool(true)
});

// js/pp/cauldron/benchmarks/benchmark_max_visible_triangles_component.js
var BenchmarkMaxVisibleTrianglesComponent = class extends Component17 {
  _start() {
    this._myBackgroundSize = 4;
    this._myBackgroundObject.pp_setActive(true);
    this._myBackgroundObject.pp_setScale(this._myBackgroundSize + 0.1);
    this._myBackgroundObject.pp_translate(vec3_create2(0, 0, -1e-3));
    this._myDoubleTimer = new Timer(this._mySecondsBeforeDoubling);
    this._myIsDone = false;
    this._myCurrentPlanes = this._myStartPlaneCount;
    this._myDTHistory = [];
    this._myUpperLimit = -1;
    this._myLowerLimit = 0;
    this._myPlanes = [];
    this._mySkipNextFrames = 0;
    this._myMaxWaitFrames = 0;
    this._myMaxPlanesReached = false;
    this._myFirstTime = true;
  }
  _update(dt) {
    {
      if (dt < 1e-5) {
        return;
      }
      if (dt > 0.5 && this._myMaxWaitFrames > 0) {
        this._myMaxWaitFrames--;
        return;
      }
      this._myMaxWaitFrames = 10;
      if (this._mySkipNextFrames > 0) {
        this._mySkipNextFrames--;
        return;
      }
    }
    if (!this._myIsDone) {
      this._myDoubleTimer.update(dt);
      this._myDTHistory.push(dt);
      if (this._myDoubleTimer.isDone()) {
        this._myDoubleTimer.start();
        let frameRate = this._computeAverageFrameRate(false);
        if (this._myFirstTime) {
          this._myFirstTime = false;
        } else {
          let isLagging = false;
          if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
            this._myUpperLimit = this._myCurrentPlanes;
            isLagging = true;
            if (this._myUpperLimit == 1) {
              this._myLowerLimit = 1;
            }
          } else {
            this._myLowerLimit = this._myCurrentPlanes;
            if (this._myUpperLimit > 0) {
              this._myUpperLimit = Math.max(this._myUpperLimit, this._myLowerLimit);
            }
          }
          this._myTriangleTextComponent.text = "Triangles: " + this._myCurrentPlanes * this._myRealTrianglesAmount;
          this._myPlaneTextComponent.text = "Planes: " + this._myCurrentPlanes;
          this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
          if (isLagging) {
            this._myTriangleTextComponent.material.color = this._myLagColor;
            this._myPlaneTextComponent.material.color = this._myLagColor;
            this._myFPSTextComponent.material.color = this._myLagColor;
          } else {
            this._myTriangleTextComponent.material.color = this._myNormalColor;
            this._myPlaneTextComponent.material.color = this._myNormalColor;
            this._myFPSTextComponent.material.color = this._myNormalColor;
          }
          let reset12 = false;
          if (this._myUpperLimit > 0 && (!isLagging && this._myUpperLimit - this._myLowerLimit <= Math.max(2, 1e3 / this._myRealTrianglesAmount)) || isLagging && this._myUpperLimit - this._myLowerLimit <= 1 || !isLagging && this._myMaxPlanesReached) {
            if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
              this._myLowerLimit = Math.max(1, Math.floor(this._myUpperLimit / 2.5));
              this._myUpperLimit = 0;
              reset12 = true;
              if (this._myLogActive) {
                console.log("Rst - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
              }
            } else {
              if (this._myMaxPlanesReached) {
                if (this._myLogActive) {
                  console.log("Aborted - Max Planes Reached");
                  this._myDoneTextComponent.text = "Aborted - Max Planes Reached";
                }
              } else {
                this._displayPlanes(this._myLowerLimit);
                if (this._myLogActive) {
                  console.log("\nEnd - Triangles:", this._myLowerLimit * this._myRealTrianglesAmount, "- Planes:", this._myLowerLimit, "- Frame Rate:", frameRate);
                  console.log("Plane Triangles (Adjusted):", this._myRealTrianglesAmount);
                  console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
                }
                this._myTriangleTextComponent.text = "Triangles: " + this._myLowerLimit * this._myRealTrianglesAmount;
                this._myPlaneTextComponent.text = "Planes: " + this._myLowerLimit;
                this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
                this._myDoneTextComponent.text = "End";
              }
              this._myIsDone = true;
            }
          }
          if (isLagging && !reset12) {
            if (this._myLogActive) {
              console.log("Lag - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
            }
          }
          if (!this._myIsDone) {
            if (this._myUpperLimit > 0) {
              this._myCurrentPlanes = Math.floor((this._myUpperLimit + this._myLowerLimit) / 2);
              this._myCurrentPlanes = Math.max(this._myCurrentPlanes, 1);
            } else if (!reset12) {
              this._myCurrentPlanes = this._myLowerLimit * 2;
            } else {
              this._myCurrentPlanes = this._myLowerLimit;
            }
            if (this._myCurrentPlanes > 5e4) {
              this._myCurrentPlanes = 5e4;
              this._myMaxPlanesReached = true;
            } else {
              this._myMaxPlanesReached = false;
            }
          }
        }
        if (!this._myIsDone) {
          this._displayPlanes(this._myCurrentPlanes);
          this._myElapsedTime = 0;
          this._myFrameCount = 0;
          this._mySkipNextFrames = 30;
        }
      }
    }
  }
  _displayPlanes(count) {
    while (this._myPlanes.length > count) {
      let plane = this._myPlanes.pop();
      this._myPlanePool.release(plane);
    }
    while (this._myPlanes.length < count) {
      let plane = this._myPlanePool.get();
      this._myPlanes.push(plane);
    }
    let gridSize = 1;
    while (gridSize * gridSize < count) {
      gridSize++;
    }
    let spaceBetween = 0.01;
    let totalSpaceBetween = spaceBetween * (gridSize - 1);
    let planeSize = (this._myBackgroundSize * 2 - totalSpaceBetween) / (gridSize * 2);
    let currentCount = count;
    for (let i = 0; i < gridSize && currentCount > 0; i++) {
      for (let j = 0; j < gridSize && currentCount > 0; j++) {
        let plane = this._myPlanes[currentCount - 1];
        plane.pp_setScale(planeSize);
        let position = [-this._myBackgroundSize + planeSize + j * planeSize * 2 + j * spaceBetween, this._myBackgroundSize - planeSize - i * planeSize * 2 - i * spaceBetween, 0];
        plane.pp_setPositionLocal(position);
        plane.pp_setActive(true);
        currentCount--;
      }
    }
  }
  start() {
    this._myLagColor = vec4_create2(0.5, 0, 0, 1);
    this._myNormalColor = vec4_create2(0, 0, 0, 1);
    this._myRealTrianglesAmount = 0;
    let parent = this.object;
    if (this._myDisplayInFrontOfPlayer) {
      parent = getPlayerObjects2().myHead.pp_addObject();
      parent.pp_rotateAxis(180, vec3_create2(0, 1, 0));
      parent.pp_translateLocal(vec3_create2(0, 0, this._myDisplayInFrontOfPlayerDistance));
    }
    this._myTrianglesObject = parent.pp_addObject();
    this._myBackgroundObject = this._myTrianglesObject.pp_addObject();
    {
      let meshComponent = this._myBackgroundObject.pp_addComponent(MeshComponent7);
      meshComponent.mesh = MeshUtils.createPlaneMesh();
      meshComponent.material = this._myBackgroundMaterial.clone();
    }
    this._myPlaneObject = this._myTrianglesObject.pp_addObject();
    {
      let meshComponent = this._myPlaneObject.pp_addComponent(MeshComponent7);
      meshComponent.mesh = this._createPlaneMesh(this._myPlaneTriangles);
      this._myRealTrianglesAmount = meshComponent.mesh.indexData.length / 3;
      meshComponent.material = this._myPlaneMaterial.clone();
    }
    let poolParams = new ObjectPoolParams();
    if (!this._myCloneMesh) {
      poolParams.myInitialPoolSize = 3e4;
    } else {
      if (this._myRealTrianglesAmount <= 4) {
        poolParams.myInitialPoolSize = 15e3;
      } else if (this._myRealTrianglesAmount <= 8) {
        poolParams.myInitialPoolSize = 1e4;
      } else if (this._myRealTrianglesAmount <= 64) {
        poolParams.myInitialPoolSize = 7500;
      } else {
        poolParams.myInitialPoolSize = 5e3;
      }
    }
    poolParams.myPercentageToAddWhenEmpty = 0;
    poolParams.myAmountToAddWhenEmpty = 1e4;
    poolParams.myCloneParams = new CloneParams();
    poolParams.myCloneParams.myDeepCloneParams.setDeepCloneComponentVariable(MeshComponent7.TypeName, "material", this._myCloneMaterial);
    poolParams.myCloneParams.myDeepCloneParams.setDeepCloneComponentVariable(MeshComponent7.TypeName, "mesh", this._myCloneMesh);
    this._myPlanePool = new ObjectPool(this._myPlaneObject, poolParams);
    this._myBackgroundObject.pp_setActive(false);
    this._myPlaneObject.pp_setActive(false);
    this._myStartTimer = new Timer(2);
    this._mySessionStarted = false;
    this._myTextsObject = this._myTrianglesObject.pp_addObject();
    this._myTriangleTextObject = this._myTextsObject.pp_addObject();
    this._myTriangleTextComponent = this._myTriangleTextObject.pp_addComponent(TextComponent4);
    this._myTriangleTextComponent.alignment = this.engine.Alignment.Left;
    this._myTriangleTextComponent.justification = this.engine.Justification.Line;
    this._myTriangleTextComponent.material = this._myTextMaterial.clone();
    this._myTriangleTextComponent.material.color = this._myNormalColor;
    this._myTriangleTextComponent.text = " ";
    this._myPlaneTextObject = this._myTextsObject.pp_addObject();
    this._myPlaneTextComponent = this._myPlaneTextObject.pp_addComponent(TextComponent4);
    this._myPlaneTextComponent.alignment = this.engine.Alignment.Left;
    this._myPlaneTextComponent.justification = this.engine.Justification.Line;
    this._myPlaneTextComponent.material = this._myTextMaterial.clone();
    this._myPlaneTextComponent.material.color = this._myNormalColor;
    this._myPlaneTextComponent.text = " ";
    this._myFPSTextObject = this._myTextsObject.pp_addObject();
    this._myFPSTextComponent = this._myFPSTextObject.pp_addComponent(TextComponent4);
    this._myFPSTextComponent.alignment = this.engine.Alignment.Left;
    this._myFPSTextComponent.justification = this.engine.Justification.Line;
    this._myFPSTextComponent.material = this._myTextMaterial.clone();
    this._myFPSTextComponent.material.color = this._myNormalColor;
    this._myFPSTextComponent.text = " ";
    this._myDoneTextObject = this._myTrianglesObject.pp_addObject();
    this._myDoneTextComponent = this._myDoneTextObject.pp_addComponent(TextComponent4);
    this._myDoneTextComponent.alignment = this.engine.Alignment.Center;
    this._myDoneTextComponent.justification = this.engine.Justification.Line;
    this._myDoneTextComponent.material = this._myTextMaterial.clone();
    this._myDoneTextComponent.material.color = this._myNormalColor;
    this._myDoneTextComponent.text = " ";
    this._myTextsObject.pp_setPositionLocal(vec3_create2(0, 4.3, 0));
    this._myTextsObject.pp_setScale(2.75);
    this._myTriangleTextObject.pp_setPositionLocal(vec3_create2(-1.4, 0, 0));
    this._myPlaneTextObject.pp_setPositionLocal(vec3_create2(0.55, 0, 0));
    this._myFPSTextObject.pp_setPositionLocal(vec3_create2(-0.315, 0, 0));
    this._myDoneTextObject.pp_setPositionLocal(vec3_create2(0, -4.6, 0));
    this._myDoneTextObject.pp_setScale(4);
    this._myDTHistory = [];
  }
  update(dt) {
    if (this._mySessionStarted || !this._myStartOnXRStart) {
      if (this._myStartTimer.isRunning()) {
        this._myStartTimer.update(dt);
        this._myDTHistory.push(dt);
        if (this._myStartTimer.isDone()) {
          this._myStableFrameRate = this._computeAverageFrameRate(true);
          if (this._myTargetFrameRate > 0) {
            this._myStableFrameRate = this._myTargetFrameRate;
          }
          if (this._myLogActive) {
            console.log("\nPlane Triangles (Adjusted):", this._myRealTrianglesAmount);
            console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
            console.log("");
          }
          this._start();
        }
      } else {
        this._update(dt);
      }
    } else {
      this._mySessionStarted = XRUtils.getSession(this.engine) != null;
    }
  }
  _computeAverageFrameRate(isStart) {
    let frameRate = 0;
    this._myDTHistory.sort();
    let elementToRemove = Math.floor(this._myDTHistory.length) * Math.min(0.9, this._myDTHistoryToIgnorePercentage * (isStart ? 2 : 1));
    for (let i = 0; i < elementToRemove; i++) {
      this._myDTHistory.pop();
    }
    let averageDT = 0;
    for (let dt of this._myDTHistory) {
      averageDT += dt;
    }
    averageDT /= this._myDTHistory.length;
    frameRate = Math.round(1 / averageDT);
    this._myDTHistory = [];
    return frameRate;
  }
  _createPlaneMesh(trianglesAmount) {
    let squaresAmount = Math.ceil(trianglesAmount / 2);
    let row = 1;
    let column = 1;
    let closestSqrt = 1;
    while (closestSqrt * closestSqrt < squaresAmount) {
      closestSqrt++;
    }
    row = closestSqrt;
    column = closestSqrt;
    while (row > 1 && column > 1 && row * column > squaresAmount && (row - 1) * column >= squaresAmount) {
      row--;
    }
    let meshParams = new MeshCreationParams(this.engine);
    for (let i = 0; i < row + 1; i++) {
      for (let j = 0; j < column + 1; j++) {
        let x = 2 / column * j;
        let y = 2 / row * i;
        let vertexParams = new MeshCreationVertexParams();
        vertexParams.myPosition = vec3_create2();
        vertexParams.myPosition[0] = x - 1;
        vertexParams.myPosition[1] = y - 1;
        vertexParams.myPosition[2] = 0;
        vertexParams.myTextureCoordinates = vec2_create();
        vertexParams.myTextureCoordinates[0] = x / 2;
        vertexParams.myTextureCoordinates[1] = y / 2;
        vertexParams.myNormal = vec3_create2();
        vertexParams.myNormal[0] = 0;
        vertexParams.myNormal[1] = 0;
        vertexParams.myNormal[2] = 1;
        meshParams.myVertexes.push(vertexParams);
      }
    }
    for (let i = 0; i < row; i++) {
      for (let j = 0; j < column; j++) {
        let firstTriangle = new MeshCreationTriangleParams();
        firstTriangle.myIndexes[0] = i * (column + 1) + j;
        firstTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        firstTriangle.myIndexes[2] = (i + 1) * (column + 1) + j;
        let secondTriangle = new MeshCreationTriangleParams();
        secondTriangle.myIndexes[0] = (i + 1) * (column + 1) + j;
        secondTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        secondTriangle.myIndexes[2] = (i + 1) * (column + 1) + j + 1;
        meshParams.myTriangles.push(firstTriangle);
        meshParams.myTriangles.push(secondTriangle);
      }
    }
    let mesh = MeshUtils.createMesh(meshParams);
    return mesh;
  }
};
__publicField(BenchmarkMaxVisibleTrianglesComponent, "TypeName", "pp-benchmark-max-visible-triangles");
__publicField(BenchmarkMaxVisibleTrianglesComponent, "Properties", {
  _myTargetFrameRate: Property17.int(-1),
  _myTargetFrameRateThreshold: Property17.int(3),
  _myStartPlaneCount: Property17.int(1),
  _myPlaneTriangles: Property17.int(100),
  _mySecondsBeforeDoubling: Property17.float(0.5),
  _myDTHistoryToIgnorePercentage: Property17.float(0.25),
  _myCloneMaterial: Property17.bool(false),
  _myCloneMesh: Property17.bool(false),
  _myLogActive: Property17.bool(true),
  _myStartOnXRStart: Property17.bool(false),
  _myDisplayInFrontOfPlayer: Property17.bool(true),
  _myDisplayInFrontOfPlayerDistance: Property17.float(10),
  _myPlaneMaterial: Property17.material(),
  _myBackgroundMaterial: Property17.material(),
  _myTextMaterial: Property17.material(null)
});

// js/pp/cauldron/utils/save_utils.js
function save(id, value) {
  if (value != null) {
    localStorage.setItem(id, value);
  }
}
function has(id) {
  return loadString(id, null) != null;
}
function remove(id) {
  return localStorage.removeItem(id);
}
function clear() {
  return localStorage.clear();
}
function load(id, defaultValue2 = null) {
  return loadString(id, defaultValue2);
}
function loadString(id, defaultValue2 = null) {
  let item = localStorage.getItem(id);
  if (item == null) {
    item = defaultValue2;
  }
  return item;
}
function loadNumber(id, defaultValue2 = null) {
  let item = loadString(id);
  if (item != null) {
    return Number(item);
  }
  return defaultValue2;
}
function loadBool(id, defaultValue2 = null) {
  let item = loadString(id);
  if (item == "true") {
    return true;
  } else if (item == "false") {
    return false;
  }
  return defaultValue2;
}
var SaveUtils = {
  save,
  has,
  remove,
  clear,
  load,
  loadString,
  loadNumber,
  loadBool
};

// js/pp/cauldron/cauldron/save_manager.js
var SaveManager = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
    this._mySaveCache = /* @__PURE__ */ new Map();
    this._myCacheEnabled = true;
    this._myCommitSavesDelayTimer = new Timer(0, false);
    this._myDelaySavesCommit = true;
    this._myIDsToCommit = [];
    this._myCacheDefaultValueOnFail = true;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
    this._myClearCallbacks = /* @__PURE__ */ new Map();
    this._myDeleteCallbacks = /* @__PURE__ */ new Map();
    this._myDeleteIDCallbacks = /* @__PURE__ */ new Map();
    this._mySaveCallbacks = /* @__PURE__ */ new Map();
    this._mySaveValueChangedCallbacks = /* @__PURE__ */ new Map();
    this._mySaveIDCallbacks = /* @__PURE__ */ new Map();
    this._mySaveValueChangedIDCallbacks = /* @__PURE__ */ new Map();
    this._myCommitSaveCallbacks = /* @__PURE__ */ new Map();
    this._myCommitSaveIDCallbacks = /* @__PURE__ */ new Map();
    this._myCommitSavesCallbacks = /* @__PURE__ */ new Map();
    this._myLoadCallbacks = /* @__PURE__ */ new Map();
    this._myLoadIDCallbacks = /* @__PURE__ */ new Map();
  }
  setCommitSavesDelay(delay) {
    this._myCommitSavesDelayTimer.start(delay);
  }
  setDelaySavesCommit(delayed) {
    this._myDelaySavesCommit = delayed;
  }
  setCacheDefaultValueOnFail(cache) {
    this._myCacheDefaultValueOnFail = cache;
  }
  setCacheEnabled(enabled) {
    this._myCacheEnabled = enabled;
  }
  update(dt) {
    if (this._myCommitSavesDelayTimer.isRunning()) {
      this._myCommitSavesDelayTimer.update(dt);
      if (this._myCommitSavesDelayTimer.isDone()) {
        this.commitSaves();
      }
    }
  }
  save(id, value, overrideDelaySavesCommit = null, overrideCacheEnabled = null) {
    let sameValue = false;
    if (this._mySaveCache.has(id) && this._isCacheEnabled(overrideCacheEnabled)) {
      sameValue = this._mySaveCache.get(id) === value;
    }
    if (!sameValue) {
      this._mySaveCache.set(id, value);
      if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
        this._myIDsToCommit.pp_pushUnique(id);
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        let failed = this._commitSave(id, false);
        if (this._myCommitSavesCallbacks.size > 0) {
          let isCommitSaveDelayed = false;
          this._myCommitSavesCallbacks.forEach(function(callback) {
            callback(isCommitSaveDelayed, failed);
          });
        }
      }
    }
    if (this._mySaveCallbacks.size > 0) {
      this._mySaveCallbacks.forEach(function(callback) {
        callback(id, value);
      });
    }
    if (this._mySaveIDCallbacks.size > 0) {
      let callbacks = this._mySaveIDCallbacks.get(id);
      if (callbacks != null) {
        callbacks.forEach(function(callback) {
          callback(id, value);
        });
      }
    }
    if (!sameValue) {
      if (this._mySaveValueChangedCallbacks.size > 0) {
        this._mySaveValueChangedCallbacks.forEach(function(callback) {
          callback(id, value);
        });
      }
      if (this._mySaveValueChangedIDCallbacks.size > 0) {
        let callbacks = this._mySaveValueChangedIDCallbacks.get(id);
        if (callbacks != null) {
          callbacks.forEach(function(callback) {
            callback(id, value);
          });
        }
      }
    }
  }
  commitSaves() {
    if (this._myIDsToCommit.length > 0) {
      let failed = false;
      for (let id of this._myIDsToCommit) {
        if (this._mySaveCache.has(id)) {
          let result2 = this._commitSave(id, true);
          failed = failed || result2;
        }
      }
      this._myIDsToCommit = [];
      if (this._myCommitSavesCallbacks.size > 0) {
        let isCommitSavesDelayed = true;
        this._myCommitSavesCallbacks.forEach(function(callback) {
          callback(isCommitSavesDelayed, failed);
        });
      }
    }
  }
  has(id, overrideCacheEnabled = null) {
    return this._mySaveCache.has(id) && this._isCacheEnabled(overrideCacheEnabled) || SaveUtils.has(id);
  }
  remove(id) {
    this._mySaveCache.delete(id);
    SaveUtils.remove(id);
    if (this._myDeleteCallbacks.size > 0) {
      this._myDeleteCallbacks.forEach(function(callback) {
        callback(id);
      });
    }
    if (this._myDeleteIDCallbacks.size > 0) {
      let callbacks = this._myDeleteIDCallbacks.get(id);
      if (callbacks != null) {
        callbacks.forEach(function(callback) {
          callback(id);
        });
      }
    }
  }
  clear() {
    this._mySaveCache.clear();
    SaveUtils.clear();
    if (this._myClearCallbacks.size > 0) {
      this._myClearCallbacks.forEach(function(callback) {
        callback();
      });
    }
  }
  load(id, defaultValue2 = null, overrideCacheEnabled = null) {
    return this._load(id, defaultValue2, "load", overrideCacheEnabled);
  }
  loadString(id, defaultValue2 = null, overrideCacheEnabled = null) {
    return this._load(id, defaultValue2, "loadString", overrideCacheEnabled);
  }
  loadNumber(id, defaultValue2 = null, overrideCacheEnabled = null) {
    return this._load(id, defaultValue2, "loadNumber", overrideCacheEnabled);
  }
  loadBool(id, defaultValue2 = null, overrideCacheEnabled = null) {
    return this._load(id, defaultValue2, "loadBool", overrideCacheEnabled);
  }
  getCommitSavesDelay() {
    return this._myCommitSavesDelayTimer.getDuration();
  }
  isDelaySavesCommit() {
    return this._myDelaySavesCommit;
  }
  isCacheDefaultValueOnFail() {
    return this._myCacheDefaultValueOnFail;
  }
  isCacheEnabled() {
    return this._myCacheEnabled;
  }
  _commitSave(id, isCommitSaveDelayed) {
    let value = this._mySaveCache.get(id);
    let failed = false;
    try {
      SaveUtils.save(id, value);
    } catch (error) {
      failed = true;
    }
    if (this._myCommitSaveCallbacks.size > 0) {
      this._myCommitSaveCallbacks.forEach(function(callback) {
        callback(id, value, isCommitSaveDelayed, failed);
      });
    }
    if (this._myCommitSaveIDCallbacks.size > 0) {
      let callbacks = this._myCommitSaveIDCallbacks.get(id);
      if (callbacks != null) {
        callbacks.forEach(function(callback) {
          callback(id, value, isCommitSaveDelayed, failed);
        });
      }
    }
    return failed;
  }
  _load(id, defaultValue2, functionName, overrideCacheEnabled = null) {
    let value = null;
    let failed = false;
    let loadFromCache = false;
    if (this._mySaveCache.has(id) && this._isCacheEnabled(overrideCacheEnabled)) {
      value = this._mySaveCache.get(id);
      if (value == null && defaultValue2 != null) {
        value = defaultValue2;
        if (this._myCacheDefaultValueOnFail) {
          this._mySaveCache.set(id, value);
        }
      }
      loadFromCache = true;
    } else {
      let saveResult = null;
      try {
        saveResult = SaveUtils[functionName](id, null);
      } catch (error) {
        saveResult = null;
        failed = true;
      }
      if (saveResult == null) {
        value = defaultValue2;
      } else {
        value = saveResult;
      }
      if (saveResult != null || this._myCacheDefaultValueOnFail) {
        this._mySaveCache.set(id, value);
      } else {
        this._mySaveCache.set(id, null);
      }
    }
    if (this._myLoadCallbacks.size > 0) {
      this._myLoadCallbacks.forEach(function(callback) {
        callback(id, value, loadFromCache, failed);
      });
    }
    if (this._myLoadIDCallbacks.size > 0) {
      let callbacks = this._myLoadIDCallbacks.get(id);
      if (callbacks != null) {
        callbacks.forEach(function(callback) {
          callback(id, value, loadFromCache, failed);
        });
      }
    }
    return value;
  }
  _onXRSessionStart(session) {
    session.addEventListener("visibilitychange", function(event) {
      if (event.session.visibilityState != "visible") {
        this._onXRSessionInterrupt();
      }
    }.bind(this));
  }
  _onXRSessionEnd() {
    this._onXRSessionInterrupt();
  }
  _onXRSessionInterrupt() {
    this.commitSaves();
  }
  registerClearEventListener(callbackID, callback) {
    this._myClearCallbacks.set(callbackID, callback);
  }
  unregisterClearEventListener(callbackID) {
    this._myClearCallbacks.delete(callbackID);
  }
  registerDeleteEventListener(callbackID, callback) {
    this._myDeleteCallbacks.set(callbackID, callback);
  }
  unregisterDeleteEventListener(callbackID) {
    this._myDeleteCallbacks.delete(callbackID);
  }
  registerDeleteIDEventListener(valueID, callbackID, callback) {
    let valueIDCallbacks = this._myDeleteIDCallbacks.get(valueID);
    if (valueIDCallbacks == null) {
      this._myDeleteIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
      valueIDCallbacks = this._myDeleteIDCallbacks.get(valueID);
    }
    valueIDCallbacks.set(callbackID, callback);
  }
  unregisterDeleteIDEventListener(valueID, callbackID) {
    let valueIDCallbacks = this._myDeleteIDCallbacks.get(valueID);
    if (valueIDCallbacks != null) {
      valueIDCallbacks.delete(callbackID);
      if (valueIDCallbacks.size <= 0) {
        this._myDeleteIDCallbacks.delete(valueID);
      }
    }
  }
  registerSaveEventListener(callbackID, callback) {
    this._mySaveCallbacks.set(callbackID, callback);
  }
  unregisterSaveEventListener(callbackID) {
    this._mySaveCallbacks.delete(callbackID);
  }
  registerSaveIDEventListener(valueID, callbackID, callback) {
    let valueIDCallbacks = this._mySaveIDCallbacks.get(valueID);
    if (valueIDCallbacks == null) {
      this._mySaveIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
      valueIDCallbacks = this._mySaveIDCallbacks.get(valueID);
    }
    valueIDCallbacks.set(callbackID, callback);
  }
  unregisterSaveIDEventListener(valueID, callbackID) {
    let valueIDCallbacks = this._mySaveIDCallbacks.get(valueID);
    if (valueIDCallbacks != null) {
      valueIDCallbacks.delete(callbackID);
      if (valueIDCallbacks.size <= 0) {
        this._mySaveIDCallbacks.delete(valueID);
      }
    }
  }
  registerSaveValueChangedEventListener(callbackID, callback) {
    this._mySaveValueChangedCallbacks.set(callbackID, callback);
  }
  unregisterSaveValueChangedEventListener(callbackID) {
    this._mySaveValueChangedCallbacks.delete(callbackID);
  }
  registerSaveValueChangedIDEventListener(valueID, callbackID, callback) {
    let valueIDCallbacks = this._mySaveValueChangedIDCallbacks.get(valueID);
    if (valueIDCallbacks == null) {
      this._mySaveValueChangedIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
      valueIDCallbacks = this._mySaveValueChangedIDCallbacks.get(valueID);
    }
    valueIDCallbacks.set(callbackID, callback);
  }
  unregisterSaveValueChangedIDEventListener(valueID, callbackID) {
    let valueIDCallbacks = this._mySaveValueChangedIDCallbacks.get(valueID);
    if (valueIDCallbacks != null) {
      valueIDCallbacks.delete(callbackID);
      if (valueIDCallbacks.size <= 0) {
        this._mySaveValueChangedIDCallbacks.delete(valueID);
      }
    }
  }
  registerCommitSavesEventListener(callbackID, callback) {
    this._myCommitSavesCallbacks.set(callbackID, callback);
  }
  unregisterCommitSavesEventListener(callbackID) {
    this._myCommitSavesCallbacks.delete(callbackID);
  }
  registerCommitSaveEventListener(callbackID, callback) {
    this._myCommitSaveCallbacks.set(callbackID, callback);
  }
  unregisterCommitSaveEventListener(callbackID) {
    this._myCommitSaveCallbacks.delete(callbackID);
  }
  registerCommitSaveIDEventListener(valueID, callbackID, callback) {
    let valueIDCallbacks = this._myCommitSaveIDCallbacks.get(valueID);
    if (valueIDCallbacks == null) {
      this._myCommitSaveIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
      valueIDCallbacks = this._myCommitSaveIDCallbacks.get(valueID);
    }
    valueIDCallbacks.set(callbackID, callback);
  }
  unregisterCommitSaveIDEventListener(valueID, callbackID) {
    let valueIDCallbacks = this._myCommitSaveIDCallbacks.get(valueID);
    if (valueIDCallbacks != null) {
      valueIDCallbacks.delete(callbackID);
      if (valueIDCallbacks.size <= 0) {
        this._myCommitSaveIDCallbacks.delete(valueID);
      }
    }
  }
  registerLoadEventListener(callbackID, callback) {
    this._myLoadCallbacks.set(callbackID, callback);
  }
  unregisterLoadEventListener(callbackID) {
    this._myLoadCallbacks.delete(callbackID);
  }
  registerLoadIDEventListener(valueID, callbackID, callback) {
    let valueIDCallbacks = this._myLoadIDCallbacks.get(valueID);
    if (valueIDCallbacks == null) {
      this._myLoadIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
      valueIDCallbacks = this._myLoadIDCallbacks.get(valueID);
    }
    valueIDCallbacks.set(callbackID, callback);
  }
  unregisterLoadIDEventListener(valueID, callbackID) {
    let valueIDCallbacks = this._myLoadIDCallbacks.get(valueID);
    if (valueIDCallbacks != null) {
      valueIDCallbacks.delete(callbackID);
      if (valueIDCallbacks.size <= 0) {
        this._myLoadIDCallbacks.delete(valueID);
      }
    }
  }
  _isCacheEnabled(overrideCacheEnabled = null) {
    return this._myCacheEnabled && overrideCacheEnabled == null || overrideCacheEnabled != null && overrideCacheEnabled;
  }
};

// js/pp/cauldron/components/clear_console_on_xr_session_start_component.js
import { Component as Component18, Property as Property18 } from "@wonderlandengine/api";
var ClearConsoleOnXRSessionStartComponent = class extends Component18 {
  start() {
    this._myFirstTime = true;
    XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), this.engine);
  }
  _onXRSessionStart() {
    if (!this._myFirstTimeOnly || this._myFirstTime) {
      this._myFirstTime = false;
      console.clear();
    }
  }
};
__publicField(ClearConsoleOnXRSessionStartComponent, "TypeName", "pp-clear-console-on-xr-session-start");
__publicField(ClearConsoleOnXRSessionStartComponent, "Properties", {
  _myFirstTimeOnly: Property18.bool(true)
});

// js/pp/cauldron/components/set_active_component.js
import { Component as Component19, Property as Property19 } from "@wonderlandengine/api";
var SetActiveComponent = class extends Component19 {
  init() {
    if (this.active && this._mySetActiveWhen == 0) {
      this._setActive();
    }
  }
  start() {
    if (this._mySetActiveWhen == 1) {
      this._setActive();
    }
    this._myFirst = true;
  }
  update(dt) {
    if (this._mySetActiveWhen == 2 && this._myFirst) {
      this._myFirst = false;
      this._setActive();
    }
  }
  _setActive() {
    if (this._mySetActiveOn == 0) {
      this.object.pp_setActiveSelf(this._myActive);
    } else if (this._mySetActiveOn == 1) {
      this.object.pp_setActiveChildren(this._myActive);
    } else if (this._mySetActiveOn == 2) {
      this.object.pp_setActiveDescendants(this._myActive);
    } else {
      this.object.pp_setActive(this._myActive);
    }
  }
};
__publicField(SetActiveComponent, "TypeName", "pp-set-active");
__publicField(SetActiveComponent, "Properties", {
  _myActive: Property19.bool(true),
  _mySetActiveOn: Property19.enum(["Self", "Children", "Descendants", "Hierarchy"], "Hierarchy"),
  _mySetActiveWhen: Property19.enum(["Init", "Start", "First Update"], "Init")
});

// js/pp/cauldron/components/adjust_hierarchy_physx_scale_component.js
import { Component as Component20, Property as Property20, PhysXComponent as PhysXComponent4 } from "@wonderlandengine/api";
var AdjustHierarchyPhysXScaleComponent = class extends Component20 {
  init() {
    if (this.active && this._myWhen == 0) {
      this._adjustScale();
    }
  }
  start() {
    if (this._myWhen == 1) {
      this._adjustScale();
    }
    this._myFirst = true;
  }
  update(dt) {
    if (this._myWhen == 2 && this._myFirst) {
      this._myFirst = false;
      this._adjustScale();
    }
  }
  _adjustScale() {
    let scale = this.object.pp_getScale();
    let physXComponents = this.object.pp_getComponents(PhysXComponent4);
    for (let physX of physXComponents) {
      physX.extents[0] = physX.extents[0] * scale[0];
      physX.extents[1] = physX.extents[1] * scale[1];
      physX.extents[2] = physX.extents[2] * scale[2];
      if (physX.active) {
        physX.active = false;
        physX.active = true;
      }
    }
  }
};
__publicField(AdjustHierarchyPhysXScaleComponent, "TypeName", "pp-adjust-hierarchy-physx-scale");
__publicField(AdjustHierarchyPhysXScaleComponent, "Properties", {
  _myWhen: Property20.enum(["Init", "Start", "First Update"], "Start")
});

// js/pp/cauldron/components/show_fps_component.js
import { Component as Component21, Property as Property21 } from "@wonderlandengine/api";
var ShowFPSComponent = class extends Component21 {
  start() {
    this._myTimer = new Timer(this._myRefreshSeconds);
    this._myTotalDT = 0;
    this._myFrames = 0;
    this._myVisualFPSParent = this.object.pp_addObject();
    let visualParams = new VisualTextParams(this.engine);
    visualParams.myText = "00";
    visualParams.myTransform.mat4_setPositionRotationScale(vec3_create2(-0.115, -0.115, 0.35), vec3_create2(0, 180, 0), vec3_create2(0.3, 0.3, 0.3));
    if (this._myTextMaterial != null) {
      visualParams.myMaterial = this._myTextMaterial.clone();
    } else {
      visualParams.myMaterial = getDefaultResources(this.engine).myMaterials.myText.clone();
      visualParams.myMaterial.color = vec4_create2(1, 1, 1, 1);
    }
    visualParams.myParent = this._myVisualFPSParent;
    visualParams.myIsLocal = true;
    this._myVisualFPS = new VisualText(visualParams);
  }
  update(dt) {
  }
};
__publicField(ShowFPSComponent, "TypeName", "pp-show-fps");
__publicField(ShowFPSComponent, "Properties", {
  _myRefreshSeconds: Property21.float(0.25),
  _myTextMaterial: Property21.material()
});
ShowFPSComponent.prototype.update = function() {
  let playerTransformQuat = quat2_create();
  return function update(dt) {
    this._myTotalDT += dt;
    this._myFrames++;
    this._myTimer.update(dt);
    if (this._myTimer.isDone()) {
      this._myTimer.start();
      let fps = Math.round(this._myFrames / this._myTotalDT);
      let visualParams = this._myVisualFPS.getParams();
      if (XRUtils.isSessionActive(this.engine)) {
        visualParams.myTransform.mat4_setPositionRotationScale(vec3_create2(-0.115, -0.115, 0.35), vec3_create2(0, 180, 0), vec3_create2(0.3, 0.3, 0.3));
      } else {
        visualParams.myTransform.mat4_setPositionRotationScale(vec3_create2(-0.25, -0.13, 0.35), vec3_create2(0, 180, 0), vec3_create2(0.3, 0.3, 0.3));
      }
      visualParams.myText = fps.toFixed(0);
      this._myVisualFPS.paramsUpdated();
      this._myTotalDT = 0;
      this._myFrames = 0;
    }
    this._myVisualFPSParent.pp_setTransformQuat(getPlayerObjects2(this.engine).myHead.pp_getTransformQuat(playerTransformQuat));
  };
}();

// js/pp/cauldron/fsm/fsm.js
var StateData = class {
  constructor(stateID, stateObject) {
    this.myID = stateID;
    this.myObject = stateObject;
  }
};
var TransitionData = class {
  constructor(transitionID, fromStateData, toStateData, transitionObject, skipStateFunction) {
    this.myID = transitionID;
    this.myFromState = fromStateData;
    this.myToState = toStateData;
    this.myObject = transitionObject;
    this.mySkipStateFunction = skipStateFunction;
  }
};
var PerformMode = {
  IMMEDIATE: 0,
  DELAYED: 1
};
var PerformDelayedMode = {
  QUEUE: 0,
  KEEP_FIRST: 1,
  KEEP_LAST: 2
};
var SkipStateFunction = {
  NONE: 0,
  END: 1,
  START: 2,
  BOTH: 3
};
var FSM = class {
  constructor(performMode = PerformMode.IMMEDIATE, performDelayedMode = PerformDelayedMode.QUEUE) {
    this._myCurrentStateData = null;
    this._myStates = /* @__PURE__ */ new Map();
    this._myTransitions = /* @__PURE__ */ new Map();
    this._myDebugLogActive = false;
    this._myDebugShowDelayedInfo = false;
    this._myDebugLogName = "FSM";
    this._myPerformMode = performMode;
    this._myPerformDelayedMode = performDelayedMode;
    this._myPendingPerforms = [];
    this._myCurrentlyPerformedTransition = null;
    this._myInitCallbacks = /* @__PURE__ */ new Map();
    this._myInitIDCallbacks = /* @__PURE__ */ new Map();
    this._myTransitionCallbacks = /* @__PURE__ */ new Map();
    this._myTransitionIDCallbacks = [];
  }
  addState(stateID, state = null) {
    let stateObject = null;
    if (!state || typeof state == "function") {
      stateObject = {};
      if (typeof state == "function") {
        stateObject.update = function update() {
          return state(...arguments);
        };
      } else {
        stateObject.update = null;
      }
      stateObject.clone = function clone() {
        let cloneObject = {};
        cloneObject.update = this.update;
        cloneObject.clone = this.clone;
        return cloneObject;
      };
    } else {
      stateObject = state;
    }
    let stateData = new StateData(stateID, stateObject);
    this._myStates.set(stateID, stateData);
    this._myTransitions.set(stateID, /* @__PURE__ */ new Map());
  }
  addTransition(fromStateID, toStateID, transitionID, transition = null, skipStateFunction = SkipStateFunction.NONE) {
    let transitionObject = null;
    if (!transition || typeof transition == "function") {
      transitionObject = {};
      if (typeof transition == "function") {
        transitionObject.perform = function perform() {
          return transition(...arguments);
        };
      } else {
        transitionObject.perform = null;
      }
      transitionObject.clone = function clone() {
        let cloneObject = {};
        cloneObject.perform = this.perform;
        cloneObject.clone = this.clone;
        return cloneObject;
      };
    } else {
      transitionObject = transition;
    }
    if (this.hasState(fromStateID) && this.hasState(toStateID)) {
      let transitionsFromState = this._getTransitionsFromState(fromStateID);
      let transitionData = new TransitionData(transitionID, this.getState(fromStateID), this.getState(toStateID), transitionObject, skipStateFunction);
      transitionsFromState.set(transitionID, transitionData);
    } else {
      if (!this.hasState(fromStateID) && !this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID, "- to state not found:", toStateID);
      } else if (!this.hasState(fromStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID);
      } else if (!this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- to state not found:", toStateID);
      }
    }
  }
  init(initStateID, initTransition = null, ...args) {
    let initTransitionObject = initTransition;
    if (initTransition && typeof initTransition == "function") {
      initTransitionObject = {};
      initTransitionObject.performInit = initTransition;
    }
    if (this.hasState(initStateID)) {
      let initStateData = this._myStates.get(initStateID);
      if (this._myDebugLogActive) {
        console.log(this._myDebugLogName, "- Init:", initStateID);
      }
      if (initTransitionObject && initTransitionObject.performInit) {
        initTransitionObject.performInit(this, initStateData, ...args);
      } else if (initStateData.myObject && initStateData.myObject.init) {
        initStateData.myObject.init(this, initStateData, ...args);
      }
      this._myCurrentStateData = initStateData;
      if (this._myInitCallbacks.size > 0) {
        this._myInitCallbacks.forEach(function(callback) {
          callback(this, initStateData, initTransitionObject, ...args);
        }.bind(this));
      }
      if (this._myInitIDCallbacks.size > 0) {
        let callbacks = this._myInitIDCallbacks.get(initStateID);
        if (callbacks != null) {
          callbacks.forEach(function(callback) {
            callback(this, initStateData, initTransitionObject, ...args);
          }.bind(this));
        }
      }
    } else if (this._myDebugLogActive) {
      console.warn(this._myDebugLogName, "- Init state not found:", initStateID);
    }
  }
  update(dt, ...args) {
    if (this._myPendingPerforms.length > 0) {
      for (let i = 0; i < this._myPendingPerforms.length; i++) {
        this._perform(this._myPendingPerforms[i].myID, PerformMode.DELAYED, ...this._myPendingPerforms[i].myArgs);
      }
      this._myPendingPerforms = [];
    }
    if (this._myCurrentStateData && this._myCurrentStateData.myObject && this._myCurrentStateData.myObject.update) {
      this._myCurrentStateData.myObject.update(dt, this, ...args);
    }
  }
  perform(transitionID, ...args) {
    if (this._myPerformMode == PerformMode.DELAYED) {
      this.performDelayed(transitionID, ...args);
    } else {
      this.performImmediate(transitionID, ...args);
    }
  }
  performDelayed(transitionID, ...args) {
    let performDelayed = false;
    switch (this._myPerformDelayedMode) {
      case PerformDelayedMode.QUEUE:
        this._myPendingPerforms.push(new PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
      case PerformDelayedMode.KEEP_FIRST:
        if (!this.hasPendingPerforms()) {
          this._myPendingPerforms.push(new PendingPerform(transitionID, ...args));
          performDelayed = true;
        }
        break;
      case PerformDelayedMode.KEEP_LAST:
        this.resetPendingPerforms();
        this._myPendingPerforms.push(new PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
    }
    return performDelayed;
  }
  performImmediate(transitionID, ...args) {
    return this._perform(transitionID, PerformMode.IMMEDIATE, ...args);
  }
  canPerform(transitionID) {
    return this.hasTransitionFromState(this._myCurrentStateData.myID, transitionID);
  }
  canGoTo(stateID, transitionID = null) {
    return this.hasTransitionFromStateToState(this._myCurrentStateData.myID, stateID, transitionID);
  }
  isInState(stateID) {
    return this._myCurrentStateData != null && this._myCurrentStateData.myID == stateID;
  }
  isPerformingTransition() {
    return this._myCurrentlyPerformedTransition != null;
  }
  getCurrentlyPerformedTransition() {
    return this._myCurrentlyPerformedTransition;
  }
  hasBeenInit() {
    return this._myCurrentStateData != null;
  }
  reset() {
    this.resetState();
    this.resetPendingPerforms();
  }
  resetState() {
    this._myCurrentStateData = null;
  }
  resetPendingPerforms() {
    this._myPendingPerforms = [];
  }
  getCurrentState() {
    return this._myCurrentStateData;
  }
  getCurrentTransitions() {
    return this.getTransitionsFromState(this._myCurrentStateData.myID);
  }
  getCurrentTransitionsToState(stateID) {
    return this.getTransitionsFromStateToState(this._myCurrentStateData.myID, stateID);
  }
  getState(stateID) {
    return this._myStates.get(stateID);
  }
  getStates() {
    return this._myStates.values();
  }
  getTransitions() {
    let transitions = [];
    for (let transitionsFromState of this._myTransitions.values()) {
      for (let transitionData of transitionsFromState.values()) {
        transitions.push(transitionData);
      }
    }
    return transitions;
  }
  getTransitionsFromState(fromStateID) {
    let transitionsFromState = this._getTransitionsFromState(fromStateID);
    return Array.from(transitionsFromState.values());
  }
  getTransitionsFromStateToState(fromStateID, toStateID) {
    let transitionsFromState = this._getTransitionsFromState(fromStateID);
    let transitionsToState = [];
    for (let transitionData of transitionsFromState.values()) {
      if (transitionData.myToState.myID == toStateID) {
        transitionsToState.push(transitionData);
      }
    }
    return transitionsToState;
  }
  removeState(stateID) {
    if (this.hasState(stateID)) {
      this._myStates.delete(stateID);
      this._myTransitions.delete(stateID);
      for (let transitionsFromState of this._myTransitions.values()) {
        let toDelete = [];
        for (let [transitionID, transitionData] of transitionsFromState.entries()) {
          if (transitionData.myToState.myID == stateID) {
            toDelete.push(transitionID);
          }
        }
        for (let transitionID of toDelete) {
          transitionsFromState.delete(transitionID);
        }
      }
      return true;
    }
    return false;
  }
  removeTransitionFromState(fromStateID, transitionID) {
    let fromTransitions = this._getTransitionsFromState(fromStateID);
    if (fromTransitions) {
      return fromTransitions.delete(transitionID);
    }
    return false;
  }
  hasState(stateID) {
    return this._myStates.has(stateID);
  }
  hasTransitionFromState(fromStateID, transitionID) {
    let transitions = this.getTransitionsFromState(fromStateID);
    let transitionIndex = transitions.findIndex(function(transition) {
      return transition.myID == transitionID;
    });
    return transitionIndex >= 0;
  }
  hasTransitionFromStateToState(fromStateID, toStateID, transitionID = null) {
    let transitions = this.getTransitionsFromStateToState(fromStateID, toStateID);
    let hasTransition = false;
    if (transitionID) {
      let transitionIndex = transitions.findIndex(function(transition) {
        return transition.myID == transitionID;
      });
      hasTransition = transitionIndex >= 0;
    } else {
      hasTransition = transitions.length > 0;
    }
    return hasTransition;
  }
  setPerformMode(performMode) {
    this._myPerformMode = performMode;
  }
  getPerformMode() {
    return this._myPerformMode;
  }
  setPerformDelayedMode(performDelayedMode) {
    this._myPerformDelayedMode = performDelayedMode;
  }
  getPerformDelayedMode() {
    return this._myPerformDelayedMode;
  }
  hasPendingPerforms() {
    return this._myPendingPerforms.length > 0;
  }
  getPendingPerforms() {
    return this._myPendingPerforms.pp_clone();
  }
  clone(deepClone = false) {
    if (!this.isCloneable(deepClone)) {
      return null;
    }
    let cloneFSM = new FSM();
    cloneFSM._myDebugLogActive = this._myDebugLogActive;
    cloneFSM._myDebugShowDelayedInfo = this._myDebugShowDelayedInfo;
    cloneFSM._myDebugLogName = this._myDebugLogName.slice(0);
    cloneFSM._myPerformMode = this._myPerformMode;
    cloneFSM._myPerformDelayedMode = this._myPerformDelayedMode;
    cloneFSM._myPendingPerforms = this._myPendingPerforms.pp_clone();
    for (let entry of this._myStates.entries()) {
      let stateData = null;
      if (deepClone) {
        stateData = new StateData(entry[1].myID, entry[1].myObject.clone());
      } else {
        stateData = new StateData(entry[1].myID, entry[1].myObject);
      }
      cloneFSM._myStates.set(stateData.myID, stateData);
    }
    for (let entry of this._myTransitions.entries()) {
      let transitionsFromState = /* @__PURE__ */ new Map();
      cloneFSM._myTransitions.set(entry[0], transitionsFromState);
      for (let transitonEntry of entry[1].entries()) {
        let transitionData = null;
        let fromState = cloneFSM.getState(transitonEntry[1].myFromState.myID);
        let toState = cloneFSM.getState(transitonEntry[1].myToState.myID);
        if (deepClone) {
          transitionData = new TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject.clone(), transitonEntry[1].mySkipStateFunction);
        } else {
          transitionData = new TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject, transitonEntry[1].mySkipStateFunction);
        }
        transitionsFromState.set(transitionData.myID, transitionData);
      }
    }
    if (this._myCurrentStateData) {
      cloneFSM._myCurrentStateData = cloneFSM.getState(this._myCurrentStateData.myID);
    }
    return cloneFSM;
  }
  isCloneable(deepClone = false) {
    if (!deepClone) {
      return true;
    }
    let isDeepCloneable = true;
    for (let entry of this._myStates.entries()) {
      isDeepCloneable = isDeepCloneable && entry[1].myObject.clone != null;
    }
    for (let entry of this._myTransitions.entries()) {
      for (let transitonEntry of entry[1].entries()) {
        isDeepCloneable = isDeepCloneable && transitonEntry[1].myObject.clone != null;
      }
    }
    return isDeepCloneable;
  }
  setDebugLogActive(active, debugLogName = null, showDelayedInfo = false) {
    this._myDebugLogActive = active;
    this._myDebugShowDelayedInfo = showDelayedInfo;
    if (debugLogName) {
      this._myDebugLogName = "FSM: ".concat(debugLogName);
    }
  }
  registerInitEventListener(callbackID, callback) {
    this._myInitCallbacks.set(callbackID, callback);
  }
  unregisterInitEventListener(callbackID) {
    this._myInitCallbacks.delete(callbackID);
  }
  registerInitIDEventListener(initStateID, callbackID, callback) {
    let initStateIDCallbacks = this._myInitIDCallbacks.get(initStateID);
    if (initStateIDCallbacks == null) {
      this._myInitIDCallbacks.set(initStateID, /* @__PURE__ */ new Map());
      initStateIDCallbacks = this._myInitIDCallbacks.get(initStateID);
    }
    initStateIDCallbacks.set(callbackID, callback);
  }
  unregisterInitIDEventListener(initStateID, callbackID) {
    let initStateIDCallbacks = this._myInitIDCallbacks.get(initStateID);
    if (initStateIDCallbacks != null) {
      initStateIDCallbacks.delete(callbackID);
      if (initStateIDCallbacks.size <= 0) {
        this._myInitIDCallbacks.delete(initStateID);
      }
    }
  }
  registerTransitionEventListener(callbackID, callback) {
    this._myTransitionCallbacks.set(callbackID, callback);
  }
  unregisterTransitionEventListener(callbackID) {
    this._myTransitionCallbacks.delete(callbackID);
  }
  registerTransitionIDEventListener(fromStateID, toStateID, transitionID, callbackID, callback) {
    let internalTransitionIDCallbacks = null;
    for (let value of this._myTransitionIDCallbacks) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDCallbacks = value[3];
        break;
      }
    }
    if (internalTransitionIDCallbacks == null) {
      let transitionIDCallbacks = [];
      transitionIDCallbacks[0] = fromStateID;
      transitionIDCallbacks[1] = toStateID;
      transitionIDCallbacks[2] = transitionID;
      transitionIDCallbacks[3] = /* @__PURE__ */ new Map();
      internalTransitionIDCallbacks = transitionIDCallbacks[3];
      this._myTransitionIDCallbacks.push(transitionIDCallbacks);
    }
    internalTransitionIDCallbacks.set(callbackID, callback);
  }
  unregisterTransitionIDEventListener(fromStateID, toStateID, transitionID, callbackID) {
    let internalTransitionIDCallbacks = null;
    for (let value of this._myTransitionIDCallbacks) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDCallbacks = value[3];
        break;
      }
    }
    if (internalTransitionIDCallbacks != null) {
      internalTransitionIDCallbacks.delete(callbackID);
      if (internalTransitionIDCallbacks.size <= 0) {
        this._myTransitionIDCallbacks.pp_remove((element) => element[0] == fromStateID && element[1] == toStateID && element[2] == transitionID);
      }
    }
  }
  _perform(transitionID, performMode, ...args) {
    if (this.isPerformingTransition()) {
      let currentlyPerformedTransition = this.getCurrentlyPerformedTransition();
      let consoleArguments = [this._myDebugLogName, "- Trying to perform:", transitionID];
      if (this._myDebugShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      consoleArguments.push("- But another transition is currently being performed -", currentlyPerformedTransition.myID);
      console.warn(...consoleArguments);
      return false;
    }
    if (this._myCurrentStateData) {
      if (this.canPerform(transitionID)) {
        let transitions = this._myTransitions.get(this._myCurrentStateData.myID);
        let transitionToPerform = transitions.get(transitionID);
        this._myCurrentlyPerformedTransition = transitionToPerform;
        let fromState = this._myCurrentStateData;
        let toState = this._myStates.get(transitionToPerform.myToState.myID);
        if (this._myDebugLogActive) {
          let consoleArguments = [this._myDebugLogName, "- From:", fromState.myID, "- To:", toState.myID, "- With:", transitionID];
          if (this._myDebugShowDelayedInfo) {
            consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
          }
          console.log(...consoleArguments);
        }
        if (transitionToPerform.mySkipStateFunction != SkipStateFunction.END && transitionToPerform.mySkipStateFunction != SkipStateFunction.BOTH && fromState.myObject && fromState.myObject.end) {
          fromState.myObject.end(this, transitionToPerform, ...args);
        }
        if (transitionToPerform.myObject && transitionToPerform.myObject.perform) {
          transitionToPerform.myObject.perform(this, transitionToPerform, ...args);
        }
        if (transitionToPerform.mySkipStateFunction != SkipStateFunction.START && transitionToPerform.mySkipStateFunction != SkipStateFunction.BOTH && toState.myObject && toState.myObject.start) {
          toState.myObject.start(this, transitionToPerform, ...args);
        }
        this._myCurrentStateData = transitionToPerform.myToState;
        if (this._myTransitionCallbacks.size > 0) {
          this._myTransitionCallbacks.forEach(function(callback) {
            callback(this, fromState, toState, transitionToPerform, performMode, ...args);
          }.bind(this));
        }
        if (this._myTransitionIDCallbacks.length > 0) {
          let internalTransitionIDCallbacks = [];
          for (let value of this._myTransitionIDCallbacks) {
            if ((value[0] == null || value[0] == fromState.myID) && (value[1] == null || value[1] == toState.myID) && (value[2] == null || value[2] == transitionToPerform.myID)) {
              internalTransitionIDCallbacks.push(value[3]);
            }
          }
          for (let callbacks of this.internalTransitionIDCallbacks) {
            callbacks.forEach(function(callback) {
              callback(this, fromState, toState, transitionToPerform, performMode, ...args);
            }.bind(this));
          }
        }
        this._myCurrentlyPerformedTransition = null;
        return true;
      } else if (this._myDebugLogActive) {
        let consoleArguments = [this._myDebugLogName, "- No Transition:", transitionID, "- From:", this._myCurrentStateData.myID];
        if (this._myDebugShowDelayedInfo) {
          consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
        }
        console.warn(...consoleArguments);
      }
    } else if (this._myDebugLogActive) {
      let consoleArguments = [this._myDebugLogName, "- FSM not initialized yet"];
      if (this._myDebugShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      console.warn(...consoleArguments);
    }
    return false;
  }
  _getTransitionsFromState(fromStateID) {
    return this._myTransitions.get(fromStateID);
  }
};
var PendingPerform = class {
  constructor(transitionID, ...args) {
    this.myID = transitionID;
    this.myArgs = args;
  }
};

// js/pp/cauldron/fsm/state.js
var State = class {
  update(dt, fsm, ...args) {
  }
  init(fsm, state, ...args) {
  }
  start(fsm, transition, ...args) {
  }
  end(fsm, transition, ...args) {
  }
};

// js/pp/cauldron/fsm/transition.js
var Transition = class {
  performInit(fsm, initState, ...args) {
  }
  perform(fsm, transition, ...args) {
  }
};

// js/pp/cauldron/fsm/states/timer_state.js
var TimerState = class extends State {
  constructor(duration = 0, transitionToPerformOnEnd = null, ...transitionArgs) {
    super();
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
    this._myTimer = new Timer(duration, false);
  }
  setDuration(duration) {
    this._myTimer.setDuration(duration);
  }
  setTransitionToPerformOnEnd(transitionToPerformOnEnd, ...transitionArgs) {
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
  }
  onEnd(callback, id = null) {
    this._myTimer.onEnd(callback, id);
  }
  unregisterOnEnd(id = null) {
    this._myTimer.unregisterOnEnd(id);
  }
  update(dt, fsm) {
    this._myTimer.update(dt);
    if (this._myTimer.isDone()) {
      if (this._myTransitionToPerformOnEnd != null) {
        fsm.perform(this._myTransitionToPerformOnEnd, ...this._myTransitionArgs);
      }
    }
  }
  start(fsm, transition, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
    this._myTimer.start(duration);
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
  init(fsm, state, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
    this._myTimer.start(duration);
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
};

// js/pp/cauldron/utils/color_utils.js
function rgbToHsv(rgb) {
  let hsv = rgb.pp_clone();
  let r = rgb[0];
  let g = rgb[1];
  let b = rgb[2];
  let max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min, h, s = max === 0 ? 0 : d / max, v = max;
  switch (max) {
    case min:
      h = 0;
      break;
    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;
    case b:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
  return hsv;
}
function hsvToRgb(hsv) {
  let rgb = hsv.pp_clone();
  let h = hsv[0];
  let s = hsv[1];
  let v = hsv[2];
  let r, g, b, i, f, p, q, t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
  return rgb;
}
function rgbCodeToHuman(rgb) {
  return color1To255(rgb);
}
function rgbHumanToCode(rgb) {
  return color255To1(rgb);
}
function hsvCodeToHuman(hsv) {
  return color1To255(hsv);
}
function hsvHumanToCode(hsv) {
  return color255To1(hsv);
}
function color255To1(color) {
  let result2 = color.pp_clone();
  for (let i = 0; i < result2.length; i++) {
    result2[i] /= 255;
    result2[i] = Math.pp_clamp(result2[i], 0, 1);
  }
  return result2;
}
function color1To255(color) {
  let result2 = color.pp_clone();
  for (let i = 0; i < result2.length; i++) {
    result2[i] = Math.round(result2[i] * 255);
    result2[i] = Math.pp_clamp(result2[i], 0, 255);
  }
  return result2;
}
var ColorUtils = {
  rgbToHsv,
  hsvToRgb,
  rgbCodeToHuman,
  rgbHumanToCode,
  hsvCodeToHuman,
  hsvHumanToCode,
  color255To1,
  color1To255
};

// js/pp/cauldron/utils/material_utils.js
import { MeshComponent as MeshComponent8 } from "@wonderlandengine/api";
var setAlpha = function() {
  let color = vec4_create2();
  return function setAlpha2(material, alpha) {
    if (material.color != null) {
      color.vec4_copy(material.color);
      color[3] = alpha;
      material.color = color;
    }
    if (material.diffuseColor != null) {
      color.vec4_copy(material.diffuseColor);
      color[3] = alpha;
      material.diffuseColor = color;
    }
    if (material.ambientColor != null) {
      color.vec4_copy(material.ambientColor);
      color[3] = alpha;
      material.ambientColor = color;
    }
  };
}();
function setObjectAlpha(object, alpha) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      setAlpha(meshComponent.material, alpha);
    }
  }
}
function setObjectMaterial(object, material, cloneMaterial = false) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (cloneMaterial) {
      meshComponent.material = material.clone();
    } else {
      meshComponent.material = material;
    }
  }
}
function setObjectClonedMaterials(object) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    meshComponent.material = meshComponent.material.clone();
  }
}
function setObjectSpecularColor(object, color) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material.specularColor != null) {
      meshComponent.material.specularColor = color;
    }
  }
}
function setObjectFogColor(object, color) {
  let meshComponents = object.pp_getComponents(MeshComponent8);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material.fogColor != null) {
      meshComponent.material.fogColor = color;
    }
  }
}
var MaterialUtils = {
  setAlpha,
  setObjectAlpha,
  setObjectMaterial,
  setObjectClonedMaterials,
  setObjectSpecularColor,
  setObjectFogColor
};

// js/pp/cauldron/utils/text_utils.js
import { TextComponent as TextComponent5 } from "@wonderlandengine/api";
function setClonedMaterials(object) {
  let textComponents = object.pp_getComponents(TextComponent5);
  for (let textComponent of textComponents) {
    textComponent.material = textComponent.material.clone();
  }
}
var TextUtils = {
  setClonedMaterials
};

// js/pp/cauldron/utils/browser_utils.js
function isMobile() {
  return /Mobi/i.test(window.navigator.userAgent);
}
function isDesktop() {
  return !isMobile();
}
var BrowserUtils = {
  isMobile,
  isDesktop
};

// js/pp/cauldron/utils/js_utils.js
function getObjectPrototypes(object) {
  let prototypes = [];
  prototypes.push(object);
  let objectProto = Object.getPrototypeOf(object);
  while (objectProto != null) {
    prototypes.pp_pushUnique(objectProto);
    objectProto = Object.getPrototypeOf(objectProto);
  }
  let prototypesToCheck = [object];
  while (prototypesToCheck.length > 0) {
    let prototypeToCheck = prototypesToCheck.shift();
    if (prototypeToCheck != null) {
      prototypes.pp_pushUnique(prototypeToCheck);
      prototypesToCheck.pp_pushUnique(Object.getPrototypeOf(prototypeToCheck));
      prototypesToCheck.pp_pushUnique(prototypeToCheck.prototype);
    }
  }
  return prototypes;
}
function getObjectPropertyNames(object) {
  let propertyNames = [];
  let prototypes = getObjectPrototypes(object);
  for (let prototype of prototypes) {
    if (prototype != null) {
      let ownPropertyNames = Object.getOwnPropertyNames(prototype);
      for (let ownPropertyName of ownPropertyNames) {
        propertyNames.pp_pushUnique(ownPropertyName);
      }
    }
  }
  return propertyNames;
}
function getObjectPropertyDescriptor(object, propertyName) {
  let propertyDescriptor = null;
  let propertyParent = getObjectPropertyOwnParent(object, propertyName);
  if (propertyParent != null) {
    propertyDescriptor = Object.getOwnPropertyDescriptor(propertyParent, propertyName);
  }
  return propertyDescriptor;
}
function getObjectProperty(object, propertyName) {
  let property = void 0;
  let propertyDescriptor = getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null) {
    if (propertyDescriptor.get != null) {
      property = propertyDescriptor.get.bind(object)();
    } else {
      property = propertyDescriptor.value;
    }
  }
  return property;
}
function setObjectProperty(valueToSet, object, propertyName) {
  let propertyDescriptor = getObjectPropertyDescriptor(object, propertyName);
  let setUsed = false;
  if (propertyDescriptor != null) {
    if (propertyDescriptor.set != null) {
      setUsed = true;
      propertyDescriptor.set.bind(object)(valueToSet);
    }
  }
  if (!setUsed) {
    let propertyParent = getObjectPropertyOwnParent(object, propertyName);
    if (propertyParent == null) {
      propertyParent = object;
    }
    Object.defineProperty(propertyParent, propertyName, {
      value: valueToSet
    });
  }
}
function getObjectPropertyOwnParent(object, propertyName) {
  let parent = null;
  let parents = getObjectPropertyOwnParents(object, propertyName);
  if (parents.length > 0) {
    parent = parents[0];
  }
  return parent;
}
function getObjectPropertyOwnParents(object, propertyName) {
  let parents = [];
  let possibleParents = getObjectPrototypes(object);
  for (let possibleParent of possibleParents) {
    let propertyNames = Object.getOwnPropertyNames(possibleParent);
    if (propertyNames.pp_hasEqual(propertyName)) {
      parents.push(possibleParent);
    }
  }
  return parents;
}
function getObjectFromPath(path, pathStartObject = window) {
  let object = null;
  let objectName = getObjectNameFromPath(path);
  if (objectName != null) {
    object = getObjectProperty(getObjectParentFromPath(path, pathStartObject), objectName);
  }
  return object;
}
function getObjectNameFromPath(path) {
  let objectName = null;
  if (path != null) {
    let pathSplit = path.split(".");
    if (pathSplit.length > 0) {
      objectName = pathSplit[pathSplit.length - 1];
    }
  }
  return objectName;
}
function getObjectParentFromPath(path, pathStartObject = window) {
  let pathSplit = path.split(".");
  let currentParent = pathStartObject;
  for (let i = 0; i < pathSplit.length - 1; i++) {
    currentParent = getObjectProperty(currentParent, pathSplit[i]);
  }
  return currentParent;
}
function overwriteObjectProperty(newProperty, object, propertyName, overwriteOnOwnParent = true, jsObjectFunctionsSpecialOverwrite = false, debugLogActive = false) {
  let success = false;
  try {
    let propertyOwnParent = getObjectPropertyOwnParent(object, propertyName);
    if (propertyOwnParent != null) {
      let originalPropertyDescriptor = Object.getOwnPropertyDescriptor(propertyOwnParent, propertyName);
      if (originalPropertyDescriptor != null) {
        let originalProperty = getObjectProperty(propertyOwnParent, propertyName);
        copyObjectProperties(originalProperty, newProperty, true, jsObjectFunctionsSpecialOverwrite, debugLogActive);
        let overwriteTarget = object;
        if (overwriteOnOwnParent) {
          overwriteTarget = propertyOwnParent;
        }
        Object.defineProperty(overwriteTarget, propertyName, {
          value: newProperty,
          enumerable: originalPropertyDescriptor.enumerable,
          writable: originalPropertyDescriptor.writable,
          configurable: originalPropertyDescriptor.configurable
        });
        success = true;
      } else {
        Object.defineProperty(object, propertyName, {
          value: newProperty
        });
        success = true;
      }
    } else {
      Object.defineProperty(object, propertyName, {
        value: newProperty
      });
      success = true;
    }
  } catch (error) {
    if (debugLogActive) {
      console.error("Property:", propertyName, "of:", object, "can't be overwritten.");
    }
  }
  return success;
}
function copyObjectProperties(fromObject, toObject, cleanCopy = false, jsObjectFunctionsSpecialCopy = false, debugLogActive = false) {
  if (fromObject != null) {
    if (cleanCopy) {
      cleanObjectProperties(toObject);
    }
    Object.setPrototypeOf(toObject, Object.getPrototypeOf(fromObject));
    let fromObjectPropertyNames = Object.getOwnPropertyNames(fromObject);
    for (let fromObjectPropertyName of fromObjectPropertyNames) {
      try {
        let fromObjectPropertyDescriptor = Object.getOwnPropertyDescriptor(fromObject, fromObjectPropertyName);
        Object.defineProperty(toObject, fromObjectPropertyName, {
          value: fromObjectPropertyDescriptor.value,
          enumerable: fromObjectPropertyDescriptor.enumerable,
          writable: fromObjectPropertyDescriptor.writable,
          configurable: fromObjectPropertyDescriptor.configurable
        });
      } catch (error) {
        if (debugLogActive) {
          console.error("Property:", fromObjectPropertyName, "of:", fromObject.name, "can't be overwritten.");
        }
      }
    }
    if (jsObjectFunctionsSpecialCopy) {
      _jsObjectFunctionsSpecialCopy(fromObject, toObject);
    }
  }
}
function cleanObjectProperties(object) {
  let objectNames = Object.getOwnPropertyNames(object);
  objectNames.pp_pushUnique("__proto__");
  for (let objectName of objectNames) {
    try {
      Object.defineProperty(object, objectName, {
        value: void 0
      });
    } catch (error) {
    }
    try {
      delete object[objectName];
    } catch (error) {
    }
  }
  Object.setPrototypeOf(object, null);
}
function doesObjectPropertyUseAccessors(object, propertyName) {
  let propertyUseAccessors = false;
  let propertyDescriptor = getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null)) {
    propertyUseAccessors = true;
  }
  return propertyUseAccessors;
}
function isFunctionByName(functionParent, functionName) {
  let isFunction = false;
  let functionProperty = getObjectProperty(functionParent, functionName);
  if (functionProperty != null) {
    isFunction = typeof functionProperty == "function" && !isClassByName(functionParent, functionName);
  }
  return isFunction;
}
function isClassByName(classParent, className) {
  let isClass = false;
  let classProperty = getObjectProperty(classParent, className);
  if (classProperty != null) {
    isClass = typeof classProperty == "function" && className != "constructor" && classProperty.prototype != null && typeof classProperty.prototype.constructor == "function" && classProperty.toString != null && typeof classProperty.toString == "function" && /^class/.test(classProperty.toString());
  }
  return isClass;
}
function isObjectByName(objectParent, objectName) {
  let isObject = false;
  let objectProperty = getObjectProperty(objectParent, objectName);
  if (objectProperty != null) {
    isObject = typeof objectProperty == "object";
  }
  return isObject;
}
var JSUtils = {
  getObjectPrototypes,
  getObjectPropertyNames,
  getObjectPropertyDescriptor,
  getObjectProperty,
  setObjectProperty,
  getObjectPropertyOwnParent,
  getObjectPropertyOwnParents,
  getObjectFromPath,
  getObjectNameFromPath,
  getObjectParentFromPath,
  overwriteObjectProperty,
  copyObjectProperties,
  cleanObjectProperties,
  doesObjectPropertyUseAccessors,
  isFunctionByName,
  isClassByName,
  isObjectByName
};
function _jsObjectFunctionsSpecialCopy(fromObject, toObject) {
  try {
    if (typeof toObject == "function" && typeof fromObject == "function") {
      let functionsToOverwrite = ["toString", "toLocaleString", "valueOf"];
      for (let functionToOverwrite of functionsToOverwrite) {
        let propertyDescriptorToOverwrite = getObjectPropertyDescriptor(fromObject, functionToOverwrite);
        if (propertyDescriptorToOverwrite != null && propertyDescriptorToOverwrite.value != null && propertyDescriptorToOverwrite.value == Object[functionToOverwrite]) {
          let valueToReturn = Object[functionToOverwrite].bind(fromObject)();
          let overwrittenFunction = function() {
            return valueToReturn;
          };
          overwriteObjectProperty(overwrittenFunction, toObject, functionToOverwrite, false, false);
        }
      }
    }
  } catch (error) {
  }
}

// js/pp/debug/components/debug_transform_component.js
import { Component as Component22, Property as Property22 } from "@wonderlandengine/api";
var DebugTransformComponent = class extends Component22 {
  start() {
    this._myDebugVisualTransform = null;
    if (isDebugEnabled(this.engine)) {
      this._myDebugTransformParams = new VisualTransformParams(this.engine);
      this._myDebugTransformParams.myLength = this._myLength;
      this._myDebugTransformParams.myThickness = this._myThickness;
      this._myDebugVisualTransform = new VisualTransform(this._myDebugTransformParams);
    }
  }
  update(dt) {
    if (isDebugEnabled(this.engine)) {
      if (this._myDebugVisualTransform != null) {
        this.object.pp_getTransform(this._myDebugTransformParams.myTransform);
        this._myDebugVisualTransform.paramsUpdated();
      }
    }
  }
};
__publicField(DebugTransformComponent, "TypeName", "pp-debug-transform");
__publicField(DebugTransformComponent, "Properties", {
  _myLength: Property22.float(0.1),
  _myThickness: Property22.float(5e-3)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_overwriter.js
var DebugFunctionsOverwriterParams = class {
  constructor() {
    this.myObjectsByReference = [];
    this.myObjectsByPath = [];
    this.myClassesByReference = [];
    this.myClassesByPath = [];
    this.myFunctionsByPath = [];
    this.myExcludeConstructors = false;
    this.myExcludeJSObjectFunctions = false;
    this.myFunctionNamesToInclude = [];
    this.myFunctionNamesToExclude = [];
    this.myFunctionPathsToInclude = [];
    this.myFunctionPathsToExclude = [];
    this.myObjectAddObjectDescendantsDepthLevel = 0;
    this.myObjectAddClassDescendantsDepthLevel = 0;
    this.myObjectNamesToInclude = [];
    this.myObjectNamesToExclude = [];
    this.myClassNamesToInclude = [];
    this.myClassNamesToExclude = [];
    this.myObjectPathsToInclude = [];
    this.myObjectPathsToExclude = [];
    this.myClassPathsToInclude = [];
    this.myClassPathsToExclude = [];
    this.myDebugLogActive = false;
  }
};
var DebugFunctionsOverwriter = class {
  constructor(params = new DebugFunctionsOverwriterParams()) {
    this._myParams = params;
    this._myPropertiesAlreadyOverwritten = /* @__PURE__ */ new Map();
  }
  overwriteFunctions() {
    let classesAndParents = this._getReferencesAndParents(this._myParams.myClassesByReference, this._myParams.myClassesByPath, true);
    let objectsAndParents = this._getReferencesAndParents(this._myParams.myObjectsByReference, this._myParams.myObjectsByPath, false);
    let functionsAndParents = this._getReferencesAndParents([], this._myParams.myFunctionsByPath, false);
    this._objectAddDescendants(objectsAndParents, classesAndParents);
    for (let referenceAndParent of classesAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, true);
    }
    for (let referenceAndParent of objectsAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, false);
    }
    for (let referenceAndParent of functionsAndParents) {
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      this._overwriteFunction(referenceParent, referenceName, null, null, referencePath, false, true);
    }
  }
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass, isFunction) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass, isFunction) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction, isConstructor) {
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction, isConstructor) {
  }
  _overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, isClass) {
    let includePathList = this._myParams.myObjectPathsToInclude;
    let excludePathList = this._myParams.myObjectPathsToExclude;
    let includeNameList = this._myParams.myObjectNamesToInclude;
    let excludeNameList = this._myParams.myObjectNamesToExclude;
    if (isClass) {
      includePathList = this._myParams.myClassPathsToInclude;
      excludePathList = this._myParams.myClassPathsToExclude;
      includeNameList = this._myParams.myClassNamesToInclude;
      excludeNameList = this._myParams.myClassNamesToExclude;
    }
    let isValidReferencePath = this._filterName(referencePath, includePathList, excludePathList);
    let isValidReferenceName = this._filterName(referenceNameForFilter, includeNameList, excludeNameList);
    if (isValidReferencePath && isValidReferenceName) {
      let propertyNames = JSUtils.getObjectPropertyNames(reference);
      if (propertyNames.pp_hasEqual("constructor")) {
        propertyNames.unshift("constructor");
      }
      for (let propertyName of propertyNames) {
        let overwriteTargetReference = null;
        let referenceParentForConstructor = null;
        let referenceNameForConstructor = null;
        if (isClass) {
          let fixedReference = reference;
          if (referenceParent != null) {
            let ownReferenceDescriptor = Object.getOwnPropertyDescriptor(referenceParent, referenceName);
            if (ownReferenceDescriptor != null && ownReferenceDescriptor.value != null) {
              fixedReference = ownReferenceDescriptor.value;
            }
          }
          overwriteTargetReference = fixedReference.prototype;
          if (overwriteTargetReference == null) {
            overwriteTargetReference = fixedReference;
          } else {
            try {
              let referenceProperty = JSUtils.getObjectProperty(overwriteTargetReference, propertyName);
              if (referenceProperty == null) {
                overwriteTargetReference = fixedReference;
              }
            } catch (error) {
              overwriteTargetReference = fixedReference;
            }
          }
          referenceParentForConstructor = referenceParent;
          referenceNameForConstructor = referenceName;
        } else {
          overwriteTargetReference = reference;
        }
        this._overwriteFunction(overwriteTargetReference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, false);
      }
    }
  }
  _overwriteFunction(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction) {
    try {
      let isPropertyCountedAlready = this._myPropertiesAlreadyOverwritten.get(propertyName) != null && this._myPropertiesAlreadyOverwritten.get(propertyName).pp_hasEqual(reference);
      if (!isPropertyCountedAlready) {
        if (JSUtils.isFunctionByName(reference, propertyName)) {
          if (!this._myParams.myExcludeJSObjectFunctions || !this._isJSObjectFunction(propertyName)) {
            let isValidFunctionName = this._filterName(propertyName, this._myParams.myFunctionNamesToInclude, this._myParams.myFunctionNamesToExclude);
            let isValidFunctionPath = this._filterName((referencePath != null ? referencePath + "." : "") + propertyName, this._myParams.myFunctionPathsToInclude, this._myParams.myFunctionPathsToExclude);
            if (isValidFunctionName && isValidFunctionPath) {
              if (!this._myPropertiesAlreadyOverwritten.has(propertyName)) {
                this._myPropertiesAlreadyOverwritten.set(propertyName, []);
              }
              let overwriteSuccess = false;
              let isConstructor = false;
              if (propertyName != "constructor") {
                try {
                  let newFunction = this._getOverwrittenFunction(reference, propertyName, referencePath, isClass, isFunction);
                  if (newFunction != JSUtils.getObjectProperty(reference, propertyName)) {
                    overwriteSuccess = JSUtils.overwriteObjectProperty(newFunction, reference, propertyName, false, true, this._myParams.myDebugLogActive);
                  } else {
                    overwriteSuccess = true;
                  }
                } catch (error) {
                  overwriteSuccess = false;
                  if (this._myParams.myDebugLogActive) {
                    console.error(error);
                  }
                }
              } else if (!this._myParams.myExcludeConstructors && isClass && referenceParentForConstructor != null) {
                let referenceForConstructor = JSUtils.getObjectProperty(referenceParentForConstructor, referenceNameForConstructor);
                if (referenceForConstructor != null && referenceForConstructor.prototype != null) {
                  isConstructor = true;
                  try {
                    let newConstructor = this._getOverwrittenConstructor(referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction);
                    if (newConstructor != referenceForConstructor) {
                      overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceParentForConstructor, referenceNameForConstructor, false, true, this._myParams.myDebugLogActive);
                      if (overwriteSuccess) {
                        overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceForConstructor.prototype, propertyName, false, true, this._myParams.myDebugLogActive);
                      }
                    } else {
                      overwriteSuccess = true;
                    }
                  } catch (error) {
                    overwriteSuccess = false;
                    if (this._myParams.myDebugLogActive) {
                      console.error(error);
                    }
                  }
                }
              }
              if (overwriteSuccess) {
                this._myPropertiesAlreadyOverwritten.get(propertyName).push(reference);
                this._onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction, isConstructor);
              } else {
                this._onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction, isConstructor);
              }
            }
          }
        }
      }
    } catch (error) {
      if (this._myParams.myDebugLogActive) {
        console.error(error);
      }
    }
  }
  _getReferencesAndParents(byReferenceList, byPathList, isClass) {
    let referenceAndParents = [];
    let equalCallback = (first, second) => first[0] == second[0];
    for (let pathPair of byPathList) {
      let path = pathPair;
      let referenceName = "";
      let referencePath = pathPair;
      let referenceNameForFilter = "";
      if (pathPair != null && Array.isArray(pathPair) && pathPair.length != null && pathPair.length == 2 && typeof pathPair[1] == "string") {
        path = pathPair[0];
        referencePath = pathPair[1];
      }
      referenceName = JSUtils.getObjectNameFromPath(path);
      referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      let reference = JSUtils.getObjectFromPath(path);
      let referenceParent = JSUtils.getObjectParentFromPath(path);
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, referenceParent, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    for (let referencePair of byReferenceList) {
      let reference = referencePair;
      let referenceName = "";
      let referencePath = "";
      let referenceNameForFilter = "";
      if (referencePair != null && referencePair.length != null && referencePair.length == 2 && typeof referencePair[1] == "string") {
        reference = referencePair[0];
        referencePath = referencePair[1];
        referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      } else {
        referencePath = isClass ? reference.name : null;
        referenceNameForFilter = isClass ? reference.name : null;
      }
      if (isClass) {
        referenceName = reference.name;
      } else {
        referenceName = JSUtils.getObjectNameFromPath(referencePath);
      }
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, null, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    return referenceAndParents;
  }
  _objectAddDescendants(objectsAndParents, classesAndParents) {
    let equalCallback = (first, second) => first[0] == second[0];
    let objectsToVisit = [];
    for (let objectAndParent of objectsAndParents) {
      objectsToVisit.pp_pushUnique([objectAndParent[0], 0, objectAndParent[3]], equalCallback);
    }
    while (objectsToVisit.length > 0) {
      let objectToVisit = objectsToVisit.shift();
      let object = objectToVisit[0];
      let objectLevel = objectToVisit[1];
      let objectPath = objectToVisit[2];
      if (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1 || objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1) {
        let propertyNames = null;
        try {
          propertyNames = JSUtils.getObjectPropertyNames(object);
        } catch (error) {
          continue;
        }
        for (let propertyName of propertyNames) {
          let objectProperty = null;
          try {
            objectProperty = JSUtils.getObjectProperty(object, propertyName);
            if (objectProperty == null) {
              continue;
            }
          } catch (error) {
            continue;
          }
          let currentPath = "";
          let currentName = "";
          if (objectPath != null) {
            if (objectPath == "_WL._components" && objectProperty._type != null) {
              currentName = "[" + propertyName + ']{"' + objectProperty._type + '"}';
              currentPath = objectPath + currentName;
            } else if (objectPath == "_WL._componentTypes" && objectProperty.TypeName != null) {
              currentName = objectProperty.TypeName;
              currentPath = objectPath + '["' + currentName + '"]';
            } else {
              currentName = propertyName;
              currentPath = objectPath + "." + currentName;
            }
            currentName = propertyName;
            currentPath = objectPath + "." + currentName;
          } else {
            currentName = propertyName;
            currentPath = currentName;
          }
          let isClass = JSUtils.isClassByName(object, propertyName);
          let isObject = JSUtils.isObjectByName(object, propertyName);
          let includePathList = this._myParams.myObjectPathsToInclude;
          let excludePathList = this._myParams.myObjectPathsToExclude;
          let includeNameList = this._myParams.myObjectNamesToInclude;
          let excludeNameList = this._myParams.myObjectNamesToExclude;
          if (isClass) {
            includePathList = this._myParams.myClassPathsToInclude;
            excludePathList = this._myParams.myClassPathsToExclude;
            includeNameList = this._myParams.myClassNamesToInclude;
            excludeNameList = this._myParams.myClassNamesToExclude;
          }
          let isValidReferencePath = this._filterName(currentPath, includePathList, excludePathList);
          let isValidReferenceName = this._filterName(propertyName, includeNameList, excludeNameList);
          if (isValidReferencePath && isValidReferenceName) {
            if (isObject && (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1)) {
              objectsAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isClass && (objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1)) {
              classesAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isObject) {
              objectsToVisit.pp_pushUnique([objectProperty, objectLevel + 1, currentPath], equalCallback);
            }
          }
        }
      }
    }
  }
  _filterName(name, includeList, excludeList) {
    let isValidName = includeList.length == 0;
    for (let includeName of includeList) {
      if (name.match(new RegExp(includeName)) != null) {
        isValidName = true;
        break;
      }
    }
    if (isValidName) {
      for (let excludeName of excludeList) {
        if (name.match(new RegExp(excludeName)) != null) {
          isValidName = false;
          break;
        }
      }
    }
    return isValidName;
  }
  _isJSObjectFunction(propertyName) {
  }
};
DebugFunctionsOverwriter.prototype._isJSObjectFunction = function() {
  let jsObjectFunctions = [
    "__defineGetter__",
    "__defineSetter__",
    "hasOwnProperty",
    "__lookupGetter__",
    "__lookupSetter__",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toString",
    "valueOf",
    "__proto__",
    "toLocaleString",
    "arguments",
    "caller",
    "apply",
    "bind",
    "call",
    "callee"
  ];
  return function _isJSObjectFunction(propertyName) {
    return jsObjectFunctions.pp_hasEqual(propertyName);
  };
}();

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analyzer.js
var DebugFunctionsPerformanceAnalyzerParams = class extends DebugFunctionsOverwriterParams {
  constructor() {
    super();
    this.myExecutionTimeAnalysisEnabled = true;
    this.myAddPathPrefixToFunctionID = true;
    this.myFilterDebugFunctionsPerformanceAnalyzerClasses = true;
  }
};
var DebugFunctionPerformanceAnalysisResults = class {
  constructor() {
    this.myReference = null;
    this.myName = "";
    this.myPath = "";
    this.myID = "";
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  reset() {
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  max(other2) {
    this.myCallsCount = Math.max(this.myCallsCount, other2.myCallsCount);
    this.myTotalExecutionTime = Math.max(this.myTotalExecutionTime, other2.myTotalExecutionTime);
    this.myTotalExecutionTimePercentage = Math.max(this.myTotalExecutionTimePercentage, other2.myTotalExecutionTimePercentage);
    this.myAverageExecutionTime = Math.max(this.myAverageExecutionTime, other2.myAverageExecutionTime);
  }
  copy(other2) {
    this.myReference = other2.myReference;
    this.myName = other2.myName;
    this.myPath = other2.myPath;
    this.myID = other2.myID;
    this.myCallsCount = other2.myCallsCount;
    this.myTotalExecutionTime = other2.myTotalExecutionTime;
    this.myTotalExecutionTimePercentage = other2.myTotalExecutionTimePercentage;
    this.myAverageExecutionTime = other2.myAverageExecutionTime;
    this.myTimeElapsedSinceLastReset = other2.myTimeElapsedSinceLastReset;
    this._myTotalExecutionTimeInternal = other2._myTotalExecutionTimeInternal;
  }
};
var DebugFunctionsPerformanceAnalyzerSortOrder = {
  NONE: 0,
  CALLS_COUNT: 1,
  TOTAL_EXECUTION_TIME: 2,
  AVERAGE_EXECUTION_TIME: 3
};
var DebugFunctionsPerformanceAnalyzer = class extends DebugFunctionsOverwriter {
  constructor(params = new DebugFunctionsPerformanceAnalyzerParams()) {
    super(params);
    this._myFunctionPerformanceAnalysisResults = /* @__PURE__ */ new Map();
    this._myFunctionPerformanceAnalysisMaxResults = /* @__PURE__ */ new Map();
    this._myResultsAlreadyAdded = false;
    this._myExecutionTimes = {
      myOverheadExecutionTimeSinceLastReset: 0,
      myLastFunctionExecutionTime: 0,
      myOriginalFunctionOverheadExecutionTimes: []
    };
    this._myTimeOfLastReset = window.performance.now();
    this._myMaxTimeElapsedSinceLastReset = 0;
    let originalPush = Array.prototype["push"];
    let originalPop = Array.prototype["pop"];
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.push = function() {
      return originalPush.bind(this)(...arguments);
    };
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.pop = function() {
      return originalPop.bind(this)(...arguments);
    };
  }
  overwriteFunctions() {
    super.overwriteFunctions();
    this.resetResults();
    this.resetMaxResults();
  }
  getTimeElapsedSinceLastReset() {
    return window.performance.now() - this._myTimeOfLastReset - this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset;
  }
  getMaxTimeElapsedSinceLastReset() {
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    return this._myMaxTimeElapsedSinceLastReset;
  }
  resetResults() {
    this._updateDerivatesResults();
    this._updateMaxResults();
    for (let property of this._myFunctionPerformanceAnalysisResults.keys()) {
      this._myFunctionPerformanceAnalysisResults.get(property).reset();
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset = 0;
    this._myTimeOfLastReset = window.performance.now();
  }
  resetMaxResults() {
    this._myMaxTimeElapsedSinceLastReset = 0;
    for (let property of this._myFunctionPerformanceAnalysisMaxResults.keys()) {
      this._myFunctionPerformanceAnalysisMaxResults.get(property).reset();
    }
  }
  getResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  getMaxResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisMaxResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass, isFunction) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass, isFunction, false);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass, isFunction) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass, isFunction, true);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction, isConstructor) {
    this._myResultsAlreadyAdded = false;
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass, isFunction, isConstructor) {
    if (this._myResultsAlreadyAdded) {
      let propertyID = this._getPropertyID(propertyName, referencePath, isFunction, isConstructor);
      this._myFunctionPerformanceAnalysisResults.delete(propertyID);
    }
  }
  _sortResults(results, sortOrder) {
    let sortedResults = results;
    if (sortOrder != DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
      sortedResults = new Map([...results.entries()].sort(function(first, second) {
        let sortResult = 0;
        if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT) {
          sortResult = -(first[1].myCallsCount - second[1].myCallsCount);
          if (sortResult == 0) {
            sortResult = -(first[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            }
          }
        } else if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME) {
          sortResult = -(first[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first[1].myCallsCount - second[1].myCallsCount);
            }
          }
        } else {
          sortResult = -(first[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first[1].myCallsCount - second[1].myCallsCount);
            }
          }
        }
        return sortResult;
      }));
    }
    return sortedResults;
  }
  _getPropertyID(propertyName, referencePath, isFunction, isConstructor) {
    let id = isConstructor ? "constructor" : propertyName;
    if (referencePath != null && this._myParams.myAddPathPrefixToFunctionID) {
      if (!isFunction) {
        id = referencePath + "." + id;
      } else {
        id = referencePath;
      }
    }
    return id;
  }
  _updateDerivatesResults() {
    let timeElapsedSinceLastReset = this.getTimeElapsedSinceLastReset();
    let beforeTime = window.performance.now();
    for (let property of this._myFunctionPerformanceAnalysisResults.keys()) {
      let results = this._myFunctionPerformanceAnalysisResults.get(property);
      if (timeElapsedSinceLastReset != 0) {
        results.myTotalExecutionTimePercentage = results.myTotalExecutionTime / timeElapsedSinceLastReset;
      } else {
        if (results.myCallsCount != 0) {
          results.myTotalExecutionTimePercentage = 1;
        } else {
          results.myTotalExecutionTimePercentage = 0;
        }
      }
      if (results.myCallsCount != 0) {
        results.myAverageExecutionTime = results.myTotalExecutionTime / results.myCallsCount;
      } else {
        results.myAverageExecutionTime = 0;
      }
      results.myTimeElapsedSinceLastReset = timeElapsedSinceLastReset;
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now() - beforeTime;
  }
  _updateMaxResults() {
    let beforeTime = window.performance.now();
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    for (let property of this._myFunctionPerformanceAnalysisResults.keys()) {
      if (this._myFunctionPerformanceAnalysisMaxResults.has(property)) {
        this._myFunctionPerformanceAnalysisMaxResults.get(property).max(this._myFunctionPerformanceAnalysisResults.get(property));
      } else {
        let maxResults = new DebugFunctionPerformanceAnalysisResults();
        maxResults.copy(this._myFunctionPerformanceAnalysisResults.get(property));
        this._myFunctionPerformanceAnalysisMaxResults.set(property, maxResults);
      }
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now() - beforeTime;
  }
  _getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass, isFunction, isConstructor) {
    let newFunction = JSUtils.getObjectProperty(reference, propertyName);
    if (!this._myParams.myFilterDebugFunctionsPerformanceAnalyzerClasses || !this._isPerformanceAnalyzer(reference, propertyName, isClass)) {
      if (propertyName != "_myPerformanceAnalyzerOriginalFunction") {
        let propertyID = this._getPropertyID(propertyName, referencePath, isFunction, isConstructor);
        this._myResultsAlreadyAdded = this._myFunctionPerformanceAnalysisResults.has(propertyID);
        let analysisResults = new DebugFunctionPerformanceAnalysisResults();
        analysisResults.myReference = reference;
        analysisResults.myName = propertyName;
        analysisResults.myPath = referencePath;
        analysisResults.myID = referencePath;
        this._myFunctionPerformanceAnalysisResults.set(propertyID, analysisResults);
        try {
          let functionPerformanceAnalysisResults = this._myFunctionPerformanceAnalysisResults.get(propertyID);
          let executionTimes = this._myExecutionTimes;
          let originalFunction = reference[propertyName];
          let functionCallOverhead = 175e-6;
          let overheadError = 35e-5;
          let executionTimeAnalysisEnabled = this._myParams.myExecutionTimeAnalysisEnabled;
          if (!isConstructor) {
            newFunction = function() {
              let startTime = window.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let bindFunction = null;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window.performance.now();
                endOriginalFunctionTime = window.performance.now();
                try {
                  bindFunction = originalFunction.bind(this);
                  startOriginalFunctionTime = window.performance.now();
                  returnValue = bindFunction(...arguments);
                  endOriginalFunctionTime = window.performance.now();
                } catch (error) {
                  endOriginalFunctionTime = window.performance.now();
                  errorToThrow = error;
                }
              } else {
                try {
                  bindFunction = originalFunction.bind(this);
                  returnValue = bindFunction(...arguments);
                } catch (error) {
                  errorToThrow = error;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          } else {
            newFunction = function() {
              let startTime = window.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let bindFunction = null;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window.performance.now();
                endOriginalFunctionTime = window.performance.now();
                try {
                  startOriginalFunctionTime = window.performance.now();
                  returnValue = new originalFunction(...arguments);
                  endOriginalFunctionTime = window.performance.now();
                } catch (error) {
                  endOriginalFunctionTime = window.performance.now();
                  errorToThrow = error;
                }
              } else {
                try {
                  returnValue = new originalFunction(...arguments);
                } catch (error) {
                  errorToThrow = error;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          }
          if (newFunction != null) {
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerHasBeenOverwritten", {
              value: true,
              enumerable: false,
              configurable: false,
              writable: false
            });
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerOriginalFunction", {
              value: originalFunction,
              enumerable: false,
              configurable: false,
              writable: false
            });
          }
        } catch (error) {
          if (this._myParams.myDebugLogActive) {
            console.error("Function:", propertyName, "of:", reference, "can't be overwritten.\nError:", error);
          }
        }
      }
    }
    return newFunction;
  }
  _isPerformanceAnalyzer(reference, propertyName, isClass) {
    let isPerformanceAnalyzer = false;
    if (isClass) {
      if (reference == DebugFunctionsPerformanceAnalyzer.prototype || reference == DebugFunctionPerformanceAnalysisResults.prototype) {
        isPerformanceAnalyzer = true;
      }
    }
    return isPerformanceAnalyzer;
  }
};

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analysis_results_logger.js
var DebugFunctionsPerformanceAnalysisResultsLoggerParams = class {
  constructor() {
    this.myPerformanceAnalyzer = null;
    this.myLogTitle = "Functions Performance Analysis Results";
    this.mySecondsBetweenLogs = 1;
    this.myLogFunction = "log";
    this.myFormatLog = true;
    this.myFormatLogIndentationCharacter = "-";
    this.myLogMaxResults = false;
    this.myLogSortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE;
    this.myLogMaxAmountOfFunctions = null;
    this.myLogFunctionsWithCallsCountAbove = null;
    this.myLogFunctionsWithTotalExecutionTimePercentageAbove = null;
    this.myLogCallsCountResults = false;
    this.myLogTotalExecutionTimeResults = false;
    this.myLogTotalExecutionTimePercentageResults = false;
    this.myLogAverageExecutionTimeResults = false;
    this.myClearConsoleBeforeLog = false;
  }
};
var DebugFunctionsPerformanceAnalysisResultsLogger = class {
  constructor(params) {
    this._myParams = params;
    this._myLogTimer = new Timer(this._myParams.mySecondsBetweenLogs);
    this._myMaxNameLength = 0;
    this._myMaxCallsCountLength = 0;
    this._myMaxTotalExecutionTimeLength = 0;
    this._myMaxTotalExecutionTimePercentageLength = 0;
    this._myMaxAverageExecutionTimeLength = 0;
  }
  update(dt) {
    if (this._myParams.myPerformanceAnalyzer == null) {
      return;
    }
    this._myLogTimer.update(dt);
    if (this._myLogTimer.isDone()) {
      this._myLogTimer.start();
      let timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getTimeElapsedSinceLastReset();
      if (this._myParams.myLogMaxResults) {
        timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getMaxTimeElapsedSinceLastReset();
      }
      let analysisResults = null;
      if (!this._myParams.myLogMaxResults) {
        analysisResults = this._myParams.myPerformanceAnalyzer.getResults(this._myParams.myLogSortOrder);
      } else {
        analysisResults = this._myParams.myPerformanceAnalyzer.getMaxResults(this._myParams.myLogSortOrder);
      }
      if (this._myParams.myLogFunctionsWithCallsCountAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myCallsCount > this._myParams.myLogFunctionsWithCallsCountAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myTotalExecutionTimePercentage * 100 > this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogMaxAmountOfFunctions != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < this._myParams.myLogMaxAmountOfFunctions && i < keys.length; i++) {
          let counter = analysisResultsClone.get(keys[i]);
          analysisResults.set(keys[i], counter);
        }
      }
      if (this._myParams.myClearConsoleBeforeLog) {
        console.clear();
      }
      let analysisResultsToLog = /* @__PURE__ */ new Map();
      for (let key of analysisResults.keys()) {
        let currentResults = analysisResults.get(key);
        let resultsToLog = {};
        if (this._myParams.myLogCallsCountResults) {
          resultsToLog.myCallsCount = currentResults.myCallsCount;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          resultsToLog.myTotalExecutionTime = currentResults.myTotalExecutionTime;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          resultsToLog.myTotalExecutionTimePercentage = currentResults.myTotalExecutionTimePercentage;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          resultsToLog.myAverageExecutionTime = currentResults.myAverageExecutionTime;
        }
        analysisResultsToLog.set(key, resultsToLog);
      }
      let resultsText = "";
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        this._myMaxNameLength = Math.max(this._myMaxNameLength, name.length);
        this._myMaxCallsCountLength = Math.max(this._myMaxCallsCountLength, results.myCallsCount.toFixed(0).length);
        this._myMaxTotalExecutionTimeLength = Math.max(this._myMaxTotalExecutionTimeLength, results.myTotalExecutionTime.toFixed(5).length);
        this._myMaxTotalExecutionTimePercentageLength = Math.max(this._myMaxTotalExecutionTimePercentageLength, (results.myTotalExecutionTimePercentage * 100).toFixed(2).length);
        this._myMaxAverageExecutionTimeLength = Math.max(this._myMaxAverageExecutionTimeLength, results.myAverageExecutionTime.toFixed(5).length);
      }
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        let parametersToLog = 0;
        if (this._myParams.myLogCallsCountResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          parametersToLog++;
        }
        let textOrdered = [];
        let callsCountText = parametersToLog > 1 ? "Calls Count: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxCallsCountLength - results.myCallsCount.toFixed(0).length; i++) {
            callsCountText += " ";
          }
        }
        callsCountText += results.myCallsCount.toFixed(0);
        let totalExecutionTimeText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimeLength - results.myTotalExecutionTime.toFixed(5).length; i++) {
            totalExecutionTimeText += " ";
          }
        }
        totalExecutionTimeText += results.myTotalExecutionTime.toFixed(5) + "ms";
        let totalExecutionTimePercentageText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimePercentageLength - (results.myTotalExecutionTimePercentage * 100).toFixed(2).length; i++) {
            totalExecutionTimePercentageText += " ";
          }
        }
        totalExecutionTimePercentageText += (results.myTotalExecutionTimePercentage * 100).toFixed(2) + "%";
        let averageExecutionTimeText = parametersToLog > 1 ? "Average Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxAverageExecutionTimeLength - results.myAverageExecutionTime.toFixed(5).length; i++) {
            averageExecutionTimeText += " ";
          }
        }
        averageExecutionTimeText += results.myAverageExecutionTime.toFixed(5) + "ms";
        if (!this._myParams.myLogCallsCountResults) {
          callsCountText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimeResults) {
          totalExecutionTimeText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimePercentageResults) {
          totalExecutionTimePercentageText = null;
        }
        if (!this._myParams.myLogAverageExecutionTimeResults) {
          averageExecutionTimeText = null;
        }
        switch (this._myParams.myLogSortOrder) {
          case DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME:
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(callsCountText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.AVERAGE_EXECUTION_TIME:
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(callsCountText);
            break;
          default:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
        }
        resultsText += "\n";
        if (this._myParams.myFormatLog) {
          let nameIndented = name + " ";
          while (nameIndented.length < this._myMaxNameLength + 1) {
            nameIndented += this._myParams.myFormatLogIndentationCharacter;
          }
          nameIndented += this._myParams.myFormatLogIndentationCharacter + " ";
          resultsText += nameIndented;
        } else {
          resultsText += name + " - ";
        }
        let avoidFirst = true;
        for (let text of textOrdered) {
          if (text != null) {
            if (avoidFirst) {
              avoidFirst = false;
            } else {
              resultsText += " - ";
            }
            resultsText += text;
          }
        }
      }
      if (this._myParams.myLogTotalExecutionTimeResults || this._myParams.myLogTotalExecutionTimePercentageResults || this._myParams.myLogAverageExecutionTimeResults) {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n\nTotal Time:", timeSinceLastReset.toFixed(5), "ms\n", resultsText);
      } else {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n", resultsText);
      }
    }
  }
};

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_functions_performance_analyzer_component.js
import { Component as Component23, Property as Property23 } from "@wonderlandengine/api";
var DebugFunctionsPerformanceAnalyzerComponent = class extends Component23 {
  init() {
    this._myActive = false;
    if (isDebugEnabled(this.engine)) {
      this._myActive = true;
      this._myFunctionsPerformanceAnalyzer = null;
      this._myFunctionsPerformanceAnalysisResultsLogger = null;
      this._mySkipFirstUpdate = true;
      this._myStartTimer = new Timer(this._myDelayStart);
      if (this._myDelayStart == 0) {
        this._myStartTimer.end();
        this._mySkipFirstUpdate = false;
        this._start();
      }
    }
  }
  update(dt) {
    if (this._myActive) {
      if (this._mySkipFirstUpdate) {
        this._mySkipFirstUpdate = false;
        return;
      }
      if (this._myStartTimer.isRunning()) {
        this._myStartTimer.update(dt);
        if (this._myStartTimer.isDone()) {
          this._start();
        }
      } else {
        this._myFunctionsPerformanceAnalysisResultsLogger.update(dt);
        this._myFunctionsPerformanceAnalyzer.resetResults();
      }
      if (this._myResetMaxResultsShortcutEnabled) {
        if (getLeftGamepad(this.engine).getButtonInfo(GamepadButtonID.SELECT).isPressEnd(3)) {
          this._myFunctionsPerformanceAnalyzer.resetMaxResults();
        }
      }
    }
  }
  _start() {
    let functionsPerformanceAnalyzerParams = new DebugFunctionsPerformanceAnalyzerParams();
    if (this._myObjectsByPath.length > 0) {
      let toIncludeList = [...this._myObjectsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myObjectsByPath.push(...toIncludeList);
    }
    if (this._myClassesByPath.length > 0) {
      let toIncludeList = [...this._myClassesByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myClassesByPath.push(...toIncludeList);
    }
    if (this._myFunctionsByPath.length > 0) {
      let toIncludeList = [...this._myFunctionsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionsByPath.push(...toIncludeList);
    }
    functionsPerformanceAnalyzerParams.myExcludeConstructors = this._myExcludeConstructors;
    functionsPerformanceAnalyzerParams.myExcludeJSObjectFunctions = this._myExcludeJSObjectFunctions;
    functionsPerformanceAnalyzerParams.myAddPathPrefixToFunctionID = this._myAddPathPrefixToFunctionID;
    if (this._myFunctionPathsToInclude.length > 0) {
      let toIncludeList = [...this._myFunctionPathsToInclude.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToInclude.push(...toIncludeList);
    }
    if (this._myFunctionPathsToExclude.length > 0) {
      let toExcludeList = [...this._myFunctionPathsToExclude.split(",")];
      for (let i = 0; i < toExcludeList.length; i++) {
        toExcludeList[i] = toExcludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToExclude.push(...toExcludeList);
    }
    functionsPerformanceAnalyzerParams.myObjectAddObjectDescendantsDepthLevel = this._myObjectAddObjectDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myObjectAddClassDescendantsDepthLevel = this._myObjectAddClassDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myExecutionTimeAnalysisEnabled = this._myLogTotalExecutionTimeResults || this._myLogTotalExecutionTimePercentageResults || this._myLogAverageExecutionTimeResults;
    functionsPerformanceAnalyzerParams.myClassesByReference = this._myClassesByReference != 0 ? this._myClassesByReference : [];
    functionsPerformanceAnalyzerParams.myObjectsByReference = this._myObjectsByReference != 0 ? this._myObjectsByReference : [];
    this._myFunctionsPerformanceAnalyzer = new DebugFunctionsPerformanceAnalyzer(functionsPerformanceAnalyzerParams);
    this._myFunctionsPerformanceAnalyzer.overwriteFunctions();
    let functionsPerformanceAnalysisResultsLoggerParams = new DebugFunctionsPerformanceAnalysisResultsLoggerParams();
    functionsPerformanceAnalysisResultsLoggerParams.myPerformanceAnalyzer = this._myFunctionsPerformanceAnalyzer;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTitle = this._myLogTitle;
    functionsPerformanceAnalysisResultsLoggerParams.mySecondsBetweenLogs = this._mySecondsBetweenLogs;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunction = ["log", "error", "warn", "debug"][this._myLogFunction];
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxAmountOfFunctions = this._myLogMaxAmountOfFunctions >= 0 ? this._myLogMaxAmountOfFunctions : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithCallsCountAbove = this._myLogFunctionsWithCallsCountAbove >= 0 ? this._myLogFunctionsWithCallsCountAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithTotalExecutionTimePercentageAbove = this._myLogFunctionsWithTotalExecutionTimePercentageAbove >= 0 ? this._myLogFunctionsWithTotalExecutionTimePercentageAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxResults = this._myLogMaxResults;
    functionsPerformanceAnalysisResultsLoggerParams.myClearConsoleBeforeLog = this._myClearConsoleBeforeLog;
    functionsPerformanceAnalysisResultsLoggerParams.myLogSortOrder = this._myLogSortOrder;
    functionsPerformanceAnalysisResultsLoggerParams.myLogCallsCountResults = this._myLogCallsCountResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimeResults = this._myLogTotalExecutionTimeResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimePercentageResults = this._myLogTotalExecutionTimePercentageResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogAverageExecutionTimeResults = this._myLogAverageExecutionTimeResults;
    this._myFunctionsPerformanceAnalysisResultsLogger = new DebugFunctionsPerformanceAnalysisResultsLogger(functionsPerformanceAnalysisResultsLoggerParams);
  }
};
__publicField(DebugFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-functions-performance-analyzer");
__publicField(DebugFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myObjectsByPath: Property23.string(""),
  _myClassesByPath: Property23.string(""),
  _myFunctionsByPath: Property23.string(""),
  _myDelayStart: Property23.float(0),
  _myLogTitle: Property23.string("Functions Performance Analysis Results"),
  _myLogFunction: Property23.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property23.float(1),
  _myLogMaxResults: Property23.bool(false),
  _myLogSortOrder: Property23.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property23.bool(true),
  _myLogTotalExecutionTimeResults: Property23.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property23.bool(true),
  _myLogAverageExecutionTimeResults: Property23.bool(true),
  _myLogMaxAmountOfFunctions: Property23.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property23.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property23.float(-1),
  _myFunctionPathsToInclude: Property23.string(""),
  _myFunctionPathsToExclude: Property23.string(""),
  _myExcludeConstructors: Property23.bool(false),
  _myExcludeJSObjectFunctions: Property23.bool(true),
  _myAddPathPrefixToFunctionID: Property23.bool(true),
  _myObjectAddObjectDescendantsDepthLevel: Property23.int(0),
  _myObjectAddClassDescendantsDepthLevel: Property23.int(0),
  _myClearConsoleBeforeLog: Property23.bool(false),
  _myResetMaxResultsShortcutEnabled: Property23.bool(false),
  _myClassesByReference: Property23.enum(["Code Driven"], "Code Driven"),
  _myObjectsByReference: Property23.enum(["Code Driven"], "Code Driven")
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_functions_performance_analyzer_component.js
import { Component as Component24, Property as Property24 } from "@wonderlandengine/api";
var DebugPPFunctionsPerformanceAnalyzerComponent = class extends Component24 {
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "PP",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugPPFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-pp-functions-performance-analyzer");
__publicField(DebugPPFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myDelayStart: Property24.float(0),
  _myLogFunction: Property24.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property24.float(1),
  _myLogMaxResults: Property24.bool(false),
  _myLogSortOrder: Property24.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property24.bool(true),
  _myLogTotalExecutionTimeResults: Property24.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property24.bool(true),
  _myLogAverageExecutionTimeResults: Property24.bool(true),
  _myLogMaxAmountOfFunctions: Property24.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property24.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property24.float(-1),
  _myFunctionPathsToInclude: Property24.string(""),
  _myFunctionPathsToExclude: Property24.string(""),
  _myExcludeConstructors: Property24.bool(false),
  _myClearConsoleBeforeLog: Property24.bool(false),
  _myResetMaxResultsShortcutEnabled: Property24.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_array_functions_performance_analyzer_component.js
import { Component as Component25, Property as Property25 } from "@wonderlandengine/api";
var DebugArrayFunctionsPerformanceAnalyzerComponent = class extends Component25 {
  init() {
    let classesByPath = "Array, Uint8ClampedArray, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array";
    if (this._myIncludeOnlyMainArrayTypes) {
      classesByPath = "Array, Uint8Array, Uint16Array, Float32Array";
    }
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myClassesByPath: classesByPath,
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "Array Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude + (this._myFunctionPathsToInclude.length > 0 && this._myIncludeOnlyArrayExtensionFunctions ? ", " : "") + (this._myIncludeOnlyArrayExtensionFunctions ? "pp_, vec_, vec2_, vec3_, vec4_, quat_, quat2_, mat3_, mat4_, _pp_, _vec_, _quat_" : ""),
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugArrayFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-array-functions-performance-analyzer");
__publicField(DebugArrayFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myIncludeOnlyMainArrayTypes: Property25.bool(true),
  _myIncludeOnlyArrayExtensionFunctions: Property25.bool(false),
  _myDelayStart: Property25.float(0),
  _myLogFunction: Property25.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property25.float(1),
  _myLogMaxResults: Property25.bool(false),
  _myLogSortOrder: Property25.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property25.bool(true),
  _myLogTotalExecutionTimeResults: Property25.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property25.bool(true),
  _myLogAverageExecutionTimeResults: Property25.bool(true),
  _myLogMaxAmountOfFunctions: Property25.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property25.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property25.float(-1),
  _myFunctionPathsToInclude: Property25.string(""),
  _myFunctionPathsToExclude: Property25.string(""),
  _myExcludeConstructors: Property25.bool(false),
  _myClearConsoleBeforeLog: Property25.bool(false),
  _myResetMaxResultsShortcutEnabled: Property25.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_array_creation_performance_analyzer_component.js
import { Component as Component26, Property as Property26 } from "@wonderlandengine/api";
var DebugPPArrayCreationPerformanceAnalyzerComponent = class extends Component26 {
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "PP",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Array Creation Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: "vec2_create, vec3_create, vec4_create, quat_create, quat2_create, mat3_create, mat4_create",
      _myExcludeConstructors: true,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugPPArrayCreationPerformanceAnalyzerComponent, "TypeName", "pp-debug-pp-array-creation-performance-analyzer");
__publicField(DebugPPArrayCreationPerformanceAnalyzerComponent, "Properties", {
  _myDelayStart: Property26.float(0),
  _myLogFunction: Property26.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property26.float(1),
  _myLogMaxResults: Property26.bool(false),
  _myLogSortOrder: Property26.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property26.bool(true),
  _myLogTotalExecutionTimeResults: Property26.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property26.bool(true),
  _myLogAverageExecutionTimeResults: Property26.bool(true),
  _myLogMaxAmountOfFunctions: Property26.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property26.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property26.float(-1),
  _myClearConsoleBeforeLog: Property26.bool(false),
  _myResetMaxResultsShortcutEnabled: Property26.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_function_performance_analyzer_component.js
import { Component as Component27, Property as Property27 } from "@wonderlandengine/api";
var DebugWLFunctionsPerformanceAnalyzerComponent = class extends Component27 {
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "WL",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "WL Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugWLFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-wl-functions-performance-analyzer");
__publicField(DebugWLFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myDelayStart: Property27.float(0),
  _myLogFunction: Property27.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property27.float(1),
  _myLogMaxResults: Property27.bool(false),
  _myLogSortOrder: Property27.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property27.bool(true),
  _myLogTotalExecutionTimeResults: Property27.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property27.bool(true),
  _myLogAverageExecutionTimeResults: Property27.bool(true),
  _myLogMaxAmountOfFunctions: Property27.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property27.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property27.float(-1),
  _myFunctionPathsToInclude: Property27.string(""),
  _myFunctionPathsToExclude: Property27.string(""),
  _myExcludeConstructors: Property27.bool(false),
  _myClearConsoleBeforeLog: Property27.bool(false),
  _myResetMaxResultsShortcutEnabled: Property27.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_components_function_performance_analyzer_component.js
import { AnimationComponent, CollisionComponent as CollisionComponent2, Component as Component28, InputComponent as InputComponent2, LightComponent, MeshComponent as MeshComponent9, TextComponent as TextComponent6, Property as Property28, ViewComponent as ViewComponent3 } from "@wonderlandengine/api";
var DebugWLComponentsFunctionsPerformanceAnalyzerComponent = class extends Component28 {
  init() {
    this._myStartTimer = new Timer(this._myDelayStart);
    if (this._myDelayStart == 0) {
      this._myStartTimer.end();
      this._start();
    }
  }
  update(dt) {
    if (this._myStartTimer.isRunning()) {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._start();
      }
    }
  }
  _start() {
    let objectsByReference = [];
    if (this._myAnalyzeComponentInstances) {
      this._addComponentInstanceReferences(objectsByReference);
    }
    if (this._myAnalyzeComponentTypes) {
      this._addComponentTypeReferences(objectsByReference);
    }
    this._myAnalyzerComponent = this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: objectsByReference,
      _myDelayStart: 0,
      _myLogTitle: "WL Components Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddClassDescendantsDepthLevel: 0,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
  _addComponentTypeReferences(objectsByReference) {
    let nativeComponentTypes = [
      MeshComponent9,
      AnimationComponent,
      CollisionComponent2,
      InputComponent2,
      LightComponent,
      TextComponent6,
      ViewComponent3
    ];
    for (let nativeComponentType of nativeComponentTypes) {
      objectsByReference.push([
        Object.getPrototypeOf(this.engine._wrapComponent(nativeComponentType.TypeName, this.engine.wasm._typeIndexFor(nativeComponentType.TypeName), 0)),
        '{"' + nativeComponentType.TypeName + '"}'
      ]);
    }
    for (let componentType of this.engine.wasm._componentTypes) {
      objectsByReference.push([
        componentType.prototype,
        '{"' + componentType.TypeName + '"}'
      ]);
    }
  }
  _addComponentInstanceReferences(objectsByReference) {
    for (let component of this.engine.wasm._components) {
      let id = "";
      switch (this._myComponentInstanceID) {
        case 0:
          id = component.object.pp_getID();
          break;
        case 1:
          id = component.object.pp_getName();
          break;
        case 2:
          id = component.object.pp_getID();
          if (component.object.pp_getName().length > 0) {
            id = id + " - " + component.object.pp_getName();
          }
          break;
      }
      objectsByReference.push([
        component,
        '{"' + component.type + '"}[' + id + "]"
      ]);
    }
  }
};
__publicField(DebugWLComponentsFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-wl-components-functions-performance-analyzer");
__publicField(DebugWLComponentsFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myAnalyzeComponentTypes: Property28.bool(true),
  _myAnalyzeComponentInstances: Property28.bool(false),
  _myComponentInstanceID: Property28.enum(["Object ID", "Object Name", "Object ID - Object Name"], "Object ID - Object Name"),
  _myDelayStart: Property28.float(0),
  _myLogFunction: Property28.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property28.float(1),
  _myLogMaxResults: Property28.bool(false),
  _myLogSortOrder: Property28.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property28.bool(true),
  _myLogTotalExecutionTimeResults: Property28.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property28.bool(true),
  _myLogAverageExecutionTimeResults: Property28.bool(true),
  _myLogMaxAmountOfFunctions: Property28.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property28.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property28.float(-1),
  _myFunctionPathsToInclude: Property28.string(""),
  _myFunctionPathsToExclude: Property28.string(""),
  _myExcludeConstructors: Property28.bool(false),
  _myClearConsoleBeforeLog: Property28.bool(false),
  _myResetMaxResultsShortcutEnabled: Property28.bool(false)
});

// js/pp/gameplay/cauldron/cauldron/direction_2D_to_3D_converter.js
var Direction2DTo3DConverterParams = class {
  constructor() {
    this.myStartFlyingForward = false;
    this.myStartFlyingRight = false;
    this.myAutoUpdateFlyForward = false;
    this.myAutoUpdateFlyRight = false;
    this.myResetFlyForwardWhenZero = false;
    this.myResetFlyRightWhenZero = false;
    this.myMinAngleToFlyForwardUp = 90;
    this.myMinAngleToFlyForwardDown = 90;
    this.myMinAngleToFlyRightUp = 90;
    this.myMinAngleToFlyRightDown = 90;
  }
};
var Direction2DTo3DConverter = class {
  constructor(params = new Direction2DTo3DConverterParams()) {
    this._myParams = params;
    this._myIsFlyingForward = this._myParams.myStartFlyingForward;
    this._myIsFlyingRight = this._myParams.myStartFlyingRight;
    this._myLastValidFlatForward = vec3_create2();
    this._myLastValidFlatRight = vec3_create2();
    this._myMinAngleToBeValid = 5;
  }
  convert(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create2()) {
    return this.convertTransform(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  isFlying() {
    return this._myIsFlyingForward || this._myIsFlyingRight;
  }
  isFlyingForward() {
    return this._myIsFlyingForward;
  }
  isFlyingRight() {
    return this._myIsFlyingRight;
  }
  startFlying() {
    this._myIsFlyingForward = true;
    this._myIsFlyingRight = true;
  }
  startFlyingForward() {
    this._myIsFlyingForward = true;
  }
  startFlyingRight() {
    this._myIsFlyingRight = true;
  }
  stopFlying() {
    this._myIsFlyingForward = false;
    this._myIsFlyingRight = false;
  }
  stopFlyingForward() {
    this._myIsFlyingForward = false;
  }
  stopFlyingRight() {
    this._myIsFlyingRight = false;
  }
  resetFly() {
    this.resetFlyForward();
    this.resetFlyRight();
  }
  resetFlyForward() {
    if (this._myParams.myStartFlyingForward) {
      this.startFlyingForward();
    } else {
      this.stopFlyingForward();
    }
    this._myLastValidFlatForward.vec3_zero();
  }
  resetFlyRight() {
    if (this._myParams.myStartFlyingRight) {
      this.startFlyingRight();
    } else {
      this.stopFlyingRight();
    }
    this._myLastValidFlatRight.vec3_zero();
  }
  convertForward(direction2D, forward, direction3DUp = null, outDirection3D = vec3_create2()) {
  }
  convertTransform(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create2()) {
    return this.convertTransformMatrix(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create2()) {
  }
  convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create2()) {
  }
  convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create2()) {
  }
};
Direction2DTo3DConverter.prototype.convertForward = function() {
  let rotationQuat = quat_create();
  return function convertForward(direction2D, forward, direction3DUp = null, outDirection3D = vec3_create2()) {
    rotationQuat.quat_identity();
    rotationQuat.quat_setForward(forward, direction3DUp);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformMatrix = function() {
  let rotationQuat = quat_create();
  return function convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create2()) {
    rotationQuat = conversionTransformMatrix.mat4_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformQuat = function() {
  let rotationQuat = quat_create();
  return function convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create2()) {
    rotationQuat = conversionTransformQuat.quat2_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertRotationQuat = function() {
  let forward = vec3_create2();
  let right = vec3_create2();
  let direction3DUpNegate = vec3_create2();
  let forwardScaled = vec3_create2();
  let rightScaled = vec3_create2();
  return function convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create2()) {
    if (direction2D.vec2_isZero()) {
      let resetFlyForward = this._myParams.myAutoUpdateFlyForward && this._myParams.myResetFlyForwardWhenZero;
      if (resetFlyForward) {
        this.resetFlyForward();
      }
      let resetFlyRight = this._myParams.myAutoUpdateFlyRight && this._myParams.myResetFlyRightWhenZero;
      if (resetFlyRight) {
        this.resetFlyRight();
      }
      outDirection3D.vec3_zero();
      return outDirection3D;
    } else {
      if (direction2D[0] == 0) {
        this._myLastValidFlatRight.vec3_zero();
      }
      if (direction2D[1] == 0) {
        this._myLastValidFlatForward.vec3_zero();
      }
    }
    forward = conversionRotationQuat.quat_getForward(forward);
    right = conversionRotationQuat.quat_getRight(right);
    if (direction3DUp != null) {
      direction3DUpNegate = direction3DUp.vec3_negate(direction3DUpNegate);
      if (this._myParams.myAutoUpdateFlyForward) {
        let angleForwardWithDirectionUp = forward.vec3_angle(direction3DUp);
        this._myIsFlyingForward = this._myIsFlyingForward || (angleForwardWithDirectionUp < 90 - this._myParams.myMinAngleToFlyForwardUp || angleForwardWithDirectionUp > 90 + this._myParams.myMinAngleToFlyForwardDown);
      }
      if (this._myParams.myAutoUpdateFlyRight) {
        let angleRightWithDirectionUp = right.vec3_angle(direction3DUp);
        this._myIsFlyingRight = this._myIsFlyingRight || (angleRightWithDirectionUp < 90 - this._myParams.myMinAngleToFlyRightUp || angleRightWithDirectionUp > 90 + this._myParams.myMinAngleToFlyRightDown);
      }
      if (!this._myIsFlyingForward) {
        if (!this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON) && (forward.vec3_angle(direction3DUp) < this._myMinAngleToBeValid || forward.vec3_angle(direction3DUpNegate) < this._myMinAngleToBeValid)) {
          if (forward.vec3_isConcordant(this._myLastValidFlatForward)) {
            forward.pp_copy(this._myLastValidFlatForward);
          } else {
            forward = this._myLastValidFlatForward.vec3_negate(forward);
          }
        }
        forward = forward.vec3_removeComponentAlongAxis(direction3DUp, forward);
        forward.vec3_normalize(forward);
      }
      if (!this._myIsFlyingRight) {
        if (!this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON) && (right.vec3_angle(direction3DUp) < this._myMinAngleToBeValid || right.vec3_angle(direction3DUpNegate) < this._myMinAngleToBeValid)) {
          if (right.vec3_isConcordant(this._myLastValidFlatRight)) {
            right.pp_copy(this._myLastValidFlatRight);
          } else {
            right = this._myLastValidFlatRight.vec3_negate(right);
          }
        }
        right = right.vec3_removeComponentAlongAxis(direction3DUp, right);
        right.vec3_normalize(right);
      }
      if (forward.vec3_angle(direction3DUp) > this._myMinAngleToBeValid && forward.vec3_angle(direction3DUpNegate) > this._myMinAngleToBeValid || direction2D[1] != 0 && this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
        this._myLastValidFlatForward = forward.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatForward);
        this._myLastValidFlatForward.vec3_normalize(this._myLastValidFlatForward);
      }
      if (right.vec3_angle(direction3DUp) > this._myMinAngleToBeValid && right.vec3_angle(direction3DUpNegate) > this._myMinAngleToBeValid || direction2D[0] != 0 && this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
        this._myLastValidFlatRight = right.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatRight);
        this._myLastValidFlatRight.vec3_normalize(this._myLastValidFlatRight);
      }
    }
    outDirection3D = right.vec3_scale(direction2D[0], rightScaled).vec3_add(forward.vec3_scale(direction2D[1], forwardScaled), outDirection3D);
    if (direction3DUp != null && !this._myIsFlyingForward && !this._myIsFlyingRight) {
      outDirection3D = outDirection3D.vec3_removeComponentAlongAxis(direction3DUp, outDirection3D);
    }
    outDirection3D.vec3_normalize(outDirection3D);
    return outDirection3D;
  };
}();

// js/pp/gameplay/cauldron/cauldron/number_over_value.js
var NumberOverValue = class {
  constructor(startNumber, endNumber = null, startInterpolationValue = 0, endInterpolationValue = 0, easingFunction = EasingFunction2.linear, roundingFunction = null) {
    if (endNumber == null) {
      endNumber = startNumber;
    }
    this._myStartNumber = startNumber;
    this._myEndNumber = endNumber;
    this._myStartInterpolationValue = startInterpolationValue;
    this._myEndInterpolationValue = endInterpolationValue;
    this._myEasingFunction = easingFunction;
    this._myRoundingFunction = roundingFunction;
  }
  get(interpolationValue) {
    let lerpInterpolationValue = this._myEasingFunction(Math.pp_mapToRange(interpolationValue, this._myStartInterpolationValue, this._myEndInterpolationValue, 0, 1));
    let lerpNumber = Math.pp_lerp(this._myStartNumber, this._myEndNumber, lerpInterpolationValue);
    if (this._myRoundingFunction) {
      lerpNumber = this._myRoundingFunction(lerpNumber, this._myStartNumber, this._myEndNumber);
    }
    return lerpNumber;
  }
  getAverage(interpolationValue) {
    return this.get(interpolationValue);
  }
  getRange(interpolationValue) {
    let number = this.get(interpolationValue);
    return [number, number];
  }
  getMax(interpolationValue) {
    return this.get(interpolationValue);
  }
  getMin(interpolationValue) {
    return this.get(interpolationValue);
  }
  isInside(number, interpolationValue) {
    let currentNumber = this.get(interpolationValue);
    return currentNumber == number;
  }
  isInsideAngleRange(number, interpolationValue) {
    return this.isInsideAngleRangeDegrees(number, interpolationValue);
  }
  isInsideAngleRangeDegrees(number, interpolationValue) {
    let currentNumber = this.get(interpolationValue);
    let clampedNumber = Math.pp_angleClampDegrees(number);
    let clampedCurrentNumber = Math.pp_angleClampDegrees(currentNumber);
    return clampedNumber == clampedCurrentNumber;
  }
  isInsideAngleRangeRadians(number, interpolationValue) {
    let currentNumber = this.get(interpolationValue);
    let clampedNumber = Math.pp_angleClampRadians(number);
    let clampedCurrentNumber = Math.pp_angleClampRadians(currentNumber);
    return clampedNumber == clampedCurrentNumber;
  }
};
var IntOverValue = class extends NumberOverValue {
  constructor(startNumber, endNumber, startInterpolationValue, endInterpolationValue, easingFunction = EasingFunction2.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(numberToRound, startNumber2, endNumber2) {
        let roundedNumber = null;
        let useFloor = startNumber2 <= endNumber2;
        if (useFloor) {
          roundedNumber = Math.floor(numberToRound);
        } else {
          roundedNumber = Math.ceil(numberToRound);
        }
        return roundedNumber;
      };
    }
    super(startNumber, endNumber, startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
  }
};
var NumberRangeOverValue = class {
  constructor(startRange, endRange = null, startInterpolationValue = 0, endInterpolationValue = 0, easingFunction = EasingFunction2.linear, roundingFunction = null) {
    if (endRange == null) {
      endRange = startRange;
    }
    this._myStartNumberOverValue = new NumberOverValue(startRange[0], endRange[0], startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
    this._myEndNumberOverValue = new NumberOverValue(startRange[1], endRange[1], startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
    this._myRoundingFunction = roundingFunction;
  }
  get(interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    let randomValue = null;
    if (this._myRoundingFunction) {
      randomValue = Math.pp_randomInt(startNumber, endNumber);
    } else {
      randomValue = Math.pp_random(startNumber, endNumber);
    }
    return randomValue;
  }
  getAverage(interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    let average = (startNumber + endNumber) / 2;
    if (this._myRoundingFunction) {
      average = this._myRoundingFunction(average, startNumber, endNumber);
    }
    return average;
  }
  getRange(interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    return [startNumber, endNumber];
  }
  getMax(interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    return Math.max(startNumber, endNumber);
  }
  getMin(interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    return Math.min(startNumber, endNumber);
  }
  isInside(number, interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    let min = Math.min(startNumber, endNumber);
    let max = Math.max(startNumber, endNumber);
    return number >= min && number <= max;
  }
  isInsideAngleRange(number, interpolationValue) {
    return this.isInsideAngleRangeDegrees(number, interpolationValue);
  }
  isInsideAngleRangeDegrees(number, interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    return Math.pp_isInsideAngleRangeDegrees(number, startNumber, endNumber);
  }
  isInsideAngleRangeRadians(number, interpolationValue) {
    let startNumber = this._myStartNumberOverValue.get(interpolationValue);
    let endNumber = this._myEndNumberOverValue.get(interpolationValue);
    return Math.pp_isInsideAngleRangeRadians(number, startNumber, endNumber);
  }
};
var IntRangeOverValue = class extends NumberRangeOverValue {
  constructor(startRange, endRange, startInterpolationValue, endInterpolationValue, easingFunction = EasingFunction2.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(numberToRound, startNumber, endNumber) {
        let roundedNumber = null;
        let useFloor = startNumber <= endNumber;
        if (useFloor) {
          roundedNumber = Math.floor(numberToRound);
        } else {
          roundedNumber = Math.ceil(numberToRound);
        }
        return roundedNumber;
      };
    }
    super(startRange, endRange, startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
  }
};

// js/pp/gameplay/grab_throw/grabbable_component.js
import { Component as Component29, Property as Property29, PhysXComponent as PhysXComponent5 } from "@wonderlandengine/api";
var GrabbableComponent = class extends Component29 {
  init() {
    this._myIsGrabbed = false;
    this._myGrabber = null;
    this._myGrabCallbacks = /* @__PURE__ */ new Map();
    this._myThrowCallbacks = /* @__PURE__ */ new Map();
    this._myReleaseCallbacks = /* @__PURE__ */ new Map();
  }
  start() {
    this._myOldParent = this.object.pp_getParent();
    this._myPhysX = this.object.pp_getComponent(PhysXComponent5);
    this._myOldKinematicValue = null;
  }
  onDeactivate() {
    this.release();
  }
  grab(grabber) {
    if (!this.isGrabbed()) {
      this._myOldKinematicValue = this._myPhysX.kinematic;
    }
    this.release();
    this._myPhysX.kinematic = true;
    this._myOldParent = this.object.pp_getParent();
    this.object.pp_setParent(grabber);
    this._myIsGrabbed = true;
    this._myGrabCallbacks.forEach(function(callback) {
      callback(grabber, this);
    }.bind(this));
  }
  throw(linearVelocity, angularVelocity) {
    if (this._myIsGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myPhysX.linearVelocity = linearVelocity.vec3_scale(this._myThrowLinearVelocityMultiplier);
      this._myPhysX.angularVelocity = angularVelocity.vec3_scale(this._myThrowAngularVelocityMultiplier);
      this._myThrowCallbacks.forEach(function(callback) {
        callback(grabber, this);
      }.bind(this));
      this._myReleaseCallbacks.forEach(function(callback) {
        callback(grabber, this, true);
      }.bind(this));
    }
  }
  release() {
    if (this._myIsGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myReleaseCallbacks.forEach(function(callback) {
        callback(grabber, this, false);
      }.bind(this));
    }
  }
  getLinearVelocity() {
    let linearVelocity = vec3_create2();
    this._myPhysX.linearVelocity.vec3_clone(linearVelocity);
    return linearVelocity;
  }
  getAngularVelocity() {
    return this.getAngularVelocityDegrees();
  }
  getAngularVelocityDegrees() {
    let angularVelocityDegrees = vec3_create2();
    this._myPhysX.angularVelocity.vec3_toDegrees(angularVelocityDegrees);
    return angularVelocityDegrees;
  }
  getAngularVelocityRadians() {
    let angularVelocityRadians = vec3_create2();
    this._myPhysX.angularVelocity.vec3_clone(angularVelocityRadians);
    return angularVelocityRadians;
  }
  isGrabbed() {
    return this._myIsGrabbed;
  }
  getGrabber() {
    return this._myGrabber;
  }
  registerGrabEventListener(id, callback) {
    this._myGrabCallbacks.set(id, callback);
  }
  unregisterGrabEventListener(id) {
    this._myGrabCallbacks.delete(id);
  }
  registerThrowEventListener(id, callback) {
    this._myThrowCallbacks.set(id, callback);
  }
  unregisterThrowEventListener(id) {
    this._myThrowCallbacks.delete(id);
  }
  registerReleaseEventListener(id, callback) {
    this._myReleaseCallbacks.set(id, callback);
  }
  unregisterReleaseEventListener(id) {
    this._myReleaseCallbacks.delete(id);
  }
  _release() {
    if (this._myParentOnRelease == 0) {
      this.object.pp_setParent(null);
    } else {
      this.object.pp_setParent(this._myOldParent);
    }
    this._myIsGrabbed = false;
    this._myGrabber = null;
    if (this._myKinematicValueOnRelease == 0) {
      this._myPhysX.kinematic = true;
    } else if (this._myKinematicValueOnRelease == 1) {
      this._myPhysX.kinematic = false;
    } else if (this._myOldKinematicValue != null) {
      this._myPhysX.kinematic = this._myOldKinematicValue;
    }
    if (this._myPhysX.kinematic) {
      this._myPhysX.linearVelocity = vec3_create2();
      this._myPhysX.angularVelocity = vec3_create2();
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = targetObject.pp_addComponent(this.type);
    clonedComponent.active = this.active;
    clonedComponent._myThrowLinearVelocityMultiplier = this._myThrowLinearVelocityMultiplier;
    clonedComponent._myThrowAngularVelocityMultiplier = this._myThrowAngularVelocityMultiplier;
    clonedComponent._myKinematicValueOnRelease = this._myKinematicValueOnRelease;
    return clonedComponent;
  }
  pp_clonePostProcess() {
    this.start();
  }
};
__publicField(GrabbableComponent, "TypeName", "pp-grabbable");
__publicField(GrabbableComponent, "Properties", {
  _myThrowLinearVelocityMultiplier: Property29.float(1),
  _myThrowAngularVelocityMultiplier: Property29.float(1),
  _myKinematicValueOnRelease: Property29.enum(["True", "False", "Own"], "False"),
  _myParentOnRelease: Property29.enum(["Root", "Own"], "Own")
});

// js/pp/gameplay/grab_throw/grabber_hand_component.js
import { Component as Component30, Property as Property30, PhysXComponent as PhysXComponent6 } from "@wonderlandengine/api";
var GrabberHandComponent = class extends Component30 {
  init() {
    this._myGrabbables = [];
    this._myGamepad = null;
    this._myActiveGrabButton = null;
    this._myLinearVelocityHistorySize = 5;
    this._myLinearVelocityHistorySpeedAverageSamplesFromStart = 1;
    this._myLinearVelocityHistoryDirectionAverageSamplesFromStart = 3;
    this._myLinearVelocityHistoryDirectionAverageSkipFromStart = 0;
    this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
    this._myHandLinearVelocityHistory.fill(vec3_create2());
    this._myAngularVelocityHistorySize = 1;
    this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
    this._myHandAngularVelocityHistory.fill(vec3_create2());
    this._myThrowMaxAngularSpeedRadians = Math.pp_toRadians(this._myThrowMaxAngularSpeed);
    this._myGrabCallbacks = /* @__PURE__ */ new Map();
    this._myThrowCallbacks = /* @__PURE__ */ new Map();
    this._myDebugActive = false;
  }
  start() {
    if (this._myHandedness == HandednessIndex.LEFT) {
      this._myGamepad = getLeftGamepad(this.engine);
    } else {
      this._myGamepad = getRightGamepad(this.engine);
    }
    this._myPhysX = this.object.pp_getComponent(PhysXComponent6);
    this._myCollisionsCollector = new PhysicsCollisionCollector(this._myPhysX, true);
  }
  update(dt) {
    this._myCollisionsCollector.update(dt);
    if (this._myGrabbables.length > 0) {
      this._updateLinearVelocityHistory();
      this._updateAngularVelocityHistory();
    }
  }
  grab(grabButton = null) {
    this._grab(grabButton);
  }
  throw(throwButton = null) {
    this._throw(throwButton);
  }
  getGamepad() {
    return this._myGamepad;
  }
  getHandedness() {
    return InputUtils.getHandednessByIndex(this._myHandedness);
  }
  registerGrabEventListener(id, callback) {
    this._myGrabCallbacks.set(id, callback);
  }
  unregisterGrabEventListener(id) {
    this._myGrabCallbacks.delete(id);
  }
  registerThrowEventListener(id, callback) {
    this._myThrowCallbacks.set(id, callback);
  }
  unregisterThrowEventListener(id) {
    this._myThrowCallbacks.delete(id);
  }
  onActivate() {
    if (this._myGamepad == null) {
      return;
    }
    if (this._myGrabButton == 0) {
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SELECT));
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SELECT));
    } else if (this._myGrabButton == 1) {
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SQUEEZE));
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SQUEEZE));
    } else {
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SQUEEZE));
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SQUEEZE));
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SELECT));
      this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SELECT));
    }
  }
  onDeactivate() {
    if (this._myGamepad == null) {
      return;
    }
    if (this._myGrabButton == 0) {
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this);
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this);
    } else if (this._myGrabButton == 1) {
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this);
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this);
    } else {
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this);
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this);
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this);
      this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this);
    }
  }
  _grab(grabButton) {
    if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
      return;
    }
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == grabButton || grabButton == null) {
      let grabbablesToGrab = [];
      let collisions = this._myCollisionsCollector.getCollisions();
      for (let i = 0; i < collisions.length; i++) {
        let grabbable = collisions[i].pp_getComponent(GrabbableComponent);
        if (grabbable && grabbable.active) {
          grabbablesToGrab.push(grabbable);
        }
      }
      let grabberPosition = this.object.pp_getPosition();
      grabbablesToGrab.sort(function(first, second) {
        let firstPosition = first.object.pp_getPosition();
        let secondPosition = second.object.pp_getPosition();
        let firstDistance = firstPosition.vec3_distance(grabberPosition);
        let secondDistance = secondPosition.vec3_distance(grabberPosition);
        return Math.pp_sign(firstDistance - secondDistance, 0);
      });
      for (let grabbableToGrab of grabbablesToGrab) {
        if (!this._isAlreadyGrabbed(grabbableToGrab)) {
          let grabbableData = new _GrabberHandComponentGrabbableData(grabbableToGrab, this._myThrowVelocitySource == 1, this._myLinearVelocityHistorySize, this._myAngularVelocityHistorySize);
          this._myGrabbables.push(grabbableData);
          grabbableToGrab.grab(this.object);
          grabbableToGrab.registerReleaseEventListener(this, this._onRelease.bind(this));
          if (this._mySnapOnPivot) {
            grabbableToGrab.object.pp_resetPositionLocal();
          }
          this._myGrabCallbacks.forEach(function(callback) {
            callback(this, grabbableToGrab);
          }.bind(this));
        }
        if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
          break;
        }
      }
      if (this._myGrabbables.length > 0) {
        if (this._myActiveGrabButton == null) {
          this._myActiveGrabButton = grabButton;
        }
      }
    }
  }
  _throw(throwButton) {
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == throwButton || throwButton == null) {
      if (this._myGrabbables.length > 0) {
        let linearVelocity = null;
        let angularVelocity = null;
        if (this._myThrowVelocitySource == 0) {
          linearVelocity = this._computeReleaseLinearVelocity(this._myHandLinearVelocityHistory);
          angularVelocity = this._computeReleaseAngularVelocity(this._myHandAngularVelocityHistory);
        }
        for (let grabbableData of this._myGrabbables) {
          let grabbable = grabbableData.getGrabbable();
          grabbable.unregisterReleaseEventListener(this);
          if (this._myThrowVelocitySource == 1) {
            linearVelocity = this._computeReleaseLinearVelocity(grabbableData.getLinearVelocityHistory());
            angularVelocity = this._computeReleaseAngularVelocity(grabbableData.getAngularVelocityHistory());
          }
          grabbable.throw(linearVelocity, angularVelocity);
          this._myThrowCallbacks.forEach(function(callback) {
            callback(this, grabbable);
          }.bind(this));
        }
        this._myGrabbables = [];
      }
      this._myActiveGrabButton = null;
    }
  }
  _onRelease(grabber, grabbable) {
    grabbable.unregisterReleaseEventListener(this);
    this._myGrabbables.pp_remove((element) => element.getGrabbable() == grabbable);
    if (this._myGrabbables.length <= 0) {
      this._myActiveGrabButton = null;
    }
  }
  _updateLinearVelocityHistory() {
    let handPose = this._myGamepad.getHandPose();
    this._myHandLinearVelocityHistory.unshift(handPose.getLinearVelocity().pp_clone());
    this._myHandLinearVelocityHistory.pop();
    for (let grabbable of this._myGrabbables) {
      grabbable.updateLinearVelocityHistory();
    }
  }
  _updateAngularVelocityHistory() {
    let handPose = this._myGamepad.getHandPose();
    this._myHandAngularVelocityHistory.unshift(handPose.getAngularVelocityRadians().pp_clone());
    this._myHandAngularVelocityHistory.pop();
    for (let grabbable of this._myGrabbables) {
      grabbable.updateAngularVelocityHistory();
    }
  }
  _computeReleaseLinearVelocity(linearVelocityHistory) {
    let speed = linearVelocityHistory[0].vec3_length();
    for (let i = 1; i < this._myLinearVelocityHistorySpeedAverageSamplesFromStart; i++) {
      speed += linearVelocityHistory[i].vec3_length();
    }
    speed /= this._myLinearVelocityHistorySpeedAverageSamplesFromStart;
    let speedEaseMultiplier = Math.pp_mapToRange(speed, this._myThrowLinearVelocityBoostMinSpeedThreshold, this._myThrowLinearVelocityBoostMaxSpeedThreshold, 0, 1);
    speedEaseMultiplier = EasingFunction2.easeIn(speedEaseMultiplier);
    let extraSpeed = speed * (speedEaseMultiplier * this._myThrowLinearVelocityBoost);
    speed += extraSpeed;
    speed *= this._myThrowLinearVelocityMultiplier;
    speed = Math.pp_clamp(speed, 0, this._myThrowMaxLinearSpeed);
    if (this._myDebugActive) {
      this._debugDirectionLines(linearVelocityHistory);
    }
    let directionCurrentWeight = this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let lastDirectionIndex = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let direction = vec3_create2();
    for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
      let currentDirection = linearVelocityHistory[i];
      currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
      direction.vec3_add(currentDirection, direction);
      directionCurrentWeight--;
    }
    direction.vec3_normalize(direction);
    direction.vec3_scale(speed, direction);
    return direction;
  }
  _computeReleaseAngularVelocity(angularVelocityHistory) {
    let angularVelocity = angularVelocityHistory[0];
    let speed = angularVelocity.vec3_length();
    speed = Math.pp_clamp(speed * this._myThrowAngularVelocityMultiplier, 0, this._myThrowMaxAngularSpeedRadians);
    let direction = angularVelocity;
    direction.vec3_normalize(direction);
    direction.vec3_scale(speed, direction);
    return direction;
  }
  _debugDirectionLines(linearVelocityHistory) {
    for (let j = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart; j > this._myLinearVelocityHistoryDirectionAverageSkipFromStart; j--) {
      let directionCurrentWeight = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let lastDirectionIndex = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let direction = vec3_create2();
      for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
        let currentDirection = linearVelocityHistory[i].pp_clone();
        currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
        direction.vec3_add(currentDirection, direction);
        directionCurrentWeight--;
      }
      direction.vec3_normalize(direction);
      let color = 1 / j;
      getDebugVisualManager2(this.engine).drawLine(5, this.object.pp_getPosition(), direction, 0.2, vec4_create2(olor, color, color, 1));
    }
  }
  _isAlreadyGrabbed(grabbable) {
    let found = this._myGrabbables.pp_find((element) => element.getGrabbable() == grabbable);
    return found != null;
  }
};
__publicField(GrabberHandComponent, "TypeName", "pp-grabber-hand");
__publicField(GrabberHandComponent, "Properties", {
  _myHandedness: Property30.enum(["Left", "Right"], "Left"),
  _myGrabButton: Property30.enum(["Select", "Squeeze", "Both", "Both Exclusive"], "Squeeze"),
  _mySnapOnPivot: Property30.bool(false),
  _myMaxNumberOfObjects: Property30.int(1),
  _myThrowVelocitySource: Property30.enum(["Hand", "Grabbable"], "Hand"),
  _myThrowLinearVelocityMultiplier: Property30.float(1),
  _myThrowMaxLinearSpeed: Property30.float(15),
  _myThrowAngularVelocityMultiplier: Property30.float(0.5),
  _myThrowMaxAngularSpeed: Property30.float(1080),
  _myThrowLinearVelocityBoost: Property30.float(1.75),
  _myThrowLinearVelocityBoostMinSpeedThreshold: Property30.float(0.6),
  _myThrowLinearVelocityBoostMaxSpeedThreshold: Property30.float(2.5)
});
var _GrabberHandComponentGrabbableData = class {
  constructor(grabbable, useGrabbableAsVelocitySource, linearVelocityHistorySize, angularVelocityHistorySize) {
    this._myGrabbable = grabbable;
    this._myUseGrabbableAsVelocitySource = useGrabbableAsVelocitySource;
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory = new Array(linearVelocityHistorySize);
      this._myLinearVelocityHistory.fill(vec3_create2());
      this._myAngularVelocityHistory = new Array(angularVelocityHistorySize);
      this._myAngularVelocityHistory.fill(vec3_create2());
    }
  }
  getGrabbable() {
    return this._myGrabbable;
  }
  getLinearVelocityHistory() {
    return this._myLinearVelocityHistory;
  }
  getAngularVelocityHistory() {
    return this._myAngularVelocityHistory;
  }
  updateLinearVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory.unshift(this._myGrabbable.getLinearVelocity());
      this._myLinearVelocityHistory.pop();
    }
  }
  updateAngularVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myAngularVelocityHistory.unshift(this._myGrabbable.getAngularVelocityRadians());
      this._myAngularVelocityHistory.pop();
    }
  }
};

// js/pp/gameplay/integrations/construct_arcade/ca_utils.js
var _myDummyServer = null;
var _myUseDummyServerOnSDKMissing = false;
var _myUseDummyServerOnError = false;
var CAError = {
  DUMMY_NOT_INITIALIZED: 0,
  CA_SDK_MISSING: 1,
  SUBMIT_SCORE_FAILED: 2,
  GET_LEADERBOARD_FAILED: 3,
  GET_USER_FAILED: 4,
  USER_HAS_NO_SCORE: 5
};
function setUseDummyServerOnSDKMissing(useDummyServer) {
  _myUseDummyServerOnSDKMissing = useDummyServer;
}
function setUseDummyServerOnError(useDummyServer) {
  _myUseDummyServerOnError = useDummyServer;
}
function setDummyServer(dummyServer) {
  _myDummyServer = dummyServer;
}
function isUseDummyServerOnSDKMissing() {
  return _myUseDummyServerOnSDKMissing;
}
function isUseDummyServerOnError() {
  return _myUseDummyServerOnError;
}
function getDummyServer() {
  return _myDummyServer;
}
function isSDKAvailable() {
  return "casdk" in window;
}
function getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError, overrideUseDummyServer = null) {
  if (isSDKAvailable()) {
    if (!isAroundPlayer) {
      casdk.getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount).then(function(result2) {
        if (result2.leaderboard) {
          if (callbackOnDone) {
            callbackOnDone(result2.leaderboard);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
            getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
          } else if (callbackOnError) {
            let error = {};
            error.reason = "Get leaderboard failed";
            error.type = CAError.GET_LEADERBOARD_FAILED;
            callbackOnError(error, result2);
          }
        }
      }).catch(function(result2) {
        if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
          getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
        } else if (callbackOnError) {
          let error = {};
          error.reason = "Get leaderboard failed";
          error.type = CAError.GET_LEADERBOARD_FAILED;
          callbackOnError(error, result2);
        }
      });
    } else {
      getUser(
        function(user) {
          let userName = user.displayName;
          casdk.getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount).then(function(result2) {
            if (result2.leaderboard) {
              let userValid = false;
              for (let value of result2.leaderboard) {
                if (value.displayName == userName && value.score != 0) {
                  userValid = true;
                  break;
                }
              }
              if (userValid) {
                if (callbackOnDone) {
                  callbackOnDone(result2.leaderboard);
                }
              } else {
                if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
                  getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
                } else if (callbackOnError) {
                  let error = {};
                  error.reason = "Searching for around player but the user has not submitted a score yet";
                  error.type = CAError.USER_HAS_NO_SCORE;
                  callbackOnError(error, result2);
                }
              }
            } else {
              if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
                getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
              } else if (callbackOnError) {
                let error = {};
                error.reason = "Get leaderboard failed";
                error.type = CAError.GET_LEADERBOARD_FAILED;
                callbackOnError(error, result2);
              }
            }
          }).catch(function(result2) {
            if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
              getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
            } else if (callbackOnError) {
              let error = {};
              error.reason = "Get leaderboard failed";
              error.type = CAError.GET_LEADERBOARD_FAILED;
              callbackOnError(error, result2);
            }
          });
        },
        function() {
          if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
            getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
          } else if (callbackOnError) {
            let error = {};
            error.reason = "Searching for around player but the user can't be retrieved";
            error.type = CAError.GET_USER_FAILED;
            callbackOnError(error, result);
          }
        },
        false
      );
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnSDKMissing && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
      getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
    } else if (callbackOnError) {
      let error = {};
      error.reason = "Construct Arcade SDK missing";
      error.type = CAError.CA_SDK_MISSING;
      callbackOnError(error, null);
    }
  }
}
function getLeaderboardDummy(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError) {
  if (_myDummyServer) {
    _myDummyServer.getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError);
  } else {
    if (callbackOnError) {
      let error = {};
      error.reason = "Dummy server not initialized";
      error.type = CAError.DUMMY_NOT_INITIALIZED;
      callbackOnError(error);
    }
  }
}
function submitScore(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError, overrideUseDummyServer = null) {
  if (isSDKAvailable()) {
    casdk.submitScore(leaderboardID, scoreToSubmit).then(function(result2) {
      if (result2.error) {
        if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
          submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
        } else if (callbackOnError) {
          let error = {};
          error.reason = "Submit score failed";
          error.type = CAError.SUBMIT_SCORE_FAILED;
          callbackOnError(error, result2);
        }
      } else {
        callbackOnDone();
      }
    }).catch(function(result2) {
      if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
        submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
      } else if (callbackOnError) {
        let error = {};
        error.reason = "Submit score failed";
        error.type = CAError.SUBMIT_SCORE_FAILED;
        callbackOnError(error, result2);
      }
    });
  } else {
    if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnSDKMissing && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
      submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
    } else if (callbackOnError) {
      let error = {};
      error.reason = "Construct Arcade SDK missing";
      error.type = CAError.CA_SDK_MISSING;
      callbackOnError(error, null);
    }
  }
}
function submitScoreDummy(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError) {
  if (_myDummyServer) {
    _myDummyServer.submitScore(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError);
  } else {
    if (callbackOnError) {
      let error = {};
      error.reason = "Dummy server not initialized";
      error.type = CAError.DUMMY_NOT_INITIALIZED;
      callbackOnError(error);
    }
  }
}
function getUser(callbackOnDone, callbackOnError, overrideUseDummyServer = null) {
  if (isSDKAvailable()) {
    casdk.getUser().then(function(result2) {
      if (result2.user) {
        if (callbackOnDone) {
          callbackOnDone(result2.user);
        }
      } else {
        if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
          getUserDummy(callbackOnDone, callbackOnError);
        } else if (callbackOnError) {
          let error = {};
          error.reason = "Get user failed";
          error.type = CAError.GET_USER_FAILED;
          callbackOnError(error, result2);
        }
      }
    }).catch(function(result2) {
      if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
        getUserDummy(callbackOnDone, callbackOnError);
      } else if (callbackOnError) {
        let error = {};
        error.reason = "Get user failed";
        error.type = CAError.GET_USER_FAILED;
        callbackOnError(error, result2);
      }
    });
  } else {
    if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnSDKMissing && overrideUseDummyServer == null) || overrideUseDummyServer != null && overrideUseDummyServer) {
      getUserDummy(callbackOnDone, callbackOnError);
    } else if (callbackOnError) {
      let error = {};
      error.reason = "Construct Arcade SDK missing";
      error.type = CAError.CA_SDK_MISSING;
      callbackOnError(error, null);
    }
  }
}
function getUserDummy(callbackOnDone, callbackOnError) {
  if (_myDummyServer) {
    _myDummyServer.getUser(callbackOnDone, callbackOnError);
  } else {
    if (callbackOnError) {
      let error = {};
      error.reason = "Dummy server not initialized";
      error.type = CAError.DUMMY_NOT_INITIALIZED;
      callbackOnError(error);
    }
  }
}
var CAUtils2 = {
  setUseDummyServerOnSDKMissing,
  setUseDummyServerOnError,
  setDummyServer,
  isUseDummyServerOnSDKMissing,
  isUseDummyServerOnError,
  getDummyServer,
  isSDKAvailable,
  getLeaderboard,
  getLeaderboardDummy,
  submitScore,
  submitScoreDummy,
  getUser,
  getUserDummy
};

// js/pp/gameplay/integrations/construct_arcade/ca_dummy_server.js
var CADummyServer = class {
  constructor() {
  }
  getLeaderboard(leaderboardID, isAscending, isAroundPlayer, scoresAmount, callbackOnDone, callbackOnError) {
    let leaderboard = null;
    if (CAUtils2.isSDKAvailable()) {
      leaderboard = [
        { rank: 0, displayName: "An", score: 0 },
        { rank: 1, displayName: "Error", score: 0 },
        { rank: 2, displayName: "Has", score: 0 },
        { rank: 3, displayName: "Occurred", score: 0 },
        { rank: 4, displayName: "While", score: 0 },
        { rank: 5, displayName: "Trying", score: 0 },
        { rank: 6, displayName: "To", score: 0 },
        { rank: 7, displayName: "Retrieve", score: 0 },
        { rank: 8, displayName: "The", score: 0 },
        { rank: 9, displayName: "Leaderboard", score: 0 }
      ];
    } else {
      if (isAroundPlayer) {
        leaderboard = [
          { rank: 0, displayName: "Sign In", score: 0 },
          { rank: 1, displayName: "And", score: 0 },
          { rank: 2, displayName: "Play", score: 0 },
          { rank: 3, displayName: "On", score: 0 },
          { rank: 4, displayName: "HeyVR", score: 0 },
          { rank: 5, displayName: "To", score: 0 },
          { rank: 6, displayName: "Submit", score: 0 },
          { rank: 7, displayName: "Your", score: 0 },
          { rank: 8, displayName: "Own", score: 0 },
          { rank: 9, displayName: "Score", score: 0 }
        ];
      } else {
        leaderboard = [
          { rank: 0, displayName: "The", score: 0 },
          { rank: 1, displayName: "Top 10", score: 0 },
          { rank: 2, displayName: "Leaderboard", score: 0 },
          { rank: 3, displayName: "Is", score: 0 },
          { rank: 4, displayName: "Available", score: 0 },
          { rank: 5, displayName: "Only", score: 0 },
          { rank: 5, displayName: "When", score: 0 },
          { rank: 7, displayName: "Playing", score: 0 },
          { rank: 8, displayName: "On", score: 0 },
          { rank: 9, displayName: "HeyVR", score: 0 }
        ];
      }
    }
    while (leaderboard.length > scoresAmount) {
      leaderboard.pop();
    }
    if (callbackOnDone) {
      callbackOnDone(leaderboard);
    }
  }
  submitScore(leaderboardID, scoreToSubmit, callbackOnDone, callbackOnError) {
    if (callbackOnDone) {
      callbackOnDone();
    }
  }
  getUser(callbackOnDone, callbackOnError) {
    let user = {};
    user.displayName = "J";
    if (callbackOnDone) {
      callbackOnDone(user);
    }
  }
};

// js/pp/gameplay/integrations/construct_arcade/ca_display_leaderboard_component.js
import { Component as Component31, Property as Property31, TextComponent as TextComponent7 } from "@wonderlandengine/api";
var CADisplayLeaderboardComponent = class extends Component31 {
  start() {
    this._myNamesTextComponent = null;
    this._myScoresTextComponent = null;
    this._myStarted = false;
    CAUtils.setDummyServer(new CADummyServer());
    CAUtils.setUseDummyServerOnSDKMissing(true);
    CAUtils.setUseDummyServerOnError(true);
  }
  update(dt) {
    if (!this._myStarted) {
      this._myStarted = true;
      let namesObject = this.object.pp_getObjectByName("Names");
      let scoresObject = this.object.pp_getObjectByName("Scores");
      if (namesObject != null && scoresObject != null) {
        this._myNamesTextComponent = namesObject.pp_getComponent(TextComponent7);
        this._myScoresTextComponent = scoresObject.pp_getComponent(TextComponent7);
      }
      this.updateLeaderboard();
    }
  }
  updateLeaderboard() {
    CAUtils.getLeaderboard(this._myLeaderboardID, this._myIsAscending, this._myIsLocal, this._myScoresAmount, this._onLeaderboardRetrieved.bind(this));
  }
  _onLeaderboardRetrieved(leaderboard) {
    let namesText = "";
    let scoresText = "";
    let maxRankDigit = 0;
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      if (rank.toFixed(0).length > maxRankDigit) {
        maxRankDigit = rank.toFixed(0).length;
      }
    }
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      let fixedRank = rank.toFixed(0);
      while (fixedRank.length < maxRankDigit) {
        fixedRank = "0".concat(fixedRank);
      }
      let newlines = "\n";
      for (let i = 0; i < this._myNumberOfLinesBetweenScores; i++) {
        newlines = newlines + "\n";
      }
      namesText = namesText.concat(fixedRank, this._myPositionAndUsernameSeparator, value.displayName, newlines);
      let convertedScore = this._formatScore(value.score);
      scoresText = scoresText.concat(convertedScore, newlines);
    }
    if (this._myNamesTextComponent != null && this._myScoresTextComponent != null) {
      this._myNamesTextComponent.text = namesText;
      this._myScoresTextComponent.text = scoresText;
    }
  }
  _formatScore(score) {
    let convertedScore = score.toString();
    if (this._myScoreFormat == 1) {
      convertedScore = this._formatTime(score, true, true, true);
    } else if (this._myScoreFormat == 2) {
      convertedScore = this._formatTime(score, false, true, true);
    } else if (this._myScoreFormat == 3) {
      convertedScore = this._formatTime(score, false, false, true);
    } else if (this._myScoreFormat == 4) {
      convertedScore = this._formatTime(score, true, true, false);
    } else if (this._myScoreFormat == 5) {
      convertedScore = this._formatTime(score, false, true, false);
    }
    return convertedScore;
  }
  _formatTime(score, displayHours, displayMinutes, displaySeconds) {
    let time = Math.floor(score / 1e3);
    let hours = 0;
    if (displayHours) {
      hours = Math.floor(time / 3600);
      time -= hours * 3600;
    }
    let minutes = 0;
    if (displayMinutes) {
      minutes = Math.floor(time / 60);
      time -= minutes * 60;
    }
    let seconds = 0;
    if (displaySeconds) {
      seconds = Math.floor(time);
    }
    let convertedTime = "";
    if (displaySeconds) {
      convertedTime = seconds.toFixed(0).length < 2 && (displayMinutes || displayHours) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
    }
    if (displayMinutes) {
      convertedTime = (minutes.toFixed(0).length < 2 && (displaySeconds || displayHours) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0)) + (displaySeconds ? ":" + convertedTime : "");
    }
    if (displayHours) {
      convertedTime = (hours.toFixed(0).length < 2 && (displaySeconds || displayMinutes) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0)) + (displayMinutes ? ":" + convertedTime : "");
    }
    return convertedTime;
  }
  pp_clone(targetObject) {
    let clonedComponent = targetObject.pp_addComponent(this.type);
    clonedComponent.active = this.active;
    clonedComponent._myLeaderboardID = this._myLeaderboardID;
    clonedComponent._myIsLocal = this._myIsLocal;
    clonedComponent._myPositionAndUsernameSeparator = this._myPositionAndUsernameSeparator;
    clonedComponent._myNumberOfLinesBetweenScores = this._myNumberOfLinesBetweenScores;
    return clonedComponent;
  }
};
__publicField(CADisplayLeaderboardComponent, "TypeName", "pp-ca-display-leaderboard");
__publicField(CADisplayLeaderboardComponent, "Properties", {
  _myLeaderboardID: Property31.string(""),
  _myIsLocal: Property31.bool(false),
  _myIsAscending: Property31.bool(false),
  _myScoresAmount: Property31.int(10),
  _myScoreFormat: Property31.enum(["Value", "Hours:Minutes:Seconds", "Minutes:Seconds", "Seconds", "Hours:Minutes", "Minutes"], "Value"),
  _myPositionAndUsernameSeparator: Property31.string(" - "),
  _myNumberOfLinesBetweenScores: Property31.int(1)
});

// js/pp/gameplay/experimental/cauldron/player/player_head_controller.js
var PlayerHeadController = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/cauldron/player/player_view_occlusion.js
var PlayerViewOcclusion = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/cauldron/player/components/player_head_controller_component.js
import { Component as Component32, Property as Property32 } from "@wonderlandengine/api";
var PlayerHeadControllerComponent = class extends Component32 {
  init() {
  }
  start() {
    this._myPlayerHeadController = new PlayerHeadController();
  }
  update(dt) {
    this._myPlayerHeadController.update(dt);
  }
  getPlayerHeadController() {
    return this._myPlayerHeadController;
  }
};
__publicField(PlayerHeadControllerComponent, "TypeName", "pp-player-head-controller");
__publicField(PlayerHeadControllerComponent, "Properties", {});

// js/pp/gameplay/experimental/cauldron/player/components/player_view_occlusion_component.js
import { Component as Component33, Property as Property33 } from "@wonderlandengine/api";
var PlayerViewOcclusionComponent = class extends Component33 {
  init() {
  }
  start() {
    this._myPlayerViewOcclusion = new PlayerViewOcclusion();
  }
  update(dt) {
    this._myPlayerViewOcclusion.update(dt);
  }
  getPlayerViewOcclusion() {
    return this._myPlayerViewOcclusion;
  }
};
__publicField(PlayerViewOcclusionComponent, "TypeName", "pp-player-occlusion");
__publicField(PlayerViewOcclusionComponent, "Properties", {});

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_params.js
var CollisionCheckParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxLength = 0;
    this.mySplitMovementMaxStepsEnabled = false;
    this.mySplitMovementMaxSteps = 0;
    this.mySplitMovementStepEqualLength = false;
    this.mySplitMovementStepEqualLengthMinLength = 0;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = false;
    this.mySplitMovementStopWhenVerticalMovementCanceled = false;
    this.mySplitMovementStopCallback = null;
    this.mySplitMovementStopReturnPrevious = false;
    this.myRadius = 0;
    this.myDistanceFromFeetToIgnore = 0;
    this.myDistanceFromHeadToIgnore = 0;
    this.myPositionOffsetLocal = vec3_create2();
    this.myRotationOffsetLocalQuat = quat_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementStepEnabled = false;
    this.myHorizontalMovementStepMaxLength = 0;
    this.myHorizontalMovementRadialStepAmount = 0;
    this.myHorizontalMovementCheckDiagonalOutward = false;
    this.myHorizontalMovementCheckDiagonalInward = false;
    this.myHorizontalMovementCheckStraight = false;
    this.myHorizontalMovementCheckHorizontalBorder = false;
    this.myHorizontalMovementCheckVerticalStraight = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHalfConeAngle = 0;
    this.myHalfConeSliceAmount = 0;
    this.myCheckConeBorder = false;
    this.myCheckConeRay = false;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = true;
    this.myHorizontalPositionCheckVerticalDirectionType = 0;
    this.myCheckHorizontalFixedForwardEnabled = false;
    this.myCheckHorizontalFixedForward = vec3_create2();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myFeetRadius = 0;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = false;
    this.myAdjustVerticalMovementWithGroundAngleUphill = false;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = null;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = false;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = null;
    this.myCheckVerticalFixedForwardEnabled = false;
    this.myCheckVerticalFixedForward = vec3_create2();
    this.myCheckVerticalBothDirection = false;
    this.mySnapOnGroundEnabled = false;
    this.mySnapOnGroundExtraDistance = 0;
    this.mySnapOnCeilingEnabled = false;
    this.mySnapOnCeilingExtraDistance = 0;
    this.myGroundPopOutEnabled = false;
    this.myGroundPopOutExtraDistance = 0;
    this.myCeilingPopOutEnabled = false;
    this.myCeilingPopOutExtraDistance = 0;
    this.myVerticalMovementReduceEnabled = false;
    this.myGroundCircumferenceAddCenter = false;
    this.myGroundCircumferenceSliceAmount = 0;
    this.myGroundCircumferenceStepAmount = 0;
    this.myGroundCircumferenceRotationPerStep = 0;
    this.myVerticalAllowHitInsideCollisionIfOneOk = false;
    this.myCheckHeight = false;
    this.myCheckHeightVerticalMovement = false;
    this.myCheckHeightVerticalPosition = false;
    this.myCheckHeightTopMovement = false;
    this.myCheckHeightTopPosition = false;
    this.myCheckHeightConeOnCollision = false;
    this.myCheckHeightConeOnCollisionKeepHit = false;
    this.myHeightCheckStepAmountMovement = 0;
    this.myHeightCheckStepAmountPosition = 0;
    this.myCheckVerticalStraight = false;
    this.myCheckVerticalDiagonalRayOutward = false;
    this.myCheckVerticalDiagonalRayInward = false;
    this.myCheckVerticalDiagonalBorderOutward = false;
    this.myCheckVerticalDiagonalBorderInward = false;
    this.myCheckVerticalDiagonalBorderRayOutward = false;
    this.myCheckVerticalDiagonalBorderRayInward = false;
    this.myCheckVerticalSearchFartherVerticalHit = false;
    this.myGroundAngleToIgnore = 0;
    this.myGroundAngleToIgnoreWithPerceivedAngle = null;
    this.myCeilingAngleToIgnore = 0;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = null;
    this.myHorizontalMovementGroundAngleIgnoreHeight = null;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = null;
    this.myHorizontalPositionGroundAngleIgnoreHeight = null;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = null;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = null;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = null;
    this.myHeight = 0;
    this.myComputeGroundInfoEnabled = false;
    this.myComputeCeilingInfoEnabled = false;
    this.myDistanceToBeOnGround = 0;
    this.myDistanceToComputeGroundInfo = 0;
    this.myDistanceToBeOnCeiling = 0;
    this.myDistanceToComputeCeilingInfo = 0;
    this.myVerticalFixToBeOnGround = 0;
    this.myVerticalFixToComputeGroundInfo = 0;
    this.myVerticalFixToBeOnCeiling = 0;
    this.myVerticalFixToComputeCeilingInfo = 0;
    this.myGroundIsBaseInsideCollisionCheckEnabled = false;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = false;
    this.myIsOnGroundIfInsideHit = false;
    this.myIsOnCeilingIfInsideHit = false;
    this.myIsOnGroundMaxSurfaceAngle = null;
    this.myIsOnCeilingMaxSurfaceAngle = null;
    this.myFindGroundDistanceMaxOutsideDistance = 0;
    this.myFindGroundDistanceMaxInsideDistance = 0;
    this.myFindCeilingDistanceMaxOutsideDistance = 0;
    this.myFindCeilingDistanceMaxInsideDistance = 0;
    this.myAllowGroundSteepFix = false;
    this.myAllowCeilingSteepFix = false;
    this.myMustStayOnGround = false;
    this.myMustStayOnCeiling = false;
    this.myMustStayOnValidGroundAngleDownhill = false;
    this.myMustStayOnValidCeilingAngleDownhill = false;
    this.myRegatherGroundInfoOnSurfaceCheckFail = false;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = false;
    this.myMustStayBelowIgnorableGroundAngleDownhill = false;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = false;
    this.myMustStayBelowGroundAngleDownhill = null;
    this.myMustStayBelowCeilingAngleDownhill = null;
    this.myMovementMustStayOnGroundHitAngle = null;
    this.myMovementMustStayOnCeilingHitAngle = null;
    this.myTeleportMustBeOnIgnorableGroundAngle = false;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = false;
    this.myTeleportMustBeOnIgnorableCeilingAngle = false;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = false;
    this.myTeleportMustBeOnGroundAngle = null;
    this.myCheckTransformMustBeOnGroundAngle = null;
    this.myTeleportMustBeOnCeilingAngle = null;
    this.myCheckTransformMustBeOnCeilingAngle = null;
    this.myTeleportMustBeOnGround = false;
    this.myCheckTransformMustBeOnGround = false;
    this.myTeleportMustBeOnCeiling = false;
    this.myCheckTransformMustBeOnCeiling = false;
    this.mySlidingEnabled = false;
    this.mySlidingHorizontalMovementCheckBetterNormal = false;
    this.mySlidingMaxAttempts = 0;
    this.mySlidingCheckBothDirections = false;
    this.mySlidingFlickeringPreventionType = 0;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingAdjustSign90Degrees = false;
    this.myHorizontalBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalObjectsToIgnore = [];
    this.myVerticalBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalObjectsToIgnore = [];
    this.myExtraMovementCheckCallback = null;
    this.myExtraTeleportCheckCallback = null;
    this.myExtraCheckTransformCheckCallback = null;
    this.myDebugActive = false;
    this.myDebugHorizontalMovementActive = false;
    this.myDebugHorizontalPositionActive = false;
    this.myDebugVerticalMovementActive = false;
    this.myDebugVerticalPositionActive = false;
    this.myDebugSlidingActive = false;
    this.myDebugGroundInfoActive = false;
    this.myDebugCeilingInfoActive = false;
    this.myDebugRuntimeParamsActive = false;
    this.myDebugMovementActive = false;
  }
  copy(other2) {
    this.mySplitMovementEnabled = other2.mySplitMovementEnabled;
    this.mySplitMovementMaxLength = other2.mySplitMovementMaxLength;
    this.mySplitMovementMaxStepsEnabled = other2.mySplitMovementMaxStepsEnabled;
    this.mySplitMovementMaxSteps = other2.mySplitMovementMaxSteps;
    this.mySplitMovementStepEqualLength = other2.mySplitMovementStepEqualLength;
    this.mySplitMovementStepEqualLengthMinLength = other2.mySplitMovementStepEqualLengthMinLength;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = other2.mySplitMovementStopWhenHorizontalMovementCanceled;
    this.mySplitMovementStopWhenVerticalMovementCanceled = other2.mySplitMovementStopWhenVerticalMovementCanceled;
    this.mySplitMovementStopCallback = other2.mySplitMovementStopCallback;
    this.mySplitMovementStopReturnPrevious = other2.mySplitMovementStopReturnPrevious;
    this.myRadius = other2.myRadius;
    this.myDistanceFromFeetToIgnore = other2.myDistanceFromFeetToIgnore;
    this.myDistanceFromHeadToIgnore = other2.myDistanceFromHeadToIgnore;
    this.myPositionOffsetLocal.vec3_copy(other2.myPositionOffsetLocal);
    this.myRotationOffsetLocalQuat.quat_copy(other2.myRotationOffsetLocalQuat);
    this.myHorizontalMovementCheckEnabled = other2.myHorizontalMovementCheckEnabled;
    this.myHorizontalMovementStepEnabled = other2.myHorizontalMovementStepEnabled;
    this.myHorizontalMovementStepMaxLength = other2.myHorizontalMovementStepMaxLength;
    this.myHorizontalMovementRadialStepAmount = other2.myHorizontalMovementRadialStepAmount;
    this.myHorizontalMovementCheckDiagonalOutward = other2.myHorizontalMovementCheckDiagonalOutward;
    this.myHorizontalMovementCheckDiagonalInward = other2.myHorizontalMovementCheckDiagonalInward;
    this.myHorizontalMovementCheckStraight = other2.myHorizontalMovementCheckStraight;
    this.myHorizontalMovementCheckHorizontalBorder = other2.myHorizontalMovementCheckHorizontalBorder;
    this.myHorizontalMovementCheckVerticalStraight = other2.myHorizontalMovementCheckVerticalStraight;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = other2.myHorizontalMovementCheckVerticalDiagonalUpwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = other2.myHorizontalMovementCheckVerticalDiagonalUpwardInward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = other2.myHorizontalMovementCheckVerticalDiagonalDownwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = other2.myHorizontalMovementCheckVerticalDiagonalDownwardInward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = other2.myHorizontalMovementCheckVerticalStraightDiagonalUpward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = other2.myHorizontalMovementCheckVerticalStraightDiagonalDownward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = other2.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = other2.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other2.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other2.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other2.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other2.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    this.myHorizontalPositionCheckEnabled = other2.myHorizontalPositionCheckEnabled;
    this.myHalfConeAngle = other2.myHalfConeAngle;
    this.myHalfConeSliceAmount = other2.myHalfConeSliceAmount;
    this.myCheckConeBorder = other2.myCheckConeBorder;
    this.myCheckConeRay = other2.myCheckConeRay;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = other2.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision;
    this.myHorizontalPositionCheckVerticalDirectionType = other2.myHorizontalPositionCheckVerticalDirectionType;
    this.myVerticalMovementCheckEnabled = other2.myVerticalMovementCheckEnabled;
    this.myVerticalPositionCheckEnabled = other2.myVerticalPositionCheckEnabled;
    this.myFeetRadius = other2.myFeetRadius;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = other2.myAdjustVerticalMovementWithGroundAngleDownhill;
    this.myAdjustVerticalMovementWithGroundAngleUphill = other2.myAdjustVerticalMovementWithGroundAngleUphill;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = other2.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = other2.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = other2.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = other2.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = other2.myAdjustHorizontalMovementWithGroundAngleDownhill;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = other2.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = other2.myAdjustVerticalMovementWithCeilingAngleDownhill;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = other2.myAdjustVerticalMovementWithCeilingAngleUphill;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other2.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other2.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other2.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other2.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = other2.myAdjustHorizontalMovementWithCeilingAngleDownhill;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = other2.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle;
    this.myCheckVerticalFixedForwardEnabled = other2.myCheckVerticalFixedForwardEnabled;
    this.myCheckVerticalFixedForward.vec3_copy(other2.myCheckVerticalFixedForward);
    this.myCheckVerticalBothDirection = other2.myCheckVerticalBothDirection;
    this.mySnapOnGroundEnabled = other2.mySnapOnGroundEnabled;
    this.mySnapOnGroundExtraDistance = other2.mySnapOnGroundExtraDistance;
    this.mySnapOnCeilingEnabled = other2.mySnapOnCeilingEnabled;
    this.mySnapOnCeilingExtraDistance = other2.mySnapOnCeilingExtraDistance;
    this.myGroundPopOutEnabled = other2.myGroundPopOutEnabled;
    this.myGroundPopOutExtraDistance = other2.myGroundPopOutExtraDistance;
    this.myCeilingPopOutEnabled = other2.myCeilingPopOutEnabled;
    this.myCeilingPopOutExtraDistance = other2.myCeilingPopOutExtraDistance;
    this.myVerticalMovementReduceEnabled = other2.myVerticalMovementReduceEnabled;
    this.myGroundCircumferenceAddCenter = other2.myGroundCircumferenceAddCenter;
    this.myGroundCircumferenceSliceAmount = other2.myGroundCircumferenceSliceAmount;
    this.myGroundCircumferenceStepAmount = other2.myGroundCircumferenceStepAmount;
    this.myGroundCircumferenceRotationPerStep = other2.myGroundCircumferenceRotationPerStep;
    this.myVerticalAllowHitInsideCollisionIfOneOk = other2.myVerticalAllowHitInsideCollisionIfOneOk;
    this.myCheckHeight = other2.myCheckHeight;
    this.myCheckHeightVerticalMovement = other2.myCheckHeightVerticalMovement;
    this.myCheckHeightVerticalPosition = other2.myCheckHeightVerticalPosition;
    this.myCheckHeightTopMovement = other2.myCheckHeightTopMovement;
    this.myCheckHeightTopPosition = other2.myCheckHeightTopPosition;
    this.myCheckHeightConeOnCollision = other2.myCheckHeightConeOnCollision;
    this.myCheckHeightConeOnCollisionKeepHit = other2.myCheckHeightConeOnCollisionKeepHit;
    this.myHeightCheckStepAmountMovement = other2.myHeightCheckStepAmountMovement;
    this.myHeightCheckStepAmountPosition = other2.myHeightCheckStepAmountPosition;
    this.myCheckVerticalStraight = other2.myCheckVerticalStraight;
    this.myCheckVerticalDiagonalRayOutward = other2.myCheckVerticalDiagonalRayOutward;
    this.myCheckVerticalDiagonalRayInward = other2.myCheckVerticalDiagonalRayInward;
    this.myCheckVerticalDiagonalBorderOutward = other2.myCheckVerticalDiagonalBorderOutward;
    this.myCheckVerticalDiagonalBorderInward = other2.myCheckVerticalDiagonalBorderInward;
    this.myCheckVerticalDiagonalBorderRayOutward = other2.myCheckVerticalDiagonalBorderRayOutward;
    this.myCheckVerticalDiagonalBorderRayInward = other2.myCheckVerticalDiagonalBorderRayInward;
    this.myCheckVerticalSearchFartherVerticalHit = other2.myCheckVerticalSearchFartherVerticalHit;
    this.myGroundAngleToIgnore = other2.myGroundAngleToIgnore;
    this.myGroundAngleToIgnoreWithPerceivedAngle = other2.myGroundAngleToIgnoreWithPerceivedAngle;
    this.myCeilingAngleToIgnore = other2.myCeilingAngleToIgnore;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = other2.myCeilingAngleToIgnoreWithPerceivedAngle;
    this.myHorizontalMovementGroundAngleIgnoreHeight = other2.myHorizontalMovementGroundAngleIgnoreHeight;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = other2.myHorizontalMovementCeilingAngleIgnoreHeight;
    this.myHorizontalPositionGroundAngleIgnoreHeight = other2.myHorizontalPositionGroundAngleIgnoreHeight;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = other2.myHorizontalPositionCeilingAngleIgnoreHeight;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = other2.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = other2.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
    this.myHeight = other2.myHeight;
    this.myComputeGroundInfoEnabled = other2.myComputeGroundInfoEnabled;
    this.myComputeCeilingInfoEnabled = other2.myComputeCeilingInfoEnabled;
    this.myDistanceToBeOnGround = other2.myDistanceToBeOnGround;
    this.myDistanceToComputeGroundInfo = other2.myDistanceToComputeGroundInfo;
    this.myDistanceToBeOnCeiling = other2.myDistanceToBeOnCeiling;
    this.myDistanceToComputeCeilingInfo = other2.myDistanceToComputeCeilingInfo;
    this.myVerticalFixToBeOnGround = other2.myVerticalFixToBeOnGround;
    this.myVerticalFixToComputeGroundInfo = other2.myVerticalFixToComputeGroundInfo;
    this.myVerticalFixToBeOnCeiling = other2.myVerticalFixToBeOnCeiling;
    this.myVerticalFixToComputeCeilingInfo = other2.myVerticalFixToComputeCeilingInfo;
    this.myGroundIsBaseInsideCollisionCheckEnabled = other2.myGroundIsBaseInsideCollisionCheckEnabled;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = other2.myCeilingIsBaseInsideCollisionCheckEnabled;
    this.myIsOnGroundIfInsideHit = other2.myIsOnGroundIfInsideHit;
    this.myIsOnCeilingIfInsideHit = other2.myIsOnCeilingIfInsideHit;
    this.myIsOnGroundMaxSurfaceAngle = other2.myIsOnGroundMaxSurfaceAngle;
    this.myIsOnCeilingMaxSurfaceAngle = other2.myIsOnCeilingMaxSurfaceAngle;
    this.myFindGroundDistanceMaxOutsideDistance = other2.myFindGroundDistanceMaxOutsideDistance;
    this.myFindGroundDistanceMaxInsideDistance = other2.myFindGroundDistanceMaxInsideDistance;
    this.myFindCeilingDistanceMaxOutsideDistance = other2.myFindCeilingDistanceMaxOutsideDistance;
    this.myFindCeilingDistanceMaxInsideDistance = other2.myFindCeilingDistanceMaxInsideDistance;
    this.myAllowGroundSteepFix = other2.myAllowGroundSteepFix;
    this.myAllowCeilingSteepFix = other2.myAllowCeilingSteepFix;
    this.myMustStayOnGround = other2.myMustStayOnGround;
    this.myMustStayOnCeiling = other2.myMustStayOnCeiling;
    this.myMustStayOnValidGroundAngleDownhill = other2.myMustStayOnValidGroundAngleDownhill;
    this.myMustStayOnValidCeilingAngleDownhill = other2.myMustStayOnValidCeilingAngleDownhill;
    this.myRegatherGroundInfoOnSurfaceCheckFail = other2.myRegatherGroundInfoOnSurfaceCheckFail;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = other2.myRegatherCeilingInfoOnSurfaceCheckFail;
    this.myMustStayBelowGroundAngleDownhill = other2.myMustStayBelowGroundAngleDownhill;
    this.myMustStayBelowCeilingAngleDownhill = other2.myMustStayBelowCeilingAngleDownhill;
    this.myMustStayBelowIgnorableGroundAngleDownhill = other2.myMustStayBelowIgnorableGroundAngleDownhill;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = other2.myMustStayBelowIgnorableCeilingAngleDownhill;
    this.myMovementMustStayOnGroundHitAngle = other2.myMovementMustStayOnGroundHitAngle;
    this.myMovementMustStayOnCeilingHitAngle = other2.myMovementMustStayOnCeilingHitAngle;
    this.myTeleportMustBeOnIgnorableGroundAngle = other2.myTeleportMustBeOnIgnorableGroundAngle;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = other2.myCheckTransformMustBeOnIgnorableGroundAngle;
    this.myTeleportMustBeOnIgnorableCeilingAngle = other2.myTeleportMustBeOnIgnorableCeilingAngle;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = other2.myCheckTransformMustBeOnIgnorableCeilingAngle;
    this.myTeleportMustBeOnGroundAngle = other2.myTeleportMustBeOnGroundAngle;
    this.myCheckTransformMustBeOnGroundAngle = other2.myCheckTransformMustBeOnGroundAngle;
    this.myTeleportMustBeOnCeilingAngle = other2.myTeleportMustBeOnCeilingAngle;
    this.myCheckTransformMustBeOnCeilingAngle = other2.myCheckTransformMustBeOnCeilingAngle;
    this.myTeleportMustBeOnGround = other2.myTeleportMustBeOnGround;
    this.myCheckTransformMustBeOnGround = other2.myCheckTransformMustBeOnGround;
    this.myTeleportMustBeOnCeiling = other2.myTeleportMustBeOnCeiling;
    this.myCheckTransformMustBeOnCeiling = other2.myCheckTransformMustBeOnCeiling;
    this.mySlidingEnabled = other2.mySlidingEnabled;
    this.mySlidingHorizontalMovementCheckBetterNormal = other2.mySlidingHorizontalMovementCheckBetterNormal;
    this.mySlidingMaxAttempts = other2.mySlidingMaxAttempts;
    this.mySlidingCheckBothDirections = other2.mySlidingCheckBothDirections;
    this.mySlidingFlickeringPreventionType = other2.mySlidingFlickeringPreventionType;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = other2.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other2.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingAdjustSign90Degrees = other2.mySlidingAdjustSign90Degrees;
    this.myHorizontalBlockLayerFlags.copy(other2.myHorizontalBlockLayerFlags);
    this.myHorizontalObjectsToIgnore.pp_copy(other2.myHorizontalObjectsToIgnore);
    this.myVerticalBlockLayerFlags.copy(other2.myVerticalBlockLayerFlags);
    this.myVerticalObjectsToIgnore.pp_copy(other2.myVerticalObjectsToIgnore);
    this.myExtraMovementCheckCallback = other2.myExtraMovementCheckCallback;
    this.myExtraTeleportCheckCallback = other2.myExtraTeleportCheckCallback;
    this.myExtraCheckTransformCheckCallback = other2.myExtraCheckTransformCheckCallback;
    this.myDebugActive = other2.myDebugActive;
    this.myDebugHorizontalMovementActive = other2.myDebugHorizontalMovementActive;
    this.myDebugHorizontalPositionActive = other2.myDebugHorizontalPositionActive;
    this.myDebugVerticalMovementActive = other2.myDebugVerticalMovementActive;
    this.myDebugVerticalPositionActive = other2.myDebugVerticalPositionActive;
    this.myDebugSlidingActive = other2.myDebugSlidingActive;
    this.myDebugGroundInfoActive = other2.myDebugGroundInfoActive;
    this.myDebugCeilingInfoActive = other2.myDebugCeilingInfoActive;
    this.myDebugRuntimeParamsActive = other2.myDebugRuntimeParamsActive;
    this.myDebugMovementActive = other2.myDebugMovementActive;
  }
};
var CollisionRuntimeParams = class {
  constructor() {
    this.myOriginalPosition = vec3_create2();
    this.myNewPosition = vec3_create2();
    this.myOriginalHeight = 0;
    this.myOriginalForward = vec3_create2();
    this.myOriginalUp = vec3_create2();
    this.myOriginalMovement = vec3_create2();
    this.myFixedMovement = vec3_create2();
    this.myLastValidOriginalHorizontalMovement = vec3_create2();
    this.myLastValidOriginalVerticalMovement = vec3_create2();
    this.myLastValidSurfaceAdjustedHorizontalMovement = vec3_create2();
    this.myLastValidSurfaceAdjustedVerticalMovement = vec3_create2();
    this.myLastValidEndHorizontalMovement = vec3_create2();
    this.myLastValidEndVerticalMovement = vec3_create2();
    this.myIsOnGround = false;
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal = vec3_create2();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal = vec3_create2();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal = vec3_create2();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal = vec3_create2();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit = new RaycastHit();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit = new RaycastHit();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit = new RaycastHit();
    this.mySlidingWallNormal = new vec3_create2();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement = vec3_create2();
    this.myOriginalTeleportPosition = vec3_create2();
    this.myFixedTeleportPosition = vec3_create2();
    this.myOriginalPositionCheckPosition = vec3_create2();
    this.myFixedPositionCheckPosition = vec3_create2();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementMovementChecked = vec3_create2();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  reset() {
    this.myOriginalPosition.vec3_zero();
    this.myNewPosition.vec3_zero();
    this.myOriginalHeight = 0;
    this.myOriginalForward.vec3_zero();
    this.myOriginalUp.vec3_zero();
    this.myOriginalMovement.vec3_zero();
    this.myFixedMovement.vec3_zero();
    this.myLastValidOriginalHorizontalMovement.vec3_zero();
    this.myLastValidOriginalVerticalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_zero();
    this.myLastValidEndHorizontalMovement.vec3_zero();
    this.myLastValidEndVerticalMovement.vec3_zero();
    this.myIsOnGround = false;
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal.vec3_zero();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal.vec3_zero();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal.vec3_zero();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal.vec3_zero();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit.reset();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit.reset();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit.reset();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement.vec3_zero();
    this.mySlidingWallNormal.vec3_zero();
    this.myOriginalTeleportPosition.vec3_zero();
    this.myFixedTeleportPosition.vec3_zero();
    this.myOriginalPositionCheckPosition.vec3_zero();
    this.myFixedPositionCheckPosition.vec3_zero();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementMovementChecked.vec3_zero();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  copy(other2) {
    this.myOriginalPosition.vec3_copy(other2.myOriginalPosition);
    this.myNewPosition.vec3_copy(other2.myNewPosition);
    this.myOriginalHeight = other2.myOriginalHeight;
    this.myOriginalForward.vec3_copy(other2.myOriginalForward);
    this.myOriginalUp.vec3_copy(other2.myOriginalUp);
    this.myOriginalMovement.vec3_copy(other2.myOriginalMovement);
    this.myFixedMovement.vec3_copy(other2.myFixedMovement);
    this.myLastValidOriginalHorizontalMovement.vec3_copy(other2.myLastValidOriginalHorizontalMovement);
    this.myLastValidOriginalVerticalMovement.vec3_copy(other2.myLastValidOriginalVerticalMovement);
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(other2.myLastValidSurfaceAdjustedHorizontalMovement);
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(other2.myLastValidSurfaceAdjustedVerticalMovement);
    this.myLastValidEndHorizontalMovement.vec3_copy(other2.myLastValidEndHorizontalMovement);
    this.myLastValidEndVerticalMovement.vec3_copy(other2.myLastValidEndVerticalMovement);
    this.myIsOnGround = other2.myIsOnGround;
    this.myGroundAngle = other2.myGroundAngle;
    this.myGroundPerceivedAngle = other2.myGroundPerceivedAngle;
    this.myGroundNormal.vec3_copy(other2.myGroundNormal);
    this.myGroundHitMaxAngle = other2.myGroundHitMaxAngle;
    this.myGroundHitMaxNormal.vec3_copy(other2.myGroundHitMaxNormal);
    this.myGroundDistance = other2.myGroundDistance;
    this.myGroundIsBaseInsideCollision = other2.myGroundIsBaseInsideCollision;
    this.myIsOnCeiling = other2.myIsOnCeiling;
    this.myCeilingAngle = other2.myCeilingAngle;
    this.myCeilingPerceivedAngle = other2.myCeilingPerceivedAngle;
    this.myCeilingNormal.vec3_copy(other2.myCeilingNormal);
    this.myCeilingHitMaxAngle = other2.myCeilingHitMaxAngle;
    this.myCeilingHitMaxNormal.vec3_copy(other2.myCeilingHitMaxNormal);
    this.myCeilingDistance = other2.myCeilingDistance;
    this.myCeilingIsBaseInsideCollision = other2.myCeilingIsBaseInsideCollision;
    this.myHorizontalMovementCanceled = other2.myHorizontalMovementCanceled;
    this.myIsCollidingHorizontally = other2.myIsCollidingHorizontally;
    this.myHorizontalCollisionHit.copy(other2.myHorizontalCollisionHit);
    this.myVerticalMovementCanceled = other2.myVerticalMovementCanceled;
    this.myIsCollidingVertically = other2.myIsCollidingVertically;
    this.myVerticalCollisionHit.copy(other2.myVerticalCollisionHit);
    this.myHasSnappedOnGround = other2.myHasSnappedOnGround;
    this.myHasSnappedOnCeiling = other2.myHasSnappedOnCeiling;
    this.myHasPoppedOutGround = other2.myHasPoppedOutGround;
    this.myHasPoppedOutCeiling = other2.myHasPoppedOutCeiling;
    this.myHasReducedVerticalMovement = other2.myHasReducedVerticalMovement;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = other2.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = other2.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = other2.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = other2.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = other2.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = other2.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill;
    this.myIsSliding = other2.myIsSliding;
    this.myIsSlidingIntoOppositeDirection = other2.myIsSlidingIntoOppositeDirection;
    this.myIsSlidingFlickerPrevented = other2.myIsSlidingFlickerPrevented;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other2.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingMovementAngle = other2.mySlidingMovementAngle;
    this.mySlidingCollisionAngle = other2.mySlidingCollisionAngle;
    this.mySlidingCollisionHit.copy(other2.mySlidingCollisionHit);
    this.mySliding90DegreesSign = other2.mySliding90DegreesSign;
    this.mySlidingRecompute90DegreesSign = other2.mySlidingRecompute90DegreesSign;
    this.myLastValidIsSliding = other2.myLastValidIsSliding;
    this.mySlidingPreviousHorizontalMovement.vec3_copy(other2.mySlidingPreviousHorizontalMovement);
    this.mySlidingWallNormal.vec3_copy(other2.mySlidingWallNormal);
    this.myOriginalTeleportPosition.vec3_copy(other2.myOriginalTeleportPosition);
    this.myFixedTeleportPosition.vec3_copy(other2.myFixedTeleportPosition);
    this.myTeleportCanceled = other2.myTeleportCanceled;
    this.myIsPositionOk = other2.myIsPositionOk;
    this.myOriginalPositionCheckPosition.vec3_copy(other2.myOriginalPositionCheckPosition);
    this.myFixedPositionCheckPosition.vec3_copy(other2.myFixedPositionCheckPosition);
    this.myIsTeleport = other2.myIsTeleport;
    this.myIsMove = other2.myIsMove;
    this.myIsPositionCheck = other2.myIsPositionCheck;
    this.myIsPositionCheckAllowAdjustments = other2.myIsPositionCheckAllowAdjustments;
    this.mySplitMovementSteps = other2.mySplitMovementSteps;
    this.mySplitMovementStepsPerformed = other2.mySplitMovementStepsPerformed;
    this.mySplitMovementStop = other2.mySplitMovementStop;
    this.mySplitMovementMovementChecked.vec3_copy(other2.mySplitMovementMovementChecked);
    this.myRealIsOnGround = other2.myRealIsOnGround;
    this.myRealIsOnCeiling = other2.myRealIsOnCeiling;
  }
};

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check.js
function generate360TeleportParamsFromMovementParams(movementParams, outTeleportParams = new CollisionCheckParams()) {
  outTeleportParams.copy(movementParams);
  outTeleportParams.myHalfConeAngle = 180;
  outTeleportParams.myHalfConeSliceAmount = Math.round(outTeleportParams.myHalfConeAngle / movementParams.myHalfConeAngle * movementParams.myHalfConeSliceAmount);
  outTeleportParams.myCheckHorizontalFixedForwardEnabled = true;
  outTeleportParams.myCheckHorizontalFixedForward = vec3_create2(0, 0, 1);
  return outTeleportParams;
}
var CollisionCheckUtils = {
  generate360TeleportParamsFromMovementParams
};
var CollisionCheck = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
    this._myRaycastSetup = new RaycastSetup(this._myEngine.physics);
    this._myRaycastResult = new RaycastResults();
    this._myFixRaycastResult = new RaycastResults();
    this._myBackupRaycastHit = new RaycastHit();
    this._myPrevCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myCheckBetterSlidingNormalCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myInternalSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOppositeDirectionCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOnVerticalCheckCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myDebugActive = false;
    this._myTotalRaycasts = 0;
    this._myTotalRaycastsMax = 0;
  }
  move(movement, transformQuat, collisionCheckParams, collisionRuntimeParams) {
    this._move(movement, transformQuat, collisionCheckParams, collisionRuntimeParams);
  }
  teleport(position, transformQuat, collisionCheckParams, collisionRuntimeParams) {
    this._teleport(position, transformQuat, collisionCheckParams, collisionRuntimeParams);
  }
  positionCheck(allowFix, transformQuat, collisionCheckParams, collisionRuntimeParams) {
    this._positionCheck(allowFix, transformQuat, collisionCheckParams, collisionRuntimeParams);
  }
  updateSurfaceInfo(transformQuat, collisionCheckParams, collisionRuntimeParams) {
    this._updateSurfaceInfo(transformQuat, collisionCheckParams, collisionRuntimeParams);
  }
  _debugMovement(movement, fixedMovement, feetPosition, up, collisionCheckParams) {
    let originalHorizontalMovement = movement.vec3_removeComponentAlongAxis(up);
    let horizontalMovement = fixedMovement.vec3_removeComponentAlongAxis(up);
    let verticalMovement = fixedMovement.vec3_componentAlongAxis(up);
    let feetPositionPlusOffset = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-3));
    if (!originalHorizontalMovement.vec3_isZero()) {
      originalHorizontalMovement.vec3_normalize(originalHorizontalMovement);
      getDebugVisualManager2(this._myEngine).drawArrow(0, feetPositionPlusOffset, originalHorizontalMovement, 0.2, vec4_create2(0.5, 0.5, 1, 1));
    }
    if (!horizontalMovement.vec3_isZero()) {
      horizontalMovement.vec3_normalize(horizontalMovement);
      getDebugVisualManager2(this._myEngine).drawArrow(0, feetPositionPlusOffset, horizontalMovement, 0.2, vec4_create2(0, 0, 1, 1));
    }
    if (!verticalMovement.vec3_isZero()) {
      verticalMovement.vec3_normalize(verticalMovement);
      getDebugVisualManager2(this._myEngine).drawArrow(0, feetPosition, verticalMovement, 0.2, vec4_create2(0, 0, 1, 1));
    }
  }
  _debugRuntimeParams(collisionRuntimeParams) {
    if (collisionRuntimeParams.myHorizontalCollisionHit.isValid()) {
      getDebugVisualManager2(this._myEngine).drawArrow(
        0,
        collisionRuntimeParams.myHorizontalCollisionHit.myPosition,
        collisionRuntimeParams.myHorizontalCollisionHit.myNormal,
        0.2,
        vec4_create2(1, 0, 0, 1)
      );
    }
    if (collisionRuntimeParams.mySlidingCollisionHit.isValid()) {
      getDebugVisualManager2(this._myEngine).drawArrow(
        0,
        collisionRuntimeParams.mySlidingCollisionHit.myPosition,
        collisionRuntimeParams.mySlidingCollisionHit.myNormal,
        0.2,
        vec4_create2(1, 0, 0, 1)
      );
    }
    if (collisionRuntimeParams.myVerticalCollisionHit.isValid()) {
      getDebugVisualManager2(this._myEngine).drawArrow(
        0,
        collisionRuntimeParams.myVerticalCollisionHit.myPosition,
        collisionRuntimeParams.myVerticalCollisionHit.myNormal,
        0.2,
        vec4_create2(1, 0, 0, 1)
      );
    }
  }
  _raycastAndDebug(origin, direction, distance, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheck.prototype._raycastAndDebug = function() {
  let tempRaycastResult = new RaycastResults();
  return function _raycastAndDebug(origin, direction, distance, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
    this._myRaycastSetup.myOrigin.vec3_copy(origin);
    this._myRaycastSetup.myDirection.vec3_copy(direction);
    this._myRaycastSetup.myDistance = distance;
    if (isHorizontal) {
      this._myRaycastSetup.myBlockLayerFlags.copy(collisionCheckParams.myHorizontalBlockLayerFlags);
      this._myRaycastSetup.myObjectsToIgnore = collisionCheckParams.myHorizontalObjectsToIgnore;
    } else {
      this._myRaycastSetup.myBlockLayerFlags.copy(collisionCheckParams.myVerticalBlockLayerFlags);
      this._myRaycastSetup.myObjectsToIgnore = collisionCheckParams.myVerticalObjectsToIgnore;
    }
    this._myRaycastSetup.myIgnoreHitsInsideCollision = ignoreHitsInsideCollision;
    let raycastResult2 = null;
    if (true) {
      raycastResult2 = PhysicsUtils.raycast(this._myRaycastSetup, this._myRaycastResult);
    } else {
      let raycastAlways = false;
      if (raycastAlways || !this._myRaycastResult.isColliding()) {
        raycastResult2 = PhysicsUtils.raycast(this._myRaycastSetup, tempRaycastResult);
      }
      if (!this._myRaycastResult.isColliding() && tempRaycastResult.isColliding()) {
        this._myRaycastResult.copy(tempRaycastResult);
      }
      raycastResult2 = this._myRaycastResult;
    }
    this._myTotalRaycasts++;
    if (this._myDebugActive) {
      getDebugVisualManager2(this._myEngine).drawRaycast(0, raycastResult2);
    }
    return raycastResult2;
  };
}();

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_movement_check.js
CollisionCheck.prototype._move = function() {
  let transformUp = vec3_create2();
  let transformForward = vec3_create2();
  let feetPosition = vec3_create2();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let horizontalMovement = vec3_create2();
  let verticalMovement = vec3_create2();
  let movementStep = vec3_create2();
  let currentMovementStep = vec3_create2();
  let movementChecked = vec3_create2();
  let fixedMovement = vec3_create2();
  let newFeetPosition = vec3_create2();
  let fixedMovementStep = vec3_create2();
  let previousCollisionRuntimeParams = new CollisionRuntimeParams();
  let previousFixedMovement = vec3_create2();
  let previousMovementChecked = vec3_create2();
  return function _move(movement, transformQuat, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat, offsetTransformQuat);
    if (transformQuat.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (!movement.vec3_isZero(1e-5) && collisionCheckParams.mySplitMovementEnabled) {
      let equalStepLength = movement.vec3_length() / collisionCheckParams.mySplitMovementMaxSteps;
      if (!collisionCheckParams.mySplitMovementStepEqualLength || equalStepLength < collisionCheckParams.mySplitMovementStepEqualLengthMinLength) {
        let maxLength = collisionCheckParams.mySplitMovementStepEqualLength ? collisionCheckParams.mySplitMovementStepEqualLengthMinLength : collisionCheckParams.mySplitMovementMaxLength;
        movementStepAmount = Math.ceil(movement.vec3_length() / maxLength);
        if (movementStepAmount > 1) {
          movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
          movementStepAmount = collisionCheckParams.mySplitMovementMaxStepsEnabled ? Math.min(movementStepAmount, collisionCheckParams.mySplitMovementMaxSteps) : movementStepAmount;
        }
        movementStepAmount = Math.max(1, movementStepAmount);
        if (movementStepAmount == 1) {
          movementStep.vec3_copy(movement);
        }
      } else {
        movementStepAmount = collisionCheckParams.mySplitMovementMaxSteps;
        if (movementStepAmount > 1) {
          movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
        }
      }
    }
    fixedMovement.vec3_zero();
    movementChecked.vec3_zero();
    previousCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousFixedMovement.vec3_copy(fixedMovement);
    previousMovementChecked.vec3_copy(movementChecked);
    let stepsPerformed = 0;
    let splitMovementStop = false;
    for (let i = 0; i < movementStepAmount; i++) {
      if (movementStepAmount == 1 || i != movementStepAmount - 1) {
        currentMovementStep.vec3_copy(movementStep);
      } else {
        currentMovementStep = movement.vec3_sub(movementChecked, currentMovementStep);
      }
      newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
      fixedMovementStep.vec3_zero();
      fixedMovementStep = this._moveStep(currentMovementStep, newFeetPosition, transformUp, transformForward, height, true, collisionCheckParams, collisionRuntimeParams, fixedMovementStep);
      fixedMovement.vec3_add(fixedMovementStep, fixedMovement);
      movementChecked = movementChecked.vec3_add(movementStep, movementChecked);
      stepsPerformed = i + 1;
      if (collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled || collisionRuntimeParams.myHorizontalMovementCanceled && collisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled || collisionRuntimeParams.myVerticalMovementCanceled && collisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled || collisionCheckParams.mySplitMovementStopCallback != null && collisionCheckParams.mySplitMovementStopCallback(collisionRuntimeParams)) {
        if (collisionCheckParams.mySplitMovementStopReturnPrevious) {
          collisionRuntimeParams.copy(previousCollisionRuntimeParams);
          fixedMovement.vec3_copy(previousFixedMovement);
          movementChecked.vec3_copy(previousMovementChecked);
          stepsPerformed -= 1;
        }
        splitMovementStop = true;
        break;
      }
      previousCollisionRuntimeParams.copy(collisionRuntimeParams);
      previousFixedMovement.vec3_copy(fixedMovement);
      previousMovementChecked.vec3_copy(movementChecked);
    }
    collisionRuntimeParams.mySplitMovementSteps = movementStepAmount;
    collisionRuntimeParams.mySplitMovementStepsPerformed = stepsPerformed;
    collisionRuntimeParams.mySplitMovementStop = splitMovementStop;
    collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movementChecked);
    collisionRuntimeParams.myOriginalUp = transformQuat.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
    collisionRuntimeParams.myFixedMovement.vec3_copy(fixedMovement);
    collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
    collisionRuntimeParams.myIsMove = true;
  };
}();
CollisionCheck.prototype._moveStep = function() {
  let horizontalMovement = vec3_create2();
  let verticalMovement = vec3_create2();
  let fixedHorizontalMovement = vec3_create2();
  let fixedVerticalMovement = vec3_create2();
  let horizontalDirection = vec3_create2();
  let forwardForHorizontal = vec3_create2();
  let forwardForVertical = vec3_create2();
  let forwardForPerceivedAngle = vec3_create2();
  let newFeetPosition = vec3_create2();
  let surfaceAdjustedVerticalMovement = vec3_create2();
  let surfaceAdjustedHorizontalMovement = vec3_create2();
  let fixedMovement = vec3_create2();
  let zAxis = vec3_create2(0, 0, 1);
  let xAxis = vec3_create2(1, 0, 0);
  return function _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    if (horizontalMovement.vec3_isZero(1e-6)) {
      horizontalMovement.vec3_zero();
    }
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    if (verticalMovement.vec3_isZero(1e-6)) {
      verticalMovement.vec3_zero();
    }
    if (horizontalMovement.vec3_isZero()) {
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    surfaceAdjustedHorizontalMovement = this._adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedHorizontalMovement);
    if (surfaceAdjustedHorizontalMovement.vec3_isZero(1e-5)) {
      surfaceAdjustedHorizontalMovement.vec3_zero();
    }
    this._syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
    {
      forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForHorizontal = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForHorizontal);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForHorizontal = horizontalMovement.vec3_normalize(forwardForHorizontal);
        } else {
          forwardForHorizontal.vec3_copy(transformForward);
        }
      } else {
        if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForHorizontal.vec3_copy(xAxis);
          } else {
            forwardForHorizontal.vec3_copy(zAxis);
          }
        }
        forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
        forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
        if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
          forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
        }
      }
      fixedHorizontalMovement.vec3_zero();
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        fixedHorizontalMovement = this._horizontalCheck(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
        if (collisionCheckParams.mySlidingEnabled && collisionRuntimeParams.myIsCollidingHorizontally && this._isSlidingNormalValid(surfaceAdjustedHorizontalMovement, transformUp, collisionRuntimeParams)) {
          fixedHorizontalMovement = this._horizontalSlide(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, fixedHorizontalMovement);
        } else {
        }
      }
      if (fixedHorizontalMovement.vec3_isZero(1e-6)) {
        fixedHorizontalMovement.vec3_zero();
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && fixedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
      }
    }
    {
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (fixedHorizontalMovement.vec3_isZero()) {
          if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
            forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
          } else if (!horizontalMovement.vec3_isZero()) {
            forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
          } else {
            forwardForVertical.vec3_copy(transformForward);
          }
        } else {
          forwardForVertical = fixedHorizontalMovement.vec3_normalize(forwardForVertical);
        }
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      surfaceAdjustedVerticalMovement = this._adjustVerticalMovementWithSurface(fixedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedVerticalMovement);
      newFeetPosition = feetPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      let originalMovementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(transformUp), 0);
      fixedVerticalMovement.vec3_zero();
      fixedVerticalMovement = this._verticalCheck(surfaceAdjustedVerticalMovement, originalMovementSign, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (fixedVerticalMovement.vec3_isZero(1e-6)) {
        fixedVerticalMovement.vec3_zero();
      }
    }
    outFixedMovement.vec3_zero();
    if (!collisionRuntimeParams.myIsCollidingVertically) {
      outFixedMovement = fixedHorizontalMovement.vec3_add(fixedVerticalMovement, outFixedMovement);
    } else {
      collisionRuntimeParams.myHorizontalMovementCanceled = true;
      collisionRuntimeParams.myVerticalMovementCanceled = true;
      fixedHorizontalMovement.vec3_zero();
      fixedVerticalMovement.vec3_zero();
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
        } else {
          forwardForVertical.vec3_copy(transformForward);
        }
      }
    }
    newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
    forwardForPerceivedAngle.vec3_copy(transformForward);
    if (!fixedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = fixedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!horizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
    if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && !collisionRuntimeParams.myHorizontalMovementCanceled) {
      let surfaceCheckOk = this._postSurfaceCheck(fixedHorizontalMovement, fixedVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
      if (!surfaceCheckOk) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
        collisionRuntimeParams.myVerticalMovementCanceled = true;
        fixedHorizontalMovement.vec3_zero();
        fixedVerticalMovement.vec3_zero();
        outFixedMovement.vec3_zero();
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else {
          forwardForPerceivedAngle.vec3_copy(transformForward);
        }
        if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
          collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
          collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
          collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
          collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
          collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
          collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
        }
      }
    }
    if (collisionCheckParams.myExtraMovementCheckCallback != null) {
      fixedMovement.vec3_copy(outFixedMovement);
      outFixedMovement = collisionCheckParams.myExtraMovementCheckCallback(
        movement,
        fixedMovement,
        feetPosition,
        transformUp,
        transformForward,
        height,
        collisionCheckParams,
        this._myPrevCollisionRuntimeParams,
        collisionRuntimeParams,
        outFixedMovement
      );
      fixedHorizontalMovement = outFixedMovement.vec3_removeComponentAlongAxis(transformUp, fixedHorizontalMovement);
      fixedVerticalMovement = outFixedMovement.vec3_componentAlongAxis(transformUp, fixedVerticalMovement);
    }
    {
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myIsSliding && !fixedHorizontalMovement.vec3_isZero()) {
          collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
        }
      }
      if (!horizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(horizontalMovement);
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(surfaceAdjustedHorizontalMovement);
      }
      if (!verticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(verticalMovement);
      }
      if (!surfaceAdjustedVerticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(surfaceAdjustedVerticalMovement);
      }
      if (!fixedHorizontalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidIsSliding = collisionRuntimeParams.myIsSliding;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = false;
        collisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(fixedHorizontalMovement);
        if (!collisionRuntimeParams.myIsSliding) {
        } else {
        }
      } else {
      }
      if (!fixedVerticalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(fixedVerticalMovement);
      }
    }
    let moveStepFixed = false;
    if (!collisionRuntimeParams.myHorizontalMovementCanceled && !fixedHorizontalMovement.vec3_isZero(1e-6)) {
      horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
      let surfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, this._myPrevCollisionRuntimeParams);
      if (surfaceTooSteepResults[0] || surfaceTooSteepResults[1]) {
        horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
        let newSurfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, collisionRuntimeParams);
        if (surfaceTooSteepResults[0] && newSurfaceTooSteepResults[0] || surfaceTooSteepResults[1] && newSurfaceTooSteepResults[1] || !allowSurfaceSteepFix || surfaceTooSteepResults[0] && !collisionCheckParams.myAllowGroundSteepFix || surfaceTooSteepResults[1] && !collisionCheckParams.myAllowCeilingSteepFix) {
          outFixedMovement.vec3_zero();
          collisionRuntimeParams.copy(this._myPrevCollisionRuntimeParams);
          this._moveStep(movement, feetPosition, transformUp, transformForward, height, false, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
          moveStepFixed = true;
        }
      }
    }
    if (!moveStepFixed) {
      if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugMovementActive) {
        this._debugMovement(movement, outFixedMovement, newFeetPosition, transformUp, collisionCheckParams);
      }
      if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugRuntimeParamsActive) {
        this._debugRuntimeParams(collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._syncCollisionRuntimeParamsWithPrevious = function() {
  let previousFixedHorizontalMovement = vec3_create2();
  return function _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    collisionRuntimeParams.myIsSlidingFlickerPrevented = previousCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalVerticalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    collisionRuntimeParams.myLastValidIsSliding = previousCollisionRuntimeParams.myLastValidIsSliding;
    collisionRuntimeParams.mySliding90DegreesSign = previousCollisionRuntimeParams.mySliding90DegreesSign;
    collisionRuntimeParams.mySlidingRecompute90DegreesSign = previousCollisionRuntimeParams.mySlidingRecompute90DegreesSign;
    if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
      let angleWithPreviousThreshold = 0.5;
      if (!previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_isZero() && !surfaceAdjustedHorizontalMovement.vec3_isZero() && surfaceAdjustedHorizontalMovement.vec3_angle(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement) > angleWithPreviousThreshold) {
        if (!previousCollisionRuntimeParams.myLastValidIsSliding) {
          let angleSigned = surfaceAdjustedHorizontalMovement.vec3_angleSigned(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement, up);
          let angleSignedThreshold = 10;
          if (Math.abs(angleSigned) < 180 - angleSignedThreshold) {
            collisionRuntimeParams.mySliding90DegreesSign = Math.pp_sign(angleSigned);
          }
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
      }
    }
    previousFixedHorizontalMovement = previousCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(up, previousFixedHorizontalMovement);
    if (previousFixedHorizontalMovement.vec3_isZero(1e-6)) {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    } else {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousFixedHorizontalMovement);
    }
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_move", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_moveStep", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_syncCollisionRuntimeParamsWithPrevious", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_teleport_check.js
CollisionCheck.prototype._teleport = function() {
  let transformUp = vec3_create2();
  let transformForward = vec3_create2();
  let feetPosition = vec3_create2();
  let originalFeetPosition = vec3_create2();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let feetPositionOffsetToOriginal = vec3_create2();
  let offsetTeleportPosition = vec3_create2();
  let zero = vec3_create2();
  let forwardForHorizontal = vec3_create2();
  let forwardForVertical = vec3_create2();
  let forwardForPerceivedAngle = vec3_create2();
  let fixedHorizontalMovement = vec3_create2();
  let fixedVerticalMovement = vec3_create2();
  let newFeetPosition = vec3_create2();
  let endPosition = vec3_create2();
  let zAxis = vec3_create2(0, 0, 1);
  let xAxis = vec3_create2(1, 0, 0);
  return function _teleport(teleportPosition, transformQuat, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat, offsetTransformQuat);
    if (transformQuat.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    offsetTeleportPosition.vec3_copy(teleportPosition);
    originalFeetPosition = transformQuat.quat2_getPosition(originalFeetPosition);
    feetPositionOffsetToOriginal = originalFeetPosition.vec3_sub(feetPosition, feetPositionOffsetToOriginal);
    if (feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
      feetPositionOffsetToOriginal.vec3_zero();
    } else {
      offsetTeleportPosition = offsetTeleportPosition.vec3_sub(feetPositionOffsetToOriginal, offsetTeleportPosition);
    }
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
    if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
      forwardForHorizontal.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForHorizontal.vec3_copy(xAxis);
        } else {
          forwardForHorizontal.vec3_copy(zAxis);
        }
      }
      forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
      forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
      if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
        forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      }
    }
    fixedHorizontalMovement = this._horizontalCheck(zero, offsetTeleportPosition, height, transformUp, forwardForHorizontal, false, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      newFeetPosition = offsetTeleportPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        forwardForVertical.vec3_copy(transformForward);
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      let downward = -1;
      fixedVerticalMovement = this._verticalCheck(zero, downward, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (!collisionRuntimeParams.myIsCollidingVertically) {
        newFeetPosition = newFeetPosition.vec3_add(fixedVerticalMovement, newFeetPosition);
        forwardForPerceivedAngle.vec3_copy(transformForward);
        if (collisionCheckParams.myComputeGroundInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        }
        if (!collisionRuntimeParams.myIsOnGround) {
          if (collisionCheckParams.myTeleportMustBeOnGround && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnGround && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (!collisionRuntimeParams.myIsOnCeiling) {
          if (collisionCheckParams.myTeleportMustBeOnCeiling && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnCeiling && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnGround) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnGroundAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnGroundAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnCeiling) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnCeilingAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnCeilingAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myTeleportCanceled) {
          if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
            collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
            collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
            collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
          }
          if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
            collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
            collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
            collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
          }
        }
      } else {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
    } else {
      collisionRuntimeParams.myTeleportCanceled = true;
    }
    if (!isPositionCheck) {
      if (collisionCheckParams.myExtraTeleportCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraTeleportCheckCallback(
          offsetTeleportPosition,
          endPosition,
          feetPosition,
          transformUp,
          transformForward,
          height,
          collisionCheckParams,
          this._myPrevCollisionRuntimeParams,
          collisionRuntimeParams,
          newFeetPosition
        );
      }
    } else {
      if (collisionCheckParams.myExtraCheckTransformCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraCheckTransformCheckCallback(
          endPosition,
          feetPosition,
          transformUp,
          transformForward,
          height,
          collisionCheckParams,
          this._myPrevCollisionRuntimeParams,
          collisionRuntimeParams,
          newFeetPosition
        );
      }
    }
    collisionRuntimeParams.myOriginalUp = transformQuat.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(teleportPosition);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(newFeetPosition);
      if (!feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
        collisionRuntimeParams.myFixedTeleportPosition = collisionRuntimeParams.myFixedTeleportPosition.vec3_add(feetPositionOffsetToOriginal, collisionRuntimeParams.myFixedTeleportPosition);
      }
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    } else {
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myOriginalPosition);
    }
    collisionRuntimeParams.myIsTeleport = true;
    if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugRuntimeParamsActive) {
      this._debugRuntimeParams(collisionRuntimeParams);
    }
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_teleport", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_position_check.js
CollisionCheck.prototype._positionCheck = function() {
  let feetPosition = vec3_create2();
  return function _positionCheck(allowAdjustments, transformQuat, collisionCheckParams, collisionRuntimeParams) {
    feetPosition = transformQuat.quat2_getPosition(feetPosition);
    this._teleport(feetPosition, transformQuat, collisionCheckParams, collisionRuntimeParams, true);
    collisionRuntimeParams.myIsPositionOk = !collisionRuntimeParams.myTeleportCanceled;
    collisionRuntimeParams.myIsPositionCheck = true;
    collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
    collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowAdjustments;
    if (!allowAdjustments) {
      collisionRuntimeParams.myIsPositionOk = collisionRuntimeParams.myIsPositionOk && collisionRuntimeParams.myOriginalPositionCheckPosition.vec_equals(collisionRuntimeParams.myFixedPositionCheckPosition, 1e-5);
    }
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
    collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
    collisionRuntimeParams.myTeleportCanceled = false;
    collisionRuntimeParams.myIsTeleport = false;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_positionCheck", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_check.js
CollisionCheck.prototype._horizontalCheck = function() {
  let fixedFeetPosition = vec3_create2();
  let newFixedFeetPosition = vec3_create2();
  let newFeetPosition = vec3_create2();
  let horizontalDirection = vec3_create2();
  return function _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingHorizontally = false;
    collisionRuntimeParams.myHorizontalCollisionHit.reset();
    outFixedMovement.vec3_zero();
    horizontalDirection = movement.vec3_normalize(horizontalDirection);
    let surfaceTooSteepResults = this._surfaceTooSteep(up, horizontalDirection, collisionCheckParams, previousCollisionRuntimeParams);
    if (movement.vec3_isZero(1e-6) || (!surfaceTooSteepResults[0] || allowSurfaceSteepFix && collisionCheckParams.myAllowGroundSteepFix) && (!surfaceTooSteepResults[1] || allowSurfaceSteepFix && collisionCheckParams.myAllowCeilingSteepFix)) {
      fixedFeetPosition = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-4, fixedFeetPosition), fixedFeetPosition);
      let fixedHeight = Math.max(0, height - collisionCheckParams.myDistanceFromFeetToIgnore - collisionCheckParams.myDistanceFromHeadToIgnore - 1e-4 * 2);
      let canMove = true;
      if (collisionCheckParams.myHorizontalMovementCheckEnabled && !movement.vec3_isZero(1e-6)) {
        canMove = this._horizontalMovementCheck(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, collisionCheckParams, collisionRuntimeParams);
      }
      if (canMove) {
        if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
          newFixedFeetPosition = fixedFeetPosition.vec3_add(movement, newFixedFeetPosition);
          newFeetPosition = feetPosition.vec3_add(movement, newFeetPosition);
          let canStay = this._horizontalPositionCheck(newFeetPosition, height, newFixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
          if (canStay) {
            outFixedMovement.vec3_copy(movement);
          }
          if (outFixedMovement.vec3_isZero(1e-6)) {
            outFixedMovement.vec3_zero();
          }
        } else {
          outFixedMovement.vec3_copy(movement);
        }
      } else if (!avoidSlidingExtraCheck && collisionCheckParams.mySlidingEnabled && collisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal) {
        this._horizontalCheckBetterSlideNormal(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._horizontalCheckRaycast = function() {
  let direction = vec3_create2();
  let fixedFeetPosition = vec3_create2();
  let fixedHitPosition = vec3_create2();
  return function _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
    let origin = startPosition;
    direction = endPosition.vec3_sub(origin, direction);
    if (movementDirection != null && !direction.vec3_isConcordant(movementDirection)) {
      direction.vec3_negate(direction);
      origin = endPosition;
    }
    let distance = direction.vec3_length();
    direction.vec3_normalize(direction);
    let raycastResult2 = this._raycastAndDebug(origin, direction, distance, ignoreHitsInsideCollision, true, collisionCheckParams, collisionRuntimeParams);
    let isOk = true;
    if (raycastResult2.isColliding()) {
      let hitsToControl = checkAllHits ? raycastResult2.myHits.length : 1;
      let validHitIndex = 0;
      for (let i = 0; i < hitsToControl; i++) {
        let hit = raycastResult2.myHits[i];
        if ((ignoreGroundAngleCallback == null || !ignoreGroundAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore)) && (ignoreCeilingAngleCallback == null || !ignoreCeilingAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore))) {
          isOk = false;
          validHitIndex = i;
          break;
        }
      }
      if (!isOk && validHitIndex > 0) {
        for (let i = 0; i < validHitIndex; i++) {
          raycastResult2.removeHit(0);
        }
      }
    }
    if (!isOk && fixHitOnCollision) {
      let hitPosition = raycastResult2.myHits[0].myPosition;
      fixedFeetPosition = feetPosition.vec3_copyComponentAlongAxis(hitPosition, up, fixedFeetPosition);
      fixedHitPosition.vec3_copy(hitPosition);
      let directionOffsetEpsilonValue = 1e-4;
      direction = direction.vec3_componentAlongAxis(up, direction);
      if (!direction.vec3_isZero(1e-6)) {
        direction.vec3_normalize(direction);
        direction.vec3_scale(directionOffsetEpsilonValue, direction);
        fixedFeetPosition.vec3_add(direction, fixedFeetPosition);
        fixedHitPosition.vec3_add(direction, fixedHitPosition);
      }
      direction = fixedHitPosition.vec3_sub(fixedFeetPosition, direction);
      direction.vec3_normalize(direction);
      direction.vec3_scale(directionOffsetEpsilonValue, direction);
      fixedHitPosition = fixedHitPosition.vec3_add(direction, fixedHitPosition);
      let swapRaycastResult = this._myRaycastResult;
      this._myRaycastResult = this._myFixRaycastResult;
      isOk = this._horizontalCheckRaycast(
        fixedFeetPosition,
        fixedHitPosition,
        null,
        up,
        false,
        ignoreGroundAngleCallback,
        ignoreCeilingAngleCallback,
        feetPosition,
        false,
        collisionCheckParams,
        collisionRuntimeParams
      );
      if (this._myRaycastResult.isColliding()) {
        this._myFixRaycastResult = swapRaycastResult;
      } else {
        isOk = false;
        this._myRaycastResult = swapRaycastResult;
      }
    }
    return isOk;
  };
}();
CollisionCheck.prototype._ignoreSurfaceAngle = function() {
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  let movementDirection = vec3_create2();
  let hitDirection = vec3_create2();
  let hitMovement = vec3_create2();
  let projectAlongAxis = vec3_create2();
  return function _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
    let isIgnorable = false;
    let surfaceIgnoreHeight = null;
    let groundIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
    let ceilingIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight;
    if (isGround && groundIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(groundIgnoreHeight + 2e-4, 0, height);
    } else if (!isGround && ceilingIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(height - ceilingIgnoreHeight - 2e-4, 0, height);
    }
    let surfaceIgnoreMaxMovementLeft = null;
    if (isMovementCheck) {
      if (isGround && collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      } else if (!isGround && collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
      }
    }
    if (!hit.myIsInsideCollision) {
      movementDirection = movementOrForward.vec3_normalize(movementDirection);
      let surfaceAngle = hit.myNormal.vec3_angle(up);
      if (!isGround) {
        surfaceAngle = 180 - surfaceAngle;
      }
      if (isGround && collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(
            hit.myNormal,
            movementDirection,
            up,
            true
          );
          surfaceAngle = Math.abs(perceivedAngle);
        }
      } else if (!isGround && collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(
            hit.myNormal,
            movementDirection,
            up,
            false
          );
          surfaceAngle = Math.abs(perceivedAngle);
        }
      }
      if (isGround && (collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) || !isGround && (collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4)) {
        if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
          let surfaceHeightCheckOk = true;
          let maxMovementLeftCheckOk = true;
          if (surfaceIgnoreHeight != null) {
            surfaceHeightCheckOk = false;
            let feetPositionUp = feetPosition.vec3_valueAlongAxis(up);
            let hitUp = hit.myPosition.vec3_valueAlongAxis(up);
            let hitHeight = hitUp - feetPositionUp;
            if (isGround && hitHeight <= surfaceIgnoreHeight || !isGround && hitHeight >= surfaceIgnoreHeight) {
              surfaceHeightCheckOk = true;
            } else {
            }
          }
          if (surfaceHeightCheckOk && isMovementCheck) {
            if (surfaceIgnoreMaxMovementLeft != null) {
              let movementLength = movementOrForward.vec3_length();
              if (movementLength > surfaceIgnoreMaxMovementLeft) {
                maxMovementLeftCheckOk = false;
                let hitPosition = hit.myPosition;
                let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
                hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
                if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
                } else {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
                }
                hitMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, hitMovement);
                let hitMovementLength = hitMovement.vec3_length();
                let movementLeft = movementLength - hitMovementLength;
                if (movementLeft <= surfaceIgnoreMaxMovementLeft) {
                  maxMovementLeftCheckOk = true;
                } else {
                }
              }
            }
          }
          if (surfaceHeightCheckOk && maxMovementLeftCheckOk) {
            isIgnorable = true;
          }
        }
      }
    } else if (ignoreHitsInsideCollisionIfObjectToIgnore) {
      if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
        isIgnorable = true;
      }
    }
    if (isIgnorable) {
      if (outIgnoredObjects != null) {
        outIgnoredObjects.pp_pushUnique(hit.myObject, objectsEqualCallback);
      }
    }
    return isIgnorable;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalCheckRaycast", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_ignoreSurfaceAngle", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_sliding.js
CollisionCheck.prototype._horizontalSlide = function() {
  let previousHorizontalMovement = vec3_create2();
  return function _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    this._mySlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    outSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, outSlideMovement);
    if (collisionCheckParams.mySlidingCheckBothDirections) {
      this._horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, this._myPrevCollisionRuntimeParams.myIsSliding, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement);
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding && collisionCheckParams.mySlidingFlickeringPreventionType > 0) {
      let isFlickering = this._horizontalSlideFlickerCheck(movement, outSlideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams);
      this._mySlidingCollisionRuntimeParams.myIsSliding = !isFlickering;
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding) {
      let backupFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
      collisionRuntimeParams.copy(this._mySlidingCollisionRuntimeParams);
      collisionRuntimeParams.myIsSlidingFlickerPrevented = backupFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    } else {
      collisionRuntimeParams.myIsSlidingFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
      outSlideMovement.vec3_zero();
    }
    return outSlideMovement;
  };
}();
CollisionCheck.prototype._horizontalSlideCheckOpposite = function() {
  let horizontalCollisionNormal = vec3_create2();
  let oppositeSlideMovement = vec3_create2();
  let hitNormal = vec3_create2();
  return function _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    horizontalCollisionNormal = preSlideCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, horizontalCollisionNormal);
    horizontalCollisionNormal.vec3_normalize(horizontalCollisionNormal);
    let angleNormalWithMovementThreshold = 20;
    if (horizontalCollisionNormal.vec3_angle(movement) > 180 - angleNormalWithMovementThreshold) {
      return;
    } else if (previousIsSliding && postSlideCollisionRuntimeParams.myIsSliding && outSlideMovement.vec3_isConcordant(previousHorizontalMovement)) {
      return;
    } else {
    }
    this._mySlidingOppositeDirectionCollisionRuntimeParams.copy(preSlideCollisionRuntimeParams);
    oppositeSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingOppositeDirectionCollisionRuntimeParams, previousCollisionRuntimeParams, true, oppositeSlideMovement);
    if (this._mySlidingOppositeDirectionCollisionRuntimeParams.myIsSliding) {
      let isOppositeBetter = false;
      if (postSlideCollisionRuntimeParams.myIsSliding) {
        if (movement.vec3_angle(oppositeSlideMovement) < movement.vec3_angle(outSlideMovement) - 1e-4) {
          isOppositeBetter = true;
        } else {
          if (Math.abs(movement.vec3_angle(oppositeSlideMovement) - movement.vec3_angle(outSlideMovement)) <= 1e-4) {
            if (previousHorizontalMovement.vec3_angle(oppositeSlideMovement) < previousHorizontalMovement.vec3_angle(outSlideMovement) - 1e-4) {
              let angleNormalWithMovementThreshold2 = 5;
              if (horizontalCollisionNormal.vec3_angle(movement) < 90 + angleNormalWithMovementThreshold2) {
                isOppositeBetter = true;
              }
            }
          }
        }
      } else {
        let angleEpsilon = 1e-3;
        if (movement.vec3_isConcordant(oppositeSlideMovement) && movement.vec3_angle(oppositeSlideMovement) < 90 - angleEpsilon) {
          isOppositeBetter = true;
        } else {
        }
      }
      if (isOppositeBetter) {
        outSlideMovement.vec3_copy(oppositeSlideMovement);
        postSlideCollisionRuntimeParams.copy(this._mySlidingOppositeDirectionCollisionRuntimeParams);
      } else {
      }
    } else {
    }
  };
}();
CollisionCheck.prototype._horizontalSlideFlickerCheck = function() {
  let previousHorizontalMovement = vec3_create2();
  let newFeetPosition = vec3_create2();
  let fixedMovement = vec3_create2();
  let flickerFixSlideMovement = vec3_create2();
  return function _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isFlickering = false;
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    let shouldCheckFlicker = this._myPrevCollisionRuntimeParams.myIsSlidingFlickerPrevented || previousHorizontalMovement.vec3_isZero(1e-5);
    if (!shouldCheckFlicker) {
      if (this._myPrevCollisionRuntimeParams.myIsSliding || !collisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding) {
        let flickerCollisionAngle = 90;
        let flickerMovementAngle = 85;
        switch (collisionCheckParams.mySlidingFlickeringPreventionType) {
          case 1:
            shouldCheckFlicker = previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0);
            break;
          case 2:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            break;
          case 3:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) - flickerCollisionAngle) < 1e-5 && Math.abs(collisionRuntimeParams.mySlidingMovementAngle) > flickerMovementAngle + 1e-5;
            break;
          case 4:
            shouldCheckFlicker = true;
            break;
        }
      }
    }
    if (shouldCheckFlicker || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) {
      if (shouldCheckFlicker) {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = collisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter;
      } else {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = Math.max(0, this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter - 1);
      }
      if ((collisionCheckParams.mySlidingFlickeringPreventionType != 1 || collisionRuntimeParams.myIsSlidingFlickerPrevented || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) && (this._myPrevCollisionRuntimeParams.myIsSliding && previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0))) {
        isFlickering = true;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
      } else {
        this._mySlidingFlickeringFixCollisionRuntimeParams.reset();
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySliding90DegreesSign = collisionRuntimeParams.mySliding90DegreesSign;
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
        newFeetPosition = feetPosition.vec3_add(slideMovement, newFeetPosition);
        let backupDebugActive = collisionCheckParams.myDebugActive;
        collisionCheckParams.myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugSlidingActive;
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(movement, newFeetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, previousCollisionRuntimeParams, false, fixedMovement);
        collisionCheckParams.myDebugActive = backupDebugActive;
        if (fixedMovement.vec3_isZero(1e-5)) {
          this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.copy(this._mySlidingFlickeringFixCollisionRuntimeParams);
          flickerFixSlideMovement = this._internalHorizontalSlide(movement, newFeetPosition, height, up, forward, slideMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, flickerFixSlideMovement);
          if (collisionCheckParams.mySlidingCheckBothDirections) {
            this._horizontalSlideCheckOpposite(movement, newFeetPosition, height, up, forward, slideMovement, true, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, flickerFixSlideMovement);
          }
          if (this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.myIsSliding) {
            if (slideMovement.vec3_signTo(movement, up, 0) != flickerFixSlideMovement.vec3_signTo(movement, up, 0)) {
              isFlickering = true;
              collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
            }
          }
        }
      }
    } else {
    }
    if (isFlickering) {
    } else {
    }
    return isFlickering;
  };
}();
CollisionCheck.prototype._internalHorizontalSlide = function() {
  let invertedNormal = vec3_create2();
  let slidingMovement = vec3_create2();
  let movement90 = vec3_create2();
  let currentMovement = vec3_create2();
  let slideMovementForward = vec3_create2();
  let fixedMovement = vec3_create2();
  return function _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    invertedNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_negate(invertedNormal);
    invertedNormal.vec3_removeComponentAlongAxis(up, invertedNormal);
    invertedNormal[0] = Math.abs(invertedNormal[0]) < 0.01 ? 0 : invertedNormal[0];
    invertedNormal[2] = Math.abs(invertedNormal[2]) < 0.01 ? 0 : invertedNormal[2];
    invertedNormal.vec3_normalize(invertedNormal);
    collisionRuntimeParams.mySlidingCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    collisionRuntimeParams.mySlidingWallNormal.vec3_copy(collisionRuntimeParams.myHorizontalCollisionHit.myNormal);
    outSlideMovement.vec3_zero();
    slidingMovement.vec3_copy(invertedNormal);
    if (checkOppositeDirection) {
      slidingMovement.vec3_copy(movement);
      slidingMovement.vec3_normalize(slidingMovement);
    }
    if (!slidingMovement.vec3_isZero(1e-5)) {
      slidingMovement.vec3_scale(movement.vec3_length(), slidingMovement);
      let slidingSign = invertedNormal.vec3_signTo(movement, up);
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        let angleThreshold = 0.1;
        if (invertedNormal.vec3_angle(movement) < angleThreshold && collisionRuntimeParams.mySliding90DegreesSign != 0) {
          slidingSign = collisionRuntimeParams.mySliding90DegreesSign;
        } else if (collisionRuntimeParams.mySliding90DegreesSign == 0 || collisionRuntimeParams.mySlidingRecompute90DegreesSign) {
          collisionRuntimeParams.mySliding90DegreesSign = slidingSign;
        } else {
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
      }
      if (checkOppositeDirection) {
        slidingSign *= -1;
      }
      let currentAngle = 90 * slidingSign;
      let maxAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement.vec3_rotateAxis(90 * slidingSign, up, movement90), up) * slidingSign, true) * slidingSign;
      let minAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement, up) * slidingSign, true) * slidingSign;
      if (checkOppositeDirection) {
        maxAngle = currentAngle;
        minAngle = 0;
      } else {
        if (Math.abs(maxAngle) < Math.abs(minAngle)) {
          minAngle = 0;
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          minAngle = maxAngle;
        }
        if (Math.abs(maxAngle) < Math.abs(currentAngle) || Math.abs(Math.abs(maxAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = maxAngle;
        }
        if (Math.abs(currentAngle) < Math.abs(minAngle) || Math.abs(Math.abs(minAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = minAngle;
        }
      }
      if (checkOppositeDirection && !previousHorizontalMovement.vec3_isZero(1e-6)) {
        let angleWithPrevious = movement.vec3_angleSigned(previousHorizontalMovement, up);
        if (Math.pp_sign(angleWithPrevious) == Math.pp_sign(maxAngle) && Math.abs(maxAngle) > Math.abs(angleWithPrevious)) {
          currentAngle = angleWithPrevious;
        }
      }
      currentMovement.vec3_zero();
      let backupDebugActive = collisionCheckParams.myDebugActive;
      collisionCheckParams.myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugSlidingActive;
      let originalCurrentAngle = currentAngle;
      for (let i = 0; i < collisionCheckParams.mySlidingMaxAttempts; i++) {
        this._myInternalSlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
        currentMovement = slidingMovement.vec3_rotateAxis(currentAngle, up, currentMovement);
        slideMovementForward.vec3_copy(forward);
        if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
          if (!currentMovement.vec3_isZero()) {
            slideMovementForward = currentMovement.vec3_normalize(slideMovementForward);
          }
        }
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(currentMovement, feetPosition, height, up, slideMovementForward, allowSurfaceSteepFix, collisionCheckParams, this._myInternalSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, true, fixedMovement);
        if (!fixedMovement.vec3_isZero(1e-5)) {
          outSlideMovement.vec3_copy(currentMovement);
          collisionRuntimeParams.copy(this._myInternalSlidingCollisionRuntimeParams);
          collisionRuntimeParams.myIsSliding = true;
          collisionRuntimeParams.myIsSlidingIntoOppositeDirection = checkOppositeDirection;
          collisionRuntimeParams.mySlidingMovementAngle = movement.vec3_angleSigned(currentMovement, up);
          collisionRuntimeParams.mySlidingCollisionAngle = invertedNormal.vec3_angleSigned(currentMovement, up);
          maxAngle = currentAngle;
          currentAngle = (maxAngle + minAngle) / 2;
        } else {
          if (currentAngle != maxAngle) {
            minAngle = currentAngle;
          }
          if (i == 0 && currentAngle != maxAngle) {
            currentAngle = maxAngle;
          } else {
            currentAngle = (minAngle + maxAngle) / 2;
          }
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          break;
        }
      }
      collisionCheckParams.myDebugActive = backupDebugActive;
    }
    if (!collisionRuntimeParams.myIsSliding) {
      collisionRuntimeParams.mySlidingCollisionHit.reset();
    } else {
    }
    return outSlideMovement;
  };
}();
CollisionCheck.prototype._horizontalCheckBetterSlideNormal = function() {
  let movementDirection = vec3_create2();
  let hitDirection = vec3_create2();
  let projectAlongAxis = vec3_create2();
  let fixedMovement = vec3_create2();
  let newFixedFeetPosition = vec3_create2();
  let newFeetPosition = vec3_create2();
  return function _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    movementDirection = movement.vec3_normalize(movementDirection);
    let hitPosition = collisionRuntimeParams.myHorizontalCollisionHit.myPosition;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
    if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
      projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
    } else {
      projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
    }
    fixedMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, fixedMovement);
    if (fixedMovement.vec3_isConcordant(movementDirection)) {
      fixedMovement = movementDirection.vec3_scale(Math.min(fixedMovement.vec3_length(), movement.vec3_length()), fixedMovement);
    } else {
      fixedMovement.vec3_zero();
    }
    if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugHorizontalMovementActive) {
      getDebugVisualManager2(this._myEngine).drawArrow(0, feetPosition, movementDirection, fixedMovement.vec3_length(), vec4_create(1, 0, 1, 1));
    }
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.copy(collisionRuntimeParams);
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally = false;
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.reset();
    newFixedFeetPosition = feetPosition.vec3_add(fixedMovement, newFixedFeetPosition);
    newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
    let backupDebugActive = collisionCheckParams.myDebugActive;
    collisionCheckParams.myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugSlidingActive;
    if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
      this._horizontalPositionCheck(originalFeetPosition, originalHeight, newFixedFeetPosition, height, up, forward, collisionCheckParams, this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
    collisionCheckParams.myDebugActive = backupDebugActive;
    if (this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally && !this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.myIsInsideCollision) {
      collisionRuntimeParams.copy(this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
  };
}();
CollisionCheck.prototype._isSlidingNormalValid = function() {
  let flatNormal = vec3_create2();
  return function _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
    let isValid = false;
    flatNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatNormal);
    flatNormal.vec3_normalize(flatNormal);
    if (!flatNormal.vec3_isZero(1e-6)) {
      isValid = true;
    }
    return isValid;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalSlide", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalSlideCheckOpposite", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalSlideFlickerCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_internalHorizontalSlide", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalCheckBetterSlideNormal", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_isSlidingNormalValid", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_movement_check.js
CollisionCheck.prototype._horizontalMovementCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create2());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  let movementDirection = vec3_create2();
  let heightOffset = vec3_create2();
  let heightStep = vec3_create2();
  let currentHeightOffset = vec3_create2();
  let leftRadialDirection = vec3_create2();
  let rightRadialDirection = vec3_create2();
  return function _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugHorizontalMovementActive;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    movementDirection = movement.vec3_normalize(movementDirection);
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let steplength = collisionCheckParams.myRadius / collisionCheckParams.myHorizontalMovementRadialStepAmount;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    {
      leftRadialDirection = movementDirection.vec3_rotateAxis(halfConeAngle, up, leftRadialDirection);
      rightRadialDirection = movementDirection.vec3_rotateAxis(-halfConeAngle, up, rightRadialDirection);
      for (let i = 1; i <= collisionCheckParams.myHorizontalMovementRadialStepAmount; i++) {
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = leftRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = rightRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
      }
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundObjectsToIgnore, true, true, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundCeilingObjectsToIgnore, false, true, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, ceilingObjectsToIgnore, false, true, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, ceilingObjectsToIgnore, null, false, true, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountMovement > 0 && height > 1e-6) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountMovement;
        heightStep = up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopMovement || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, currentHeightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalMovement) {
            this._horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, currentHeightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionRuntimeParams.myIsCollidingHorizontally) {
            break;
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheck.prototype._horizontalMovementVerticalCheck = function() {
  let movementStep = vec3_create2();
  let movementDirection = vec3_create2();
  let firstPosition = vec3_create2();
  let secondPosition = vec3_create2();
  let firstMovementPosition = vec3_create2();
  let secondMovementPosition = vec3_create2();
  let firstHeightPosition = vec3_create2();
  let secondHeightPosition = vec3_create2();
  let firstHeightMovementPosition = vec3_create2();
  let secondHeightMovementPosition = vec3_create2();
  return function _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondHeightPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightPosition,
              secondMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward) {
            firstHeightMovementPosition = firstPosition.vec3_add(movementStep, firstHeightMovementPosition);
            firstHeightMovementPosition = firstHeightMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondPosition,
              firstHeightMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward) {
            secondHeightMovementPosition = secondPosition.vec3_add(movementStep, secondHeightMovementPosition);
            secondHeightMovementPosition = secondHeightMovementPosition.vec3_sub(heightStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstPosition,
              secondHeightMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (m == 0) {
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
              secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                secondHeightPosition,
                firstPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
              let firstHeightPosition2 = firstPosition.vec3_sub(heightStep);
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                firstHeightPosition2,
                secondPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightMovementPosition = secondPosition.vec3_sub(heightStep, secondHeightMovementPosition).vec3_add(movementStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondHeightMovementPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightMovementPosition,
              secondMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraight || collisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled && j == 0) {
          if (m == 0) {
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightPosition,
              firstPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            firstHeightMovementPosition = firstMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightMovementPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            firstHeightPosition,
            firstMovementPosition,
            movementDirection,
            up,
            true,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled && j == 0) {
          firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            firstPosition,
            firstHeightMovementPosition,
            movementDirection,
            up,
            true,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
        if (!isHorizontalCheckOk) {
          collisionRuntimeParams.myIsCollidingHorizontally = true;
          collisionRuntimeParams.myHorizontalCollisionHit.copy(raycastResult.myHits[0]);
          break;
        }
      }
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheck.prototype._horizontalMovementHorizontalCheck = function() {
  let movementStep = vec3_create2();
  let movementDirection = vec3_create2();
  let firstPosition = vec3_create2();
  let secondPosition = vec3_create2();
  let firstMovementPosition = vec3_create2();
  let secondMovementPosition = vec3_create2();
  return function _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstPosition,
              secondMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckHorizontalBorder) {
            if (m == 0) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                secondPosition,
                firstPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
            {
              firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
              secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                secondMovementPosition,
                firstMovementPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckStraight || collisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            firstPosition,
            firstMovementPosition,
            null,
            up,
            true,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        collisionRuntimeParams.myIsCollidingHorizontally = true;
        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
        break;
      }
    }
    return isHorizontalCheckOk;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementVerticalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementHorizontalCheck", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_position_check.js
CollisionCheck.prototype._horizontalPositionCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create2());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  let heightOffset = vec3_create2();
  let heightStep = vec3_create2();
  let currentHeightOffset = vec3_create2();
  let hitHeightOffset = vec3_create2();
  let hitHeightOffsetEpsilon = vec3_create2();
  let downwardHeightOffset = vec3_create2();
  let downwardHeightStep = vec3_create2();
  let verticalDirection = vec3_create2();
  let vertilCheckHit = new RaycastHit();
  return function _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugHorizontalPositionActive;
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 180);
    let sliceAngle = halfConeAngle / collisionCheckParams.myHalfConeSliceAmount;
    let tempCheckPosition = _localGetCachedCheckPosition();
    checkPositions.push(feetPosition.vec3_add(forward.vec3_scale(collisionCheckParams.myRadius, tempCheckPosition), tempCheckPosition));
    for (let i = 1; i <= collisionCheckParams.myHalfConeSliceAmount; i++) {
      let currentAngle = i * sliceAngle;
      tempCheckPosition = _localGetCachedCheckPosition();
      let radialDirection = forward.vec3_rotateAxis(-currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
      tempCheckPosition = _localGetCachedCheckPosition();
      radialDirection = forward.vec3_rotateAxis(currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundObjectsToIgnore, true, false, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundCeilingObjectsToIgnore, false, false, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, ceilingObjectsToIgnore, false, false, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, ceilingObjectsToIgnore, null, false, false, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountPosition > 0 && height > 0) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountPosition;
        up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopPosition || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i != 0 && i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, currentHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalPosition) {
            let hitHeightOffsetEpsilonValue = 1e-4;
            if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 0 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
              verticalDirection.vec3_copy(up);
              this._horizontalPositionVerticalCheck(feetPosition, checkPositions, currentHeightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 1 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
                verticalDirection = up.vec3_negate(verticalDirection);
                downwardHeightOffset = currentHeightOffset.vec3_sub(heightStep, downwardHeightOffset);
                downwardHeightStep = heightStep.vec3_negate(downwardHeightStep);
                this._horizontalPositionVerticalCheck(feetPosition, checkPositions, downwardHeightOffset, downwardHeightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              }
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheck.prototype._horizontalPositionHorizontalCheck = function() {
  let basePosition = vec3_create2();
  let forwardNegate = vec3_create2();
  let currentRadialPosition = vec3_create2();
  let previousRadialPosition = vec3_create2();
  return function _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    let halfRadialPositions = Math.floor(checkPositions.length / 2) + 1;
    for (let j = 0; j < halfRadialPositions; j++) {
      if (j > 0) {
        let leftIndex = Math.max(0, j * 2);
        let rightIndex = Math.max(0, j * 2 - 1);
        let leftAndRightEqual = checkPositions[leftIndex].vec_equals(checkPositions[rightIndex], 1e-6);
        if (collisionCheckParams.myCheckConeBorder) {
          for (let r = 0; r < 2; r++) {
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            let previousIndex = Math.max(0, currentIndex - 2);
            previousRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              previousRadialPosition,
              currentRadialPosition,
              forward.vec3_negate(forwardNegate),
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myCheckConeRay && isHorizontalCheckOk) {
          for (let r = 0; r < 2; r++) {
            if (r == 1 && leftAndRightEqual) {
              break;
            }
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              basePosition,
              currentRadialPosition,
              null,
              up,
              false,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              false,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
      } else {
        if (collisionCheckParams.myCheckConeRay) {
          currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            basePosition,
            currentRadialPosition,
            null,
            up,
            false,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            false,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        break;
      }
    }
    if (!isHorizontalCheckOk) {
      collisionRuntimeParams.myIsCollidingHorizontally = true;
      collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheck.prototype._horizontalPositionVerticalCheck = function() {
  let basePosition = vec3_create2();
  let previousBasePosition = vec3_create2();
  let currentRadialPosition = vec3_create2();
  let previousRadialPosition = vec3_create2();
  let previousCurrentRadialPosition = vec3_create2();
  let previousPreviousRadialPosition = vec3_create2();
  return function _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    previousBasePosition = basePosition.vec3_sub(heightStep, previousBasePosition);
    for (let j = 0; j <= checkPositions.length; j++) {
      let previousCheckPositionIsEqual = false;
      if (j == checkPositions.length) {
        currentRadialPosition.vec3_copy(basePosition);
        previousRadialPosition.vec3_copy(previousBasePosition);
      } else {
        currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
        previousRadialPosition = currentRadialPosition.vec3_sub(heightStep, previousRadialPosition);
        if (j > 0) {
          previousCheckPositionIsEqual = checkPositions[j].vec_equals(checkPositions[j - 1], 1e-6);
        }
      }
      if (collisionCheckParams.myCheckVerticalStraight && !previousCheckPositionIsEqual) {
        isHorizontalCheckOk = this._horizontalCheckRaycast(
          previousRadialPosition,
          currentRadialPosition,
          null,
          up,
          collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
          ignoreGroundAngleCallback,
          ignoreCeilingAngleCallback,
          feetPosition,
          true,
          collisionCheckParams,
          collisionRuntimeParams,
          true,
          true
        );
        if (!isHorizontalCheckOk) {
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            collisionRuntimeParams.myIsCollidingHorizontally = true;
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          }
          if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
            break;
          }
        }
      }
      if (j < checkPositions.length) {
        if ((collisionCheckParams.myCheckVerticalDiagonalRayOutward || collisionCheckParams.myCheckVerticalDiagonalBorderRayOutward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            previousBasePosition,
            currentRadialPosition,
            null,
            up,
            collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams,
            true,
            true
          );
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if ((collisionCheckParams.myCheckVerticalDiagonalRayInward || collisionCheckParams.myCheckVerticalDiagonalBorderRayInward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            previousRadialPosition,
            basePosition,
            null,
            up,
            collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams,
            true,
            true
          );
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if (j > 0) {
          if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward || collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
            let previousIndex = Math.max(0, j - 2);
            previousCurrentRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousCurrentRadialPosition);
            previousPreviousRadialPosition = previousCurrentRadialPosition.vec3_sub(heightStep, previousPreviousRadialPosition);
            if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                previousPreviousRadialPosition,
                currentRadialPosition,
                null,
                up,
                collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams,
                true,
                true
              );
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
            if (collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                previousRadialPosition,
                previousCurrentRadialPosition,
                null,
                up,
                collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams,
                true,
                true
              );
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionHorizontalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionVerticalCheck", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/vertical_collision_check.js
CollisionCheck.prototype._verticalCheck = function() {
  let newFeetPosition = vec3_create2();
  let additionalFixedMovement = vec3_create2();
  let zero = vec3_create2(0, 0, 0);
  return function _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingVertically = false;
    collisionRuntimeParams.myVerticalCollisionHit.reset();
    let movementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(up), -1);
    let isMovementDownward = movementSign < 0;
    outFixedMovement.vec3_copy(verticalMovement);
    if (collisionCheckParams.myVerticalMovementCheckEnabled) {
      outFixedMovement = this._verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
      if (collisionCheckParams.myCheckVerticalBothDirection && (outFixedMovement.vec_equals(verticalMovement, 1e-5) || originalMovementSign == 0 || movementSign != originalMovementSign)) {
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        let isOppositeMovementDownward = !isMovementDownward;
        additionalFixedMovement = this._verticalMovementAdjustment(zero, isOppositeMovementDownward, originalMovementSign, newFeetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, additionalFixedMovement);
        outFixedMovement.vec3_add(additionalFixedMovement, outFixedMovement);
        isMovementDownward = !isMovementDownward;
      }
    }
    if (collisionCheckParams.myVerticalPositionCheckEnabled) {
      newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
      let canStay = this._verticalPositionCheck(newFeetPosition, isMovementDownward, height, up, forward, collisionCheckParams, collisionRuntimeParams);
      if (!canStay) {
        outFixedMovement.vec3_zero();
        collisionRuntimeParams.myHasSnappedOnGround = false;
        collisionRuntimeParams.myHasSnappedOnCeiling = false;
        collisionRuntimeParams.myHasPoppedOutGround = false;
        collisionRuntimeParams.myHasPoppedOutCeiling = false;
        collisionRuntimeParams.myHasReducedVerticalMovement = false;
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._verticalMovementAdjustment = function() {
  let startOffset = vec3_create2();
  let endOffset = vec3_create2();
  let tempVector = vec3_create2();
  let furtherDirection = vec3_create2();
  let furtherDirectionPosition = vec3_create2();
  let upNegate = vec3_create2();
  let origin = vec3_create2();
  let direction = vec3_create2();
  return function _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugVerticalMovementActive;
    startOffset.vec3_zero();
    endOffset.vec3_zero();
    let popOutEnabled = false;
    let snapEnabled = false;
    if (isMovementDownward) {
      startOffset.vec3_zero();
      endOffset.vec3_copy(verticalMovement);
      if (collisionCheckParams.myGroundPopOutExtraDistance > 0 && collisionCheckParams.myGroundPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(collisionCheckParams.myGroundPopOutExtraDistance + 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    } else {
      startOffset = up.vec3_scale(height, startOffset);
      endOffset = up.vec3_scale(height, endOffset).vec3_add(verticalMovement, endOffset);
      if (collisionCheckParams.myCeilingPopOutExtraDistance > 0 && collisionCheckParams.myCeilingPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(-collisionCheckParams.myCeilingPopOutExtraDistance - 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    }
    if (isMovementDownward && originalMovementSign <= 0 && this._myPrevCollisionRuntimeParams.myIsOnGround && collisionCheckParams.mySnapOnGroundEnabled && collisionCheckParams.mySnapOnGroundExtraDistance > 0) {
      endOffset.vec3_add(up.vec3_scale(-collisionCheckParams.mySnapOnGroundExtraDistance - 1e-5, tempVector), endOffset);
      snapEnabled = true;
    } else if (!isMovementDownward && this._myPrevCollisionRuntimeParams.myIsOnCeiling && collisionCheckParams.mySnapOnCeilingEnabled && collisionCheckParams.mySnapOnCeilingExtraDistance > 0 && (originalMovementSign > 0 || originalMovementSign == 0 && (!this._myPrevCollisionRuntimeParams.myIsOnGround || !collisionCheckParams.mySnapOnGroundEnabled))) {
      endOffset.vec3_add(up.vec3_scale(collisionCheckParams.mySnapOnCeilingExtraDistance + 1e-5, tempVector), endOffset);
      snapEnabled = true;
    }
    outFixedMovement.vec3_zero();
    if (startOffset.vec3_distance(endOffset) > 1e-5) {
      let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
      furtherDirection.vec3_copy(up);
      if (!isMovementDownward) {
        furtherDirection.vec3_negate(furtherDirection);
      }
      let furtherDirectionPositionSet = false;
      for (let i = 0; i < checkPositions.length; i++) {
        let currentPosition = checkPositions[i];
        origin = currentPosition.vec3_add(startOffset, origin);
        direction = currentPosition.vec3_add(endOffset, direction).vec3_sub(origin, direction);
        let distance = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult2 = this._raycastAndDebug(origin, direction, distance, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult2.myHits.length > 0) {
          if (furtherDirectionPositionSet) {
            if (raycastResult2.myHits[0].myPosition.vec3_isFartherAlongAxis(furtherDirectionPosition, furtherDirection)) {
              furtherDirectionPosition.vec3_copy(raycastResult2.myHits[0].myPosition);
            }
          } else {
            furtherDirectionPositionSet = true;
            furtherDirectionPosition.vec3_copy(raycastResult2.myHits[0].myPosition);
          }
        }
      }
      if (furtherDirectionPositionSet) {
        upNegate = up.vec3_negate(upNegate);
        if (isMovementDownward) {
          outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition, outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
          if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
            collisionRuntimeParams.myHasSnappedOnGround = true;
          } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
            if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
              collisionRuntimeParams.myHasPoppedOutGround = true;
            } else {
              collisionRuntimeParams.myHasReducedVerticalMovement = true;
            }
          } else {
            collisionRuntimeParams.myHasReducedVerticalMovement = true;
          }
        } else {
          outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition.vec3_add(up.vec3_scale(height, outFixedMovement), outFixedMovement), outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
          if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
            collisionRuntimeParams.myHasSnappedOnCeiling = true;
          } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
            if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
              collisionRuntimeParams.myHasPoppedOutCeiling = true;
            } else {
              collisionRuntimeParams.myHasReducedVerticalMovement = true;
            }
          } else {
            collisionRuntimeParams.myHasReducedVerticalMovement = true;
          }
        }
        if (!popOutEnabled && !outFixedMovement.vec3_isConcordant(verticalMovement)) {
          outFixedMovement.vec3_zero();
        }
        if (!collisionCheckParams.myVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
          outFixedMovement.vec3_copy(verticalMovement);
          collisionRuntimeParams.myHasReducedVerticalMovement = false;
        }
      } else {
        outFixedMovement.vec3_copy(verticalMovement);
      }
    } else {
      outFixedMovement.vec3_copy(verticalMovement);
    }
    if (outFixedMovement.vec3_length() < 1e-5) {
      outFixedMovement.vec3_zero();
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._verticalPositionCheck = function() {
  let smallHeightFixOffset = vec3_create2();
  let heightOffset = vec3_create2();
  let startPosition = vec3_create2();
  let endPosition = vec3_create2();
  let direction = vec3_create2();
  return function _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    if (height < 1e-5) {
      return true;
    }
    this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugVerticalPositionActive;
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
    let isVerticalPositionOk = true;
    let atLeastOneIsOk = false;
    let adjustmentEpsilon = 1e-5;
    smallHeightFixOffset = up.vec3_scale(adjustmentEpsilon, smallHeightFixOffset);
    heightOffset = up.vec3_scale(height - adjustmentEpsilon, heightOffset);
    if (height - adjustmentEpsilon < adjustmentEpsilon * 10) {
      heightOffset = up.vec3_scale(adjustmentEpsilon * 10, heightOffset);
    }
    let insideHitSet = false;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      if (checkUpward) {
        startPosition = currentPosition.vec3_add(smallHeightFixOffset, startPosition);
        endPosition = currentPosition.vec3_add(heightOffset, endPosition);
      } else {
        startPosition = currentPosition.vec3_add(heightOffset, startPosition);
        endPosition = currentPosition.vec3_add(smallHeightFixOffset, endPosition);
      }
      let origin = startPosition;
      direction = endPosition.vec3_sub(origin, direction);
      let distance = direction.vec3_length();
      direction.vec3_normalize(direction);
      let raycastResult2 = this._raycastAndDebug(origin, direction, distance, false, false, collisionCheckParams, collisionRuntimeParams);
      if (raycastResult2.isColliding()) {
        let firstHitOutsideCollision = raycastResult2.getFirstHitOutsideCollision();
        if (firstHitOutsideCollision != null) {
          isVerticalPositionOk = false;
          collisionRuntimeParams.myVerticalCollisionHit.copy(firstHitOutsideCollision);
          break;
        } else if (!insideHitSet) {
          insideHitSet = true;
          collisionRuntimeParams.myVerticalCollisionHit.copy(raycastResult2.myHits[0]);
          if (!collisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk) {
            isVerticalPositionOk = false;
            break;
          }
        }
      } else {
        atLeastOneIsOk = true;
      }
    }
    collisionRuntimeParams.myIsCollidingVertically = !isVerticalPositionOk || !atLeastOneIsOk;
    return !collisionRuntimeParams.myIsCollidingVertically;
  };
}();
CollisionCheck.prototype._getVerticalCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create2());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create2();
  return function _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    if (collisionCheckParams.myGroundCircumferenceAddCenter) {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = collisionCheckParams.myFeetRadius / collisionCheckParams.myGroundCircumferenceStepAmount;
    let sliceAngle = 360 / collisionCheckParams.myGroundCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < collisionCheckParams.myGroundCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = forward.vec3_rotateAxis(currentStepRotation, up, currentDirection);
      for (let j = 0; j < collisionCheckParams.myGroundCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, up, tempCheckPosition);
        checkPositions.push(feetPosition.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += collisionCheckParams.myGroundCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_verticalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_verticalMovementAdjustment", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_verticalPositionCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_getVerticalCheckPositions", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_surface_check.js
CollisionCheck.prototype._updateSurfaceInfo = function() {
  let transformUp = vec3_create2();
  let transformForward = vec3_create2();
  let feetPosition = vec3_create2();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let forwardForPerceivedAngle = vec3_create2();
  let forwardForVertical = vec3_create2();
  let zAxis = vec3_create2(0, 0, 1);
  let xAxis = vec3_create2(1, 0, 0);
  return function _updateSurfaceInfo(transformQuat, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat, offsetTransformQuat);
    if (transformQuat.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    forwardForPerceivedAngle.vec3_copy(transformForward);
    forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
    if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
      forwardForVertical.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForVertical.vec3_copy(xAxis);
        } else {
          forwardForVertical.vec3_copy(zAxis);
        }
      }
      forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
      forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
      if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
        forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      }
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
  };
}();
CollisionCheck.prototype._postSurfaceCheck = function() {
  let horizontalDirection = vec3_create2();
  return function _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isVerticalMovementZero = originalVerticalMovement.vec3_isZero(1e-5);
    let isVerticalMovemenDownward = Math.pp_sign(originalVerticalMovement.vec3_lengthSigned(transformUp), -1) < 0;
    let horizontalMovementIsZero = fixedHorizontalMovement.vec3_isZero(1e-5);
    horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
    let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, horizontalDirection, transformUp, true);
    let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, horizontalDirection, transformUp, false);
    let mustRemainOnGroundOk = true;
    if (collisionCheckParams.myMustStayOnGround) {
      if (previousCollisionRuntimeParams.myIsOnGround && !collisionRuntimeParams.myIsOnGround && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnGroundOk = false;
      }
    }
    let mustRemainOnCeilingOk = true;
    if (collisionCheckParams.myMustStayOnCeiling) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !collisionRuntimeParams.myIsOnCeiling && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnCeilingOk = false;
      }
    }
    let mustStayBelowGroundAngleOk = true;
    if (collisionCheckParams.myMustStayBelowGroundAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowGroundAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowGroundAngleDownhill == null) {
        minAngle = collisionCheckParams.myGroundAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowGroundAngleDownhill, collisionCheckParams.myGroundAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundAngle <= minAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
        mustStayBelowGroundAngleOk = false;
      }
    }
    let mustStayBelowCeilingAngleOk = true;
    if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowCeilingAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill == null) {
        minAngle = collisionCheckParams.myCeilingAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowCeilingAngleDownhill, collisionCheckParams.myCeilingAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingAngle <= minAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
        mustStayBelowCeilingAngleOk = false;
      }
    }
    let mustStayOnGroundHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnGroundHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundHitMaxAngle <= collisionCheckParams.myMovementMustStayOnGroundHitAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundHitMaxAngle > collisionCheckParams.myMovementMustStayOnGroundHitAngle + 1e-4) {
        mustStayOnGroundHitAngleOk = false;
      }
    }
    let mustStayOnCeilingHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnCeilingHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingHitMaxAngle <= collisionCheckParams.myMovementMustStayOnCeilingHitAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingHitMaxAngle > collisionCheckParams.myMovementMustStayOnCeilingHitAngle + 1e-4) {
        mustStayOnCeilingHitAngleOk = false;
      }
    }
    let isOnValidGroundAngleUphill = true;
    let isOnValidGroundAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnGround && !horizontalMovementIsZero) {
        if (groundPerceivedAngle > 0) {
          isOnValidGroundAngleUphill = false;
          if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidGroundAngleUphill = Math.abs(groundPerceivedAngle) <= collisionCheckParams.myGroundAngleToIgnore + 1e-4;
          }
        } else if (groundPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidGroundAngleDownhill) {
              isOnValidGroundAngleDownhill = false;
            }
          }
        }
      }
    }
    let isOnValidCeilingAngleUphill = true;
    let isOnValidCeilingAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !horizontalMovementIsZero) {
        if (ceilingPerceivedAngle > 0) {
          isOnValidCeilingAngleUphill = false;
          if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidCeilingAngleUphill = Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
          }
        } else if (ceilingPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidCeilingAngleDownhill) {
              isOnValidCeilingAngleDownhill = false;
            }
          }
        }
      }
    }
    return mustRemainOnGroundOk && mustRemainOnCeilingOk && mustStayBelowGroundAngleOk && mustStayBelowCeilingAngleOk && mustStayOnGroundHitAngleOk && mustStayOnCeilingHitAngleOk && isOnValidGroundAngleUphill && isOnValidGroundAngleDownhill && isOnValidCeilingAngleUphill && isOnValidCeilingAngleDownhill;
  };
}();
CollisionCheck.prototype._surfaceTooSteep = function() {
  let surfaceSteepResults = [false, false];
  return function _surfaceTooSteep(up, direction, collisionCheckParams, collisionRuntimeParams) {
    let groundTooSteep = false;
    let ceilingTooSteep = false;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
        collisionRuntimeParams.myGroundNormal,
        direction,
        up,
        true
      );
      groundTooSteep = groundPerceivedAngle > 0;
      if (groundTooSteep && collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
        groundTooSteep = Math.abs(groundPerceivedAngle) > collisionCheckParams.myGroundAngleToIgnore + 1e-4;
      }
    }
    if (!groundTooSteep) {
      if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
          collisionRuntimeParams.myCeilingNormal,
          direction,
          up,
          false
        );
        ceilingTooSteep = ceilingPerceivedAngle > 0;
        if (ceilingTooSteep && collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          ceilingTooSteep = Math.abs(ceilingPerceivedAngle) > collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
        }
      }
    }
    surfaceSteepResults[0] = groundTooSteep;
    surfaceSteepResults[1] = ceilingTooSteep;
    return surfaceSteepResults;
  };
}();
CollisionCheck.prototype._adjustVerticalMovementWithSurface = function() {
  let horizontalDirection = vec3_create2();
  let extraVerticalMovement = vec3_create2();
  return function _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
    outAdjustedVerticalMovement.vec3_copy(verticalMovement);
    if (horizontalMovement.vec3_isZero(1e-5)) {
      return outAdjustedVerticalMovement;
    }
    let extraVerticalLength = 0;
    horizontalDirection = horizontalMovement.vec3_normalize(horizontalDirection);
    if (previousCollisionRuntimeParams.myIsOnGround) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
        previousCollisionRuntimeParams.myGroundNormal,
        horizontalDirection,
        up,
        true
      );
      let groundExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
      groundExtraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
      if (Math.abs(groundExtraVerticalLength) > 1e-5) {
        if (groundPerceivedAngle > 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = true;
          }
        } else if (groundPerceivedAngle < 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = true;
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
        previousCollisionRuntimeParams.myCeilingNormal,
        horizontalDirection,
        up,
        false
      );
      let ceilingExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
      ceilingExtraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
      if (Math.abs(ceilingExtraVerticalLength) > 1e-5) {
        let sameSignThanGround = Math.pp_sign(extraVerticalLength) == Math.pp_sign(ceilingExtraVerticalLength);
        if (extraVerticalLength == 0 || sameSignThanGround && Math.abs(ceilingExtraVerticalLength) > Math.abs(extraVerticalLength)) {
          if (ceilingPerceivedAngle > 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
            }
          } else if (ceilingPerceivedAngle < 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
            }
          }
        }
      }
    }
    if (Math.abs(extraVerticalLength) > 1e-5) {
      let verticalMovementLength = verticalMovement.vec3_lengthSigned(up);
      let sameSignThanExtra = Math.pp_sign(extraVerticalLength) == Math.pp_sign(verticalMovementLength);
      extraVerticalMovement = up.vec3_scale(extraVerticalLength, extraVerticalMovement);
      if (verticalMovement.vec3_isZero(1e-5)) {
        outAdjustedVerticalMovement.vec3_copy(extraVerticalMovement);
      } else if (sameSignThanExtra) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else if (!sameSignThanExtra && (collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill || collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill)) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else {
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
      }
    }
    if (outAdjustedVerticalMovement.vec3_isZero(1e-6)) {
      outAdjustedVerticalMovement.vec3_zero();
    }
    return outAdjustedVerticalMovement;
  };
}();
CollisionCheck.prototype._adjustHorizontalMovementWithSurface = function() {
  let extraHorizontalMovement = vec3_create2();
  let groundHorizontalDirection = vec3_create2();
  let ceilingHorizontalDirection = vec3_create2();
  let scaledCeilingHorizontalDirection = vec3_create2();
  let scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = vec3_create2();
  let scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = vec3_create2();
  return function _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
    outAdjustedHorizontalMovement.vec3_copy(horizontalMovement);
    if (verticalMovement.vec3_isZero(1e-5)) {
      return outAdjustedHorizontalMovement;
    }
    let isMovementDownward = !verticalMovement.vec3_isConcordant(up);
    extraHorizontalMovement.vec3_zero();
    groundHorizontalDirection.vec3_zero();
    if (previousCollisionRuntimeParams.myIsOnGround) {
      groundHorizontalDirection = previousCollisionRuntimeParams.myGroundNormal.vec3_removeComponentAlongAxis(up, groundHorizontalDirection);
      if (!groundHorizontalDirection.vec3_isZero(1e-5)) {
        groundHorizontalDirection.vec3_normalize(groundHorizontalDirection);
        let groundExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myGroundAngle));
        groundExtraHorizontalLength *= isMovementDownward ? 1 : -1;
        if (Math.abs(groundExtraHorizontalLength) > 1e-5) {
          if (isMovementDownward) {
            if (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myGroundAngle >= collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle)) {
              extraHorizontalMovement = groundHorizontalDirection.vec3_scale(groundExtraHorizontalLength, extraHorizontalMovement);
              collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = true;
            }
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      ceilingHorizontalDirection = previousCollisionRuntimeParams.myCeilingNormal.vec3_removeComponentAlongAxis(up, ceilingHorizontalDirection);
      if (!ceilingHorizontalDirection.vec3_isZero(1e-5)) {
        ceilingHorizontalDirection.vec3_normalize(ceilingHorizontalDirection);
        let ceilingExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myCeilingAngle));
        ceilingExtraHorizontalLength *= isMovementDownward ? -1 : 1;
        if (Math.abs(ceilingExtraHorizontalLength) > 1e-5) {
          let sameDirectionAsGround = ceilingHorizontalDirection.vec3_isConcordant(groundHorizontalDirection);
          if (extraHorizontalMovement.vec3_isZero() || sameDirectionAsGround) {
            if (!isMovementDownward) {
              if (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myCeilingAngle >= collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle)) {
                scaledCeilingHorizontalDirection = ceilingHorizontalDirection.vec3_scale(ceilingExtraHorizontalLength, scaledCeilingHorizontalDirection);
                if (!groundHorizontalDirection.vec3_isZero()) {
                  scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_removeComponentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_componentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  if (scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection.vec3_isFartherAlongAxis(extraHorizontalMovement, groundHorizontalDirection)) {
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = false;
                    extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = true;
                  } else if (!scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection.vec3_isZero(1e-5)) {
                    extraHorizontalMovement = extraHorizontalMovement.vec3_add(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection, extraHorizontalMovement);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = true;
                  }
                } else {
                  extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                  collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = true;
                }
              }
            }
          }
        }
      }
    }
    if (!extraHorizontalMovement.vec3_isZero()) {
      if (horizontalMovement.vec3_isZero(1e-5)) {
        outAdjustedHorizontalMovement.vec3_copy(extraHorizontalMovement);
      } else if (extraHorizontalMovement.vec3_isConcordant(horizontalMovement)) {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      } else {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      }
    }
    if (outAdjustedHorizontalMovement.vec3_isZero(1e-6)) {
      outAdjustedHorizontalMovement.vec3_zero();
    }
    return outAdjustedHorizontalMovement;
  };
}();
CollisionCheck.prototype._computeExtraSurfaceVerticalMovement = function() {
  let direction = vec3_create2();
  let tempVector = vec3_create2();
  return function _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
    outExtraSurfaceVerticalMovement.vec3_zero();
    if (!horizontalMovement.vec3_isZero()) {
      if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle != 0) {
        direction = horizontalMovement.vec3_normalize(direction);
        let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
          collisionRuntimeParams.myGroundNormal,
          direction,
          up,
          true
        );
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnGroundEnabled || extraVerticalLength > 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      } else if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle != 0) {
        direction = horizontalMovement.vec3_normalize(direction);
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
          collisionRuntimeParams.myCeilingNormal,
          direction,
          up,
          false
        );
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
        extraVerticalLength *= -1;
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnCeilingEnabled || extraVerticalLength < 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      }
    }
    return outExtraSurfaceVerticalMovement;
  };
}();
CollisionCheck.prototype._gatherSurfaceInfo = function() {
  let verticalDirection = vec3_create2();
  let startOffset = vec3_create2();
  let endOffset = vec3_create2();
  let heightOffset = vec3_create2();
  let smallOffset = vec3_create2();
  let smallStartPosition = vec3_create2();
  let smallEndPosition = vec3_create2();
  let surfaceNormal = vec3_create2();
  let surfaceHitMaxNormal = vec3_create2();
  let hitFromCurrentPosition = vec3_create2();
  let startPosition = vec3_create2();
  let endPosition = vec3_create2();
  let direction = vec3_create2();
  return function _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugActive = collisionCheckParams.myDebugActive && (isGround && collisionCheckParams.myDebugGroundInfoActive || !isGround && collisionCheckParams.myDebugCeilingInfoActive);
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forwardForVertical, collisionCheckParams, collisionRuntimeParams);
    verticalDirection.vec3_copy(up);
    let distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnGround;
    let distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeGroundInfo;
    let distanceToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxOutsideDistance;
    let verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnGround;
    let verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeGroundInfo;
    let verticalFixToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxInsideDistance;
    let isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnGroundIfInsideHit;
    let isBaseInsideCollisionCheckEnabled = collisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled;
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
      distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnCeiling;
      distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeCeilingInfo;
      distanceToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxOutsideDistance;
      verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnCeiling;
      verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeCeilingInfo;
      verticalFixToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxInsideDistance;
      isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnCeilingIfInsideHit;
      isBaseInsideCollisionCheckEnabled = collisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled;
    }
    startOffset = verticalDirection.vec3_scale(Math.max(verticalFixToBeOnSurface, verticalFixToComputeSurfaceInfo, verticalFixToFindSurfaceDistance, 1e-5), startOffset);
    endOffset = verticalDirection.vec3_negate(endOffset).vec3_scale(Math.max(distanceToBeOnSurface, distanceToComputeSurfaceInfo, distanceToFindSurfaceDistance, 1e-5), endOffset);
    heightOffset.vec3_zero();
    if (!isGround) {
      heightOffset = up.vec3_scale(height, heightOffset);
    }
    smallOffset = verticalDirection.vec3_scale(1e-4, smallOffset);
    let isOnSurface = false;
    let surfaceAngle = 0;
    let surfacePerceivedAngle = 0;
    surfaceNormal.vec3_zero();
    let surfaceHitMaxAngle = 0;
    surfaceHitMaxNormal.vec3_zero();
    let surfaceDistance = null;
    let isBaseInsideCollision = checkPositions.length > 0;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      currentPosition.vec3_add(heightOffset, currentPosition);
      let baseHitIsInsideCollision = false;
      if (isBaseInsideCollisionCheckEnabled) {
        smallStartPosition = currentPosition.vec3_add(smallOffset, smallStartPosition);
        smallEndPosition = currentPosition.vec3_sub(smallOffset, smallEndPosition);
        let origin = smallStartPosition;
        direction = smallEndPosition.vec3_sub(origin, direction);
        let distance = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult2 = this._raycastAndDebug(origin, direction, distance, false, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult2.isColliding()) {
          baseHitIsInsideCollision = raycastResult2.myHits[0].myIsInsideCollision;
        }
      }
      isBaseInsideCollision &&= baseHitIsInsideCollision;
      if (!baseHitIsInsideCollision) {
        startPosition = currentPosition.vec3_add(startOffset, startPosition);
        endPosition = currentPosition.vec3_add(endOffset, endPosition);
        let origin = startPosition;
        direction = endPosition.vec3_sub(origin, direction);
        let distance = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult2 = this._raycastAndDebug(origin, direction, distance, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult2.isColliding()) {
          hitFromCurrentPosition = raycastResult2.myHits[0].myPosition.vec3_sub(currentPosition, hitFromCurrentPosition);
          let hitFromCurrentPositionLength = hitFromCurrentPosition.vec3_lengthSigned(verticalDirection);
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToBeOnSurface + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToBeOnSurface + 1e-5) {
            isOnSurface = true;
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToComputeSurfaceInfo + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToComputeSurfaceInfo + 1e-5) {
            let currentSurfaceNormal = raycastResult2.myHits[0].myNormal;
            surfaceNormal.vec3_add(currentSurfaceNormal, surfaceNormal);
            let surfaceHitAngle = currentSurfaceNormal.vec3_angle(verticalDirection);
            if (surfaceHitAngle > surfaceHitMaxAngle) {
              surfaceHitMaxAngle = surfaceHitAngle;
              surfaceHitMaxNormal.vec3_copy(currentSurfaceNormal);
            }
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToFindSurfaceDistance + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToFindSurfaceDistance + 1e-5) {
            if (surfaceDistance == null) {
              surfaceDistance = -hitFromCurrentPositionLength;
            } else {
              if (Math.abs(hitFromCurrentPositionLength) < Math.abs(surfaceDistance)) {
                surfaceDistance = -hitFromCurrentPositionLength;
              }
            }
          }
        }
      } else if (isOnSurfaceIfInsideHit) {
        isOnSurface = true;
      }
    }
    if (!surfaceNormal.vec3_isZero()) {
      surfaceNormal.vec3_normalize(surfaceNormal);
      surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
      if (surfaceAngle <= 1e-4) {
        surfaceAngle = 0;
        surfaceNormal.vec3_copy(verticalDirection);
      } else if (surfaceAngle >= 180 - 1e-4) {
        surfaceAngle = 180;
        surfaceNormal = verticalDirection.vec3_negate(surfaceNormal);
      }
      surfacePerceivedAngle = this.computeSurfacePerceivedAngle(surfaceNormal, forwardForPerceivedAngle, up, isGround);
    }
    if (isGround) {
      collisionRuntimeParams.myRealIsOnGround = isOnSurface;
      collisionRuntimeParams.myGroundAngle = surfaceAngle;
      collisionRuntimeParams.myGroundPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myGroundNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myGroundHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myGroundDistance = surfaceDistance;
      collisionRuntimeParams.myGroundIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnGroundMaxSurfaceAngle == null || collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myIsOnGroundMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnGround = isOnSurface;
      }
    } else {
      collisionRuntimeParams.myRealIsOnCeiling = isOnSurface;
      collisionRuntimeParams.myCeilingAngle = surfaceAngle;
      collisionRuntimeParams.myCeilingPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myCeilingNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myCeilingHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myCeilingDistance = surfaceDistance;
      collisionRuntimeParams.myCeilingIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnCeilingMaxSurfaceAngle == null || collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myIsOnCeilingMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnCeiling = isOnSurface;
      }
    }
  };
}();
CollisionCheck.prototype.computeSurfacePerceivedAngle = function() {
  let forwardOnSurface = vec3_create2();
  let verticalDirection = vec3_create2();
  return function computeSurfacePerceivedAngle3(surfaceNormal, forward, up, isGround = true) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
    surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
    let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
    if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_surfaceTooSteep", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_computeExtraSurfaceVerticalMovement", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_gatherSurfaceInfo", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_updateSurfaceInfo", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/character_collision_results.js
var CharacterCollisionResults = class {
  constructor() {
    this.myCheckType = null;
    this.myTransformResults = new CharacterCollisionTransformResults();
    this.myMovementResults = new CharacterCollisionMovementResults();
    this.myHorizontalMovementResults = new CharacterCollisionMovementResults();
    this.myVerticalMovementResults = new CharacterCollisionMovementResults();
    this.myTeleportResults = new CharacterCollisionTeleportResults();
    this.myCheckTransformResults = new CharacterCollisionCheckTransformResults();
    this.myWallSlideResults = new CharacterCollisionWallSlideResults();
    this.myGroundInfo = new CharacterCollisionSurfaceInfo();
    this.myCeilingInfo = new CharacterCollisionSurfaceInfo();
    this.myGroundResults = new CharacterCollisionSurfaceResults();
    this.myCeilingResults = new CharacterCollisionSurfaceResults();
    this.mySplitMovementResults = new CharacterCollisionSplitMovementResults();
    this.myDebugResults = new CharacterCollisionDebugResults();
    this.myInternalResults = new CharacterCollisionInternalResults();
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionCheckType = {
  CHECK_MOVEMENT: 0,
  CHECK_TELEPORT: 1,
  CHECK_TRANSFORM: 2,
  UPDATE_SURFACE_INFO: 3,
  UPDATE_GROUND_INFO: 4,
  UPDATE_CEILING_INFO: 5
};
var CharacterCollisionSurfaceInfo = class {
  constructor() {
    this.myIsOnSurface = false;
    this.mySurfaceAngle = 0;
    this.mySurfacePerceivedAngle = 0;
    this.mySurfaceNormal = vec3_create2();
    this.mySurfaceHitMaxAngle = 0;
    this.mySurfaceHitMaxNormal = vec3_create2();
    this.mySurfaceDistance = null;
    this.myIsBaseInsideCollision = false;
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionWallSlideResults = class {
  constructor() {
    this.myHasSlid = false;
    this.mySlideMovementAngle = 0;
    this.mySlideMovementWallAngle = 0;
    this.myWallNormal = vec3_create2();
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionTransformResults = class {
  constructor() {
    this.myStartTransformQuat = quat2_create();
    this.myEndTransformQuat = quat2_create();
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionMovementResults = class {
  constructor() {
    this.myStartMovement = vec3_create2();
    this.myEndMovement = vec3_create2();
    this.myMovementFailed = false;
    this.myIsColliding = false;
    this.myReferenceCollisionHit = new RaycastHit();
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionTeleportResults = class {
  constructor() {
    this.myStartTeleportTransformQuat = quat2_create();
    this.myEndTeleportTransformQuat = quat2_create();
    this.myTeleportFailed = false;
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionCheckTransformResults = class {
  constructor() {
    this.myStartCheckTransformQuat = quat2_create();
    this.myEndCheckTransformQuat = quat2_create();
    this.myCheckTransformFailed = false;
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionSurfaceResults = class {
  constructor() {
    this.myHasSnappedOnSurface = false;
    this.myHasPoppedOutSurface = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = false;
    this.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = false;
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionSplitMovementResults = class {
  constructor() {
    this.myStepsToPerform = 0;
    this.myStepsPerformed = 0;
    this.myMovementInterrupted = false;
    this.myMovementChecked = vec3_create2();
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionDebugResults = class {
  constructor() {
    this._myRaycastsPerformed = 0;
  }
  reset() {
  }
  copy(other2) {
  }
};
var CharacterCollisionInternalResults = class {
  constructor() {
    this.myLastRelevantStartHorizontalMovement = vec3_create2();
    this.myLastRelevantAdjustedStartHorizontalMovement = vec3_create2();
    this.myLastRelevantEndHorizontalMovement = vec3_create2();
    this.myLastRelevantStartVerticalMovement = vec3_create2();
    this.myLastRelevantAdjustedStartVerticalMovement = vec3_create2();
    this.myLastRelevantEndVerticalMovement = vec3_create2();
    this.myLastRelevantHasWallSlid = false;
    this.myHasWallSlidTowardOppositeDirection = false;
    this.myLastRelevantWallSlideFlickerPrevented = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.myWallSlide90DegreesDirectionSign = 0;
    this.myWallSlide90DegreesRecomputeDirectionSign = true;
  }
  reset() {
  }
  copy(other2) {
  }
};
CharacterCollisionResults.prototype.reset = function reset() {
  this.myCheckType = null;
  this.myTransformResults.reset();
  this.myMovementResults.reset();
  this.myHorizontalMovementResults.reset();
  this.myVerticalMovementResults.reset();
  this.myTeleportResults.reset();
  this.myCheckTransformResults.reset();
  this.myWallSlideResults.reset();
  this.myGroundInfo.reset();
  this.myCeilingInfo.reset();
  this.myGroundResults.reset();
  this.myCeilingResults.reset();
  this.mySplitMovementResults.reset();
  this.myInternalResults.reset();
};
CharacterCollisionResults.prototype.copy = function copy9(other2) {
  this.myCheckType = other2.myCheckType;
  this.myTransformResults.copy(other2.myTransformResults);
  this.myMovementResults.copy(other2.myMovementResults);
  this.myHorizontalMovementResults.copy(other2.myHorizontalMovementResults);
  this.myVerticalMovementResults.copy(other2.myVerticalMovementResults);
  this.myTeleportResults.copy(other2.myTeleportResults);
  this.myCheckTransformResults.copy(other2.myCheckTransformResults);
  this.myWallSlideResults.copy(other2.myWallSlideResults);
  this.myGroundInfo.copy(other2.myGroundInfo);
  this.myCeilingInfo.copy(other2.myCeilingInfo);
  this.myGroundResults.copy(other2.myGroundResults);
  this.myCeilingResults.copy(other2.myCeilingResults);
  this.mySplitMovementResults.copy(other2.mySplitMovementResults);
  this.myInternalResults.copy(other2.myInternalResults);
};
CharacterCollisionSurfaceInfo.prototype.reset = function reset2() {
  this.myIsOnSurface = false;
  this.mySurfaceAngle = 0;
  this.mySurfacePerceivedAngle = 0;
  this.mySurfaceNormal.vec3_zero();
  this.mySurfaceHitMaxAngle = 0;
  this.mySurfaceHitMaxNormal.vec3_zero();
  this.mySurfaceDistance = null;
  this.myIsBaseInsideCollision = false;
};
CharacterCollisionSurfaceInfo.prototype.copy = function copy10(other2) {
  this.myIsOnSurface = other2.myIsOnSurface;
  this.mySurfaceAngle = other2.mySurfaceAngle;
  this.mySurfacePerceivedAngle = other2.mySurfacePerceivedAngle;
  this.mySurfaceNormal.vec3_copy(other2.mySurfaceNormal);
  this.mySurfaceHitMaxAngle = other2.mySurfaceHitMaxAngle;
  this.mySurfaceHitMaxNormal.vec3_copy(other2.mySurfaceHitMaxNormal);
  this.mySurfaceDistance = other2.mySurfaceDistance;
  this.myIsBaseInsideCollision = other2.myIsBaseInsideCollision;
};
CharacterCollisionWallSlideResults.prototype.reset = function reset3() {
  this.myHasSlid = false;
  this.mySlideMovementAngle = 0;
  this.mySlideMovementWallAngle = 0;
  this.myWallNormal.vec3_zero();
};
CharacterCollisionWallSlideResults.prototype.copy = function copy11(other2) {
  this.myHasSlid = other2.myHasSlid;
  this.mySlideMovementAngle = other2.mySlideMovementAngle;
  this.mySlideMovementWallAngle = other2.mySlideMovementWallAngle;
  this.myWallNormal.vec3_copy(other2.myWallNormal);
};
CharacterCollisionTransformResults.prototype.reset = function reset4() {
  this.myStartTransformQuat.quat2_identity();
  this.myEndTransformQuat.quat2_identity();
};
CharacterCollisionTransformResults.prototype.copy = function copy12(other2) {
  this.myStartTransformQuat.quat2_copy(other2.myStartTransformQuat);
  this.myEndTransformQuat.quat2_copy(other2.myEndTransformQuat);
};
CharacterCollisionMovementResults.prototype.reset = function reset5() {
  this.myStartMovement.vec3_zero();
  this.myEndMovement.vec3_zero();
  this.myMovementFailed = false;
  this.myIsColliding = false;
  this.myReferenceCollisionHit.reset();
};
CharacterCollisionMovementResults.prototype.copy = function copy13(other2) {
  this.myStartMovement.vec3_copy(other2.myStartMovement);
  this.myEndMovement.vec3_copy(other2.myEndMovement);
  this.myMovementFailed = other2.myMovementFailed;
  this.myIsColliding = other2.myIsColliding;
  this.myReferenceCollisionHit.copy(other2.myReferenceCollisionHit);
};
CharacterCollisionTeleportResults.prototype.reset = function reset6() {
  this.myStartTeleportTransformQuat.quat2_identity();
  this.myEndTeleportTransformQuat.quat2_identity();
  this.myTeleportFailed = false;
};
CharacterCollisionTeleportResults.prototype.copy = function copy14(other2) {
  this.myStartTeleportTransformQuat.quat2_copy(other2.myStartTeleportTransformQuat);
  this.myEndTeleportTransformQuat.quat2_copy(other2.myEndTeleportTransformQuat);
  this.myTeleportFailed = other2.myTeleportFailed;
};
CharacterCollisionCheckTransformResults.prototype.reset = function reset7() {
  this.myStartCheckTransformQuat.quat2_identity();
  this.myEndCheckTransformQuat.quat2_identity();
  this.myCheckTransformFailed = false;
};
CharacterCollisionCheckTransformResults.prototype.copy = function copy15(other2) {
  this.myStartCheckTransformQuat.quat2_copy(other2.myStartCheckTransformQuat);
  this.myEndCheckTransformQuat.quat2_copy(other2.myEndCheckTransformQuat);
  this.myCheckTransformFailed = other2.myCheckTransformFailed;
};
CharacterCollisionSurfaceResults.prototype.reset = function reset8() {
  this.myHasSnappedOnSurface = false;
  this.myHasPoppedOutSurface = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = false;
  this.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = false;
};
CharacterCollisionSurfaceResults.prototype.copy = function copy16(other2) {
  this.myHasSnappedOnSurface = other2.myHasSnappedOnSurface;
  this.myHasPoppedOutSurface = other2.myHasPoppedOutSurface;
  this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = other2.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
  this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = other2.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill;
  this.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = other2.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill;
};
CharacterCollisionSplitMovementResults.prototype.reset = function reset9() {
  this.myStepsToPerform = 0;
  this.myStepsPerformed = 0;
  this.myMovementInterrupted = false;
  this.myMovementChecked.vec3_zero();
};
CharacterCollisionSplitMovementResults.prototype.copy = function copy17(other2) {
  this.myStepsToPerform = other2.myStepsToPerform;
  this.myStepsPerformed = other2.myStepsPerformed;
  this.myMovementInterrupted = other2.myMovementInterrupted;
  this.myMovementChecked.vec3_copy(other2.myMovementChecked);
};
CharacterCollisionDebugResults.prototype.reset = function reset10() {
  this._myRaycastsPerformed = 0;
};
CharacterCollisionDebugResults.prototype.copy = function copy18(other2) {
  this._myRaycastsPerformed = other2._myRaycastsPerformed;
};
CharacterCollisionInternalResults.prototype.reset = function reset11() {
};
CharacterCollisionInternalResults.prototype.copy = function copy19(other2) {
  this.myLastRelevantStartHorizontalMovement.vec3_copy(other2.myLastRelevantStartHorizontalMovement);
  this.myLastRelevantAdjustedStartHorizontalMovement.vec3_copy(other2.myLastRelevantAdjustedStartHorizontalMovement);
  this.myLastRelevantEndHorizontalMovement.vec3_copy(other2.myLastRelevantEndHorizontalMovement);
  this.myLastRelevantStartVerticalMovement.vec3_copy(other2.myLastRelevantStartVerticalMovement);
  this.myLastRelevantAdjustedStartVerticalMovement.vec3_copy(other2.myLastRelevantAdjustedStartVerticalMovement);
  this.myLastRelevantEndVerticalMovement.vec3_copy(other2.myLastRelevantEndVerticalMovement);
  this.myLastRelevantHasWallSlid = other2.myLastRelevantHasWallSlid;
  this.myHasWallSlidTowardOppositeDirection = other2.myHasWallSlidTowardOppositeDirection;
  this.myLastRelevantWallSlideFlickerPrevented = other2.myLastRelevantWallSlideFlickerPrevented;
  this.myWallSlideFlickerPreventionForceCheckCounter = other2.myWallSlideFlickerPreventionForceCheckCounter;
  this.myWallSlide90DegreesDirectionSign = other2.myWallSlide90DegreesDirectionSign;
  this.myWallSlide90DegreesRecomputeDirectionSign = other2.myWallSlide90DegreesRecomputeDirectionSign;
};

// js/pp/gameplay/experimental/character_controller/collision/collision_check_bridge.js
var _myCollisionChecks = /* @__PURE__ */ new WeakMap();
function getCollisionCheck(engine2 = getMainEngine2()) {
  return _myCollisionChecks.get(engine2);
}
function setCollisionCheck(collisionCheck, engine2 = getMainEngine2()) {
  _myCollisionChecks.set(engine2, collisionCheck);
}
function initBridge(engine2 = getMainEngine2()) {
  setCollisionCheck(new CollisionCheck(engine2), engine2);
}
var checkMovement = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkMovement2(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = getMainEngine2()) {
    this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    getCollisionCheck(engine2).move(movement, currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTeleportToTransform = function() {
  let teleportPosition = vec3_create2();
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTeleportToTransform2(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = getMainEngine2()) {
    this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    teleportPosition = teleportTransformQuat.quat2_getPosition(teleportPosition);
    getCollisionCheck(engine2).teleport(teleportPosition, teleportTransformQuat, collisionCheckParams, collisionRuntimeParams);
    this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTransform = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTransform2(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = getMainEngine2()) {
    this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    getCollisionCheck(engine2).positionCheck(true, checkTransformQuat, collisionCheckParams, collisionRuntimeParams);
    this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, checkTransformQuat, outCharacterCollisionResults);
  };
}();
var updateGroundInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateGroundInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = getMainEngine2()) {
    this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeCeilingInfoEnabled = false;
    getCollisionCheck(engine2).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var updateCeilingInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateCeilingInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = getMainEngine2()) {
    this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeGroundInfoEnabled = false;
    getCollisionCheck(engine2).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
function convertCharacterCollisionResultsToCollisionRuntimeParams(characterCollisionResults, outCollisionRuntimeParams) {
  outCollisionRuntimeParams.reset();
  characterCollisionResults.myTransformResults.myStartTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPosition);
  characterCollisionResults.myTransformResults.myEndTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myNewPosition);
  characterCollisionResults.myTransformResults.myStartTransformQuat.quat2_getForward(outCollisionRuntimeParams.myOriginalForward);
  characterCollisionResults.myTransformResults.myStartTransformQuat.quat2_getUp(outCollisionRuntimeParams.myOriginalUp);
  outCollisionRuntimeParams.myOriginalMovement.vec3_copy(characterCollisionResults.myMovementResults.myStartMovement);
  outCollisionRuntimeParams.myFixedMovement.vec3_copy(characterCollisionResults.myMovementResults.myEndMovement);
  outCollisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantStartHorizontalMovement);
  outCollisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantStartVerticalMovement);
  outCollisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantEndHorizontalMovement);
  outCollisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantEndVerticalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedStartHorizontalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedStartVerticalMovement);
  outCollisionRuntimeParams.myIsOnGround = characterCollisionResults.myGroundInfo.myIsOnSurface;
  outCollisionRuntimeParams.myGroundAngle = characterCollisionResults.myGroundInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myGroundPerceivedAngle = characterCollisionResults.myGroundInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myGroundNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myGroundHitMaxAngle = characterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myGroundDistance = characterCollisionResults.myGroundInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myGroundIsBaseInsideCollision = characterCollisionResults.myGroundInfo.myIsBaseInsideCollision;
  outCollisionRuntimeParams.myIsOnCeiling = characterCollisionResults.myCeilingInfo.myIsOnSurface;
  outCollisionRuntimeParams.myCeilingAngle = characterCollisionResults.myCeilingInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myCeilingPerceivedAngle = characterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myCeilingNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myCeilingHitMaxAngle = characterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myCeilingDistance = characterCollisionResults.myCeilingInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myCeilingIsBaseInsideCollision = characterCollisionResults.myCeilingInfo.myIsBaseInsideCollision;
  outCollisionRuntimeParams.myHorizontalMovementCanceled = characterCollisionResults.myHorizontalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingHorizontally = characterCollisionResults.myHorizontalMovementResults.myIsColliding;
  outCollisionRuntimeParams.myHorizontalCollisionHit.copy(characterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myVerticalMovementCanceled = characterCollisionResults.myVerticalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingVertically = characterCollisionResults.myVerticalMovementResults.myIsColliding;
  outCollisionRuntimeParams.myVerticalCollisionHit.copy(characterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myHasSnappedOnGround = characterCollisionResults.myGroundResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasSnappedOnCeiling = characterCollisionResults.myCeilingResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasPoppedOutGround = characterCollisionResults.myGroundResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHasPoppedOutCeiling = characterCollisionResults.myCeilingResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = characterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = characterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill;
  outCollisionRuntimeParams.myIsSliding = characterCollisionResults.myWallSlideResults.myHasSlid;
  outCollisionRuntimeParams.mySlidingMovementAngle = characterCollisionResults.myWallSlideResults.mySlideMovementAngle;
  outCollisionRuntimeParams.mySlidingCollisionAngle = characterCollisionResults.myWallSlideResults.mySlideMovementWallAngle;
  outCollisionRuntimeParams.mySlidingWallNormal.vec3_copy(characterCollisionResults.myWallSlideResults.myWallNormal);
  outCollisionRuntimeParams.myIsSlidingIntoOppositeDirection = characterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection;
  outCollisionRuntimeParams.myIsSlidingFlickerPrevented = characterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented;
  outCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = characterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter;
  outCollisionRuntimeParams.mySliding90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign;
  outCollisionRuntimeParams.mySlidingRecompute90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign;
  outCollisionRuntimeParams.myLastValidIsSliding = characterCollisionResults.myInternalResults.myLastRelevantHasWallSlid;
  outCollisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantEndHorizontalMovement);
  outCollisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myStartTeleportTransformQuat);
  outCollisionRuntimeParams.myFixedTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myEndTeleportTransformQuat);
  outCollisionRuntimeParams.myTeleportCanceled = characterCollisionResults.myTeleportResults.myTeleportFailed;
  outCollisionRuntimeParams.myIsPositionOk = characterCollisionResults.myCheckTransformResults.myCheckTransformFailed;
  characterCollisionResults.myCheckTransformResults.myStartCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPositionCheckPosition);
  characterCollisionResults.myCheckTransformResults.myEndCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myFixedPositionCheckPosition);
  outCollisionRuntimeParams.myIsTeleport = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TELEPORT;
  outCollisionRuntimeParams.myIsMove = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_MOVEMENT;
  outCollisionRuntimeParams.myIsPositionCheck = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TRANSFORM;
  outCollisionRuntimeParams.mySplitMovementSteps = characterCollisionResults.mySplitMovementResults.myStepsToPerform;
  outCollisionRuntimeParams.mySplitMovementStepsPerformed = characterCollisionResults.mySplitMovementResults.myStepsPerformed;
  outCollisionRuntimeParams.mySplitMovementStop = characterCollisionResults.mySplitMovementResults.myMovementInterrupted;
  outCollisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(characterCollisionResults.mySplitMovementResults.myMovementChecked);
  return outCollisionRuntimeParams;
}
var convertCollisionRuntimeParamsToCharacterCollisionResults = function() {
  let rotationQuat = quat_create();
  return function convertCollisionRuntimeParamsToCharacterCollisionResults2(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults) {
    outCharacterCollisionResults.reset();
    if (collisionRuntimeParams.myIsMove) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_MOVEMENT;
    } else if (collisionRuntimeParams.myIsTeleport) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TELEPORT;
    } else if (collisionRuntimeParams.myIsPositionCheck) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TRANSFORM;
    }
    rotationQuat.quat_setForward(collisionRuntimeParams.myOriginalForward, collisionRuntimeParams.myOriginalUp);
    outCharacterCollisionResults.myTransformResults.myStartTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myOriginalPosition, rotationQuat);
    outCharacterCollisionResults.myTransformResults.myEndTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myNewPosition, rotationQuat);
    outCharacterCollisionResults.myMovementResults.myStartMovement.vec3_copy(collisionRuntimeParams.myOriginalMovement);
    outCharacterCollisionResults.myMovementResults.myEndMovement.vec3_copy(collisionRuntimeParams.myFixedMovement);
    outCharacterCollisionResults.myMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myMovementResults.myIsColliding = collisionRuntimeParams.myIsCollidingHorizontally || collisionRuntimeParams.myIsCollidingVertically;
    if (collisionRuntimeParams.myIsCollidingHorizontally) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    } else if (collisionRuntimeParams.myIsCollidingVertically) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    }
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled;
    outCharacterCollisionResults.myHorizontalMovementResults.myIsColliding = collisionRuntimeParams.myIsCollidingHorizontally;
    outCharacterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    outCharacterCollisionResults.myVerticalMovementResults.myMovementFailed = collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myVerticalMovementResults.myIsColliding = collisionRuntimeParams.myIsCollidingVertically;
    outCharacterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    outCharacterCollisionResults.myTeleportResults.myStartTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myStartTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myStartTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myEndTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myEndTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myEndTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myTeleportFailed = collisionRuntimeParams.myTeleportCanceled;
    outCharacterCollisionResults.myCheckTransformResults.myStartCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myStartTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myStartCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myEndCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myEndTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myEndCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myCheckTransformFailed = !collisionRuntimeParams.myIsPositionOk;
    outCharacterCollisionResults.myWallSlideResults.myHasSlid = collisionRuntimeParams.myIsSliding;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementAngle = collisionRuntimeParams.mySlidingMovementAngle;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementWallAngle = collisionRuntimeParams.mySlidingCollisionAngle;
    outCharacterCollisionResults.myWallSlideResults.myWallNormal.vec3_copy(ollisionRuntimeParams.mySlidingWallNormal);
    outCharacterCollisionResults.myGroundInfo.myIsOnSurface = collisionRuntimeParams.myIsOnGround;
    outCharacterCollisionResults.myGroundInfo.mySurfaceAngle = collisionRuntimeParams.myGroundAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myGroundPerceivedAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myGroundHitMaxAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundHitMaxNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceDistance = collisionRuntimeParams.myGroundDistance;
    outCharacterCollisionResults.myGroundInfo.myIsBaseInsideCollision = collisionRuntimeParams.myGroundIsBaseInsideCollision;
    outCharacterCollisionResults.myCeilingInfo.myIsOnSurface = collisionRuntimeParams.myIsOnCeiling;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceAngle = collisionRuntimeParams.myCeilingAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myCeilingPerceivedAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myCeilingHitMaxAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingHitMaxNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceDistance = collisionRuntimeParams.myCeilingDistance;
    outCharacterCollisionResults.myCeilingInfo.myIsBaseInsideCollision = collisionRuntimeParams.myCeilingIsBaseInsideCollision;
    outCharacterCollisionResults.myGroundResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnGround;
    outCharacterCollisionResults.myGroundResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutGround;
    outCharacterCollisionResults.myCeilingResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnCeiling;
    outCharacterCollisionResults.myCeilingResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutCeiling;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill;
    outCharacterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill;
    outCharacterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill;
    outCharacterCollisionResults.mySplitMovementResults.myStepsToPerform = collisionRuntimeParams.mySplitMovementSteps;
    outCharacterCollisionResults.mySplitMovementResults.myStepsPerformed = collisionRuntimeParams.mySplitMovementStepsPerformed;
    outCharacterCollisionResults.mySplitMovementResults.myMovementInterrupted = collisionRuntimeParams.mySplitMovementStop;
    outCharacterCollisionResults.mySplitMovementResults.myMovementChecked.vec3_copy(collisionRuntimeParams.mySplitMovementMovementChecked);
    outCharacterCollisionResults.myInternalResults.myLastRelevantStartHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantEndHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantStartVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantEndVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedStartHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedStartVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantHasWallSlid = collisionRuntimeParams.myLastValidIsSliding;
    outCharacterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection = collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
    outCharacterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
    outCharacterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter = collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign = collisionRuntimeParams.mySliding90DegreesSign;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign = collisionRuntimeParams.mySlidingRecompute90DegreesSign;
    outCharacterCollisionResults.myTransformResults.myStartTransformQuat.quat2_copy(currentTransformQuat);
    return outCharacterCollisionResults;
  };
}();
var convertCharacterColliderSetupToCollisionCheckParams = function() {
  return function convertCharacterColliderSetupToCollisionCheckParams2(characterColliderSetup, outCollisionCheckParams) {
    outCollisionCheckParams.myHeight = characterColliderSetup.myHeight;
    outCollisionCheckParams.myRadius = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeRadius;
    outCollisionCheckParams.myDistanceFromFeetToIgnore = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore;
    outCollisionCheckParams.myDistanceFromHeadToIgnore = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckHeadDistanceToIgnore;
    outCollisionCheckParams.myHorizontalMovementCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementStepEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckSplitMovementEnabled;
    outCollisionCheckParams.myHorizontalMovementStepMaxLength = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckSplitMovementMaxStepLength;
    outCollisionCheckParams.myHorizontalMovementRadialStepAmount = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckRadialSteps;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckStraight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckHorizontalBorder = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myHalfConeAngle = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle;
    outCollisionCheckParams.myHalfConeSliceAmount = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices;
    outCollisionCheckParams.myCheckConeBorder = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalBorderCheckEnabled;
    outCollisionCheckParams.myCheckConeRay = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalDirectionType = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckDirection;
    outCollisionCheckParams.myCheckHeight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalHeightCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalMovement = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalPosition = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopMovement = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopPosition = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightConeOnCollision = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
    outCollisionCheckParams.myCheckHeightConeOnCollisionKeepHit = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
    outCollisionCheckParams.myHeightCheckStepAmountMovement = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightCheckSteps;
    outCollisionCheckParams.myHeightCheckStepAmountPosition = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightCheckSteps;
    outCollisionCheckParams.myCheckVerticalStraight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalStraightCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalSearchFartherVerticalHit = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckGetFarthestHit;
    outCollisionCheckParams.myCheckHorizontalFixedForwardEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckHorizontalFixedForward.vec3_copy(characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForward);
    outCollisionCheckParams.myVerticalMovementCheckEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckEnabled;
    outCollisionCheckParams.myVerticalPositionCheckEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled;
    outCollisionCheckParams.myFeetRadius = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadius;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = characterColliderSetup.myGroundSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = characterColliderSetup.myCeilingSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myCheckVerticalFixedForwardEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckVerticalFixedForward.vec3_copy(characterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForward);
    outCollisionCheckParams.myCheckVerticalBothDirection = characterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckPerformCheckOnBothSides;
    outCollisionCheckParams.myVerticalMovementReduceEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckReductionEnabled;
    outCollisionCheckParams.myGroundCircumferenceAddCenter = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceCentralCheckEnabled;
    outCollisionCheckParams.myGroundCircumferenceSliceAmount = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
    outCollisionCheckParams.myGroundCircumferenceStepAmount = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps;
    outCollisionCheckParams.myGroundCircumferenceRotationPerStep = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep;
    outCollisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
    outCollisionCheckParams.myHorizontalBlockLayerFlags.copy(characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckBlockLayerFlags);
    outCollisionCheckParams.myVerticalBlockLayerFlags.copy(characterColliderSetup.myVerticalCheckSetup.myVerticalCheckBlockLayerFlags);
    outCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckObjectsToIgnore);
    outCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(characterColliderSetup.myVerticalCheckSetup.myVerticalCheckObjectsToIgnore);
    outCollisionCheckParams.mySnapOnGroundEnabled = characterColliderSetup.myGroundSetup.mySurfaceSnapEnabled;
    outCollisionCheckParams.mySnapOnGroundExtraDistance = characterColliderSetup.myGroundSetup.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.mySnapOnCeilingEnabled = characterColliderSetup.myCeilingSetup.mySurfaceSnapEnabled;
    outCollisionCheckParams.mySnapOnCeilingExtraDistance = characterColliderSetup.myCeilingSetup.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.myGroundPopOutEnabled = characterColliderSetup.myGroundSetup.mySurfacePopOutEnabled;
    outCollisionCheckParams.myGroundPopOutExtraDistance = characterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myCeilingPopOutEnabled = characterColliderSetup.myCeilingSetup.mySurfacePopOutEnabled;
    outCollisionCheckParams.myCeilingPopOutExtraDistance = characterColliderSetup.myCeilingSetup.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myGroundAngleToIgnore = characterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myGroundSetup.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myCeilingAngleToIgnore = characterColliderSetup.myCeilingSetup.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myCeilingSetup.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = characterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = characterColliderSetup.myGroundSetup.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingSetup.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = characterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = characterColliderSetup.myCeilingSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myComputeGroundInfoEnabled = characterColliderSetup.myGroundSetup.myCollectSurfaceInfo;
    outCollisionCheckParams.myComputeCeilingInfoEnabled = characterColliderSetup.myCeilingSetup.myCollectSurfaceInfo;
    outCollisionCheckParams.myDistanceToBeOnGround = characterColliderSetup.myGroundSetup.myIsOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeGroundInfo = characterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToBeOnCeiling = characterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeCeilingInfo = characterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnGround = characterColliderSetup.myGroundSetup.myIsOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeGroundInfo = characterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnCeiling = characterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeCeilingInfo = characterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myGroundSetup.myIsBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myCeilingSetup.myIsBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myIsOnGroundIfInsideHit = characterColliderSetup.myGroundSetup.myIsOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myIsOnCeilingIfInsideHit = characterColliderSetup.myCeilingSetup.myIsOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myFindGroundDistanceMaxOutsideDistance = characterColliderSetup.myGroundSetup.myFindSurfaceDistanceMaxOutsideDistance;
    outCollisionCheckParams.myFindGroundDistanceMaxInsideDistance = characterColliderSetup.myGroundSetup.myFindSurfaceDistanceMaxInsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxOutsideDistance = characterColliderSetup.myCeilingSetup.myFindSurfaceDistanceMaxOutsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxInsideDistance = characterColliderSetup.myCeilingSetup.myFindSurfaceDistanceMaxInsideDistance;
    outCollisionCheckParams.myAllowGroundSteepFix = characterColliderSetup.myGroundSetup.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myAllowCeilingSteepFix = characterColliderSetup.myCeilingSetup.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myMustStayOnGround = characterColliderSetup.myGroundSetup.myMovementMustStayOnSurface;
    outCollisionCheckParams.myMustStayOnCeiling = characterColliderSetup.myCeilingSetup.myMovementMustStayOnSurface;
    outCollisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail = characterColliderSetup.myGroundSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail = characterColliderSetup.myCeilingSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill = characterColliderSetup.myGroundSetup.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowGroundAngleDownhill = characterColliderSetup.myGroundSetup.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMovementMustStayOnGroundHitAngle = characterColliderSetup.myGroundSetup.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myMovementMustStayOnCeilingHitAngle = characterColliderSetup.myCeilingSetup.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundSetup.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundSetup.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingSetup.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingSetup.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGroundAngle = characterColliderSetup.myGroundSetup.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnGroundAngle = characterColliderSetup.myGroundSetup.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnCeilingAngle = characterColliderSetup.myCeilingSetup.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnCeilingAngle = characterColliderSetup.myCeilingSetup.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGround = characterColliderSetup.myGroundSetup.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnGround = characterColliderSetup.myGroundSetup.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.myTeleportMustBeOnCeiling = characterColliderSetup.myCeilingSetup.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnCeiling = characterColliderSetup.myCeilingSetup.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.mySlidingEnabled = characterColliderSetup.myWallSlideSetup.myWallSlideEnabled;
    outCollisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckGetBetterReferenceHit;
    outCollisionCheckParams.mySlidingMaxAttempts = characterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts;
    outCollisionCheckParams.mySlidingCheckBothDirections = characterColliderSetup.myWallSlideSetup.myCheckBothWallSlideDirections;
    outCollisionCheckParams.mySlidingFlickeringPreventionType = characterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode;
    outCollisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = characterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
    outCollisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter = characterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter;
    outCollisionCheckParams.mySlidingAdjustSign90Degrees = characterColliderSetup.myWallSlideSetup.my90DegreesWallSlideAdjustDirectionSign;
    outCollisionCheckParams.mySplitMovementEnabled = characterColliderSetup.mySplitMovementSetup.mySplitMovementEnabled;
    outCollisionCheckParams.mySplitMovementMaxLength = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxStepLength;
    outCollisionCheckParams.mySplitMovementMaxStepsEnabled = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxSteps != null;
    outCollisionCheckParams.mySplitMovementMaxSteps = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxSteps;
    outCollisionCheckParams.mySplitMovementStepEqualLength = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxStepLength == null;
    outCollisionCheckParams.mySplitMovementStepEqualLengthMinLength = characterColliderSetup.mySplitMovementSetup.mySplitMovementMinStepLength;
    outCollisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopOnHorizontalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopOnVerticalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopCallback = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopOnCallback;
    outCollisionCheckParams.mySplitMovementStopReturnPrevious = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopReturnPreviousResults;
    outCollisionCheckParams.myPositionOffsetLocal.vec3_copy(characterColliderSetup.myAdditionalSetup.myPositionOffsetLocal);
    outCollisionCheckParams.myRotationOffsetLocalQuat.quat_copy(characterColliderSetup.myAdditionalSetup.myRotationOffsetLocalQuat);
    outCollisionCheckParams.myDebugActive = characterColliderSetup.myDebugSetup.myVisualDebugActive;
    outCollisionCheckParams.myDebugHorizontalMovementActive = characterColliderSetup.myDebugSetup.myVisualDebugHorizontalMovementCheckActive;
    outCollisionCheckParams.myDebugHorizontalPositionActive = characterColliderSetup.myDebugSetup.myVisualDebugHorizontalPositionCheckActive;
    outCollisionCheckParams.myDebugVerticalMovementActive = characterColliderSetup.myDebugSetup.myVisualDebugVerticalMovementCheckActive;
    outCollisionCheckParams.myDebugVerticalPositionActive = characterColliderSetup.myDebugSetup.myVisualDebugVerticalPositionCheckActive;
    outCollisionCheckParams.myDebugSlidingActive = characterColliderSetup.myDebugSetup.myVisualDebugSlideActive;
    outCollisionCheckParams.myDebugGroundInfoActive = characterColliderSetup.myDebugSetup.myVisualDebugGroundInfoActive;
    outCollisionCheckParams.myDebugCeilingInfoActive = characterColliderSetup.myDebugSetup.myVisualDebugGroundInfoActive;
    outCollisionCheckParams.myDebugRuntimeParamsActive = characterColliderSetup.myDebugSetup.myVisualDebugResultsActive;
    outCollisionCheckParams.myDebugMovementActive = characterColliderSetup.myDebugSetup.myVisualDebugMovementActive;
    return outCollisionCheckParams;
  };
}();
var CollisionCheckBridge = {
  initBridge,
  checkMovement,
  checkTeleportToTransform,
  checkTransform,
  updateGroundInfo,
  updateCeilingInfo,
  convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults,
  convertCharacterColliderSetupToCollisionCheckParams
};

// js/pp/gameplay/experimental/character_controller/collision/character_collider_setup.js
var CharacterColliderSetup = class {
  constructor() {
    this.myHeight = 0;
    this.myHorizontalCheckSetup = new CharacterColliderHorizontalCheckSetup();
    this.myVerticalCheckSetup = new CharacterColliderVerticalCheckSetup();
    this.myWallSlideSetup = new CharacterColliderWallSlideSetup();
    this.myGroundSetup = new CharacterColliderSurfaceSetup();
    this.myCeilingSetup = new CharacterColliderSurfaceSetup();
    this.mySplitMovementSetup = new CharacterColliderSplitMovementSetup();
    this.myAdditionalSetup = new CharacterColliderAdditionalSetup();
    this.myDebugSetup = new CharacterColliderDebugSetup();
  }
  copy(other2) {
  }
};
var CharacterColliderHorizontalPositionVerticalCheckDirection = {
  UPWARD: 0,
  DOWNWARD: 1,
  BOTH: 2
};
var CharacterColliderHorizontalCheckSetup = class {
  constructor() {
    this.myHorizontalCheckConeRadius = 0;
    this.myHorizontalCheckConeHalfAngle = 0;
    this.myHorizontalHeightCheckEnabled = false;
    this.myHorizontalCheckFeetDistanceToIgnore = 0;
    this.myHorizontalCheckHeadDistanceToIgnore = 0;
    this.myHorizontalCheckFixedForwardEnabled = false;
    this.myHorizontalCheckFixedForward = vec3_create2();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementCheckRadialSteps = 0;
    this.myHorizontalMovementCheckSplitMovementEnabled = false;
    this.myHorizontalMovementCheckSplitMovementMaxSteps = null;
    this.myHorizontalMovementCheckSplitMovementMaxStepLength = null;
    this.myHorizontalMovementCheckSplitMovementMinStepLength = null;
    this.myHorizontalMovementCheckGetBetterReferenceHit = false;
    this.myHorizontalMovementHorizontalRadialCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementHeightCheckSteps = 0;
    this.myHorizontalMovementHeightHorizontalCheckEnabled = false;
    this.myHorizontalMovementHeightVerticalCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHorizontalPositionCheckConeHalfSlices = 0;
    this.myHorizontalPositionHorizontalBorderCheckEnabled = false;
    this.myHorizontalPositionHorizontalRadialCheckEnabled = false;
    this.myHorizontalPositionHeightCheckSteps = 0;
    this.myHorizontalPositionHeightHorizontalCheckEnabled = false;
    this.myHorizontalPositionHeightVerticalCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalCheckGetFarthestHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = false;
    this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false;
    this.myHorizontalPositionVerticalCheckDirection = CharacterColliderHorizontalPositionVerticalCheckDirection.UPWARD;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
  }
  copy(other2) {
  }
};
var CharacterColliderVerticalCheckSetup = class {
  constructor() {
    this.myVerticalCheckCircumferenceRadius = 0;
    this.myVerticalCheckCircumferenceSlices = 0;
    this.myVerticalCheckCircumferenceCentralCheckEnabled = false;
    this.myVerticalCheckCircumferenceRadialSteps = 0;
    this.myVerticalCheckCircumferenceRotationPerRadialStep = 0;
    this.myVerticalCheckFixedForwardEnabled = false;
    this.myVerticalCheckFixedForward = vec3_create2();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalMovementCheckReductionEnabled = false;
    this.myVerticalMovementCheckPerformCheckOnBothSides = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = false;
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
  }
  copy(other2) {
  }
};
var CharacterColliderSlideFlickerPreventionMode = {
  NONE: 0,
  USE_PREVIOUS_RESULTS: 1,
  COLLISION_ANGLE_ABOVE_90_DEGREES: 2,
  COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES: 3,
  ALWAYS: 4
};
var CharacterColliderWallSlideSetup = class {
  constructor() {
    this.myWallSlideEnabled = false;
    this.myWallSlideMaxAttempts = 0;
    this.myCheckBothWallSlideDirections = false;
    this.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  copy(other2) {
  }
};
var CharacterColliderSurfaceSetup = class {
  constructor() {
    this.mySurfaceSnapEnabled = false;
    this.mySurfaceSnapMaxDistance = 0;
    this.mySurfacePopOutEnabled = false;
    this.mySurfacePopOutMaxDistance = 0;
    this.mySurfaceAngleToIgnore = 0;
    this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = null;
    this.myCollectSurfaceInfo = false;
    this.myIsOnSurfaceMaxOutsideDistance = 0;
    this.myIsOnSurfaceMaxInsideDistance = 0;
    this.myIsBaseInsideCollisionCheckEnabled = false;
    this.myIsOnSurfaceIfBaseInsideCollision = false;
    this.myCollectSurfaceNormalMaxOutsideDistance = 0;
    this.myCollectSurfaceNormalMaxInsideDistance = 0;
    this.myFindSurfaceDistanceMaxOutsideDistance = 0;
    this.myFindSurfaceDistanceMaxInsideDistance = 0;
    this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill = false;
    this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill = false;
    this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = null;
    this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill = false;
    this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle = null;
    this.myMovementMustStayOnSurface = false;
    this.myMovementMustStayOnSurfaceHitMaxAngle = null;
    this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = false;
    this.myMovementMustStayOnSurfaceAngleDownhill = null;
    this.myTeleportMustBeOnSurface = false;
    this.myTeleportMustBeOnIgnorableSurfaceAngle = false;
    this.myTeleportMustBeOnSurfaceAngle = null;
    this.myCheckTransformMustBeOnSurface = false;
    this.myCheckTransformMustBeOnIgnorableSurfaceAngle = false;
    this.myCheckTransformMustBeOnSurfaceAngle = null;
    this.myRecollectSurfaceInfoOnSurfaceCheckFailed = false;
    this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = false;
  }
  copy(other2) {
  }
};
var CharacterColliderSplitMovementSetup = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxSteps = null;
    this.mySplitMovementMaxStepLength = null;
    this.mySplitMovementMinStepLength = null;
    this.mySplitMovementStopOnHorizontalMovementFailed = false;
    this.mySplitMovementStopOnVerticalMovementFailed = false;
    this.mySplitMovementStopReturnPreviousResults = false;
  }
  copy(other2) {
  }
};
var CharacterColliderAdditionalSetup = class {
  constructor() {
    this.myPositionOffsetLocal = vec3_create2();
    this.myRotationOffsetLocalQuat = quat_create();
  }
  copy(other2) {
  }
};
var CharacterColliderDebugSetup = class {
  constructor() {
    this.myVisualDebugActive = false;
    this.myVisualDebugMovementActive = false;
    this.myVisualDebugHorizontalMovementCheckActive = false;
    this.myVisualDebugHorizontalPositionCheckActive = false;
    this.myVisualDebugVerticalMovementCheckActive = false;
    this.myVisualDebugVerticalPositionCheckActive = false;
    this.myVisualDebugSlideActive = false;
    this.myVisualDebugGroundInfoActive = false;
    this.myVisualDebugCeilingInfoActive = false;
    this.myVisualDebugResultsActive = false;
  }
  copy(other2) {
  }
};
CharacterColliderSetup.prototype.copy = function copy20(other2) {
  this.myHeight = other2.myHeight;
  this.myHorizontalCheckSetup.copy(other2.myHorizontalCheckSetup);
  this.myVerticalCheckSetup.copy(other2.myVerticalCheckSetup);
  this.myWallSlideSetup.copy(other2.myWallSlideSetup);
  this.myGroundSetup.copy(other2.myGroundSetup);
  this.myCeilingSetup.copy(other2.myCeilingSetup);
  this.mySplitMovementSetup.copy(other2.mySplitMovementSetup);
  this.myAdditionalSetup.copy(other2.myAdditionalSetup);
  this.myDebugSetup.copy(other2.myDebugSetup);
};
CharacterColliderHorizontalCheckSetup.prototype.copy = function copy21(other2) {
  this.myHorizontalCheckConeRadius = other2.myHorizontalCheckConeRadius;
  this.myHorizontalCheckConeHalfAngle = other2.myHorizontalCheckConeHalfAngle;
  this.myHorizontalHeightCheckEnabled = other2.myHorizontalHeightCheckEnabled;
  this.myHorizontalCheckFeetDistanceToIgnore = other2.myHorizontalCheckFeetDistanceToIgnore;
  this.myHorizontalCheckHeadDistanceToIgnore = other2.myHorizontalCheckHeadDistanceToIgnore;
  this.myHorizontalCheckFixedForwardEnabled = other2.myHorizontalCheckFixedForwardEnabled;
  this.myHorizontalCheckFixedForward.vec3_copy(other2.myHorizontalCheckFixedForward);
  this.myHorizontalMovementCheckEnabled = other2.myHorizontalMovementCheckEnabled;
  this.myHorizontalMovementCheckRadialSteps = other2.myHorizontalMovementCheckRadialSteps;
  this.myHorizontalMovementCheckSplitMovementEnabled = other2.myHorizontalMovementCheckSplitMovementEnabled;
  this.myHorizontalMovementCheckSplitMovementMaxSteps = other2.myHorizontalMovementCheckSplitMovementMaxSteps;
  this.myHorizontalMovementCheckSplitMovementMaxStepLength = other2.myHorizontalMovementCheckSplitMovementMaxStepLength;
  this.myHorizontalMovementCheckSplitMovementMinStepLength = other2.myHorizontalMovementCheckSplitMovementMinStepLength;
  this.myHorizontalMovementCheckGetBetterReferenceHit = other2.myHorizontalMovementCheckGetBetterReferenceHit;
  this.myHorizontalMovementHorizontalRadialCheckEnabled = other2.myHorizontalMovementHorizontalRadialCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = other2.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = other2.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCheckEnabled = other2.myHorizontalMovementHorizontalStraightCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other2.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
  this.myHorizontalMovementHeightCheckSteps = other2.myHorizontalMovementHeightCheckSteps;
  this.myHorizontalMovementHeightVerticalCheckEnabled = other2.myHorizontalMovementHeightVerticalCheckEnabled;
  this.myHorizontalMovementHeightHorizontalCheckEnabled = other2.myHorizontalMovementHeightHorizontalCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = other2.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = other2.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = other2.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = other2.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = other2.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = other2.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightCheckEnabled = other2.myHorizontalMovementVerticalStraightCheckEnabled;
  this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other2.myHorizontalMovementVerticalStraightCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = other2.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other2.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = other2.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other2.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
  this.myHorizontalPositionCheckEnabled = other2.myHorizontalPositionCheckEnabled;
  this.myHorizontalPositionCheckConeHalfSlices = other2.myHorizontalPositionCheckConeHalfSlices;
  this.myHorizontalPositionHorizontalBorderCheckEnabled = other2.myHorizontalPositionHorizontalBorderCheckEnabled;
  this.myHorizontalPositionHorizontalRadialCheckEnabled = other2.myHorizontalPositionHorizontalRadialCheckEnabled;
  this.myHorizontalPositionHeightCheckSteps = other2.myHorizontalPositionHeightCheckSteps;
  this.myHorizontalPositionHeightHorizontalCheckEnabled = other2.myHorizontalPositionHeightHorizontalCheckEnabled;
  this.myHorizontalPositionHeightVerticalCheckEnabled = other2.myHorizontalPositionHeightVerticalCheckEnabled;
  this.myHorizontalPositionVerticalStraightCheckEnabled = other2.myHorizontalPositionVerticalStraightCheckEnabled;
  this.myHorizontalPositionVerticalStraightCentralCheckEnabled = other2.myHorizontalPositionVerticalStraightCentralCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = other2.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = other2.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = other2.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = other2.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = other2.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = other2.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalCheckGetFarthestHit = other2.myHorizontalPositionVerticalCheckGetFarthestHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = other2.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = other2.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
  this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = other2.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
  this.myHorizontalPositionVerticalCheckDirection = other2.myHorizontalPositionVerticalCheckDirection;
  this.myHorizontalCheckBlockLayerFlags.setMask(other2.myHorizontalCheckBlockLayerFlags.getMask());
  this.myHorizontalCheckObjectsToIgnore.pp_copy(other2.myHorizontalCheckObjectsToIgnore);
};
CharacterColliderVerticalCheckSetup.prototype.copy = function copy22(other2) {
  this.myVerticalCheckCircumferenceRadius = other2.myVerticalCheckCircumferenceRadius;
  this.myVerticalCheckCircumferenceSlices = other2.myVerticalCheckCircumferenceSlices;
  this.myVerticalCheckCircumferenceCentralCheckEnabled = other2.myVerticalCheckCircumferenceCentralCheckEnabled;
  this.myVerticalCheckCircumferenceRadialSteps = other2.myVerticalCheckCircumferenceRadialSteps;
  this.myVerticalCheckCircumferenceRotationPerRadialStep = other2.myVerticalCheckCircumferenceRotationPerRadialStep;
  this.myVerticalCheckFixedForwardEnabled = other2.myVerticalCheckFixedForwardEnabled;
  this.myVerticalCheckFixedForward.vec3_copy(other2.myVerticalCheckFixedForward);
  this.myVerticalMovementCheckEnabled = other2.myVerticalMovementCheckEnabled;
  this.myVerticalMovementCheckReductionEnabled = other2.myVerticalMovementCheckReductionEnabled;
  this.myVerticalMovementCheckPerformCheckOnBothSides = other2.myVerticalMovementCheckPerformCheckOnBothSides;
  this.myVerticalPositionCheckEnabled = other2.myVerticalPositionCheckEnabled;
  this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = other2.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
  this.myVerticalCheckBlockLayerFlags.setMask(other2.myVerticalCheckBlockLayerFlags.getMask());
  this.myVerticalCheckObjectsToIgnore.pp_copy(other2.myVerticalCheckObjectsToIgnore);
};
CharacterColliderWallSlideSetup.prototype.copy = function copy23(other2) {
  this.myWallSlideEnabled = other2.myWallSlideEnabled;
  this.myWallSlideMaxAttempts = other2.myWallSlideMaxAttempts;
  this.myCheckBothWallSlideDirections = other2.myCheckBothWallSlideDirections;
  this.myWallSlideFlickerPreventionMode = other2.myWallSlideFlickerPreventionMode;
  this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = other2.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
  this.myWallSlideFlickerPreventionForceCheckCounter = other2.myWallSlideFlickerPreventionForceCheckCounter;
  this.my90DegreesWallSlideAdjustDirectionSign = other2.my90DegreesWallSlideAdjustDirectionSign;
};
CharacterColliderSurfaceSetup.prototype.copy = function copy24(other2) {
  this.mySurfaceSnapEnabled = other2.mySurfaceSnapEnabled;
  this.mySurfaceSnapMaxDistance = other2.mySurfaceSnapMaxDistance;
  this.mySurfacePopOutEnabled = other2.mySurfacePopOutEnabled;
  this.mySurfacePopOutMaxDistance = other2.mySurfacePopOutMaxDistance;
  this.mySurfaceAngleToIgnore = other2.mySurfaceAngleToIgnore;
  this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = other2.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = other2.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = other2.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = other2.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
  this.myCollectSurfaceInfo = other2.myCollectSurfaceInfo;
  this.myIsOnSurfaceMaxOutsideDistance = other2.myIsOnSurfaceMaxOutsideDistance;
  this.myIsOnSurfaceMaxInsideDistance = other2.myIsOnSurfaceMaxInsideDistance;
  this.myIsBaseInsideCollisionCheckEnabled = other2.myIsBaseInsideCollisionCheckEnabled;
  this.myIsOnSurfaceIfBaseInsideCollision = other2.myIsOnSurfaceIfBaseInsideCollision;
  this.myCollectSurfaceNormalMaxOutsideDistance = other2.myCollectSurfaceNormalMaxOutsideDistance;
  this.myCollectSurfaceNormalMaxInsideDistance = other2.myCollectSurfaceNormalMaxInsideDistance;
  this.myFindSurfaceDistanceMaxOutsideDistance = other2.myFindSurfaceDistanceMaxOutsideDistance;
  this.myFindSurfaceDistanceMaxInsideDistance = other2.myFindSurfaceDistanceMaxInsideDistance;
  this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill = other2.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
  this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill = other2.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill;
  this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle = other2.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle = other2.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = other2.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
  this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = other2.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
  this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill = other2.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill;
  this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle = other2.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle;
  this.myMovementMustStayOnSurface = other2.myMovementMustStayOnSurface;
  this.myMovementMustStayOnSurfaceHitMaxAngle = other2.myMovementMustStayOnSurfaceHitMaxAngle;
  this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = other2.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
  this.myMovementMustStayOnSurfaceAngleDownhill = other2.myMovementMustStayOnSurfaceAngleDownhill;
  this.myTeleportMustBeOnSurface = other2.myTeleportMustBeOnSurface;
  this.myTeleportMustBeOnIgnorableSurfaceAngle = other2.myTeleportMustBeOnIgnorableSurfaceAngle;
  this.myTeleportMustBeOnSurfaceAngle = other2.myTeleportMustBeOnSurfaceAngle;
  this.myCheckTransformMustBeOnSurface = other2.myCheckTransformMustBeOnSurface;
  this.myCheckTransformMustBeOnIgnorableSurfaceAngle = other2.myCheckTransformMustBeOnIgnorableSurfaceAngle;
  this.myCheckTransformMustBeOnSurfaceAngle = other2.myCheckTransformMustBeOnSurfaceAngle;
  this.myRecollectSurfaceInfoOnSurfaceCheckFailed = other2.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = other2.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
};
CharacterColliderSplitMovementSetup.prototype.copy = function copy25(other2) {
  this.mySplitMovementEnabled = other2.mySplitMovementEnabled;
  this.mySplitMovementMaxSteps = other2.mySplitMovementMaxSteps;
  this.mySplitMovementMaxStepLength = other2.mySplitMovementMaxStepLength;
  this.mySplitMovementMinStepLength = other2.mySplitMovementMinStepLength;
  this.mySplitMovementStopOnHorizontalMovementFailed = other2.mySplitMovementStopOnHorizontalMovementFailed;
  this.mySplitMovementStopOnVerticalMovementFailed = other2.mySplitMovementStopOnVerticalMovementFailed;
  this.mySplitMovementStopReturnPreviousResults = other2.mySplitMovementStopReturnPreviousResults;
};
CharacterColliderAdditionalSetup.prototype.copy = function copy26(other2) {
  this.myPositionOffsetLocal.vec3_copy(other2.myPositionOffsetLocal);
  this.myRotationOffsetLocalQuat.quat_copy(other2.myRotationOffsetLocalQuat);
};
CharacterColliderDebugSetup.prototype.copy = function copy27(other2) {
  this.myVisualDebugActive = other2.myVisualDebugActive;
  this.myVisualDebugMovementActive = other2.myVisualDebugMovementActive;
  this.myVisualDebugHorizontalMovementCheckActive = other2.myVisualDebugHorizontalMovementCheckActive;
  this.myVisualDebugHorizontalPositionCheckActive = other2.myVisualDebugHorizontalPositionCheckActive;
  this.myVisualDebugVerticalMovementCheckActive = other2.myVisualDebugVerticalMovementCheckActive;
  this.myVisualDebugVerticalPositionCheckActive = other2.myVisualDebugVerticalPositionCheckActive;
  this.myVisualDebugSlideActive = other2.myVisualDebugSlideActive;
  this.myVisualDebugGroundInfoActive = other2.myVisualDebugGroundInfoActive;
  this.myVisualDebugCeilingInfoActive = other2.myVisualDebugCeilingInfoActive;
  this.myVisualDebugResultsActive = other2.myVisualDebugResultsActive;
};

// js/pp/gameplay/experimental/character_controller/collision/character_collider_utils.js
var CharacterColliderSetupSimplifiedCreationAccuracyLevel = {
  VERY_LOW: 0,
  LOW: 1,
  MEDIUM: 2,
  HIGH: 3,
  VERY_HIGH: 4
};
var CharacterColliderSetupSimplifiedCreationParams = class {
  constructor() {
    this.myHeight = 0;
    this.myRadius = 0;
    this.myAccuracyLevel = CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW;
    this.myIsPlayer = false;
    this.myCheckOnlyFeet = false;
    this.myAverageSpeed = 0;
    this.myCanFly = false;
    this.myShouldSlideAgainstWall = false;
    this.myCollectGroundInfo = false;
    this.myShouldSnapOnGround = false;
    this.myMaxDistanceToSnapOnGround = 0;
    this.myMaxWalkableGroundAngle = 0;
    this.myMaxWalkableGroundStepHeight = 0;
    this.myShouldNotFallFromEdges = false;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
    this.myHorizontalCheckDebugActive = false;
    this.myVerticalCheckDebugActive = false;
  }
};
function createCharacterColliderSetupSimplified(simplifiedCreationParams, outCharacterColliderSetup = new CharacterColliderSetup()) {
  outCharacterColliderSetup.myHeight = simplifiedCreationParams.myHeight;
  outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeRadius = simplifiedCreationParams.myRadius;
  outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadius = simplifiedCreationParams.myRadius / 2;
  outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForwardEnabled = true;
  outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForward.vec3_set(0, 0, 1);
  if (!simplifiedCreationParams.myCheckOnlyFeet || simplifiedCreationParams.myCanFly) {
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalHeightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled = true;
  }
  outCharacterColliderSetup.myWallSlideSetup.myWallSlideEnabled = simplifiedCreationParams.myShouldSlideAgainstWall;
  outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore = simplifiedCreationParams.myMaxWalkableGroundStepHeight;
  outCharacterColliderSetup.myGroundSetup.mySurfaceSnapMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround;
  outCharacterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround > 0 ? simplifiedCreationParams.myMaxDistanceToSnapOnGround : simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance = Math.max(outCharacterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance, outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore);
  outCharacterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = simplifiedCreationParams.myRadius;
  outCharacterColliderSetup.myGroundSetup.myCollectSurfaceInfo = simplifiedCreationParams.myCollectGroundInfo || simplifiedCreationParams.myMaxWalkableGroundAngle > 0;
  outCharacterColliderSetup.myGroundSetup.mySurfaceSnapEnabled = simplifiedCreationParams.myShouldSnapOnGround;
  outCharacterColliderSetup.myGroundSetup.mySurfacePopOutEnabled = true;
  outCharacterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore = simplifiedCreationParams.myMaxWalkableGroundAngle;
  outCharacterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngle = true;
  outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxOutsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxInsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance = simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance;
  if (simplifiedCreationParams.myCanFly) {
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckHeadDistanceToIgnore = outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore;
    outCharacterColliderSetup.myCeilingSetup.myCollectSurfaceInfo = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceInfo;
    outCharacterColliderSetup.myCeilingSetup.mySurfacePopOutEnabled = outCharacterColliderSetup.myGroundSetup.mySurfacePopOutEnabled;
    outCharacterColliderSetup.myCeilingSetup.mySurfaceAngleToIgnore = outCharacterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore;
    outCharacterColliderSetup.myCeilingSetup.mySurfaceSnapMaxDistance = outCharacterColliderSetup.myGroundSetup.mySurfaceSnapMaxDistance;
    outCharacterColliderSetup.myCeilingSetup.mySurfacePopOutMaxDistance = outCharacterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance;
    outCharacterColliderSetup.myCeilingSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = outCharacterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCharacterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngle = outCharacterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngle;
    outCharacterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxOutsideDistance = outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxInsideDistance = outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxInsideDistance;
    outCharacterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxOutsideDistance = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxInsideDistance;
  }
  if (simplifiedCreationParams.myShouldNotFallFromEdges) {
    outCharacterColliderSetup.myGroundSetup.myMovementMustStayOnSurface = true;
    outCharacterColliderSetup.myGroundSetup.myMovementMustStayOnSurfaceAngleDownhill = Math.max(60, outCharacterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore);
  }
  outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckBlockLayerFlags.copy(simplifiedCreationParams.myHorizontalCheckBlockLayerFlags);
  outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myHorizontalCheckObjectsToIgnore);
  outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckBlockLayerFlags.copy(simplifiedCreationParams.myVerticalCheckBlockLayerFlags);
  outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myVerticalCheckObjectsToIgnore);
  if (simplifiedCreationParams.myHorizontalCheckDebugActive) {
    outCharacterColliderSetup.myDebugSetup.myVisualDebugActive = true;
    outCharacterColliderSetup.myDebugSetup.myVisualDebugHorizontalMovementCheckActive = true;
    outCharacterColliderSetup.myDebugSetup.myVisualDebugHorizontalPositionCheckActive = true;
  }
  if (simplifiedCreationParams.myVerticalCheckDebugActive) {
    outCharacterColliderSetup.myDebugSetup.myVisualDebugActive = true;
    outCharacterColliderSetup.myDebugSetup.myVisualDebugVerticalMovementCheckActive = true;
    outCharacterColliderSetup.myDebugSetup.myVisualDebugVerticalPositionCheckActive = true;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW) {
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle = 60;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices = 1;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 4;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 1;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckReductionEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckAllowHitsInsideCollisionIfOneValid = true;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.LOW) {
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckRadialSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 1;
    outCharacterColliderSetup.myWallSlideSetup.myCheckBothWallSlideDirections = false;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter = 0;
    outCharacterColliderSetup.myWallSlideSetup.my90DegreesWallSlideAdjustDirectionSign = false;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 2;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.MEDIUM) {
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices = 2;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalBorderCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckPerformCheckOnBothSides = true;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 6;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 3;
    outCharacterColliderSetup.myWallSlideSetup.my90DegreesWallSlideAdjustDirectionSign = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.USE_PREVIOUS_RESULTS;
      outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = true;
      outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter = 4;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.HIGH) {
    if (outCharacterColliderSetup.myWallSlideSetup.myWallSlideEnabled) {
      outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckGetBetterReferenceHit = true;
      outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
      outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    }
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 8;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 4;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideSetup.myCheckBothWallSlideDirections = true;
    }
    outCharacterColliderSetup.myGroundSetup.myIsBaseInsideCollisionCheckEnabled = true;
    outCharacterColliderSetup.myCeilingSetup.myIsBaseInsideCollisionCheckEnabled = true;
    let fps = 90;
    if (simplifiedCreationParams.myAverageSpeed / fps > simplifiedCreationParams.myRadius) {
      outCharacterColliderSetup.mySplitMovementSetup.mySplitMovementEnabled = other.mySplitMovementEnabled;
      outCharacterColliderSetup.mySplitMovementSetup.mySplitMovementMaxSteps = Math.ceil(simplifiedCreationParams.myAverageSpeed / fps / simplifiedCreationParams.myRadius);
      outCharacterColliderSetup.mySplitMovementSetup.mySplitMovementMinStepLength = simplifiedCreationParams.myRadius;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_HIGH) {
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
    outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    outCharacterColliderSetup.myGroundSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed = true;
    outCharacterColliderSetup.myCeilingSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed = outCharacterColliderSetup.myGroundSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  }
  return outCharacterColliderSetup;
}
function createTeleportColliderFromMovementCollider(movementColliderSetup, outTeleportColliderSetup = new CharacterColliderSetup()) {
  outTeleportColliderSetup.copy(movementColliderSetup);
  outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle = 180;
  outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices = Math.round(outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle / movementColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle * movementColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices);
  outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForwardEnabled = true;
  outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForward.vec3_set(0, 0, 1);
  return outTeleportColliderSetup;
}
var CharacterColliderUtils = {
  createCharacterColliderSetupSimplified,
  createTeleportColliderFromMovementCollider
};

// js/pp/gameplay/experimental/character_controller/collision/character_collision_system.js
var CharacterCollisionSystem = class {
  constructor(engine2 = getMainEngine2()) {
    this._myLastCheckRaycastsPerformed = 0;
    this._myCurrentFrameRaycastsPerformed = 0;
    this._myMaxFrameRaycastsPerformed = 0;
    this.myEngine = engine2;
    CollisionCheckBridge.initBridge(this.myEngine);
  }
  update(dt) {
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    this._myCurrentFrameRaycastsPerformed = 0;
    getCollisionCheck(this.myEngine)._myTotalRaycasts = 0;
  }
  checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
  }
  checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateSurfaceInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    let currentFramePerformedRaycasts = this._myCurrentFrameRaycastsPerformed;
    this.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this._myLastCheckRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts - currentFramePerformedRaycasts;
    this._myCurrentFrameRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
};
CharacterCollisionSystem.prototype.checkTeleportToPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults) {
    teleportTransformQuat.quat2_copy(currentTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
  };
}();

// js/pp/gameplay/experimental/character_controller/collision/character_collision_system_global.js
var _myCharacterCollisionSystems = /* @__PURE__ */ new WeakMap();
function getCharacterCollisionSystem(engine2 = getMainEngine()) {
  return _myCharacterCollisionSystems.get(engine2);
}
function setCharacterCollisionSystem(characterCollisionSystem, engine2 = getMainEngine()) {
  _myCharacterCollisionSystems.set(engine2, characterCollisionSystem);
}
function removeCharacterCollisionSystem(engine2 = getMainEngine()) {
  _myCharacterCollisionSystems.delete(engine2);
}
function hasCharacterCollisionSystem(engine2 = getMainEngine()) {
  return _myCharacterCollisionSystems.has(engine2);
}

// js/pp/gameplay/experimental/character_controller/collision/components/character_collision_system_component.js
import { Component as Component34, Property as Property34 } from "@wonderlandengine/api";
var CharacterCollisionSystemComponent = class extends Component34 {
  init() {
    this._myCharacterCollisionSystem = null;
    if (!hasCharacterCollisionSystem(this.engine)) {
      this._myCharacterCollisionSystem = new CharacterCollisionSystem(this.engine);
      setCharacterCollisionSystem(this._myCharacterCollisionSystem, this.engine);
    }
  }
  update(dt) {
    if (this._myCharacterCollisionSystem != null) {
      this._myCharacterCollisionSystem.update(dt);
    }
  }
  onDestroy() {
    if (this._myCharacterCollisionSystem != null && getCharacterCollisionSystem(this.engine) == this._myCharacterCollisionSystem) {
      removeCharacterCollisionSystem(this.engine);
    }
  }
};
__publicField(CharacterCollisionSystemComponent, "TypeName", "pp-character-collision-system");
__publicField(CharacterCollisionSystemComponent, "Properties", {});

// js/pp/gameplay/experimental/character_controller/character_controller.js
var CharacterController = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/character_controller/synced_character_controller.js
var SyncedCharacterController = class extends CharacterController {
  constructor() {
    super();
  }
};

// js/pp/gameplay/experimental/character_controller/character_controller_utils.js
function computeGroundPerceivedAngle(surfaceNormal, direction, up) {
  return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, true);
}
function computeCeilingPerceivedAngle(surfaceNormal, direction, up) {
  return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, false);
}
var computeSurfacePerceivedAngle = function() {
  let directionOnSurface = vec3_create2();
  let verticalDirection = vec3_create2();
  return function computeSurfacePerceivedAngle3(surfaceNormal, direction, up, isGround) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    directionOnSurface = direction.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, directionOnSurface);
    surfacePerceivedAngle = directionOnSurface.vec3_angle(direction);
    let isFartherOnUp = directionOnSurface.vec3_isFartherAlongAxis(direction, up);
    if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();
var CharacterControllerUtils = {
  computeGroundPerceivedAngle,
  computeCeilingPerceivedAngle,
  computeSurfacePerceivedAngle
};

// js/pp/gameplay/experimental/character_controller/components/character_controller_component.js
import { Component as Component35, Property as Property35 } from "@wonderlandengine/api";
var CharacterControllerComponent = class extends Component35 {
  init() {
  }
  start() {
    this._myCharacterController = new CharacterController();
  }
  update(dt) {
    this._myCharacterController.update(dt);
  }
  getCharacterController() {
    return this._myCharacterController;
  }
};
__publicField(CharacterControllerComponent, "TypeName", "pp-character-controller");
__publicField(CharacterControllerComponent, "Properties", {});

// js/pp/gameplay/experimental/character_controller/player/player_character_controller.js
var PlayerCharacterController = class extends SyncedCharacterController {
  constructor() {
    super();
  }
};

// js/pp/gameplay/experimental/character_controller/player/player_head_character_controller.js
var PlayerHeadCharacterController = class extends SyncedCharacterController {
  constructor() {
    super();
  }
};

// js/pp/gameplay/experimental/character_controller/player/player_hand_character_controller.js
var PlayerHandCharacterController = class extends SyncedCharacterController {
  constructor() {
    super();
  }
};

// js/pp/gameplay/experimental/character_controller/player/components/player_character_controller_component.js
import { Component as Component36, Property as Property36 } from "@wonderlandengine/api";
var PlayerCharacterControllerComponent = class extends Component36 {
  init() {
  }
  start() {
    this._myPlayerCharacterController = new PlayerCharacterController();
  }
  update(dt) {
    this._myPlayerCharacterController.update(dt);
  }
  getPlayerCharacterController() {
    return this._myPlayerCharacterController;
  }
};
__publicField(PlayerCharacterControllerComponent, "TypeName", "pp-player-character-controller");
__publicField(PlayerCharacterControllerComponent, "Properties", {});

// js/pp/gameplay/experimental/character_controller/player/components/player_head_character_controller_component.js
import { Component as Component37, Property as Property37 } from "@wonderlandengine/api";
var PlayerHeadCharacterControllerComponent = class extends Component37 {
  init() {
  }
  start() {
    this._myPlayerHeadCharacterController = new PlayerHeadCharacterController();
  }
  update(dt) {
    this._myPlayerHeadCharacterController.update(dt);
  }
  getPlayerHeadCharacterController() {
    return this._myPlayerHeadCharacterController;
  }
};
__publicField(PlayerHeadCharacterControllerComponent, "TypeName", "pp-player-head-character-controller");
__publicField(PlayerHeadCharacterControllerComponent, "Properties", {});

// js/pp/gameplay/experimental/character_controller/player/components/player_hand_character_controller_component.js
import { Component as Component38, Property as Property38 } from "@wonderlandengine/api";
var PlayerHandCharacterControllerComponent = class extends Component38 {
  init() {
  }
  start() {
    this._myPlayerHandCharacterController = new PlayerHandCharacterController();
  }
  update(dt) {
    this._myPlayerHandCharacterController.update(dt);
  }
  getPlayerHandCharacterController() {
    return this._myPlayerHandCharacterController;
  }
};
__publicField(PlayerHandCharacterControllerComponent, "TypeName", "pp-player-hand-character-controller");
__publicField(PlayerHandCharacterControllerComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/cauldron/global_gravity_globals.js
var _myGlobalGravityAccelerations = /* @__PURE__ */ new WeakMap();
var _myGlobalGravityDirections = /* @__PURE__ */ new WeakMap();
function getGlobalGravityAcceleration(engine2 = getMainEngine2()) {
  return _myGlobalGravityAccelerations.get(engine2);
}
function setGlobalGravityAcceleration(globalGravityAcceleration, engine2 = getMainEngine2()) {
  _myGlobalGravityAccelerations.set(engine2, globalGravityAcceleration);
}
function removeGlobalGravityAcceleration(engine2 = getMainEngine2()) {
  _myGlobalGravityAccelerations.delete(engine2);
}
function hasGlobalGravityAcceleration(engine2 = getMainEngine2()) {
  return _myGlobalGravityAccelerations.has(engine2);
}
function getGlobalGravityDirection(engine2 = getMainEngine2()) {
  return _myGlobalGravityDirections.get(engine2);
}
function setGlobalGravityDirection(globalGravityDirection, engine2 = getMainEngine2()) {
  _myGlobalGravityDirections.set(engine2, globalGravityDirection);
}
function removeGlobalGravityDirection(engine2 = getMainEngine2()) {
  _myGlobalGravityDirections.delete(engine2);
}
function hasGlobalGravityDirection(engine2 = getMainEngine2()) {
  return _myGlobalGravityDirections.has(engine2);
}

// js/pp/gameplay/experimental/locomotion/cauldron/components/global_gravity_component.js
import { Component as Component39, Property as Property39 } from "@wonderlandengine/api";
var GlobalGravityComponent = class extends Component39 {
  init() {
  }
};
__publicField(GlobalGravityComponent, "TypeName", "pp-global-gravity");
__publicField(GlobalGravityComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/player/player_locomotion_smooth.js
var PlayerLocomotionSmooth = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/locomotion/player/player_locomotion_rotate.js
var PlayerLocomotionRotate = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/locomotion/player/player_locomotion_gravity.js
var PlayerLocomotionGravity = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/locomotion/player/teleport/player_locomotion_teleport.js
var PlayerLocomotionTeleport = class {
  constructor() {
  }
};

// js/pp/gameplay/experimental/locomotion/player/components/player_locomotion_teleport_component.js
import { Component as Component40, Property as Property40 } from "@wonderlandengine/api";
var PlayerLocomotionTeleportComponent = class extends Component40 {
  init() {
  }
  start() {
    this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport();
  }
  update(dt) {
    this._myPlayerLocomotionTeleport.update(dt);
  }
  getPlayerLocomotionTeleport() {
    return this._myPlayerLocomotionTeleport;
  }
};
__publicField(PlayerLocomotionTeleportComponent, "TypeName", "pp-player-locomotion-teleport");
__publicField(PlayerLocomotionTeleportComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/player/components/player_locomotion_smooth_component.js
import { Component as Component41, Property as Property41 } from "@wonderlandengine/api";
var PlayerLocomotionSmoothComponent = class extends Component41 {
  init() {
  }
  start() {
    this._myPlayerLocomotionSmooth = new PlayerLocomotionSmooth();
  }
  update(dt) {
    this._myPlayerLocomotionSmooth.update(dt);
  }
  getPlayerLocomotionSmooth() {
    return this._myPlayerLocomotionSmooth;
  }
};
__publicField(PlayerLocomotionSmoothComponent, "TypeName", "pp-player-locomotion-smooth");
__publicField(PlayerLocomotionSmoothComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/player/components/player_locomotion_rotate_component.js
import { Component as Component42, Property as Property42 } from "@wonderlandengine/api";
var PlayerLocomotionRotateComponent = class extends Component42 {
  init() {
  }
  start() {
    this._myPlayerLocomotionRotate = new PlayerLocomotionRotate();
  }
  update(dt) {
    this._myPlayerLocomotionRotate.update(dt);
  }
  getPlayerLocomotionRotate() {
    return this._myPlayerLocomotionRotate;
  }
};
__publicField(PlayerLocomotionRotateComponent, "TypeName", "pp-player-locomotion-rotate");
__publicField(PlayerLocomotionRotateComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/player/components/player_locomotion_gravity_component.js
import { Component as Component43, Property as Property43 } from "@wonderlandengine/api";
var PlayerLocomotionGravityComponent = class extends Component43 {
  init() {
  }
  start() {
    this._myPlayerLocomotionGravity = new PlayerLocomotionGravity();
  }
  update(dt) {
    this._myPlayerLocomotionGravity.update(dt);
  }
  getPlayerLocomotionGravity() {
    return this._myPlayerLocomotionGravity;
  }
};
__publicField(PlayerLocomotionGravityComponent, "TypeName", "pp-player-locomotion-gravity");
__publicField(PlayerLocomotionGravityComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/locomotion_utils.js
var EPSILON = Math.PP_EPSILON;
var EPSILON_DEGREES = Math.PP_EPSILON_DEGREES;
var computeSurfacePerceivedAngle2 = function() {
  let forwardOnSurface = vec3_create2();
  let verticalDirection = vec3_create2();
  return function computeSurfacePerceivedAngle3(surfaceNormal, forward, up, isGround = true) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
    surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
    let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
    if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();
var LocomotionUtils = {
  EPSILON,
  EPSILON_DEGREES,
  computeSurfacePerceivedAngle: computeSurfacePerceivedAngle2
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_head_manager.js
var PlayerHeadManagerParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.mySessionChangeResyncEnabled = false;
    this.myBlurEndResyncEnabled = false;
    this.myBlurEndResyncRotation = false;
    this.myResetTransformOnViewResetEnabled = true;
    this.myNextEnterSessionResyncHeight = false;
    this.myEnterSessionResyncHeight = false;
    this.myExitSessionResyncHeight = false;
    this.myExitSessionResyncVerticalAngle = false;
    this.myExitSessionRemoveRightTilt = false;
    this.myExitSessionAdjustMaxVerticalAngle = false;
    this.myExitSessionMaxVerticalAngle = 0;
    this.myHeightOffsetVRWithFloor = null;
    this.myHeightOffsetVRWithoutFloor = null;
    this.myHeightOffsetNonVR = null;
    this.myNextEnterSessionFloorHeight = null;
    this.myEnterSessionFloorHeight = null;
    this.myRotateFeetKeepUp = false;
    this.myForeheadExtraHeight = 0;
    this.myEngine = engine2;
    this.myDebugActive = false;
  }
};
var PlayerHeadManager = class {
  constructor(params = new PlayerHeadManagerParams()) {
    this._myParams = params;
    this._myCurrentHead = getPlayerObjects2(this._myParams.myEngine).myHeadNonVR;
    this._mySessionChangeResyncHeadTransform = null;
    this._myBlurRecoverHeadTransform = null;
    this._myCurrentHeadTransformQuat = quat2_create();
    this._myPreviousHeadTransformQuat = quat2_create();
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer = new Timer(5, false);
    this._myVisibilityHidden = false;
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    this._myIsSyncedDelayCounter = 0;
    this._myActive = true;
    this._myResyncCounterFrames = 3;
    this._myIsSyncedDelayCounterFrames = 1;
  }
  start() {
    this._updateHeightOffset();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myEngine);
  }
  setActive(active) {
    this._myActive = active;
  }
  getParams() {
    return this._myParams;
  }
  paramsUpdated() {
    this._updateHeightOffset();
  }
  getPlayer() {
    return getPlayerObjects2(this._myParams.myEngine).myPlayer;
  }
  getHead() {
    return this._myCurrentHead;
  }
  getHeightHead() {
    return this.getHeightEyes() + this._myParams.myForeheadExtraHeight;
  }
  getHeightEyes() {
  }
  getTransformFeetQuat(outTransformFeetQuat = quat2_create()) {
  }
  getTransformHeadQuat(outTransformFeetQuat = quat2_create()) {
    return this.getHead().pp_getTransformQuat(outTransformFeetQuat);
  }
  getPositionFeet(outPositionFeet = vec3_create2()) {
  }
  getPositionHead(outPositionHead = vec3_create2()) {
    return this._myCurrentHead.pp_getPosition(outPositionHead);
  }
  getRotationFeetQuat(outRotationFeetQuat = quat_create()) {
  }
  getRotationHeadQuat(outRotationHeadQuat = quat_create()) {
    return this.getHead().pp_getRotationQuat(outRotationHeadQuat);
  }
  isSynced() {
    return this._myIsSyncedDelayCounter == 0 && this._myDelaySessionChangeResyncCounter == 0 && this._myDelayBlurEndResyncCounter == 0 && !this._myDelayBlurEndResyncTimer.isRunning() && !this._mySessionBlurred;
  }
  setHeight(height, setOnlyForActiveOne = false) {
    if (!setOnlyForActiveOne || !this._mySessionActive) {
      this._myParams.myHeightOffsetNonVR = height;
    }
    if (!setOnlyForActiveOne || this._mySessionActive) {
      this._myParams.myHeightOffsetVRWithoutFloor = height;
      if (this._myParams.myHeightOffsetVRWithFloor == null) {
        this._myParams.myHeightOffsetVRWithFloor = 0;
      }
      let isFloor = XRUtils.isReferenceSpaceLocalFloor(this._myParams.myEngine) || XRUtils.isDeviceEmulated();
      if (this._mySessionActive && isFloor) {
        this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (height - this.getHeight());
      } else if (!this._mySessionActive) {
        this._myParams.myNextEnterSessionFloorHeight = height;
      }
    }
    this._updateHeightOffset();
  }
  moveFeet(movement) {
  }
  moveHead(movement) {
    this.moveFeet(movement);
  }
  teleportPositionHead(teleportPosition) {
  }
  teleportPositionFeet(teleportPosition) {
  }
  teleportPlayerToHeadTransformQuat(headTransformQuat) {
  }
  rotateFeetQuat(rotationQuat, keepUpOverride = null) {
  }
  rotateHeadQuat(rotationQuat) {
  }
  canRotateFeet() {
    return true;
  }
  canRotateHead() {
    return !this._mySessionActive;
  }
  setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
  }
  setRotationHeadQuat() {
  }
  lookAtFeet(position, up = null, keepUpOverride = null) {
  }
  lookToFeet(direction, up = null, keepUpOverride = null) {
  }
  lookAtHead(position, up = null) {
  }
  lookToHead(direction, up = null) {
  }
  update(dt) {
    if (this._myIsSyncedDelayCounter != 0) {
      this._myIsSyncedDelayCounter--;
      this._myIsSyncedDelayCounter = Math.max(0, this._myIsSyncedDelayCounter);
    }
    if (this._myDelaySessionChangeResyncCounter > 0) {
      this._myDelaySessionChangeResyncCounter--;
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._sessionChangeResync();
        this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncCounter > 0 && !this._myDelayBlurEndResyncTimer.isRunning()) {
      this._myDelayBlurEndResyncCounter--;
      if (this._myDelayBlurEndResyncCounter == 0) {
        this._blurEndResync();
        this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncTimer.isRunning()) {
      if (this._myDelayBlurEndResyncCounter > 0) {
        this._myDelayBlurEndResyncCounter--;
      } else {
        this._myDelayBlurEndResyncTimer.update(dt);
        if (this._myDelayBlurEndResyncTimer.isDone()) {
          this._blurEndResync();
          this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
        }
      }
    }
    if (this.isSynced()) {
      this._myPreviousHeadTransformQuat.quat2_copy(this._myCurrentHeadTransformQuat);
      this._myCurrentHead.pp_getTransformQuat(this._myCurrentHeadTransformQuat);
    }
    if (this._myParams.myDebugActive) {
      this._debugUpdate(dt);
    }
  }
  _debugUpdate(dt) {
    getDebugVisualManager2(this._myParams.myEngine).drawLineEnd(0, this.getPositionFeet(), this.getPositionHead(), vec4_create(1, 0, 0, 1), 0.01);
    console.error(this.getHeightEyes());
  }
};
PlayerHeadManager.prototype.getHeightEyes = function() {
  let headPosition = vec3_create2();
  return function getHeightEyes() {
    headPosition = this._myCurrentHead.pp_getPosition(headPosition);
    let eyesHeight = this._getPositionHeight(headPosition);
    return eyesHeight;
  };
}();
PlayerHeadManager.prototype.getTransformFeetQuat = function() {
  let feetPosition = vec3_create2();
  let feetRotationQuat = quat_create();
  return function getTransformFeetQuat(outTransformFeetQuat = quat2_create()) {
    outTransformFeetQuat.quat2_setPositionRotationQuat(this.getPositionFeet(feetPosition), this.getRotationFeetQuat(feetRotationQuat));
    return outTransformFeetQuat;
  };
}();
PlayerHeadManager.prototype.getRotationFeetQuat = function() {
  let playerUp = vec3_create2();
  let headForward = vec3_create2();
  return function getRotationFeetQuat(outRotationFeetQuat = quat_create()) {
    playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    headForward = this._myCurrentHead.pp_getForward(headForward);
    let angleWithUp = headForward.vec3_angle(playerUp);
    let mingAngle = 10;
    if (angleWithUp < mingAngle) {
      headForward = this._myCurrentHead.pp_getDown(headForward);
    } else if (angleWithUp > 180 - mingAngle) {
      headForward = this._myCurrentHead.pp_getUp(headForward);
    }
    headForward = headForward.vec3_removeComponentAlongAxis(playerUp, headForward);
    headForward.vec3_normalize(headForward);
    outRotationFeetQuat.quat_setUp(playerUp, headForward);
    return outRotationFeetQuat;
  };
}();
PlayerHeadManager.prototype.getPositionFeet = function() {
  let headPosition = vec3_create2();
  let playerUp = vec3_create2();
  return function getPositionFeet(outPositionFeet = vec3_create2()) {
    headPosition = this._myCurrentHead.pp_getPosition(headPosition);
    let headHeight = this._getPositionHeight(headPosition);
    playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    outPositionFeet = headPosition.vec3_sub(playerUp.vec3_scale(headHeight, outPositionFeet), outPositionFeet);
    return outPositionFeet;
  };
}();
PlayerHeadManager.prototype.moveFeet = function moveFeet(movement) {
  getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_translate(movement);
};
PlayerHeadManager.prototype.rotateFeetQuat = function() {
  let playerUp = vec3_create2();
  let rotationAxis = vec3_create2();
  let currentHeadPosition = vec3_create2();
  let currentFeetRotation = quat_create();
  let newFeetRotation = quat_create();
  let fixedNewFeetRotation = quat_create();
  let newFeetForward = vec3_create2();
  let fixedRotation = quat_create();
  let newHeadPosition = vec3_create2();
  let headAdjustmentMovement = vec3_create2();
  return function rotateFeetQuat(rotationQuat, keepUpOverride = null) {
    let angle = rotationQuat.quat_getAngleRadians();
    if (angle <= 1e-5) {
      return;
    }
    currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
    playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    rotationAxis = rotationQuat.quat_getAxis(rotationAxis);
    if (!rotationAxis.vec3_isOnAxis(playerUp) && (keepUpOverride == null && this._myParams.myFeetRotationKeepUp || keepUpOverride)) {
      currentFeetRotation = this.getRotationFeetQuat(currentFeetRotation);
      newFeetRotation = currentFeetRotation.quat_rotateQuat(rotationQuat, newFeetRotation);
      newFeetForward = newFeetRotation.quat_getForward(newFeetForward);
      fixedNewFeetRotation.quat_copy(newFeetRotation);
      fixedNewFeetRotation.quat_setUp(playerUp, newFeetForward);
      fixedRotation = currentFeetRotation.quat_rotationToQuat(fixedNewFeetRotation, fixedRotation);
    } else {
      fixedRotation.quat_copy(rotationQuat);
    }
    getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_rotateAroundQuat(fixedRotation, currentHeadPosition);
    newHeadPosition = this._myCurrentHead.pp_getPosition(newHeadPosition);
    headAdjustmentMovement = currentHeadPosition.vec3_sub(newHeadPosition, headAdjustmentMovement);
    if (headAdjustmentMovement.vec3_length() > 1e-5) {
      this.moveFeet(headAdjustmentMovement);
    }
  };
}();
PlayerHeadManager.prototype.rotateHeadQuat = function() {
  let newHeadRotation = quat_create();
  let newHeadUp = vec3_create2();
  return function rotateHeadQuat(rotationQuat) {
    if (this.canRotateHead()) {
      this._myCurrentHead.pp_rotateQuat(rotationQuat);
      newHeadRotation = this._myCurrentHead.pp_getRotationQuat(newHeadRotation);
      getPlayerObjects2(this._myParams.myEngine).myHead.pp_setRotationQuat(newHeadRotation);
      newHeadRotation = newHeadRotation.quat_rotateAxisRadians(Math.PI, newHeadRotation.quat_getUp(newHeadUp), newHeadRotation);
      getPlayerObjects2(this._myParams.myEngine).myCameraNonVR.pp_setRotationQuat(newHeadRotation);
    }
  };
}();
PlayerHeadManager.prototype.setRotationFeetQuat = function() {
  let currentRotationQuat = quat_create();
  let rotationQuatToRotate = quat_create();
  return function setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
    currentRotationQuat = this.getRotationFeetQuat(currentRotationQuat);
    rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateFeetQuat(rotationQuatToRotate, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.setRotationHeadQuat = function() {
  let currentRotationQuat = quat_create();
  let rotationQuatToRotate = quat_create();
  return function setRotationHeadQuat(rotationQuat) {
    currentRotationQuat = this.getRotationHeadQuat(currentRotationQuat);
    rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateHeadQuat(rotationQuatToRotate);
  };
}();
PlayerHeadManager.prototype.teleportPositionHead = function() {
  let currentHeadPosition = vec3_create2();
  let teleportMovementToPerform = vec3_create2();
  return function teleportPositionHead(teleportPosition) {
    currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
    teleportMovementToPerform = teleportPosition.vec3_sub(currentHeadPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  };
}();
PlayerHeadManager.prototype.teleportPositionFeet = function() {
  let currentFeetPosition = vec3_create2();
  let teleportMovementToPerform = vec3_create2();
  return function teleportPositionFeet(teleportPosition) {
    currentFeetPosition = this.getPositionFeet(currentFeetPosition);
    teleportMovementToPerform = teleportPosition.vec3_sub(currentFeetPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  };
}();
PlayerHeadManager.prototype.teleportPlayerToHeadTransformQuat = function() {
  let headPosition = vec3_create2();
  let playerUp = vec3_create2();
  let flatCurrentPlayerPosition = vec3_create2();
  let flatNewPlayerPosition = vec3_create2();
  let teleportMovement = vec3_create2();
  let playerForward = vec3_create2();
  let headForward = vec3_create2();
  let headForwardNegated = vec3_create2();
  let rotationToPerform = quat_create();
  return function teleportPlayerToHeadTransformQuat(headTransformQuat) {
    headPosition = headTransformQuat.quat2_getPosition(headPosition);
    playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    flatCurrentPlayerPosition = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getPosition(flatCurrentPlayerPosition).vec3_removeComponentAlongAxis(playerUp, flatCurrentPlayerPosition);
    flatNewPlayerPosition = headPosition.vec3_removeComponentAlongAxis(playerUp, flatNewPlayerPosition);
    teleportMovement = flatNewPlayerPosition.vec3_sub(flatCurrentPlayerPosition, teleportMovement);
    getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_translate(teleportMovement);
    playerForward = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getForward(playerForward);
    headForward = headTransformQuat.quat2_getForward(headForward);
    headForwardNegated = headForward.vec3_negate(headForwardNegated);
    rotationToPerform = playerForward.vec3_rotationToPivotedQuat(headForwardNegated, playerUp, rotationToPerform);
    getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_rotateQuat(rotationToPerform);
  };
}();
PlayerHeadManager.prototype.lookAtFeet = function() {
  let direction = vec3_create2();
  let feetPosition = vec3_create2();
  return function lookAtFeet(position, up = null, keepUpOverride = null) {
    feetPosition = this.getPositionFeet(feetPosition);
    direction = position.vec3_sub(feetPosition, direction).vec3_normalize(direction);
    this.lookToFeet(direction, up, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.lookToFeet = function() {
  let feetRotation = quat_create();
  return function lookToFeet(direction, up = null, keepUpOverride = null) {
    feetRotation = this.getRotationFeetQuat(feetRotation);
    feetRotation.quat_setForward(direction, up);
    this.setRotationFeetQuat(feetRotation, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.lookAtHead = function() {
  let direction = vec3_create2();
  let headPosition = vec3_create2();
  return function lookAtHead(position, up = null) {
    headPosition = this.getPositionHead(headPosition);
    direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
    this.lookToHead(direction, up);
  };
}();
PlayerHeadManager.prototype.lookToHead = function() {
  let headRotation = quat_create();
  return function lookToHead(direction, up = null) {
    headRotation = this.getRotationHeadQuat(headRotation);
    headRotation.quat_setForward(direction, up);
    this.setRotationHeadQuat(headRotation);
  };
}();
PlayerHeadManager.prototype._getPositionHeight = function() {
  let playerPosition = vec3_create2();
  let playerUp = vec3_create2();
  let heightVector = vec3_create2();
  return function _getPositionHeight(position) {
    playerPosition = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getPosition(playerPosition);
    playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    heightVector = position.vec3_sub(playerPosition, heightVector).vec3_componentAlongAxis(playerUp, heightVector);
    let height = heightVector.vec3_length();
    if (!playerUp.vec3_isConcordant(heightVector)) {
      height = -height;
    }
    return height;
  };
}();
PlayerHeadManager.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(manualCall, session) {
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    session.requestReferenceSpace(getReferenceSpaceType(this._myParams.myEngine)).then(function(referenceSpace) {
      if (referenceSpace.addEventListener != null) {
        referenceSpace.addEventListener("reset", this._onViewReset.bind(this));
      }
    }.bind(this));
    session.addEventListener("visibilitychange", function(event) {
      if (event.session.visibilityState != "visible") {
        if (!this._mySessionBlurred) {
          this._onXRSessionBlurStart(event.session);
        }
        this._myVisibilityHidden = session.visibilityState == "hidden";
      } else {
        if (this._mySessionBlurred) {
          this._onXRSessionBlurEnd(event.session);
        }
        this._myVisibilityHidden = false;
      }
    }.bind(this));
    if (this._myParams.mySessionChangeResyncEnabled && !manualCall && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        let previousHeadObject = this._myCurrentHead;
        this._mySessionChangeResyncHeadTransform = previousHeadObject.pp_getTransformQuat();
      }
      this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    this._myCurrentHead = getPlayerObjects2(this._myParams.myEngine).myHeadVR;
    this._mySessionActive = true;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
    }
  };
}();
PlayerHeadManager.prototype._onXRSessionEnd = function() {
  return function _onXRSessionEnd(session) {
    if (this._myParams.mySessionChangeResyncEnabled && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        let previousHeadTransform = this._myCurrentHead.pp_getTransformQuat();
        if (this._myBlurRecoverHeadTransform != null) {
          previousHeadTransform = this._myBlurRecoverHeadTransform;
        }
        this._mySessionChangeResyncHeadTransform = previousHeadTransform;
      }
      this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._myCurrentHead = getPlayerObjects2(this._myParams.myEngine).myHeadNonVR;
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
    }
  };
}();
PlayerHeadManager.prototype._onXRSessionBlurStart = function() {
  return function _onXRSessionBlurStart(session) {
    if (this._myActive) {
      if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform == null && this._mySessionActive) {
        if (this._myDelaySessionChangeResyncCounter > 0) {
          this._myBlurRecoverHeadTransform = this._mySessionChangeResyncHeadTransform;
        } else {
          this._myBlurRecoverHeadTransform = this._myCurrentHead.pp_getTransformQuat();
        }
      } else if (!this._mySessionActive || !this._myParams.myBlurEndResyncEnabled) {
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._myDelayBlurEndResyncCounter = 0;
    this._mySessionBlurred = true;
  };
}();
PlayerHeadManager.prototype._onXRSessionBlurEnd = function() {
  return function _onXRSessionBlurEnd(session) {
    if (this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform != null && this._mySessionActive) {
          this._myDelayBlurEndResyncCounter = this._myResyncCounterFrames;
          if (this._myVisibilityHidden) {
          }
        } else {
          this._myBlurRecoverHeadTransform = null;
          this._myDelayBlurEndResyncCounter = 0;
        }
      } else {
        this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._mySessionBlurred = false;
  };
}();
PlayerHeadManager.prototype._onViewReset = function() {
  return function _onViewReset() {
    if (this._myActive) {
      if (this._myParams.myResetTransformOnViewResetEnabled && this._mySessionActive && this.isSynced()) {
        this.teleportPlayerToHeadTransformQuat(this._myPreviousHeadTransformQuat);
      }
    }
  };
}();
PlayerHeadManager.prototype._blurEndResync = function() {
  let playerUp = vec3_create2();
  let currentHeadPosition = vec3_create2();
  let recoverHeadPosition = vec3_create2();
  let flatCurrentHeadPosition = vec3_create2();
  let flatRecoverHeadPosition = vec3_create2();
  let recoverMovement = vec3_create2();
  let recoverHeadForward = vec3_create2();
  let currentHeadForward = vec3_create2();
  let rotationToPerform = quat_create();
  return function _blurEndResync() {
    if (this._myBlurRecoverHeadTransform != null) {
      if (this._mySessionChangeResyncHeadTransform != null) {
        this._myBlurRecoverHeadTransform = null;
        this._sessionChangeResync();
      } else {
        playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
        recoverHeadPosition = this._myBlurRecoverHeadTransform.quat2_getPosition(recoverHeadPosition);
        flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        flatRecoverHeadPosition = recoverHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatRecoverHeadPosition);
        recoverMovement = flatRecoverHeadPosition.vec3_sub(flatCurrentHeadPosition, recoverMovement);
        this.moveFeet(recoverMovement);
        recoverHeadForward = this._myBlurRecoverHeadTransform.quat2_getForward(recoverHeadForward);
        currentHeadForward = this._myCurrentHead.pp_getForward(currentHeadForward);
        rotationToPerform = currentHeadForward.vec3_rotationToPivotedQuat(recoverHeadForward, playerUp, rotationToPerform);
        if (this._myParams.myBlurEndResyncRotation) {
          this.rotateFeetQuat(rotationToPerform);
        }
        this._myBlurRecoverHeadTransform = null;
      }
    }
  };
}();
PlayerHeadManager.prototype._sessionChangeResync = function() {
  let currentHeadPosition = vec3_create2();
  let resyncHeadPosition = vec3_create2();
  let resyncHeadRotation = quat_create();
  let playerUp = vec3_create2();
  let flatCurrentHeadPosition = vec3_create2();
  let flatResyncHeadPosition = vec3_create2();
  let resyncMovement = vec3_create2();
  let resyncHeadForward = vec3_create2();
  let resyncHeadUp = vec3_create2();
  let resyncHeadRight = vec3_create2();
  let playerPosition = vec3_create2();
  let newPlayerPosition = vec3_create2();
  let fixedHeadRight = vec3_create2();
  let fixedHeadRightNegate = vec3_create2();
  let fixedHeadUp = vec3_create2();
  let fixedHeadForward = vec3_create2();
  let fixedHeadRotation = quat_create();
  return function _sessionChangeResync() {
    if (this._myBlurRecoverHeadTransform == null && this._mySessionChangeResyncHeadTransform != null) {
      if (this._mySessionActive) {
        currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
        resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        resyncMovement = flatResyncHeadPosition.vec3_sub(flatCurrentHeadPosition, resyncMovement);
        this.moveFeet(resyncMovement);
        let isFloor = XRUtils.isReferenceSpaceLocalFloor(this._myParams.myEngine) || XRUtils.isDeviceEmulated();
        if (this._myParams.myEnterSessionResyncHeight || this._myParams.myNextEnterSessionResyncHeight) {
          this._myParams.myNextEnterSessionResyncHeight = false;
          let resyncHeadHeight = this._getPositionHeight(resyncHeadPosition);
          let currentHeadHeight = this._getPositionHeight(currentHeadPosition);
          this._myParams.myHeightOffsetVRWithoutFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          if (this._myParams.myHeightOffsetVRWithFloor == null) {
            this._myParams.myHeightOffsetVRWithFloor = 0;
          }
          this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (resyncHeadHeight - currentHeadHeight);
          this._updateHeightOffset();
        } else if (isFloor && (this._myParams.myNextEnterSessionFloorHeight != null || this._myParams.myEnterSessionFloorHeight != null)) {
          let floorHeight = this._myParams.myNextEnterSessionFloorHeight != null ? this._myParams.myNextEnterSessionFloorHeight : this._myParams.myEnterSessionFloorHeight;
          floorHeight -= this._myParams.myForeheadExtraHeight;
          let currentHeadHeight = this._getPositionHeight(currentHeadPosition);
          if (this._myParams.myHeightOffsetVRWithFloor == null) {
            this._myParams.myHeightOffsetVRWithFloor = 0;
          }
          this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (floorHeight - currentHeadHeight);
          this._updateHeightOffset();
        }
        this._resyncHeadRotationForward(resyncHeadRotation);
      } else {
        playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        playerPosition = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getPosition(playerPosition);
        newPlayerPosition = flatResyncHeadPosition.vec3_add(playerPosition.vec3_componentAlongAxis(playerUp, newPlayerPosition), newPlayerPosition);
        getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_setPosition(newPlayerPosition);
        getPlayerObjects2(this._myParams.myEngine).myCameraNonVR.pp_resetPositionLocal();
        if (this._myParams.myExitSessionResyncHeight) {
          let resyncHeadHeight = this._getPositionHeight(resyncHeadPosition);
          this._myParams.myHeightOffsetNonVR = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          this._updateHeightOffset();
        }
        resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        if (this._myParams.myExitSessionRemoveRightTilt || this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          fixedHeadRight = resyncHeadForward.vec3_cross(playerUp, fixedHeadRight);
          fixedHeadRight.vec3_normalize(fixedHeadRight);
          if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
            let angleForwardUp = resyncHeadForward.vec3_angle(playerUp);
            let negateAngle = 45;
            if (angleForwardUp > 180 - negateAngle || angleForwardUp < negateAngle) {
              fixedHeadRight.vec3_negate(fixedHeadRight);
            }
          }
          if (fixedHeadRight.vec3_isZero(1e-6)) {
            fixedHeadRight = resyncHeadRotation.quat_getRight(fixedHeadRight);
          }
          fixedHeadUp = fixedHeadRight.vec3_cross(resyncHeadForward, fixedHeadUp);
          fixedHeadUp.vec3_normalize(fixedHeadUp);
          fixedHeadForward = fixedHeadUp.vec3_cross(fixedHeadRight, fixedHeadForward);
          fixedHeadForward.vec3_normalize(fixedHeadForward);
          fixedHeadRotation.quat_fromAxes(fixedHeadRight.vec3_negate(fixedHeadRightNegate), fixedHeadUp, fixedHeadForward);
          resyncHeadRotation.quat_copy(fixedHeadRotation);
        }
        if (this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          resyncHeadRight = resyncHeadRotation.quat_getRight(resyncHeadRight);
          let maxVerticalAngle = Math.max(0, this._myParams.myExitSessionMaxVerticalAngle - 1e-4);
          if (!this._myParams.myExitSessionResyncVerticalAngle) {
            maxVerticalAngle = 0;
          }
          let angleWithUp = Math.pp_angleClamp(resyncHeadUp.vec3_angleSigned(playerUp, resyncHeadRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            resyncHeadRotation = resyncHeadRotation.quat_rotateAxis(fixAngle, resyncHeadRight, resyncHeadRotation);
          }
        }
        this.setRotationHeadQuat(resyncHeadRotation);
      }
      if (this._mySessionActive) {
        this._myParams.myNextEnterSessionFloorHeight = null;
        this._myFirstEnterSessionResyncDone = true;
      }
      this._mySessionChangeResyncHeadTransform = null;
    }
  };
}();
PlayerHeadManager.prototype._resyncHeadRotationForward = function() {
  let playerUp = vec3_create2();
  let resyncHeadForward = vec3_create2();
  let resyncHeadUp = vec3_create2();
  let fixedResyncHeadRotation = quat_create();
  return function _resyncHeadRotationForward(resyncHeadRotation) {
    playerUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
    resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
    fixedResyncHeadRotation.quat_copy(resyncHeadRotation);
    fixedResyncHeadRotation.quat_setUp(playerUp, resyncHeadForward);
    if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
      fixedResyncHeadRotation.quat_rotateAxis(180, playerUp, fixedResyncHeadRotation);
    }
    this.setRotationFeetQuat(fixedResyncHeadRotation);
    return;
  };
}();
PlayerHeadManager.prototype._updateHeightOffset = function() {
  return function _updateHeightOffset() {
    if (this._mySessionActive) {
      if (XRUtils.isDeviceEmulated()) {
        this._setPlayerPivotHeightOffset(0, 0);
      } else if (XRUtils.isReferenceSpaceLocalFloor(this._myParams.myEngine)) {
        this._setPlayerPivotHeightOffset(this._myParams.myHeightOffsetVRWithFloor, 0);
      } else {
        this._setPlayerPivotHeightOffset(this._myParams.myHeightOffsetVRWithoutFloor, this._myParams.myForeheadExtraHeight);
      }
    } else {
      this._setPlayerPivotHeightOffset(this._myParams.myHeightOffsetNonVR, this._myParams.myForeheadExtraHeight);
    }
  };
}();
PlayerHeadManager.prototype._setPlayerPivotHeightOffset = function() {
  let playerPivotPosition = vec3_create2();
  return function _setPlayerPivotHeightOffset(offset, amountToRemove) {
    if (offset != null) {
      playerPivotPosition = getPlayerObjects2(this._myParams.myEngine).myPlayerPivot.pp_getPositionLocal(playerPivotPosition);
      getPlayerObjects2(this._myParams.myEngine).myPlayerPivot.pp_setPositionLocal([playerPivotPosition[0], offset - amountToRemove, playerPivotPosition[2]]);
    }
  };
}();
Object.defineProperty(PlayerHeadManager.prototype, "_getPositionHeight", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionStart", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionEnd", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionBlurStart", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionBlurEnd", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onViewReset", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_blurEndResync", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_sessionChangeResync", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_setPlayerPivotHeightOffset", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_component.js
import { Component as Component44, Property as Property44 } from "@wonderlandengine/api";

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/cleaned/player_locomotion_cleaned.js
import { PhysXComponent as PhysXComponent8 } from "@wonderlandengine/api";

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_movement.js
var PlayerLocomotionMovementRuntimeParams = class {
  constructor() {
    this.myIsFlying = false;
    this.myCollisionRuntimeParams = null;
    this.myIsTeleportDetecting = false;
    this.myIsTeleporting = false;
    this.myTeleportJustPerformed = false;
  }
};
var PlayerLocomotionMovement = class {
  constructor(locomotionRuntimeParams) {
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
  }
  start() {
  }
  stop() {
  }
  canStop() {
    return true;
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_rotate.js
var PlayerLocomotionRotateParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myPlayerHeadManager = null;
    this.myMaxRotationSpeed = 0;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySmoothSnapActive = true;
    this.mySmoothSnapSpeedDegrees = 240;
    this.myRotationMinStickIntensityThreshold = 0;
    this.mySnapTurnActivateThreshold = 0;
    this.mySnapTurnResetThreshold = 0;
    this.myClampVerticalAngle = true;
    this.myMaxVerticalAngle = 0;
    this.myHandedness = Handedness.RIGHT;
    this.myEngine = engine2;
  }
};
var PlayerLocomotionRotate2 = class {
  constructor(params) {
    this._myParams = params;
    this._mySnapCharge = false;
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  start() {
  }
  stop() {
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  update(dt) {
    this._rotateHeadHorizontally(dt);
    if (this._myParams.myPlayerHeadManager.canRotateHead()) {
      this._rotateHeadVertically(dt);
    }
  }
};
PlayerLocomotionRotate2.prototype._rotateHeadHorizontally = function() {
  let playerUp = vec3_create2();
  let headRotation = quat_create();
  return function _rotateHeadHorizontally(dt) {
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headRotation.quat_identity();
    let axes = getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[0]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = -axes[0];
        let speed = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity);
        headRotation.quat_fromAxis(speed * dt, playerUp);
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapHorizontalRunning) {
        if (Math.abs(axes[0]) > this._myParams.mySnapTurnActivateThreshold) {
          let angleToRotate = -Math.pp_sign(axes[0]) * this._myParams.mySnapTurnAngle;
          if (!this._myParams.mySmoothSnapActive) {
            headRotation.quat_fromAxis(angleToRotate, playerUp);
          } else {
            this._mySmoothSnapHorizontalRunning = true;
            this._mySmoothSnapHorizontalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapHorizontalRunning) {
      let angleToRotate = Math.pp_sign(this._mySmoothSnapHorizontalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapHorizontalAngleToPerform) - LocomotionUtils.EPSILON) {
        angleToRotate = this._mySmoothSnapHorizontalAngleToPerform;
      }
      headRotation.quat_fromAxis(angleToRotate, playerUp);
      this._mySmoothSnapHorizontalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapHorizontalAngleToPerform) < LocomotionUtils.EPSILON) {
        this._mySmoothSnapHorizontalRunning = false;
        this._mySmoothSnapHorizontalAngleToPerform = 0;
      }
    }
    if (headRotation.quat_getAngle() > LocomotionUtils.EPSILON_DEGREES) {
      this._myParams.myPlayerTransformManager.rotateQuat(headRotation);
    }
  };
}();
PlayerLocomotionRotate2.prototype._rotateHeadVertically = function() {
  let headForward = vec3_create2();
  let headUp = vec3_create2();
  let referenceUp = vec3_create2();
  let referenceUpNegate = vec3_create2();
  let referenceRight = vec3_create2();
  let newUp = vec3_create2();
  let headRotation = quat_create();
  return function _rotateHeadVertically(dt) {
    let head = this._myParams.myPlayerHeadManager.getHead();
    headForward = head.pp_getForward(headForward);
    headUp = head.pp_getUp(headUp);
    referenceUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(referenceUp);
    referenceUpNegate = referenceUp.vec3_negate(referenceUpNegate);
    referenceRight = headForward.vec3_cross(referenceUp, referenceRight);
    let minAngle = 1;
    if (headForward.vec3_angle(referenceUp) < minAngle) {
      referenceRight = headUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
    } else if (headForward.vec3_angle(referenceUpNegate) < minAngle) {
      referenceRight = headUp.vec3_cross(referenceUp, referenceRight);
    } else if (!headUp.vec3_isConcordant(referenceUp)) {
      referenceRight.vec3_negate(referenceRight);
    }
    referenceRight.vec3_normalize(referenceRight);
    let axes = getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    let angleToRotate = 0;
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[1]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = axes[1];
        angleToRotate = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity) * dt;
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapVerticalRunning) {
        if (Math.abs(axes[1]) > this._myParams.mySnapTurnActivateThreshold) {
          angleToRotate = Math.pp_sign(axes[1]) * this._myParams.mySnapTurnAngle;
          let angleWithUp = Math.pp_angleClamp(headUp.vec3_angleSigned(referenceUp, referenceRight));
          let snapStep = Math.round(angleWithUp / this._myParams.mySnapTurnAngle);
          let snapAngle = Math.pp_angleClamp(snapStep * this._myParams.mySnapTurnAngle);
          let angleToAlign = -Math.pp_angleDistanceSigned(angleWithUp, snapAngle);
          if (Math.abs(angleToAlign) > 1) {
            if (Math.pp_sign(angleToRotate) == Math.pp_sign(angleToAlign)) {
              angleToRotate = angleToAlign;
            } else {
              angleToRotate = -Math.pp_sign(angleToAlign) * this._myParams.mySnapTurnAngle + angleToAlign;
            }
          } else if (Math.abs(angleToAlign) > LocomotionUtils.EPSILON_DEGREES) {
            angleToRotate += angleToAlign;
          }
          if (this._myParams.mySmoothSnapActive) {
            this._mySmoothSnapVerticalRunning = true;
            this._mySmoothSnapVerticalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapVerticalRunning) {
      angleToRotate = Math.pp_sign(this._mySmoothSnapVerticalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapVerticalAngleToPerform) - LocomotionUtils.EPSILON) {
        angleToRotate = this._mySmoothSnapVerticalAngleToPerform;
      }
      this._mySmoothSnapVerticalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapVerticalAngleToPerform) < LocomotionUtils.EPSILON) {
        this._mySmoothSnapVerticalRunning = false;
        this._mySmoothSnapVerticalAngleToPerform = 0;
      }
    }
    if (angleToRotate != 0) {
      headRotation.quat_fromAxis(angleToRotate, referenceRight);
      this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
      if (this._myParams.myClampVerticalAngle) {
        let maxVerticalAngle = this._myParams.myMaxVerticalAngle - 1e-4;
        newUp = head.pp_getUp(newUp);
        let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
        if (Math.abs(angleWithUp) > maxVerticalAngle) {
          let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
          headRotation.quat_fromAxis(fixAngle, referenceRight);
          this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
        }
      }
    }
  };
}();
Object.defineProperty(PlayerLocomotionRotate2.prototype, "_rotateHeadHorizontally", { enumerable: false });
Object.defineProperty(PlayerLocomotionRotate2.prototype, "_rotateHeadVertically", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
import { PhysXComponent as PhysXComponent7 } from "@wonderlandengine/api";

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_obscure_manager.js
var PlayerObscureManagerParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myPlayerTransformManager = null;
    this.myObscureObject = null;
    this.myObscureMaterial = null;
    this.myObscureRadius = 0;
    this.myObscureFadeOutSeconds = 0.1;
    this.myObscureFadeInSeconds = 0.1;
    this.myObscureFadeEasingFunction = EasingFunction2.linear;
    this.myDistanceToStartObscureWhenHeadColliding = 0;
    this.myDistanceToStartObscureWhenBodyColliding = 0;
    this.myDistanceToStartObscureWhenFloating = 0;
    this.myDistanceToStartObscureWhenFar = 0;
    this.myRelativeDistanceToMaxObscureWhenHeadColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenBodyColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenFloating = 0;
    this.myRelativeDistanceToMaxObscureWhenFar = 0;
    this.myObscureLevelRelativeDistanceEasingFunction = EasingFunction2.linear;
    this.myEngine = engine2;
  }
};
var PlayerObscureManager = class {
  constructor(params) {
    this._myParams = params;
    this._myObscureMaterial = null;
    this._myObscureParentObject = null;
    this._myCurrentObscureLevel = 0;
    this._myTargetObscureLevel = 0;
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
    this._myFadeTimer = new Timer(0, false);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("inactive");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("fading", this._fadingUpdate.bind(this));
    this._myFSM.addTransition("init", "inactive", "end", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("inactive", "idle", "start");
    this._myFSM.addTransition("idle", "fading", "fade", this._startFading.bind(this));
    this._myFSM.addTransition("fading", "idle", "done", this._fadingDone.bind(this));
    this._myFSM.addTransition("inactive", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("idle", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("fading", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.init("init");
    this._setupVisuals();
    this._myFSM.perform("end");
  }
  start() {
    this._myFSM.perform("start");
  }
  stop() {
    this._myFSM.perform("stop");
  }
  update(dt) {
    this._myObscureParentObject.pp_resetTransformLocal();
    this._updateObscured();
    this._myFSM.update(dt);
    this._setObscureVisible(this.isObscured());
  }
  isStarted() {
    return !this._myFSM.isInState("inactive");
  }
  isObscured() {
    return this._myCurrentObscureLevel > 0;
  }
  isFading() {
    return this._myFSM.isInState("fading");
  }
  isFadingIn() {
    return this.isFading() && this._myCurrentObscureLevel > this._myTargetObscureLevel;
  }
  isFadingOut() {
    return this.isFading() && this._myCurrentObscureLevel <= this._myTargetObscureLevel;
  }
  getObscureLevel() {
    return this._myCurrentObscureLevel;
  }
  getTargetObscureLevel() {
    return this._myTargetObscureLevel;
  }
  getCurrentObscureLevel() {
    this._myCurrentObscureLevel;
  }
  obscureLevelOverride(obscureLevel, instantFade = false) {
    this._myObscurelevelOverride = obscureLevel;
    if (instantFade && this.isStarted()) {
      this._setObscureLevel(obscureLevel);
    }
  }
  resetObscureLevelOverride() {
    this._myObscurelevelOverride = null;
  }
  _idleUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) > Math.PP_EPSILON) {
      this._myFSM.perform("fade");
    }
  }
  _fadingUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON) {
      this._myFSM.perform("done");
      return;
    }
    if (this._myLastTargetObscureLevel != this._myTargetObscureLevel) {
      this._refreshFadeTimer();
      this._myLastTargetObscureLevel = this._myTargetObscureLevel;
    }
    this._myFadeTimer.update(dt);
    let newObscureLevel = this._myParams.myObscureFadeEasingFunction(this._myFadeTimer.getPercentage());
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (!isFadingIn) {
      newObscureLevel = Math.min(newObscureLevel, this._myTargetObscureLevel);
    } else {
      newObscureLevel = Math.pp_clamp(1 - newObscureLevel, 0, 1);
      newObscureLevel = Math.max(newObscureLevel, this._myTargetObscureLevel);
    }
    this._setObscureAlpha(newObscureLevel);
    this._myCurrentObscureLevel = newObscureLevel;
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON || this._myFadeTimer.isDone()) {
      this._myFSM.perform("done");
    }
  }
  _startFading() {
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
  }
  _fadingDone() {
    this._setObscureLevel(this._myTargetObscureLevel);
  }
  _refreshFadeTimer() {
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (this._myLastIsFadingIn != isFadingIn) {
      this._setFadeTimerToObscureLevel(isFadingIn);
    }
    this._myLastIsFadingIn = isFadingIn;
  }
  _setFadeTimerToObscureLevel(isFadingIn) {
    let percentage = 0;
    let closestPercentage = 0;
    let steps = 1e3;
    let increment = 1 / steps;
    while (percentage < 1) {
      if (Math.abs(this._myParams.myObscureFadeEasingFunction(percentage) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
        closestPercentage = percentage;
      }
      percentage += increment;
    }
    if (Math.abs(this._myParams.myObscureFadeEasingFunction(1) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
      closestPercentage = 1;
    }
    if (isFadingIn) {
      this._myFadeTimer.start(this._myParams.myObscureFadeInSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(1 - closestPercentage, 0, 1));
    } else {
      this._myFadeTimer.start(this._myParams.myObscureFadeOutSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(closestPercentage, 0, 1));
    }
  }
  _setObscureLevel(obscureLevel) {
    this._myTargetObscureLevel = obscureLevel;
    this._myCurrentObscureLevel = obscureLevel;
    this._setObscureAlpha(obscureLevel);
    this._setObscureVisible(this.isObscured());
  }
  _setObscureAlpha(alpha) {
    if (this._myParams.myObscureObject == null) {
      MaterialUtils.setAlpha(this._myObscureMaterial, alpha);
    } else {
      MaterialUtils.setObjectAlpha(this._myParams.myObscureObject, alpha);
    }
  }
  _updateObscured() {
    this._myTargetObscureLevel = 0;
    if (this._myObscurelevelOverride != null) {
      this._myTargetObscureLevel = this._myObscurelevelOverride;
    } else {
      if (this._myParams.myPlayerTransformManager.isHeadColliding()) {
        let distance = this._myParams.myPlayerTransformManager.getDistanceToRealHead();
        let relativeDistance = distance - this._myParams.myDistanceToStartObscureWhenHeadColliding;
        if (relativeDistance >= 0) {
          let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenHeadColliding, 0, 1);
          let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
          this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
        }
      }
      if (this._myParams.myPlayerTransformManager.isBodyColliding()) {
        let distance = this._myParams.myPlayerTransformManager.getDistanceToReal();
        let relativeDistance = distance - this._myParams.myDistanceToStartObscureWhenBodyColliding;
        if (relativeDistance >= 0) {
          let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenBodyColliding, 0, 1);
          let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
          this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
        }
      }
      if (this._myParams.myPlayerTransformManager.isFloating()) {
        let distance = this._myParams.myPlayerTransformManager.getDistanceToReal();
        let relativeDistance = distance - this._myParams.myDistanceToStartObscureWhenFloating;
        if (relativeDistance >= 0) {
          let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFloating, 0, 1);
          let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
          this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
        }
      }
      if (this._myParams.myPlayerTransformManager.isFar()) {
        let distance = this._myParams.myPlayerTransformManager.getDistanceToReal();
        let relativeDistance = distance - this._myParams.myDistanceToStartObscureWhenFar;
        if (relativeDistance >= 0) {
          let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFar, 0, 1);
          let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
          this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
        }
      }
    }
  }
  _setupVisuals() {
    this._myObscureMaterial = null;
    if (this._myParams.myObscureMaterial != null) {
      this._myObscureMaterial = this._myParams.myObscureMaterial;
    } else {
      this._myObscureMaterial = getDefaultResources(this._myParams.myEngine).myMaterials.myFlatTransparentNoDepth.clone();
      this._myObscureMaterial.color = vec4_create2(0, 0, 0, 1);
    }
    this._myObscureParentObject = getVisualData(this._myParams.myEngine).myRootObject.pp_addObject();
    let obscureVisualParams = new VisualMeshParams(this._myParams.myEngine);
    obscureVisualParams.myMesh = getDefaultResources(this._myParams.myEngine).myMeshes.myInvertedSphere;
    obscureVisualParams.myMaterial = this._myParams.myObscureMaterial != null ? this._myParams.myObscureMaterial : this._myObscureMaterial;
    obscureVisualParams.myParent = this._myObscureParentObject;
    obscureVisualParams.myIsLocal = true;
    obscureVisualParams.myTransform.mat4_setScale(vec3_create2(this._myParams.myObscureRadius, this._myParams.myObscureRadius, this._myParams.myObscureRadius));
    this._myObscureVisual = new VisualMesh(obscureVisualParams);
    if (this._myParams.myObscureObject != null) {
      this._myParams.myObscureObject.pp_setParent(this._myObscureParentObject, false);
      this._myParams.myObscureObject.pp_resetTransformLocal();
    }
    this._setObscureVisible(false);
  }
  _setObscureVisible(visible) {
    if (this._myParams.myObscureObject == null) {
      this._myObscureVisual.setVisible(visible);
    } else {
      this._myObscureVisual.setVisible(false);
      this._myParams.myObscureObject.pp_setActive(visible);
    }
    if (visible) {
      this._myObscureParentObject.pp_setParent(this._myParams.myPlayerTransformManager.getHead(), false);
    } else {
      this._myObscureParentObject.pp_setParent(null, false);
    }
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_visualizer.js
var PlayerLocomotionTeleportDetectionVisualizerParams = class {
  constructor() {
    this.myTeleportParableValidMaterial = null;
    this.myTeleportParableInvalidMaterial = null;
    this.myTeleportPositionObject = null;
    this.myTeleportParableLineEndOffset = 0.05;
    this.myTeleportParableMinVerticalDistanceToShowVerticalLine = 0.25;
    this.myTeleportParablePositionUpOffset = 0.05;
    this.myTeleportParablePositionVisualAlignOnSurface = true;
    this.myVisualTeleportPositionLerpActive = true;
    this.myVisualTeleportPositionLerpFactor = 10;
    this.myVisualTeleportPositionMinDistanceToResetLerp = 5e-3;
    this.myVisualTeleportPositionMinDistanceToLerp = 0.15;
    this.myVisualTeleportPositionMaxDistanceToLerp = 5;
    this.myVisualTeleportPositionMinDistanceToCloseLerpFactor = 0.02;
    this.myVisualTeleportPositionCloseLerpFactor = 30;
    this.myVisualTeleportPositionMinAngleDistanceToResetLerp = 0.1;
    this.myVisualTeleportPositionMinAngleDistanceToLerp = 1;
    this.myVisualTeleportPositionMaxAngleDistanceToLerp = 180;
  }
};
var PlayerLocomotionTeleportDetectionVisualizer = class {
  constructor(teleportParams, teleportRuntimeParams, detectionRuntimeParams) {
    this._myDetectionRuntimeParams = detectionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformQuat = quat2_create();
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._setupVisuals();
  }
  start() {
  }
  end() {
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._hideTeleportPosition();
  }
  update(dt) {
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._showTeleportPosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
      this._hideTeleportPosition();
    }
  }
  _showTeleportPosition(dt) {
    this._hideTeleportPosition();
    this._showTeleportParable(dt);
  }
  _hideTeleportPosition() {
    for (let visualLine of this._myValidVisualLines) {
      visualLine.setVisible(false);
    }
    for (let visualLine of this._myInvalidVisualLines) {
      visualLine.setVisible(false);
    }
    this._myValidVisualPoint.setVisible(false);
    this._myInvalidVisualPoint.setVisible(false);
    this._myValidVisualVerticalLine.setVisible(false);
    this._myValidVisualTeleportPositionTorus.setVisible(false);
    this._myValidVisualTeleportPositionTorusInner.setVisible(false);
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
  }
  _addVisualLines(amount) {
    for (let i = 0; i < amount; i++) {
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportParableValidMaterial;
        }
        this._myValidVisualLines.push(new VisualLine(visualParams));
      }
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableInvalidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportParableInvalidMaterial;
        }
        this._myInvalidVisualLines.push(new VisualLine(visualParams));
      }
    }
  }
};
PlayerLocomotionTeleportDetectionVisualizer.prototype._setupVisuals = function() {
  let innerTorusPosition = vec3_create2();
  return function _setupVisuals() {
    this._myTeleportParableValidMaterial = getDefaultResources(this._myTeleportParams.myEngine).myMaterials.myFlatOpaque.clone();
    this._myTeleportParableValidMaterial.color = vec4_create2(0, 0.5, 1, 1);
    this._myTeleportParableInvalidMaterial = getDefaultResources(this._myTeleportParams.myEngine).myMaterials.myFlatOpaque.clone();
    this._myTeleportParableInvalidMaterial.color = vec4_create2(0.75, 0.05, 0, 1);
    this._myValidVisualLines = [];
    this._myInvalidVisualLines = [];
    this._addVisualLines(30);
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportParableValidMaterial;
      }
      this._myValidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportParableInvalidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableInvalidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportParableInvalidMaterial;
      }
      this._myInvalidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportParableValidMaterial;
      }
      this._myValidVisualVerticalLine = new VisualLine(visualParams);
    }
    this._myVisualTeleportPositionObject = getVisualData(this._myTeleportParams.myEngine).myRootObject.pp_addObject();
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportParableValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myIsLocal = true;
      this._myValidVisualTeleportPositionTorus = new VisualTorus(visualParams);
    }
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportParableValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myIsLocal = true;
      let visualTorusParams = this._myValidVisualTeleportPositionTorus.getParams();
      let innerTorusCenter = (visualTorusParams.myRadius - visualTorusParams.mySegmentThickness / 2) / 2;
      innerTorusPosition.vec3_set(0, 0, innerTorusCenter);
      visualParams.myTransform.mat4_setPosition(innerTorusPosition);
      this._myValidVisualTeleportPositionTorusInner = new VisualTorus(visualParams);
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setParent(this._myVisualTeleportPositionObject);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_resetTransformLocal();
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
    this._hideTeleportPosition();
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParable = function() {
  let currentPosition = vec3_create2();
  let nextPosition = vec3_create2();
  let playerUp = vec3_create2();
  let upDifference = vec3_create2();
  return function _showTeleportParable(dt) {
    let showParableDistance = Math.max(this._myDetectionRuntimeParams.myParableDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableLineEndOffset);
    let lastParableIndex = this._myDetectionRuntimeParams.myParable.getPositionIndexByDistance(showParableDistance);
    let lastParableIndexDistance = this._myDetectionRuntimeParams.myParable.getDistance(lastParableIndex);
    if (lastParableIndex + 1 > this._myValidVisualLines.length) {
      this._addVisualLines(lastParableIndex + 1, this._myValidVisualLines.length);
    }
    for (let i = 0; i <= lastParableIndex; i++) {
      currentPosition = this._myDetectionRuntimeParams.myParable.getPosition(i, currentPosition);
      nextPosition = this._myDetectionRuntimeParams.myParable.getPosition(i + 1, nextPosition);
      let visuaLine = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualLines[i] : this._myInvalidVisualLines[i];
      let currentVisualLineParams = visuaLine.getParams();
      if (i == lastParableIndex) {
        let stepLength = Math.max(0, showParableDistance - lastParableIndexDistance);
        nextPosition = nextPosition.vec3_sub(currentPosition, nextPosition).vec3_normalize(nextPosition);
        nextPosition = currentPosition.vec3_add(nextPosition.vec3_scale(stepLength, nextPosition), nextPosition);
      }
      currentVisualLineParams.setStartEnd(currentPosition, nextPosition);
      currentVisualLineParams.myThickness = 5e-3;
      visuaLine.paramsUpdated();
      visuaLine.setVisible(true);
      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugShowActive) {
        getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, currentPosition, vec4_create2(1, 0, 0, 1), 0.01);
      }
    }
    let visualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualPoint : this._myInvalidVisualPoint;
    let visualPointParams = visualPoint.getParams();
    visualPointParams.myPosition.vec3_copy(nextPosition);
    visualPointParams.myRadius = 0.01;
    visualPoint.paramsUpdated();
    visualPoint.setVisible(true);
    if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      upDifference = nextPosition.vec3_sub(this._myTeleportRuntimeParams.myTeleportPosition, upDifference).vec3_componentAlongAxis(playerUp, upDifference);
      let upDistance = upDifference.vec3_length();
      if (upDistance >= this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine) {
        let lineLength = Math.min(upDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine, this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine);
        let visualLineParams = this._myValidVisualVerticalLine.getParams();
        visualLineParams.myStart.vec3_copy(nextPosition);
        visualLineParams.myDirection = playerUp.vec3_negate(visualLineParams.myDirection);
        visualLineParams.myLength = lineLength;
        visualLineParams.myThickness = 5e-3;
        this._myValidVisualVerticalLine.paramsUpdated();
        this._myValidVisualVerticalLine.setVisible(true);
      }
      this._showTeleportParablePosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
    }
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParablePosition = function() {
  let playerUp = vec3_create2();
  let feetTransformQuat = quat2_create();
  let feetRotationQuat = quat_create();
  let visualPosition = vec3_create2();
  let visualForward = vec3_create2();
  let visualRotationQuat = quat_create();
  let currentVisualTeleportTransformQuat = quat2_create();
  let currentVisualTeleportPosition = vec3_create2();
  let currentVisualTeleportRotationQuat = quat_create();
  let differenceRotationQuat = quat_create();
  return function _showTeleportParablePosition(dt) {
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
    feetRotationQuat = feetRotationQuat.quat_rotateAxis(this._myTeleportRuntimeParams.myTeleportRotationOnUp, playerUp, feetRotationQuat);
    visualForward = feetRotationQuat.quat_getForward(visualForward);
    visualPosition = this._myTeleportRuntimeParams.myTeleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myVisualizerParams.myTeleportParablePositionUpOffset, visualPosition), visualPosition);
    if (this._myTeleportParams.myVisualizerParams.myTeleportParablePositionVisualAlignOnSurface) {
      visualRotationQuat.quat_setUp(this._myDetectionRuntimeParams.myTeleportSurfaceNormal, visualForward);
    } else {
      visualRotationQuat.quat_setUp(playerUp, visualForward);
    }
    this._myVisualTeleportTransformQuat.quat2_setPositionRotationQuat(visualPosition, visualRotationQuat);
    if (this._myVisualTeleportTransformQuatReset || !this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpActive) {
      this._myVisualTeleportPositionObject.pp_setTransformQuat(this._myVisualTeleportTransformQuat);
      this._myVisualTeleportTransformQuatReset = false;
    } else {
      currentVisualTeleportTransformQuat = this._myVisualTeleportPositionObject.pp_getTransformQuat(currentVisualTeleportTransformQuat);
      currentVisualTeleportPosition = currentVisualTeleportTransformQuat.quat2_getPosition(currentVisualTeleportPosition);
      currentVisualTeleportRotationQuat = currentVisualTeleportTransformQuat.quat2_getRotationQuat(currentVisualTeleportRotationQuat);
      currentVisualTeleportRotationQuat.quat_rotationToQuat(visualRotationQuat, differenceRotationQuat);
      let positionDistance = currentVisualTeleportPosition.vec3_distance(visualPosition);
      let rotationAngleDistance = differenceRotationQuat.quat_getAngle();
      if ((!this._myVisualTeleportTransformPositionLerping || positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToResetLerp) && (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp)) {
        this._myVisualTeleportTransformPositionLerping = false;
        currentVisualTeleportPosition.vec3_copy(visualPosition);
      } else {
        this._myVisualTeleportTransformPositionLerping = true;
        let interpolationValue = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        if (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToCloseLerpFactor) {
          interpolationValue = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionCloseLerpFactor * dt;
        }
        currentVisualTeleportPosition.vec3_lerp(visualPosition, interpolationValue, currentVisualTeleportPosition);
      }
      if ((!this._myVisualTeleportTransformRotationLerping || rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToResetLerp) && (rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp)) {
        this._myVisualTeleportTransformRotationLerping = false;
        currentVisualTeleportRotationQuat.quat_copy(visualRotationQuat);
      } else {
        let interpolationValue = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        this._myVisualTeleportTransformRotationLerping = true;
        currentVisualTeleportRotationQuat.quat_slerp(visualRotationQuat, interpolationValue, currentVisualTeleportRotationQuat);
      }
      currentVisualTeleportTransformQuat.quat2_setPositionRotationQuat(currentVisualTeleportPosition, currentVisualTeleportRotationQuat);
      this._myVisualTeleportPositionObject.pp_setTransformQuat(currentVisualTeleportTransformQuat);
    }
    {
      let visualParams = this._myValidVisualTeleportPositionTorus.getParams();
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      this._myValidVisualTeleportPositionTorus.paramsUpdated();
    }
    {
      let visualParams = this._myValidVisualTeleportPositionTorusInner.getParams();
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      this._myValidVisualTeleportPositionTorusInner.paramsUpdated();
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject == null) {
      this._myValidVisualTeleportPositionTorus.setVisible(true);
      this._myValidVisualTeleportPositionTorusInner.setVisible(true);
    } else {
      this._myValidVisualTeleportPositionTorus.setVisible(false);
      this._myValidVisualTeleportPositionTorusInner.setVisible(false);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(true);
    }
    if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugShowActive) {
      getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, this._myTeleportRuntimeParams.myTeleportPosition, vec4_create2(0, 0, 1, 1), 0.02);
    }
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_parable.js
var PlayerLocomotionTeleportParable = class {
  constructor() {
    this._myStartPosition = vec3_create2();
    this._myForward = vec3_create2();
    this._myUp = vec3_create2();
    this._mySpeed = 0;
    this._myGravity = 0;
    this._myStepLength = 0;
  }
  setStartPosition(startPosition) {
    this._myStartPosition.vec3_copy(startPosition);
  }
  setForward(forward) {
    this._myForward.vec3_copy(forward);
  }
  setUp(up) {
    this._myUp.vec3_copy(up);
  }
  setSpeed(speed) {
    this._mySpeed = speed;
  }
  setGravity(gravity) {
    this._myGravity = gravity;
  }
  setStepLength(stepLength) {
    this._myStepLength = stepLength;
  }
  getPosition(positionIndex, outPosition = vec3_create2()) {
  }
  getDistance(positionIndex) {
  }
  getPositionIndexByDistance(distance) {
  }
  getPositionByDistance(distance, outPosition = vec3_create2()) {
  }
  getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
  }
  getFlatDistanceOverDistance(distance) {
  }
};
PlayerLocomotionTeleportParable.prototype.getPosition = function() {
  let forwardPosition = vec3_create2();
  let upPosition = vec3_create2();
  return function getPosition(positionIndex, outPosition = vec3_create2()) {
    let deltaTimePerStep = this._myStepLength / this._mySpeed;
    let elapsedTime = deltaTimePerStep * positionIndex;
    forwardPosition = this._myForward.vec3_scale(this._mySpeed * elapsedTime, forwardPosition);
    forwardPosition = forwardPosition.vec3_add(this._myStartPosition, forwardPosition);
    upPosition = this._myUp.vec3_scale(this._myGravity * elapsedTime * elapsedTime / 2, upPosition);
    outPosition = forwardPosition.vec3_add(upPosition, outPosition);
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistance = function() {
  let currentPosition = vec3_create2();
  let prevPosition = vec3_create2();
  return function getDistance(positionIndex) {
    let distance = 0;
    prevPosition.vec3_copy(this._myStartPosition);
    for (let i = 1; i <= positionIndex; i++) {
      currentPosition = this.getPosition(i, currentPosition);
      distance += currentPosition.vec3_distance(prevPosition);
      prevPosition.vec3_copy(currentPosition);
    }
    return distance;
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionIndexByDistance = function() {
  let currentPosition = vec3_create2();
  let prevPosition = vec3_create2();
  return function getPositionIndexByDistance(distance) {
    let currentDistance = 0;
    let currentIndex = 0;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (currentDistance < distance) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.max(0, currentIndex - 1);
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionByDistance = function() {
  let currentPosition = vec3_create2();
  let prevPosition = vec3_create2();
  let prevToCurrent = vec3_create2();
  return function getPositionByDistance(distance, outPosition = vec3_create2()) {
    let currentDistance = 0;
    let currentIndex = 0;
    let found = false;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (!found) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      if (currentDistance > distance) {
        let lengthToRemove = currentDistance - distance;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let lengthToAdd = prevToCurrent.vec3_length() - lengthToRemove;
        prevToCurrent.vec3_normalize(prevToCurrent);
        outPosition = prevPosition.vec3_add(prevToCurrent.vec3_scale(lengthToAdd, outPosition), outPosition);
        found = true;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistanceOverFlatDistance = function() {
  let currentPosition = vec3_create2();
  let flatCurrentPosition = vec3_create2();
  let flatStartPosition = vec3_create2();
  let prevPosition = vec3_create2();
  let prevToCurrent = vec3_create2();
  let startToCurrentFlat = vec3_create2();
  return function getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
    if (flatDistance < 1e-5) {
      return 0;
    }
    let currentDistance = 0;
    let currentIndex = 0;
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    prevPosition = this.getPosition(currentIndex, prevPosition);
    let distanceOverFlatDistance = 0;
    while (currentDistance <= maxParableDistance) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      flatCurrentPosition = currentPosition.vec3_removeComponentAlongAxis(this._myUp, flatCurrentPosition);
      startToCurrentFlat = flatCurrentPosition.vec3_sub(flatStartPosition, startToCurrentFlat);
      let currentFlatDistance = startToCurrentFlat.vec3_length();
      if (currentFlatDistance >= flatDistance) {
        let flatDifference = currentFlatDistance - flatDistance;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let angleWithFlat = prevToCurrent.vec3_angleRadians(startToCurrentFlat);
        let cos = Math.cos(angleWithFlat);
        let lengthToRemove = prevToCurrent.vec3_length();
        if (cos != 0) {
          lengthToRemove = flatDifference / Math.cos(angleWithFlat);
        }
        distanceOverFlatDistance = currentDistance - lengthToRemove;
        break;
      } else {
        distanceOverFlatDistance = currentDistance;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.min(maxParableDistance, distanceOverFlatDistance);
  };
}();
PlayerLocomotionTeleportParable.prototype.getFlatDistanceOverDistance = function() {
  let positionByDistance = vec3_create2();
  let flatPositionByDistance = vec3_create2();
  let flatStartPosition = vec3_create2();
  return function getFlatDistanceOverDistance(distance) {
    positionByDistance = this.getPositionByDistance(distance, positionByDistance);
    flatPositionByDistance = positionByDistance.vec3_removeComponentAlongAxis(this._myUp, flatPositionByDistance);
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    return flatStartPosition.vec3_distance(flatPositionByDistance);
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_state.js
var PlayerLocomotionTeleportState = class extends State {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super();
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myTeleportAsMovementFailed = false;
  }
};
PlayerLocomotionTeleportState.prototype._checkTeleport = function() {
  return function _checkTeleport(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
    getCollisionCheck2(this._myTeleportParams.myEngine).teleport(teleportPosition, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
    if (checkTeleportCollisionRuntimeParams != null) {
      checkTeleportCollisionRuntimeParams.copy(collisionRuntimeParams);
    }
  };
}();
PlayerLocomotionTeleportState.prototype._checkTeleportAsMovement = function() {
  let checkTeleportMovementCollisionRuntimeParams = new CollisionRuntimeParams();
  let feetRotationQuat = quat_create();
  let feetPosition = vec3_create2();
  let feetUp = vec3_create2();
  let teleportFeetForward = vec3_create2();
  let teleportFeetRotationQuat = quat_create();
  let teleportFeetTransformQuat = quat2_create();
  let currentFeetPosition = vec3_create2();
  let fixedTeleportPosition = vec3_create2();
  let teleportMovement = vec3_create2();
  let extraVerticalMovement = vec3_create2();
  let movementToTeleportPosition = vec3_create2();
  let movementFeetTransformQuat = quat2_create();
  return function _checkTeleportAsMovement(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
    feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
    feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
    feetUp = feetRotationQuat.quat_getUp(feetUp);
    teleportFeetForward = teleportPosition.vec3_sub(feetPosition, teleportFeetForward).vec3_removeComponentAlongAxis(feetUp, teleportFeetForward);
    teleportFeetForward.vec3_normalize(teleportFeetForward);
    if (teleportFeetForward.vec3_isZero(1e-5)) {
      teleportFeetForward = feetRotationQuat.quat_getForward(teleportFeetForward);
    }
    teleportFeetRotationQuat.quat_setUp(feetUp, teleportFeetForward);
    teleportFeetTransformQuat.quat2_setPositionRotationQuat(feetPosition, teleportFeetRotationQuat);
    this._checkTeleport(teleportPosition, teleportFeetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      let teleportMovementValid = false;
      checkTeleportMovementCollisionRuntimeParams.copy(collisionRuntimeParams);
      fixedTeleportPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
      currentFeetPosition.vec3_copy(feetPosition);
      for (let i = 0; i < this._myTeleportParams.myTeleportAsMovementMaxSteps; i++) {
        teleportMovement = fixedTeleportPosition.vec3_sub(currentFeetPosition, teleportMovement);
        if (this._myTeleportParams.myTeleportAsMovementRemoveVerticalMovement) {
          teleportMovement = teleportMovement.vec3_removeComponentAlongAxis(feetUp, teleportMovement);
        }
        if (this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter != 0) {
          let meters = teleportMovement.vec3_length();
          let extraVerticalMovementValue = meters * this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter;
          extraVerticalMovement = feetUp.vec3_scale(extraVerticalMovementValue, extraVerticalMovement);
          teleportMovement = teleportMovement.vec3_add(extraVerticalMovement, teleportMovement);
        }
        movementFeetTransformQuat.quat2_setPositionRotationQuat(currentFeetPosition, feetRotationQuat);
        getCollisionCheck2(this._myTeleportParams.myEngine).move(teleportMovement, movementFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, checkTeleportMovementCollisionRuntimeParams);
        if (!checkTeleportMovementCollisionRuntimeParams.myHorizontalMovementCanceled && !checkTeleportMovementCollisionRuntimeParams.myVerticalMovementCanceled) {
          movementToTeleportPosition = fixedTeleportPosition.vec3_sub(checkTeleportMovementCollisionRuntimeParams.myNewPosition, movementToTeleportPosition);
          if (movementToTeleportPosition.vec3_length() < this._myTeleportParams.myTeleportAsMovementMaxDistanceFromTeleportPosition + 1e-5) {
            teleportMovementValid = true;
            break;
          } else {
            teleportMovement.vec3_copy(movementToTeleportPosition);
            currentFeetPosition.vec3_copy(checkTeleportMovementCollisionRuntimeParams.myNewPosition);
          }
        } else {
          break;
        }
      }
      if (!teleportMovementValid) {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
      this._myTeleportAsMovementFailed = !teleportMovementValid;
    }
  };
}();
PlayerLocomotionTeleportState.prototype._teleportToPosition = function() {
  let playerUp = vec3_create2();
  let feetTransformQuat = quat2_create();
  let newFeetTransformQuat = quat2_create();
  let newFeetRotationQuat = quat_create();
  let teleportRotation = quat_create();
  return function _teleportToPosition(teleportPosition, rotationOnUp, collisionRuntimeParams, forceTeleport = false) {
    this._myTeleportAsMovementFailed = false;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    newFeetRotationQuat = feetTransformQuat.quat2_getRotationQuat(newFeetRotationQuat);
    if (rotationOnUp != 0) {
      newFeetRotationQuat = newFeetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, newFeetRotationQuat);
    }
    newFeetTransformQuat.quat2_setPositionRotationQuat(teleportPosition, newFeetRotationQuat);
    if (getGamepads(this._myTeleportParams.myEngine)[InputUtils.getOppositeHandedness(this._myTeleportParams.myHandedness)].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
      getCollisionCheck2(this._myTeleportParams.myEngine).positionCheck(true, newFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
      this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(teleportPosition);
      if (rotationOnUp != 0) {
        teleportRotation.quat_fromAxis(rotationOnUp, playerUp);
        this._myTeleportParams.myPlayerHeadManager.rotateFeetQuat(teleportRotation);
      }
    } else {
      this._myTeleportParams.myPlayerTransformManager.teleportTransformQuat(newFeetTransformQuat, collisionRuntimeParams, forceTeleport);
    }
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state.js
var PlayerLocomotionTeleportDetectionParams = class {
  constructor() {
    this.myMaxDistance = 0;
    this.myMaxHeightDifference = 0;
    this.myGroundAngleToIgnoreUpward = 0;
    this.myMustBeOnGround = false;
    this.myTeleportBlockLayerFlags = new PhysicsLayerFlags();
    this.myTeleportFloorLayerFlags = new PhysicsLayerFlags();
    this.myParableForwardMinAngleToBeValidUp = 30;
    this.myParableForwardMinAngleToBeValidDown = 0;
    this.myTeleportParableStartReferenceObject = null;
    this.myTeleportParableStartPositionOffset = vec3_create2(0, -0.04, 0.08);
    this.myTeleportParableStartRotationOffset = vec3_create2(30, 0, 0);
    this.myTeleportParableSpeed = 15;
    this.myTeleportParableGravity = -30;
    this.myTeleportParableStepLength = 0.25;
    this.myRotationOnUpMinStickIntensity = 0.5;
    this.myRotationOnUpActive = false;
    this.myTeleportFeetPositionMustBeVisible = false;
    this.myTeleportHeadPositionMustBeVisible = false;
    this.myTeleportHeadOrFeetPositionMustBeVisible = false;
    this.myVisibilityCheckRadius = 0.05;
    this.myVisibilityCheckFeetPositionVerticalOffset = 0.1;
    this.myVisibilityCheckDistanceFromHitThreshold = 0.1;
    this.myVisibilityCheckCircumferenceSliceAmount = 6;
    this.myVisibilityCheckCircumferenceStepAmount = 1;
    this.myVisibilityCheckCircumferenceRotationPerStep = 30;
    this.myVisibilityBlockLayerFlags = new PhysicsLayerFlags();
  }
};
var PlayerLocomotionTeleportDetectionRuntimeParams = class {
  constructor() {
    this.myTeleportDetectionValid = false;
    this.myTeleportPositionValid = false;
    this.myTeleportSurfaceNormal = vec3_create2();
    this.myParable = new PlayerLocomotionTeleportParable();
  }
};
var PlayerLocomotionTeleportDetectionState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myDetectionRuntimeParams = new PlayerLocomotionTeleportDetectionRuntimeParams();
    this._myVisualizer = new PlayerLocomotionTeleportDetectionVisualizer(this._myTeleportParams, this._myTeleportRuntimeParams, this._myDetectionRuntimeParams);
    this._myTeleportRotationOnUpNext = 0;
  }
  start() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = true;
    this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
    this._myTeleportRotationOnUpNext = 0;
    this._myDetectionRuntimeParams.myParable.setSpeed(this._myTeleportParams.myDetectionParams.myTeleportParableSpeed);
    this._myDetectionRuntimeParams.myParable.setGravity(this._myTeleportParams.myDetectionParams.myTeleportParableGravity);
    this._myDetectionRuntimeParams.myParable.setStepLength(this._myTeleportParams.myDetectionParams.myTeleportParableStepLength);
    this._myTeleportParams.myPlayerTransformManager.resetReal(true, false, false);
    this._myTeleportParams.myPlayerTransformManager.resetHeadToReal();
    this._myVisualizer.start();
  }
  end() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = false;
    this._myVisualizer.end();
  }
  update(dt, fsm) {
    this._detectTeleportPosition();
    this._myVisualizer.update(dt);
    if (this._confirmTeleport()) {
      if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
        fsm.perform("teleport");
      } else {
        fsm.perform("cancel");
      }
    } else if (this._cancelTeleport()) {
      fsm.perform("cancel");
    }
  }
  _confirmTeleport() {
    let confirmTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      if (getMouse(this._myTeleportParams.myEngine).isInsideView()) {
        confirmTeleport = getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.MIDDLE);
      }
    } else {
      let axes = getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        confirmTeleport = true;
      }
    }
    return confirmTeleport;
  }
  _cancelTeleport() {
    let cancelTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      cancelTeleport = getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.RIGHT) || !getMouse(this._myTeleportParams.myEngine).isInsideView();
    } else {
      cancelTeleport = getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed();
    }
    return cancelTeleport;
  }
  _detectTeleportPosition() {
    if (XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      this._detectTeleportRotationVR();
      this._detectTeleportPositionVR();
    } else {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
      this._myTeleportRotationOnUpNext = 0;
      this._detectTeleportPositionNonVR();
    }
  }
};
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionNonVR = function() {
  let mousePosition = vec3_create2();
  let mouseDirection = vec3_create2();
  let playerUp = vec3_create2();
  return function _detectTeleportPositionNonVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    getMouse(this._myTeleportParams.myEngine).getOriginWorld(mousePosition);
    getMouse(this._myTeleportParams.myEngine).getDirectionWorld(mouseDirection);
    this._detectTeleportPositionParable(mousePosition, mouseDirection, playerUp);
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionVR = function() {
  let teleportStartTransformLocal = quat2_create();
  let teleportStartTransformWorld = quat2_create();
  let teleportStartPosition = vec3_create2();
  let teleportDirection = vec3_create2();
  let playerUp = vec3_create2();
  let playerUpNegate = vec3_create2();
  return function _detectTeleportPositionVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = false;
    if (this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject == null) {
      let referenceObject = getPlayerObjects2(this._myTeleportParams.myEngine).myHands[this._myTeleportParams.myHandedness];
      teleportStartTransformLocal.quat2_setPositionRotationDegrees(this._myTeleportParams.myDetectionParams.myTeleportParableStartPositionOffset, this._myTeleportParams.myDetectionParams.myTeleportParableStartRotationOffset);
      teleportStartTransformWorld = referenceObject.pp_convertTransformObjectToWorldQuat(teleportStartTransformLocal, teleportStartTransformWorld);
    } else {
      let referenceObject = this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject;
      referenceObject.pp_getTransformQuat(teleportStartTransformWorld);
    }
    teleportStartPosition = teleportStartTransformWorld.quat2_getPosition(teleportStartPosition);
    teleportDirection = teleportStartTransformWorld.quat2_getForward(teleportDirection);
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    playerUpNegate = playerUp.vec3_negate(playerUpNegate);
    if (teleportDirection.vec3_angle(playerUp) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidUp && teleportDirection.vec3_angle(playerUpNegate) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidDown) {
      this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    }
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._detectTeleportPositionParable(teleportStartPosition, teleportDirection, playerUp);
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionParable = function() {
  let parablePosition = vec3_create2();
  let prevParablePosition = vec3_create2();
  let parableFinalPosition = vec3_create2();
  let raycastSetup = new RaycastSetup();
  let raycastResult2 = new RaycastResults();
  let parableHitPosition = vec3_create2();
  let parableHitNormal = vec3_create2();
  let verticalHitOrigin = vec3_create2();
  let verticalHitDirection = vec3_create2();
  let flatTeleportHorizontalHitNormal = vec3_create2();
  let flatParableHitNormal = vec3_create2();
  let flatParableDirectionNegate = vec3_create2();
  let teleportCollisionRuntimeParams = new CollisionRuntimeParams();
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  return function _detectTeleportPositionParable(startPosition, direction, up) {
    this._myDetectionRuntimeParams.myParable.setStartPosition(startPosition);
    this._myDetectionRuntimeParams.myParable.setForward(direction);
    this._myDetectionRuntimeParams.myParable.setUp(up);
    let currentPositionIndex = 1;
    let positionFlatDistance = 0;
    let positionParableDistance = 0;
    prevParablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex - 1, prevParablePosition);
    raycastSetup.myPhysics = this._myTeleportParams.myEngine.physics;
    raycastSetup.myIgnoreHitsInsideCollision = true;
    raycastSetup.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportBlockLayerFlags.getMask());
    raycastSetup.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
    for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
      raycastSetup.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
    }
    let maxParableDistance = this._myTeleportParams.myDetectionParams.myMaxDistance * 2;
    do {
      parablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex, parablePosition);
      raycastSetup.myOrigin.vec3_copy(prevParablePosition);
      raycastSetup.myDirection = parablePosition.vec3_sub(prevParablePosition, raycastSetup.myDirection);
      raycastSetup.myDistance = raycastSetup.myDirection.vec3_length();
      raycastSetup.myDirection.vec3_normalize(raycastSetup.myDirection);
      raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
        getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
      }
      prevParablePosition.vec3_copy(parablePosition);
      positionFlatDistance = parablePosition.vec3_sub(startPosition, parablePosition).vec3_removeComponentAlongAxis(up, parablePosition).vec3_length();
      positionParableDistance = this._myDetectionRuntimeParams.myParable.getDistance(currentPositionIndex);
      currentPositionIndex++;
    } while (positionFlatDistance <= this._myTeleportParams.myDetectionParams.myMaxDistance && positionParableDistance <= maxParableDistance && !raycastResult2.isColliding());
    let maxParableDistanceOverFlatDistance = this._myDetectionRuntimeParams.myParable.getDistanceOverFlatDistance(this._myTeleportParams.myDetectionParams.myMaxDistance, maxParableDistance);
    let fixedPositionParableDistance = positionParableDistance;
    if (positionParableDistance > maxParableDistanceOverFlatDistance || positionParableDistance > maxParableDistance) {
      fixedPositionParableDistance = Math.min(maxParableDistanceOverFlatDistance, maxParableDistance);
    }
    this._myDetectionRuntimeParams.myParableDistance = fixedPositionParableDistance;
    let hitCollisionValid = false;
    let bottomCheckMaxLength = 100;
    if (raycastResult2.isColliding()) {
      let hit = raycastResult2.myHits.pp_first();
      let hitParableDistance = positionParableDistance - (raycastSetup.myDistance - hit.myDistance);
      if (hitParableDistance <= fixedPositionParableDistance) {
        hitCollisionValid = true;
        this._myDetectionRuntimeParams.myParableDistance = hitParableDistance;
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        parableHitPosition.vec3_copy(hit.myPosition);
        parableHitNormal.vec3_copy(hit.myNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          verticalHitOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(0.01, verticalHitOrigin), verticalHitOrigin);
          verticalHitDirection = up.vec3_negate(verticalHitDirection);
          raycastSetup.myOrigin.vec3_copy(verticalHitOrigin);
          raycastSetup.myDirection.vec3_copy(verticalHitDirection);
          raycastSetup.myDistance = bottomCheckMaxLength;
          raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
          if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
            getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
          }
          if (raycastResult2.isColliding()) {
            let hit2 = raycastResult2.myHits.pp_first();
            teleportCollisionRuntimeParams.reset();
            this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
            this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
            this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
              flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
              if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
                flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                raycastSetup.myDistance = bottomCheckMaxLength;
                raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
                if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                  getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, raycastSetup.myOrigin, vec4_create2(0, 0, 0, 1), 0.03);
                  getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
                }
                if (raycastResult2.isColliding()) {
                  let hit3 = raycastResult2.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
              flatParableHitNormal = parableHitNormal.vec3_removeComponentAlongAxis(up, flatParableHitNormal);
              if (!flatParableHitNormal.vec3_isZero(1e-5)) {
                flatParableHitNormal.vec3_normalize(flatParableHitNormal);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatParableHitNormal.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                raycastSetup.myDistance = bottomCheckMaxLength;
                raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
                if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                  getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, raycastSetup.myOrigin, vec4_create2(0, 0, 0, 1), 0.03);
                  getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
                }
                if (raycastResult2.isColliding()) {
                  let hit3 = raycastResult2.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
              flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
              if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
                flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                raycastSetup.myDistance = bottomCheckMaxLength;
                raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
                if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                  getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, raycastSetup.myOrigin, vec4_create2(0, 0, 0, 1), 0.03);
                  getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
                }
                if (raycastResult2.isColliding()) {
                  let hit3 = raycastResult2.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
          }
        } else {
        }
      }
    }
    if (!hitCollisionValid) {
      parableFinalPosition = this._myDetectionRuntimeParams.myParable.getPositionByDistance(this._myDetectionRuntimeParams.myParableDistance, parableFinalPosition);
      verticalHitOrigin.vec3_copy(parableFinalPosition);
      verticalHitDirection = up.vec3_negate(verticalHitDirection);
      raycastSetup.myOrigin.vec3_copy(verticalHitOrigin);
      raycastSetup.myDirection.vec3_copy(verticalHitDirection);
      raycastSetup.myDistance = bottomCheckMaxLength;
      raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
        getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
      }
      if (raycastResult2.isColliding()) {
        let hit = raycastResult2.myHits.pp_first();
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
          flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
          if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
            flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
            let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
            raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
            raycastSetup.myDirection.vec3_copy(verticalHitDirection);
            raycastSetup.myDistance = bottomCheckMaxLength;
            raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
            if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
              getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, raycastSetup.myOrigin, vec4_create2(0, 0, 0, 1), 0.03);
              getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
            }
            if (raycastResult2.isColliding()) {
              let hit2 = raycastResult2.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            }
          }
        }
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
          if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
            flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
            let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
            raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
            raycastSetup.myDirection.vec3_copy(verticalHitDirection);
            raycastSetup.myDistance = bottomCheckMaxLength;
            raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
            if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
              getDebugVisualManager2(this._myTeleportParams.myEngine).drawPoint(0, raycastSetup.myOrigin, vec4_create2(0, 0, 0, 1), 0.03);
              getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
            }
            if (raycastResult2.isColliding()) {
              let hit2 = raycastResult2.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            }
          }
        }
      }
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportRotationVR = function() {
  let axesVec3 = vec3_create2();
  let axesForward = vec3_create2(0, 0, 1);
  let axesUp = vec3_create2(0, 1, 0);
  return function _detectTeleportRotationVR(dt) {
    let axes = getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (axes.vec2_length() > this._myTeleportParams.myDetectionParams.myRotationOnUpMinStickIntensity) {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = this._myTeleportRotationOnUpNext;
      axesVec3.vec3_set(axes[0], 0, axes[1]);
      this._myTeleportRotationOnUpNext = axesVec3.vec3_angleSigned(axesForward, axesUp);
    }
    if (!this._myTeleportParams.myDetectionParams.myRotationOnUpActive) {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
      this._myTeleportRotationOnUpNext = 0;
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportHitValid = function() {
  let raycastSetup = new RaycastSetup();
  let raycastResult2 = new RaycastResults();
  let playerUp = vec3_create2();
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  return function _isTeleportHitValid(hit, rotationOnUp, checkTeleportCollisionRuntimeParams) {
    let isValid = false;
    this._myTeleportAsMovementFailed = false;
    if (hit.isValid() && !hit.myIsInsideCollision) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      if (true) {
        raycastSetup.myPhysics = this._myTeleportParams.myEngine.physics;
        raycastSetup.myIgnoreHitsInsideCollision = true;
        raycastSetup.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportFloorLayerFlags.getMask());
        raycastSetup.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
        for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
          raycastSetup.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
        }
        let distanceToCheck = 0.01;
        raycastSetup.myOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(distanceToCheck, raycastSetup.myOrigin), raycastSetup.myOrigin);
        raycastSetup.myDirection = hit.myNormal.vec3_negate(raycastSetup.myDirection);
        raycastSetup.myDistance = distanceToCheck * 1.25;
        raycastSetup.myDirection.vec3_normalize(raycastSetup.myDirection);
        raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
        if (raycastResult2.isColliding()) {
          let floorHit = raycastResult2.myHits.pp_first();
          if (floorHit.myObject.pp_equals(hit.myObject)) {
            isValid = this._isTeleportPositionValid(hit.myPosition, rotationOnUp, checkTeleportCollisionRuntimeParams);
          }
        }
      }
    }
    return isValid;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionValid = function() {
  let playerUp = vec3_create2();
  let feetTransformQuat = quat2_create();
  let feetRotationQuat = quat_create();
  let feetPosition = vec3_create2();
  let differenceOnUpVector = vec3_create2();
  let teleportCheckCollisionRuntimeParams = new CollisionRuntimeParams();
  return function _isTeleportPositionValid(teleportPosition, rotationOnUp, checkTeleportCollisionRuntimeParams) {
    let isValid = false;
    let positionVisible = this._isTeleportPositionVisible(teleportPosition);
    if (positionVisible) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
      feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
      if (rotationOnUp != 0) {
        feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
        feetRotationQuat = feetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, feetRotationQuat);
        feetTransformQuat.quat2_setPositionRotationQuat(feetPosition, feetRotationQuat);
      }
      let differenceOnUp = teleportPosition.vec3_sub(feetPosition, differenceOnUpVector).vec3_componentAlongAxis(playerUp, differenceOnUpVector).vec3_length();
      if (differenceOnUp < this._myTeleportParams.myDetectionParams.myMaxHeightDifference + 1e-5) {
        let teleportCheckValid = false;
        teleportCheckCollisionRuntimeParams.copy(this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        if (!this._myTeleportParams.myPerformTeleportAsMovement) {
          this._checkTeleport(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        } else {
          this._checkTeleportAsMovement(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        }
        if (!teleportCheckCollisionRuntimeParams.myTeleportCanceled) {
          teleportCheckValid = true;
        }
        if (teleportCheckValid && (!this._myTeleportParams.myDetectionParams.myMustBeOnGround || teleportCheckCollisionRuntimeParams.myIsOnGround)) {
          let groundAngleValid = true;
          let isTeleportingUpward = teleportCheckCollisionRuntimeParams.myNewPosition.vec3_isFartherAlongAxis(feetPosition, playerUp);
          if (isTeleportingUpward) {
            groundAngleValid = teleportCheckCollisionRuntimeParams.myGroundAngle < this._myTeleportParams.myDetectionParams.myGroundAngleToIgnoreUpward + 1e-4;
          }
          if (groundAngleValid) {
            isValid = true;
          }
        }
      }
    }
    return isValid;
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_blink_state.js
import { MeshComponent as MeshComponent10 } from "@wonderlandengine/api";
var PlayerLocomotionTeleportTeleportBlinkState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myBlinkSphere = this._myTeleportParams.myEngine.scene.pp_addObject();
    this._myBlinkSphereMeshComponent = this._myBlinkSphere.pp_addComponent(MeshComponent10);
    this._myBlinkSphereMeshComponent.mesh = getDefaultResources(this._myTeleportParams.myEngine).myMeshes.myInvertedSphere;
    this._myBlinkSphereMeshComponent.material = getDefaultResources(this._myTeleportParams.myEngine).myMaterials.myFlatTransparentNoDepth.clone();
    this._myBlinkSphereMaterialColor = vec4_create2(
      this._myTeleportParams.myTeleportParams.myBlinkSphereColor[0] / 255,
      this._myTeleportParams.myTeleportParams.myBlinkSphereColor[1] / 255,
      this._myTeleportParams.myTeleportParams.myBlinkSphereColor[2] / 255,
      0
    );
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myBlinkSphere.pp_setScaleLocal(this._myTeleportParams.myTeleportParams.myBlinkSphereScale);
    this._myBlinkSphere.pp_setActive(false);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("fade_out", this._fadeOutUpdate.bind(this));
    this._myFSM.addState("wait", new TimerState(this._myTeleportParams.myTeleportParams.myBlinkWaitSeconds, "done"));
    this._myFSM.addState("fade_in", this._fadeInUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "fade_out", "teleport", this._startFadeOut.bind(this));
    this._myFSM.addTransition("fade_out", "wait", "done", this._teleport.bind(this));
    this._myFSM.addTransition("wait", "fade_in", "done", this._startFadeIn.bind(this));
    this._myFSM.addTransition("fade_in", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("fade_out", "idle", "stop", this._stop.bind(this, true));
    this._myFSM.addTransition("wait", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.addTransition("fade_in", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myFadeInTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeInSeconds);
    this._myFadeOutTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeOutSeconds);
    this._myFadeOutAlphaOverTime = new NumberOverValue(0, 1, 0, 1);
    this._myFadeInAlphaOverTime = new NumberOverValue(1, 0, 0, 1);
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myBlinkSphere.pp_setActive(false);
    this._myBlinkSphere.pp_setParent(null, false);
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myBlinkSphere.pp_setParent(this._myTeleportParams.myPlayerHeadManager.getHead(), false);
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myFSM.update(dt);
  }
  _startFadeOut() {
    this._myFadeOutTimer.start();
    this._myBlinkSphereMaterialColor[3] = 0;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_setActive(true);
  }
  _startFadeIn() {
    this._myFadeInTimer.start();
  }
  _fadeOutUpdate(dt, fsm) {
    this._myFadeOutTimer.update(dt);
    let alpha = this._myFadeOutAlphaOverTime.get(this._myFadeOutTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeOutTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _fadeInUpdate(dt, fsm) {
    this._myFadeInTimer.update(dt);
    let alpha = this._myFadeInAlphaOverTime.get(this._myFadeInTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeInTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _teleportDone() {
    this._myBlinkSphere.pp_setActive(false);
    this._myParentFSM.performDelayed("done");
  }
  _stop(teleport) {
    this._myBlinkSphere.pp_setActive(false);
    if (teleport) {
      this._teleport();
    }
  }
  _teleport() {
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_shift_state.js
var PlayerLocomotionTeleportTeleportShiftState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("shifting", this._shiftingUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "shifting", "teleport", this._startShifting.bind(this));
    this._myFSM.addTransition("shifting", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("shifting", "idle", "stop", this._stop.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myShiftMovementTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    this._myShiftRotateTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds, false);
    this._myFeetStartPosition = vec3_create2();
    this._myCurrentRotationOnUp = 0;
    this._myStartRotationOnUp = 0;
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  _startShifting() {
    this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = true;
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
    this._myFeetStartPosition = this._myTeleportParams.myPlayerHeadManager.getPositionFeet(this._myFeetStartPosition);
    this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction) {
      let distance = this._myTeleportRuntimeParams.myTeleportPosition.vec3_distance(this._myFeetStartPosition);
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction(distance);
      this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds * multiplier);
    }
    this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction) {
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction(Math.abs(this._myTeleportRuntimeParams.myTeleportRotationOnUp));
      this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds * multiplier);
    }
    this._myStartRotationOnUp = this._myTeleportRuntimeParams.myTeleportRotationOnUp;
    this._myCurrentRotationOnUp = 0;
  }
  _stop() {
    this._teleport();
  }
  _teleportDone() {
    this._teleport();
    this._myParentFSM.performDelayed("done");
  }
  _teleport() {
    this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = false;
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myStartRotationOnUp - this._myCurrentRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
};
PlayerLocomotionTeleportTeleportShiftState.prototype._shiftingUpdate = function() {
  let movementToTeleportFeet = vec3_create2();
  let newFeetPosition = vec3_create2();
  return function _shiftingUpdate(dt, fsm) {
    this._myShiftMovementTimer.update(dt);
    this._myShiftRotateTimer.update(dt);
    if (this._myShiftRotateTimer.isDone() && this._myShiftMovementTimer.isDone()) {
      fsm.perform("done");
    } else {
      newFeetPosition.vec3_copy(this._myTeleportRuntimeParams.myTeleportPosition);
      if (this._myShiftMovementTimer.isStarted() || this._myShiftMovementTimer.isJustDone()) {
        let interpolationValue = this._myTeleportParams.myTeleportParams.myShiftMovementEasingFunction(this._myShiftMovementTimer.getPercentage());
        if (interpolationValue >= this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage && !this._myShiftRotateTimer.isStarted()) {
          this._myShiftRotateTimer.start();
          this._myShiftRotateTimer.update(dt);
        }
        movementToTeleportFeet = this._myTeleportRuntimeParams.myTeleportPosition.vec3_sub(this._myFeetStartPosition, movementToTeleportFeet);
        movementToTeleportFeet.vec3_scale(interpolationValue, movementToTeleportFeet);
        newFeetPosition = this._myFeetStartPosition.vec3_add(movementToTeleportFeet, newFeetPosition);
      }
      let rotationOnUp = 0;
      if (this._myShiftRotateTimer.isRunning() || this._myShiftRotateTimer.isJustDone()) {
        let interpolationValue = this._myTeleportParams.myTeleportParams.myShiftRotateEasingFunction(this._myShiftRotateTimer.getPercentage());
        let newCurrentRotationOnUp = this._myStartRotationOnUp * interpolationValue;
        rotationOnUp = newCurrentRotationOnUp - this._myCurrentRotationOnUp;
        this._myCurrentRotationOnUp = newCurrentRotationOnUp;
      }
      this._teleportToPosition(newFeetPosition, rotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
    }
  };
}();
Object.defineProperty(PlayerLocomotionTeleportTeleportShiftState.prototype, "_shiftingUpdate", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_state.js
var PlayerLocomotionTeleportTeleportType = {
  INSTANT: 0,
  BLINK: 1,
  SHIFT: 2
};
var PlayerLocomotionTeleportTeleportParams = class {
  constructor() {
    this.myTeleportType = PlayerLocomotionTeleportTeleportType.SHIFT;
    this.myBlinkFadeOutSeconds = 0.1;
    this.myBlinkFadeInSeconds = 0.1;
    this.myBlinkWaitSeconds = 0.1;
    this.myBlinkSphereColor = vec3_create2();
    this.myBlinkSphereScale = 0.1;
    this.myShiftMovementSeconds = 0.15;
    this.myShiftMovementSecondsMultiplierOverDistanceFunction = null;
    this.myShiftMovementEasingFunction = EasingFunction2.easeInOut;
    this.myShiftRotateSeconds = 1;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = null;
    this.myShiftRotateEasingFunction = EasingFunction2.easeOut;
    this.myShiftRotateStartAfterMovementPercentage = 0.7;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = function(angle) {
      return EasingFunction2.easeOut(angle / 180);
    };
  }
};
var PlayerLocomotionTeleportTeleportState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myBlinkState = new PlayerLocomotionTeleportTeleportBlinkState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myShiftState = new PlayerLocomotionTeleportTeleportShiftState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM.addState("instant_teleport", this._instantUpdate.bind(this));
    this._myFSM.addState("blink_teleport", this._myBlinkState);
    this._myFSM.addState("shift_teleport", this._myShiftState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "instant_teleport", "start_instant");
    this._myFSM.addTransition("idle", "blink_teleport", "start_blink");
    this._myFSM.addTransition("idle", "shift_teleport", "start_shift");
    this._myFSM.addTransition("instant_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("shift_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("instant_teleport", "idle", "stop", this._instantStop.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "stop");
    this._myFSM.addTransition("shift_teleport", "idle", "stop");
    this._myFSM.init("init");
    this._myFSM.perform("start");
  }
  start(fsm) {
    this._myParentFSM = fsm;
    switch (this._myTeleportParams.myTeleportParams.myTeleportType) {
      case PlayerLocomotionTeleportTeleportType.INSTANT:
        this._myFSM.perform("start_instant");
        break;
      case PlayerLocomotionTeleportTeleportType.BLINK:
        this._myFSM.perform("start_blink");
        break;
      case PlayerLocomotionTeleportTeleportType.SHIFT:
        this._myFSM.perform("start_shift");
        break;
      default:
        this._myFSM.perform("start_instant");
    }
  }
  end() {
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  completeTeleport() {
    this._myFSM.perform("stop");
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
  _instantUpdate(dt, fsm) {
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    fsm.perform("done");
  }
  _instantStop(fsm) {
    this._instantUpdate(0, fsm);
  }
  _teleportDone() {
    this._myTeleportParams.myPlayerTransformManager.resetReal(true, false, false);
    this._myTeleportParams.myPlayerTransformManager.resetHeadToReal();
    this._myParentFSM.performDelayed("done");
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport.js
var PlayerLocomotionTeleportParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myPlayerHeadManager = null;
    this.myCollisionCheckParams = null;
    this.myDetectionParams = new PlayerLocomotionTeleportDetectionParams();
    this.myVisualizerParams = new PlayerLocomotionTeleportDetectionVisualizerParams();
    this.myTeleportParams = new PlayerLocomotionTeleportTeleportParams();
    this.myHandedness = Handedness.LEFT;
    this.myPerformTeleportAsMovement = false;
    this.myTeleportAsMovementMaxDistanceFromTeleportPosition = 1e-3;
    this.myTeleportAsMovementMaxSteps = 2;
    this.myTeleportAsMovementRemoveVerticalMovement = true;
    this.myTeleportAsMovementExtraVerticalMovementPerMeter = 1;
    this.myStickIdleThreshold = 0.1;
    this.myAdjustPositionEveryFrame = false;
    this.myGravityAcceleration = 0;
    this.myEngine = engine2;
    this.myDebugActive = false;
    this.myDebugDetectActive = false;
    this.myDebugShowActive = false;
    this.myDebugVisibilityActive = false;
  }
};
var PlayerLocomotionTeleportRuntimeParams = class {
  constructor() {
    this.myTeleportPosition = vec3_create2();
    this.myTeleportRotationOnUp = 0;
  }
};
var PlayerLocomotionTeleport2 = class extends PlayerLocomotionMovement {
  constructor(teleportParams, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = new PlayerLocomotionTeleportRuntimeParams();
    this._myStickIdleCharge = true;
    this._myGravitySpeed = 0;
    this._myDetectionState = new PlayerLocomotionTeleportDetectionState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myTeleportState = new PlayerLocomotionTeleportTeleportState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("detect", this._myDetectionState);
    this._myFSM.addState("teleport", this._myTeleportState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "detect", "detect");
    this._myFSM.addTransition("detect", "teleport", "teleport");
    this._myFSM.addTransition("detect", "idle", "cancel");
    this._myFSM.addTransition("teleport", "idle", "done");
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("detect", "idle", "stop");
    this._myFSM.addTransition("teleport", "idle", "stop", this._completeTeleport.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
  }
  start() {
    this._myGravitySpeed = 0;
  }
  stop() {
    this._myFSM.perform("stop");
  }
  canStop() {
    return this._myFSM.isInState("idle");
  }
  update(dt) {
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = false;
    this._myFSM.update(dt);
    if (this._myTeleportParams.myAdjustPositionEveryFrame || this._myTeleportParams.myGravityAcceleration != 0) {
      this._applyGravity(dt);
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
    }
  }
  _idleUpdate(dt) {
    if (this._startDetecting()) {
      this._myFSM.perform("detect");
    }
  }
  _startDetecting() {
    let startDetecting = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      startDetecting = getMouse(this._myTeleportParams.myEngine).isButtonPressStart(MouseButtonID.MIDDLE) && getMouse(this._myTeleportParams.myEngine).isTargetingRenderCanvas();
    } else {
      let axes = getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        this._myStickIdleCharge = true;
      }
      if (this._myStickIdleCharge && axes[1] >= 0.75) {
        this._myStickIdleCharge = false;
        startDetecting = true;
      }
    }
    return startDetecting;
  }
  _completeTeleport() {
    this._myTeleportState.completeTeleport();
  }
};
PlayerLocomotionTeleport2.prototype._applyGravity = function() {
  let playerUp = vec3_create2();
  let gravityMovement = vec3_create2();
  let feetTransformQuat = quat2_create();
  return function _applyGravity(dt) {
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    this._myGravitySpeed += this._myTeleportParams.myGravityAcceleration * dt;
    gravityMovement = playerUp.vec3_scale(this._myGravitySpeed * dt, gravityMovement);
    if (this._myLocomotionRuntimeParams.myIsFlying) {
      gravityMovement.vec3_zero();
    }
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    getCollisionCheck2(this._myTeleportParams.myEngine).move(gravityMovement, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
    if (!this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myVerticalMovementCanceled) {
      this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myNewPosition);
    }
    if (this._myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myGravitySpeed = 0;
    }
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
var PlayerLocomotionDirectionReferenceType = {
  HEAD: 0,
  HAND: 1,
  CUSTOM_OBJECT: 2
};
var PlayerLocomotionParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myMaxSpeed = 0;
    this.myMaxRotationSpeed = 0;
    this.myCharacterRadius = 0;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySnapTurnAngle = 0;
    this.mySnapTurnSpeedDegrees = 0;
    this.myFlyEnabled = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myMainHand = Handedness.LEFT;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myTeleportParableStartReferenceObject = null;
    this.myForeheadExtraHeight = 0;
    this.myTeleportPositionObject = null;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myPhysicsBlockLayerFlags = new PhysicsLayerFlags();
    this.myEngine = engine2;
  }
};
var PlayerLocomotion = class {
  constructor(params) {
    this._myParams = params;
    this._myCollisionCheckParamsMovement = new CollisionCheckParams();
    this._setupCollisionCheckParamsMovement();
    this._myCollisionCheckParamsTeleport = null;
    this._setupCollisionCheckParamsTeleport();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myMovementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
    this._myMovementRuntimeParams.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
    {
      let params2 = new PlayerHeadManagerParams(this._myParams.myEngine);
      params2.mySessionChangeResyncEnabled = true;
      params2.myBlurEndResyncEnabled = true;
      params2.myBlurEndResyncRotation = true;
      params2.myEnterSessionResyncHeight = false;
      params2.myExitSessionResyncHeight = false;
      params2.myExitSessionResyncVerticalAngle = true;
      params2.myExitSessionRemoveRightTilt = true;
      params2.myExitSessionAdjustMaxVerticalAngle = true;
      params2.myExitSessionMaxVerticalAngle = 90;
      params2.myHeightOffsetVRWithFloor = 0;
      params2.myHeightOffsetVRWithoutFloor = 1.75;
      params2.myHeightOffsetNonVR = 1.75;
      params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
      params2.myFeetRotationKeepUp = true;
      params2.myDebugActive = false;
      this._myPlayerHeadManager = new PlayerHeadManager(params2);
    }
    {
      let params2 = new PlayerTransformManagerParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myMovementCollisionCheckParams = this._myCollisionCheckParamsMovement;
      params2.myTeleportCollisionCheckParams = null;
      params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
      params2.myTeleportCollisionCheckParamsCheck360 = true;
      params2.myHeadCollisionBlockLayerFlags.copy(params2.myMovementCollisionCheckParams.myHorizontalBlockLayerFlags);
      params2.myHeadCollisionBlockLayerFlags.add(params2.myMovementCollisionCheckParams.myVerticalBlockLayerFlags);
      params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
      let objectsEqualCallback = (first, second) => first.pp_equals(second);
      for (let objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
        params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      params2.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
      params2.myHeadRadius = 0.15;
      params2.myIsMaxDistanceFromRealToSyncEnabled = true;
      params2.myMaxDistanceFromRealToSync = 100;
      params2.myIsFloatingValidIfVerticalMovement = false;
      params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
      params2.myIsFloatingValidIfSteepGround = false;
      params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
      params2.myIsFloatingValidIfRealOnGround = false;
      params2.myIsLeaningValidAboveDistance = true;
      params2.myLeaningValidDistance = 2;
      params2.myFloatingSplitCheckEnabled = true;
      params2.myFloatingSplitCheckMaxLength = 0.2;
      params2.myFloatingSplitCheckMaxSteps = 5;
      params2.myRealMovementAllowVerticalAdjustments = false;
      params2.myUpdateRealPositionValid = true;
      params2.myUpdatePositionValid = true;
      params2.myIsBodyCollidingWhenHeightBelowValue = null;
      params2.myIsBodyCollidingWhenHeightAboveValue = null;
      params2.myResetToValidOnEnterSession = true;
      params2.myResetToValidOnExitSession = true;
      params2.myAlwaysResetRealPositionNonVR = true;
      params2.myAlwaysResetRealRotationNonVR = true;
      params2.myAlwaysResetRealHeightNonVR = true;
      params2.myAlwaysResetRealPositionVR = false;
      params2.myAlwaysResetRealRotationVR = false;
      params2.myAlwaysResetRealHeightVR = false;
      params2.myNeverResetRealPositionNonVR = false;
      params2.myNeverResetRealRotationNonVR = true;
      params2.myNeverResetRealHeightNonVR = false;
      params2.myNeverResetRealPositionVR = false;
      params2.myNeverResetRealRotationVR = false;
      params2.myNeverResetRealHeightVR = true;
      params2.myResetRealOnMove = true;
      params2.myDebugActive = true;
      this._myPlayerTransformManager = new PlayerTransformManager(params2);
    }
    {
      let params2 = new PlayerObscureManagerParams(this._myParams.myEngine);
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myObscureObject = null;
      params2.myObscureMaterial = null;
      params2.myObscureRadius = 0.1;
      params2.myObscureFadeOutSeconds = 0.25;
      params2.myObscureFadeInSeconds = 0.25;
      params2.myObscureFadeEasingFunction = EasingFunction2.linear;
      params2.myObscureLevelRelativeDistanceEasingFunction = EasingFunction2.linear;
      params2.myDistanceToStartObscureWhenBodyColliding = 0.2;
      params2.myDistanceToStartObscureWhenHeadColliding = 0;
      params2.myDistanceToStartObscureWhenFloating = 1;
      params2.myDistanceToStartObscureWhenFar = 1;
      params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
      params2.myRelativeDistanceToMaxObscureWhenHeadColliding = 0.1;
      params2.myRelativeDistanceToMaxObscureWhenFloating = 5;
      params2.myRelativeDistanceToMaxObscureWhenFar = 5;
      this._myPlayerObscureManager = new PlayerObscureManager(params2);
    }
    {
      let params2 = new PlayerLocomotionRotateParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
      params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
      params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
      params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
      if (this._myParams.mySnapTurnSpeedDegrees > LocomotionUtils.EPSILON) {
        params2.mySmoothSnapActive = true;
        params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
      } else {
        params2.mySmoothSnapActive = false;
      }
      params2.myRotationMinStickIntensityThreshold = 0.1;
      params2.mySnapTurnActivateThreshold = 0.5;
      params2.mySnapTurnResetThreshold = 0.4;
      params2.myClampVerticalAngle = true;
      params2.myMaxVerticalAngle = 90;
      this._myPlayerLocomotionRotate = new PlayerLocomotionRotate2(params2);
      params2.myHandedness = InputUtils.getOppositeHandedness(this._myParams.myMainHand);
    }
    {
      {
        let params2 = new PlayerLocomotionSmoothParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsMovement;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myMaxSpeed = this._myParams.myMaxSpeed;
        params2.myMovementMinStickIntensityThreshold = 0.1;
        params2.myFlyEnabled = this._myParams.myFlyEnabled;
        params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
        params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
        params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
        params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
        params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
        params2.myGravityAcceleration = -20;
        params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
        params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
        params2.myMoveThroughCollisionShortcutEnabled = this._myParams.myMoveThroughCollisionShortcutEnabled;
        params2.myMoveHeadShortcutEnabled = this._myParams.myMoveHeadShortcutEnabled;
        this._myPlayerLocomotionSmooth = new PlayerLocomotionSmooth2(params2, this._myMovementRuntimeParams);
      }
      {
        let params2 = new PlayerLocomotionTeleportParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsTeleport;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myDetectionParams.myMaxDistance = 3;
        params2.myDetectionParams.myMaxHeightDifference = 4;
        params2.myDetectionParams.myGroundAngleToIgnoreUpward = this._myCollisionCheckParamsMovement.myGroundAngleToIgnore;
        params2.myDetectionParams.myMustBeOnGround = true;
        params2.myDetectionParams.myTeleportBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFloorLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
        params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
        params2.myDetectionParams.myVisibilityBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
        params2.myPerformTeleportAsMovement = false;
        params2.myTeleportAsMovementRemoveVerticalMovement = true;
        params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
        params2.myGravityAcceleration = 0;
        params2.myDebugActive = false;
        params2.myDebugDetectActive = true;
        params2.myDebugShowActive = true;
        params2.myDebugVisibilityActive = false;
        this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport2(params2, this._myMovementRuntimeParams);
      }
    }
    this._setupLocomotionMovementFSM();
    this._myIdle = false;
  }
  start() {
    this._fixAlmostUp();
    this._myPlayerHeadManager.start();
    this._myPlayerTransformManager.start();
    this._myPlayerObscureManager.start();
    this._myPlayerLocomotionRotate.start();
    this._myLocomotionMovementFSM.perform("start");
  }
  update(dt) {
    this._myPlayerHeadManager.update(dt);
    this._myPlayerTransformManager.update(dt);
    if (getLeftGamepad(this._myParams.myEngine).getButtonInfo(GamepadButtonID.THUMBSTICK).isPressEnd(2)) {
      if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
        this._myLocomotionMovementFSM.perform("next");
      } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
        this._myLocomotionMovementFSM.perform("next");
      }
    }
    if (this._myPlayerHeadManager.isSynced()) {
      this._updateCollisionHeight();
      if (!this._myIdle) {
        this._myPlayerLocomotionRotate.update(dt);
        this._myLocomotionMovementFSM.update(dt);
      }
    }
    if (getLeftGamepad(this._myParams.myEngine).getButtonInfo(GamepadButtonID.SELECT).isPressEnd(2)) {
      if (this._myPlayerObscureManager.isFading()) {
        this._myPlayerObscureManager.obscureLevelOverride(this._myPlayerObscureManager.isFadingOut() ? Math.pp_random(0, 0) : Math.pp_random(1, 1));
      } else {
        this._myPlayerObscureManager.obscureLevelOverride(this._myPlayerObscureManager.isObscured() ? Math.pp_random(0, 0) : Math.pp_random(1, 1));
      }
    }
  }
  setIdle(idle) {
    this._myIdle = idle;
    if (idle) {
      this._myLocomotionMovementFSM.perform("idle");
    } else {
      this._myLocomotionMovementFSM.perform("start");
    }
  }
  _updateCollisionHeight() {
    this._myCollisionCheckParamsMovement.myHeight = this._myPlayerHeadManager.getHeightHead();
    if (this._myCollisionCheckParamsMovement.myHeight <= 1e-6) {
      this._myCollisionCheckParamsMovement.myHeight = 0;
    }
    this._myCollisionCheckParamsTeleport.myHeight = this._myCollisionCheckParamsMovement.myHeight;
  }
  _setupCollisionCheckParamsMovement() {
    this._myCollisionCheckParamsMovement.mySplitMovementEnabled = false;
    this._myCollisionCheckParamsMovement.mySplitMovementMaxLength = 0;
    this._myCollisionCheckParamsMovement.myRadius = this._myParams.myCharacterRadius;
    this._myCollisionCheckParamsMovement.myDistanceFromFeetToIgnore = 0.1;
    this._myCollisionCheckParamsMovement.myDistanceFromHeadToIgnore = 0.1;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckEnabled = true;
    this._myCollisionCheckParamsMovement.myHorizontalMovementStepEnabled = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementStepMaxLength = 0;
    this._myCollisionCheckParamsMovement.myHorizontalMovementRadialStepAmount = 1;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckDiagonalOutward = true;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckDiagonalInward = true;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckStraight = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckHorizontalBorder = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalStraight = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
    this._myCollisionCheckParamsMovement.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
    this._myCollisionCheckParamsMovement.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
    this._myCollisionCheckParamsMovement.myHorizontalPositionCheckEnabled = true;
    this._myCollisionCheckParamsMovement.myHalfConeAngle = 60;
    this._myCollisionCheckParamsMovement.myHalfConeSliceAmount = 2;
    this._myCollisionCheckParamsMovement.myCheckConeBorder = true;
    this._myCollisionCheckParamsMovement.myCheckConeRay = true;
    this._myCollisionCheckParamsMovement.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
    this._myCollisionCheckParamsMovement.myHorizontalPositionCheckVerticalDirectionType = 2;
    this._myCollisionCheckParamsMovement.myVerticalMovementCheckEnabled = true;
    this._myCollisionCheckParamsMovement.myVerticalPositionCheckEnabled = true;
    this._myCollisionCheckParamsMovement.myVerticalMovementReduceEnabled = true;
    this._myCollisionCheckParamsMovement.myFeetRadius = 0.1;
    this._myCollisionCheckParamsMovement.myAdjustVerticalMovementWithGroundAngleDownhill = true;
    this._myCollisionCheckParamsMovement.myAdjustVerticalMovementWithGroundAngleUphill = true;
    this._myCollisionCheckParamsMovement.myAdjustVerticalMovementWithCeilingAngleUphill = true;
    this._myCollisionCheckParamsMovement.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
    this._myCollisionCheckParamsMovement.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
    this._myCollisionCheckParamsMovement.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = 30;
    this._myCollisionCheckParamsMovement.mySnapOnGroundEnabled = true;
    this._myCollisionCheckParamsMovement.mySnapOnGroundExtraDistance = 0.1;
    this._myCollisionCheckParamsMovement.mySnapOnCeilingEnabled = false;
    this._myCollisionCheckParamsMovement.mySnapOnCeilingExtraDistance = 0.1;
    this._myCollisionCheckParamsMovement.myGroundPopOutEnabled = true;
    this._myCollisionCheckParamsMovement.myGroundPopOutExtraDistance = 0.1;
    this._myCollisionCheckParamsMovement.myCeilingPopOutEnabled = true;
    this._myCollisionCheckParamsMovement.myCeilingPopOutExtraDistance = 0.1;
    this._myCollisionCheckParamsMovement.myGroundCircumferenceAddCenter = true;
    this._myCollisionCheckParamsMovement.myGroundCircumferenceSliceAmount = 8;
    this._myCollisionCheckParamsMovement.myGroundCircumferenceStepAmount = 2;
    this._myCollisionCheckParamsMovement.myGroundCircumferenceRotationPerStep = 22.5;
    this._myCollisionCheckParamsMovement.myVerticalAllowHitInsideCollisionIfOneOk = true;
    this._myCollisionCheckParamsMovement.myCheckHeight = true;
    this._myCollisionCheckParamsMovement.myCheckHeightVerticalMovement = true;
    this._myCollisionCheckParamsMovement.myCheckHeightVerticalPosition = true;
    this._myCollisionCheckParamsMovement.myCheckHeightTopMovement = true;
    this._myCollisionCheckParamsMovement.myCheckHeightTopPosition = true;
    this._myCollisionCheckParamsMovement.myCheckHeightConeOnCollision = true;
    this._myCollisionCheckParamsMovement.myCheckHeightConeOnCollisionKeepHit = false;
    this._myCollisionCheckParamsMovement.myHeightCheckStepAmountMovement = 2;
    this._myCollisionCheckParamsMovement.myHeightCheckStepAmountPosition = 2;
    this._myCollisionCheckParamsMovement.myCheckVerticalFixedForwardEnabled = true;
    this._myCollisionCheckParamsMovement.myCheckVerticalFixedForward = vec3_create(0, 0, 1);
    this._myCollisionCheckParamsMovement.myCheckVerticalBothDirection = true;
    this._myCollisionCheckParamsMovement.myCheckVerticalStraight = true;
    this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalRayOutward = false;
    this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalRayInward = false;
    this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderOutward = false;
    this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderInward = false;
    this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderRayOutward = false;
    this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderRayInward = false;
    this._myCollisionCheckParamsMovement.myCheckVerticalSearchFartherVerticalHit = false;
    this._myCollisionCheckParamsMovement.myGroundAngleToIgnore = 30;
    this._myCollisionCheckParamsMovement.myCeilingAngleToIgnore = 30;
    this._myCollisionCheckParamsMovement.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = 0.1;
    this._myCollisionCheckParamsMovement.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = 0.1;
    this._myCollisionCheckParamsMovement.myHeight = 1;
    this._myCollisionCheckParamsMovement.myComputeGroundInfoEnabled = true;
    this._myCollisionCheckParamsMovement.myComputeCeilingInfoEnabled = true;
    this._myCollisionCheckParamsMovement.myDistanceToBeOnGround = 1e-3;
    this._myCollisionCheckParamsMovement.myDistanceToComputeGroundInfo = 0.1;
    this._myCollisionCheckParamsMovement.myDistanceToBeOnCeiling = 1e-3;
    this._myCollisionCheckParamsMovement.myDistanceToComputeCeilingInfo = 0.1;
    this._myCollisionCheckParamsMovement.myVerticalFixToBeOnGround = 0;
    this._myCollisionCheckParamsMovement.myVerticalFixToComputeGroundInfo = 0;
    this._myCollisionCheckParamsMovement.myVerticalFixToBeOnCeiling = 0;
    this._myCollisionCheckParamsMovement.myVerticalFixToComputeCeilingInfo = 0;
    this._myCollisionCheckParamsMovement.myMustStayOnGround = false;
    this._myCollisionCheckParamsMovement.myMustStayOnCeiling = false;
    this._myCollisionCheckParamsMovement.myRegatherGroundInfoOnSurfaceCheckFail = true;
    this._myCollisionCheckParamsMovement.myRegatherCeilingInfoOnSurfaceCheckFail = true;
    this._myCollisionCheckParamsMovement.mySlidingEnabled = true;
    this._myCollisionCheckParamsMovement.mySlidingHorizontalMovementCheckBetterNormal = true;
    this._myCollisionCheckParamsMovement.mySlidingMaxAttempts = 4;
    this._myCollisionCheckParamsMovement.mySlidingCheckBothDirections = true;
    this._myCollisionCheckParamsMovement.mySlidingFlickeringPreventionType = 1;
    this._myCollisionCheckParamsMovement.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = true;
    this._myCollisionCheckParamsMovement.mySlidingFlickerPreventionCheckAnywayCounter = 4;
    this._myCollisionCheckParamsMovement.mySlidingAdjustSign90Degrees = true;
    this._myCollisionCheckParamsMovement.myHorizontalBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
    let physXComponents = getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getComponents(PhysXComponent7);
    for (let physXComponent of physXComponents) {
      this._myCollisionCheckParamsMovement.myHorizontalObjectsToIgnore.pp_pushUnique(physXComponent.object, (first, second) => first.pp_equals(second));
    }
    this._myCollisionCheckParamsMovement.myVerticalBlockLayerFlags.copy(this._myCollisionCheckParamsMovement.myHorizontalBlockLayerFlags);
    this._myCollisionCheckParamsMovement.myVerticalObjectsToIgnore.pp_copy(this._myCollisionCheckParamsMovement.myHorizontalObjectsToIgnore);
    this._myCollisionCheckParamsMovement.myDebugActive = false;
    this._myCollisionCheckParamsMovement.myDebugHorizontalMovementActive = false;
    this._myCollisionCheckParamsMovement.myDebugHorizontalPositionActive = true;
    this._myCollisionCheckParamsMovement.myDebugVerticalMovementActive = false;
    this._myCollisionCheckParamsMovement.myDebugVerticalPositionActive = false;
    this._myCollisionCheckParamsMovement.myDebugSlidingActive = false;
    this._myCollisionCheckParamsMovement.myDebugGroundInfoActive = false;
    this._myCollisionCheckParamsMovement.myDebugCeilingInfoActive = false;
    this._myCollisionCheckParamsMovement.myDebugRuntimeParamsActive = false;
    this._myCollisionCheckParamsMovement.myDebugMovementActive = false;
  }
  _setupCollisionCheckParamsTeleport() {
    this._myCollisionCheckParamsTeleport = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myCollisionCheckParamsMovement);
    this._myCollisionCheckParamsTeleport.myGroundAngleToIgnore = 60;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnIgnorableGroundAngle = true;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnGround = true;
  }
  _fixAlmostUp() {
    let defaultUp = vec3_create(0, 1, 0);
    let angleWithDefaultUp = getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp().vec3_angle(defaultUp);
    if (angleWithDefaultUp < 1) {
      let forward = getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward();
      let flatForward = forward.vec3_clone();
      flatForward[1] = 0;
      let defaultForward = vec3_create(0, 0, 1);
      let angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
      getPlayerObjects(this._myParams.myEngine).myPlayer.pp_resetRotation();
      getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
    }
  }
  _setupLocomotionMovementFSM() {
    this._myLocomotionMovementFSM = new FSM();
    this._myLocomotionMovementFSM.addState("init");
    this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
    this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
    this._myLocomotionMovementFSM.addState("idleSmooth");
    this._myLocomotionMovementFSM.addState("idleTeleport");
    this._myLocomotionMovementFSM.addTransition("init", "smooth", "start", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "next", function() {
      this._myPlayerLocomotionSmooth.stop();
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "next", function() {
      this._myPlayerLocomotionTeleport.stop();
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
      this._myPlayerLocomotionSmooth.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
      this._myPlayerLocomotionTeleport.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "start", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "start", function() {
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.init("init");
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_smooth.js
var PlayerLocomotionSmoothParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myPlayerHeadManager = null;
    this.myPlayerTransformManager = null;
    this.myCollisionCheckParams = null;
    this.myMaxSpeed = 0;
    this.myMovementMinStickIntensityThreshold = 0;
    this.myFlyEnabled = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myGravityAcceleration = 0;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myHandedness = Handedness.LEFT;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myEngine = engine2;
  }
};
var PlayerLocomotionSmooth2 = class extends PlayerLocomotionMovement {
  constructor(params, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myParams = params;
    this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHead;
    this._myStickIdleTimer = new Timer(0.25, false);
    let directionConverterNonVRParams = new Direction2DTo3DConverterParams();
    directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
    directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
    directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
    directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
    directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    let directionConverterVRParams = new Direction2DTo3DConverterParams();
    directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
    directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
    directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
    directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
    directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    this._myDirectionConverterNonVR = new Direction2DTo3DConverter(directionConverterNonVRParams);
    this._myDirectionConverterVR = new Direction2DTo3DConverter(directionConverterVRParams);
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myLocomotionRuntimeParams.myIsFlying = false;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  update(dt) {
  }
};
PlayerLocomotionSmooth2.prototype.update = function() {
  let playerUp = vec3_create2();
  let headMovement = vec3_create2();
  let direction = vec3_create2();
  let directionOnUp = vec3_create2();
  let verticalMovement = vec3_create2();
  let feetTransformQuat = quat2_create();
  let directionReferenceTransformQuat = quat2_create();
  return function update(dt) {
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headMovement.vec3_zero();
    let axes = getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
    axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
    if (!axes.vec2_isZero()) {
      this._myStickIdleTimer.start();
      direction = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction);
      if (!direction.vec3_isZero()) {
        this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          direction = direction.vec3_removeComponentAlongAxis(playerUp, direction);
        }
        let movementIntensity = axes.vec2_length();
        if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SELECT).isPressed()) {
          movementIntensity = 0.1;
        }
        let speed = Math.pp_lerp(0, this._myParams.myMaxSpeed, movementIntensity);
        if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsSliding) {
          speed = speed / 2;
        }
        headMovement = direction.vec3_scale(speed * dt, headMovement);
      }
    } else {
      if (this._myStickIdleTimer.isRunning()) {
        this._myStickIdleTimer.update(dt);
        if (this._myStickIdleTimer.isDone()) {
          this._myCurrentDirectionConverter.resetFly();
        }
      }
    }
    if (!getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SQUEEZE).isPressed()) {
      if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(this._myParams.myMaxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
      } else if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(-this._myParams.myMaxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
      }
    }
    if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
    }
    if (getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
      if (!getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
        if (!this._myLocomotionRuntimeParams.myIsFlying && false) {
          let gravity = -2;
          verticalMovement = playerUp.vec3_scale(gravity * dt, verticalMovement);
          headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        }
        if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SQUEEZE).isPressed()) {
          headMovement.vec3_zero();
        }
        feetTransformQuat = this._myParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
        getCollisionCheck2(this._myParams.myEngine).move(headMovement, feetTransformQuat, this._myParams.myCollisionCheckParams, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        headMovement.vec3_copy(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myFixedMovement);
      }
      if (!headMovement.vec3_isZero(1e-6)) {
        this._myParams.myPlayerHeadManager.moveFeet(headMovement);
      }
    } else {
      if (!getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          let gravity = -2;
          verticalMovement = playerUp.vec3_scale(gravity * dt, verticalMovement);
          headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        }
        if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SQUEEZE).isPressed()) {
          headMovement.vec3_zero();
        }
        feetTransformQuat = this._myParams.myPlayerTransformManager.getTransformQuat(feetTransformQuat);
        this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
      } else {
        this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
      }
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
      this._myCurrentDirectionConverter.resetFly();
    }
  };
}();
PlayerLocomotionSmooth2.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(session) {
    switch (this._myParams.myVRDirectionReferenceType) {
      case 0:
        this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHead;
        break;
      case 1:
        this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHands[this._myParams.myHandedness];
        break;
      case 2:
        this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
        break;
    }
    this._myCurrentDirectionConverter = this._myDirectionConverterVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
PlayerLocomotionSmooth2.prototype._onXRSessionEnd = function() {
  let playerUp = vec3_create2();
  return function _onXRSessionEnd(session) {
    this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHead;
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
Object.defineProperty(PlayerLocomotionSmooth2.prototype, "_onXRSessionStart", { enumerable: false });
Object.defineProperty(PlayerLocomotionSmooth2.prototype, "_onXRSessionEnd", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/cleaned/player_locomotion_smooth_cleaned.js
var CleanedPlayerLocomotionSmooth = class extends PlayerLocomotionMovement {
  constructor(params, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myParams = params;
    this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHead;
    this._myStickIdleTimer = new Timer(0.25, false);
    let directionConverterNonVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
    directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
    directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
    directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
    directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    let directionConverterVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
    directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
    directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
    directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
    directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    this._myDirectionConverterNonVR = new Direction2DTo3DConverter(directionConverterNonVRParams);
    this._myDirectionConverterVR = new Direction2DTo3DConverter(directionConverterVRParams);
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myLocomotionRuntimeParams.myIsFlying = false;
    this._myGravitySpeed = 0;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  update(dt) {
  }
};
CleanedPlayerLocomotionSmooth.prototype.update = function() {
  let playerUp = vec3_create2();
  let headMovement = vec3_create2();
  let direction = vec3_create2();
  let directionOnUp = vec3_create2();
  let verticalMovement = vec3_create2();
  let feetTransformQuat = quat2_create();
  let directionReferenceTransformQuat = quat2_create();
  return function update(dt) {
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headMovement.vec3_zero();
    let axes = getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
    axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
    let horizontalMovement = false;
    if (!axes.vec2_isZero()) {
      this._myStickIdleTimer.start();
      direction = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction);
      if (!direction.vec3_isZero()) {
        this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          direction = direction.vec3_removeComponentAlongAxis(playerUp, direction);
        }
        let movementIntensity = axes.vec2_length();
        let speed = Math.pp_lerp(0, this._myParams.myMaxSpeed, movementIntensity);
        headMovement = direction.vec3_scale(speed * dt, headMovement);
        horizontalMovement = true;
      }
    } else {
      if (this._myStickIdleTimer.isRunning()) {
        this._myStickIdleTimer.update(dt);
        if (this._myStickIdleTimer.isDone()) {
          this._myCurrentDirectionConverter.resetFly();
        }
      }
    }
    if (this._myParams.myFlyEnabled) {
      if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(this._myParams.myMaxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
      } else if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(-this._myParams.myMaxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
      }
      if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
        this._myLocomotionRuntimeParams.myIsFlying = false;
      }
    }
    if (this._myParams.myMoveHeadShortcutEnabled && getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
      this._myParams.myPlayerTransformManager.getPlayerHeadManager().moveFeet(headMovement);
    } else if (this._myParams.myMoveThroughCollisionShortcutEnabled && getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
      this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
      if (horizontalMovement) {
        this._myParams.myPlayerTransformManager.resetReal(true, false, false);
        this._myParams.myPlayerTransformManager.resetHeadToReal();
      }
    } else {
      if (!this._myLocomotionRuntimeParams.myIsFlying) {
        this._myGravitySpeed += this._myParams.myGravityAcceleration * dt;
        verticalMovement = playerUp.vec3_scale(this._myGravitySpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
      }
      if (getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SQUEEZE).isPressed()) {
      }
      feetTransformQuat = this._myParams.myPlayerTransformManager.getTransformQuat(feetTransformQuat);
      this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
      if (horizontalMovement) {
        this._myParams.myPlayerTransformManager.resetReal(true, false, false);
        this._myParams.myPlayerTransformManager.resetHeadToReal();
      }
      if (this._myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
        this._myGravitySpeed = 0;
      }
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
      this._myCurrentDirectionConverter.resetFly();
    }
  };
}();
CleanedPlayerLocomotionSmooth.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(session) {
    switch (this._myParams.myVRDirectionReferenceType) {
      case 0:
        this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHead;
        break;
      case 1:
        this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHands[this._myParams.myHandedness];
        break;
      case 2:
        this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
        break;
    }
    this._myCurrentDirectionConverter = this._myDirectionConverterVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
CleanedPlayerLocomotionSmooth.prototype._onXRSessionEnd = function() {
  let playerUp = vec3_create2();
  return function _onXRSessionEnd(session) {
    this._myDirectionReference = getPlayerObjects2(this._myParams.myEngine).myHead;
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
Object.defineProperty(CleanedPlayerLocomotionSmooth.prototype, "_onXRSessionStart", { enumerable: false });
Object.defineProperty(CleanedPlayerLocomotionSmooth.prototype, "_onXRSessionEnd", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/cleaned/player_transform_manager_cleaned.js
var CleanedPlayerTransformManager = class {
  constructor(params) {
    this._myParams = params;
    this._myRealMovementCollisionCheckParams = null;
    this._generateRealMovementParamsFromMovementParams();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myRealCollisionRuntimeParams = new CollisionRuntimeParams();
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._myHeadCollisionCheckParams = null;
    this._setupHeadCollisionCheckParams();
    this._myValidPosition = vec3_create2();
    this._myValidRotationQuat = quat_create();
    this._myValidHeight = 0;
    this._myValidPositionHead = vec3_create2();
    this._myIsBodyColliding = false;
    this._myIsHeadColliding = false;
    this._myIsLeaning = false;
    this._myIsHopping = false;
    this._myIsFar = false;
    this._myLastValidMovementDirection = vec3_create2();
    this._myIsRealPositionValid = false;
    this._myIsPositionValid = false;
    this._myResetRealOnSynced = false;
    this._myActive = true;
  }
  start() {
    this.resetToReal(true);
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  setActive(active) {
    this._myActive = active;
  }
  update(dt) {
  }
  move(movement, outCollisionRuntimeParams = null, forceMove = false) {
  }
  teleportPosition(position, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  teleportTransformQuat(transformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  rotateQuat(rotationQuat) {
  }
  setRotationQuat(rotationQuat) {
  }
  setHeight(height, forceSet = false) {
  }
  getPlayer() {
    return this._myParams.myPlayerHeadManager.getPlayer();
  }
  getHead() {
    return this._myParams.myPlayerHeadManager.getHead();
  }
  getTransformQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(this._myValidPosition), this.getRotationQuat(this._myValidRotationQuat));
  }
  getPosition(outPosition = vec3_create2()) {
    return outPosition.vec3_copy(this._myValidPosition);
  }
  getRotationQuat(outRotation = quat_create()) {
    return outRotation.quat_copy(this._myValidRotationQuat);
  }
  getPositionHead(outPosition = vec3_create2()) {
    return outPosition.vec3_copy(this._myValidPositionHead);
  }
  getTransformHeadQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(this._myValidPositionHead), this.getRotationQuat(this._myValidRotationQuat));
  }
  getHeight() {
    return this._myValidHeight;
  }
  getTransformRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
  }
  getTransformHeadRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
  }
  getPositionReal(outPosition = vec3_create2()) {
    return this.getPlayerHeadManager().getPositionFeet(outPosition);
  }
  getPositionHeadReal(outPosition = vec3_create2()) {
    return this.getPlayerHeadManager().getPositionHead(outPosition);
  }
  getRotationRealQuat(outRotation = quat_create()) {
    return this.getPlayerHeadManager().getRotationFeetQuat(outRotation);
  }
  getHeightReal() {
    return this._myParams.myPlayerHeadManager.getHeightHead();
  }
  isSynced(syncFlagMap = null) {
    let isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
    let isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
    let isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
    let isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
    return !isBodyColliding && !isHeadColliding && !isFar && !isFloating;
  }
  resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
  }
  updateReal() {
    this._updateReal(0, false);
  }
  resetToReal(updateRealFlags = false) {
    this._myValidPosition = this.getPositionReal(this._myValidPosition);
    this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
    this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
    this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    if (updateRealFlags) {
      this._updateReal(0, false);
    }
  }
  resetHeadToReal() {
    this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
  }
  isBodyColliding() {
    return this._myIsBodyColliding;
  }
  isHeadColliding() {
    return this._myIsHeadColliding;
  }
  isFloating() {
    return this.isLeaning() || this.isHopping();
  }
  isHopping() {
    return this._myIsHopping;
  }
  isLeaning() {
    return this._myIsLeaning;
  }
  isHopping() {
    return this._myIsHopping;
  }
  isFar() {
    return this._myIsFar;
  }
  getDistanceToReal() {
  }
  getDistanceToRealHead() {
  }
  getPlayerHeadManager() {
    return this._myParams.myPlayerHeadManager;
  }
  getParams() {
    return this._myParams;
  }
  getMovementCollisionCheckParams() {
    return this._myParams.myMovementCollisionCheckParams;
  }
  getTeleportCollisionCheckParams() {
    return this._myParams.myTeleportCollisionCheckParams;
  }
  collisionCheckParamsUpdated() {
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._generateRealMovementParamsFromMovementParams();
  }
  isPositionValid() {
    return this._myIsPositionValid;
  }
  isRealPositionValid() {
    return this._myIsRealPositionValid;
  }
  getCollisionRuntimeParams() {
    return this._myCollisionRuntimeParams;
  }
  getRealCollisionRuntimeParams() {
    return this._myRealCollisionRuntimeParams;
  }
  _updateCollisionHeight() {
    let validHeight = this.getHeight();
    let realHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    this._myParams.myMovementCollisionCheckParams.myHeight = validHeight;
    this._myParams.myTeleportCollisionCheckParams.myHeight = validHeight;
    this._myRealMovementCollisionCheckParams.myHeight = realHeight;
  }
  _setupHeadCollisionCheckParams() {
    this._myHeadCollisionCheckParams = new CollisionCheckParams();
    let params = this._myHeadCollisionCheckParams;
    params.myRadius = this._myParams.myHeadRadius;
    params.myDistanceFromFeetToIgnore = 0;
    params.myDistanceFromHeadToIgnore = 0;
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLength = 0.5;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 2;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.myHorizontalMovementCheckEnabled = true;
    params.myHorizontalMovementRadialStepAmount = 1;
    params.myHorizontalMovementCheckDiagonalOutward = true;
    params.myHorizontalMovementCheckDiagonalInward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
    params.myHorizontalPositionCheckEnabled = true;
    params.myHalfConeAngle = 180;
    params.myHalfConeSliceAmount = 3;
    params.myCheckConeBorder = true;
    params.myCheckConeRay = true;
    params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
    params.myHorizontalPositionCheckVerticalDirectionType = 0;
    params.myHeight = params.myRadius;
    params.myPositionOffsetLocal.vec3_set(0, -params.myRadius / 2, 0);
    params.myCheckHeight = true;
    params.myCheckHeightVerticalMovement = true;
    params.myCheckHeightVerticalPosition = true;
    params.myHeightCheckStepAmountMovement = 2;
    params.myHeightCheckStepAmountPosition = 2;
    params.myCheckHeightTopMovement = true;
    params.myCheckHeightTopPosition = true;
    params.myCheckVerticalStraight = true;
    params.myCheckVerticalFixedForwardEnabled = true;
    params.myCheckVerticalFixedForward = vec3_create2(0, 0, 1);
    params.myCheckHorizontalFixedForwardEnabled = true;
    params.myCheckHorizontalFixedForward = vec3_create2(0, 0, 1);
    params.myVerticalMovementCheckEnabled = true;
    params.myVerticalPositionCheckEnabled = true;
    params.myGroundCircumferenceAddCenter = true;
    params.myGroundCircumferenceSliceAmount = 6;
    params.myGroundCircumferenceStepAmount = 2;
    params.myGroundCircumferenceRotationPerStep = 30;
    params.myFeetRadius = params.myRadius;
    params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myDebugActive = false;
    params.myDebugHorizontalMovementActive = true;
    params.myDebugHorizontalPositionActive = false;
    params.myDebugVerticalMovementActive = false;
    params.myDebugVerticalPositionActive = false;
    params.myDebugSlidingActive = false;
    params.myDebugGroundInfoActive = false;
    params.myDebugCeilingInfoActive = false;
    params.myDebugRuntimeParamsActive = false;
    params.myDebugMovementActive = false;
  }
  _generateTeleportParamsFromMovementParams() {
    if (this._myParams.myTeleportCollisionCheckParams == null) {
      this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
    }
    if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
      this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
    } else {
      this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
    }
  }
  _generateRealMovementParamsFromMovementParams() {
    if (this._myRealMovementCollisionCheckParams == null) {
      this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
    }
    let params = this._myRealMovementCollisionCheckParams;
    params.copy(this._myParams.myMovementCollisionCheckParams);
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLength = 0.5;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 2;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.mySlidingEnabled = false;
    if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
      params.mySnapOnGroundEnabled = false;
      params.mySnapOnCeilingEnabled = false;
      params.myGroundPopOutEnabled = false;
      params.myCeilingPopOutEnabled = false;
      params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
      params.myAdjustVerticalMovementWithGroundAngleUphill = false;
      params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
      params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
      params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
      params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
      params.myVerticalMovementReduceEnabled = false;
    }
    params.myIsOnGroundIfInsideHit = true;
    params.myDebugActive = false;
    params.myDebugHorizontalMovementActive = false;
    params.myDebugHorizontalPositionActive = false;
    params.myDebugVerticalMovementActive = false;
    params.myDebugVerticalPositionActive = false;
    params.myDebugSlidingActive = false;
    params.myDebugGroundInfoActive = true;
    params.myDebugCeilingInfoActive = true;
    params.myDebugRuntimeParamsActive = false;
    params.myDebugMovementActive = false;
  }
  _onXRSessionStart(manualCall, session) {
    if (this._myActive) {
      if (this._myParams.myResetToValidOnEnterSession && !manualCall) {
        this._myResetRealOnSynced = true;
      }
    }
  }
  _onXRSessionEnd() {
    if (this._myActive) {
      if (this._myParams.myResetToValidOnExitSession) {
        this._myResetRealOnSynced = true;
      }
    }
  }
  _debugUpdate(dt) {
    getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPosition, vec4_create2(1, 0, 0, 1), 0.05);
    getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this._myValidPosition, this.getPositionReal(), vec4_create2(1, 0, 0, 1), 0.05);
    getDebugVisualManager(this._myParams.myEngine).drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, vec4_create2(0, 1, 0, 1), 0.025);
    getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPositionHead, vec4_create2(1, 1, 0, 1), 0.05);
  }
};
CleanedPlayerTransformManager.prototype.getDistanceToReal = function() {
  let realPosition = vec3_create2();
  return function getDistanceToReal() {
    realPosition = this.getPositionReal(realPosition);
    return realPosition.vec3_distance(this.getPosition());
  };
}();
CleanedPlayerTransformManager.prototype.getDistanceToRealHead = function() {
  let realPosition = vec3_create2();
  return function getDistanceToRealHead() {
    realPosition = this.getPositionHeadReal(realPosition);
    return realPosition.vec3_distance(this.getPositionHead());
  };
}();
CleanedPlayerTransformManager.prototype.resetReal = function() {
  let realUp = vec3_create2();
  let validUp = vec3_create2();
  let position = vec3_create2();
  let rotationQuat = quat_create();
  return function resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
    let playerHeadManager = this.getPlayerHeadManager();
    if (resetPosition) {
      playerHeadManager.teleportPositionFeet(this.getPosition(position));
    }
    realUp = this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
    validUp = this.getRotationQuat(rotationQuat).quat_getUp(validUp);
    if (resetRotation || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
      playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
    }
    if (resetHeight) {
      playerHeadManager.setHeight(this.getHeight(), true);
    }
    if (updateRealFlags) {
      this._updateReal(0, false);
    }
  };
}();
CleanedPlayerTransformManager.prototype.update = function() {
  let transformQuat = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let transformUp = vec3_create2();
  let horizontalDirection = vec3_create2();
  let rotationQuat = quat_create();
  return function update(dt) {
    this._updateReal(dt);
    if (this._myResetRealOnSynced) {
      if (this.getPlayerHeadManager().isSynced()) {
        this._myResetRealOnSynced = false;
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            false
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            false
          );
        }
      }
    }
    if (this._myParams.myUpdatePositionValid) {
      transformQuat = this.getTransformQuat(transformQuat);
      transformUp = transformQuat.quat2_getUp(transformUp);
      rotationQuat = transformQuat.quat2_getRotationQuat(rotationQuat);
      horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setForward(horizontalDirection);
        transformQuat.quat2_setRotationQuat(rotationQuat);
      }
      let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
      this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
      getCollisionCheck2(this._myParams.myEngine).positionCheck(true, transformQuat, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
      this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
      this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
    }
    if (this._myParams.myDebugActive) {
      this._debugUpdate(dt);
    }
  };
}();
CleanedPlayerTransformManager.prototype._updateReal = function() {
  let movementToCheck = vec3_create2();
  let position = vec3_create2();
  let positionReal = vec3_create2();
  let transformQuat = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let newPosition = vec3_create2();
  let newPositionHead = vec3_create2();
  let movementStep = vec3_create2();
  let currentMovementStep = vec3_create2();
  let transformUp = vec3_create2();
  let verticalMovement = vec3_create2();
  let movementChecked = vec3_create2();
  let newFeetPosition = vec3_create2();
  let floatingTransformQuat = quat2_create();
  let horizontalDirection = vec3_create2();
  let rotationQuat = quat_create();
  return function _updateReal(dt, resetRealEnabled = true) {
    if (this.getPlayerHeadManager().isSynced()) {
      this._updateCollisionHeight();
      this._myIsBodyColliding = false;
      this._myIsHeadColliding = false;
      this._myIsLeaning = false;
      this._myIsHopping = false;
      this._myIsFar = false;
      movementToCheck = this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
      if (movementToCheck.vec3_length() > 1e-4) {
        this._myLastValidMovementDirection = movementToCheck.vec3_normalize(this._myLastValidMovementDirection);
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
        if (this._myParams.myIsMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
          this._myIsFar = true;
        } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
          this._myIsFar = true;
        }
      }
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      collisionRuntimeParams.myIsOnGround = true;
      transformQuat = this.getTransformQuat(transformQuat);
      newPosition.vec3_copy(this._myValidPosition);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
        getCollisionCheck2(this._myParams.myEngine).move(movementToCheck, transformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          if (Math.pp_clamp(
            this._myRealMovementCollisionCheckParams.myHeight,
            this._myParams.myIsBodyCollidingWhenHeightBelowValue,
            this._myParams.myIsBodyCollidingWhenHeightAboveValue
          ) != this._myRealMovementCollisionCheckParams.myHeight) {
            this._myIsBodyColliding = true;
          } else {
            if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
              this._myIsBodyColliding = true;
            } else {
              this._myIsBodyColliding = false;
              newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
            }
          }
        } else {
          this._myIsBodyColliding = true;
        }
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
        if (!this._myIsBodyColliding) {
          movementToCheck = newPosition.vec3_sub(position, movementToCheck);
        } else {
          movementToCheck = positionReal.vec3_sub(position, movementToCheck);
        }
        collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
        floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
        getCollisionCheck2(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (collisionRuntimeParams.myIsOnGround) {
          transformUp = transformQuat.quat2_getUp(transformUp);
          verticalMovement = movementToCheck.vec3_componentAlongAxis(transformUp, verticalMovement);
          let isVertical = !verticalMovement.vec3_isZero(1e-5);
          if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
            let movementStepAmount = 1;
            movementStep.vec3_copy(movementToCheck);
            if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
              let equalStepLength = movementToCheck.vec3_length() / this._myParams.myFloatingSplitCheckMaxSteps;
              if (!this._myParams.myFloatingSplitCheckStepEqualLength || equalStepLength < this._myParams.myFloatingSplitCheckStepEqualLengthMinLength) {
                let maxLength = this._myParams.myFloatingSplitCheckStepEqualLength ? this._myParams.myFloatingSplitCheckStepEqualLengthMinLength : this._myParams.myFloatingSplitCheckMaxLength;
                movementStepAmount = Math.ceil(movementToCheck.vec3_length() / maxLength);
                if (movementStepAmount > 1) {
                  movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
                  movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps != null ? Math.min(movementStepAmount, this._myParams.myFloatingSplitCheckMaxSteps) : movementStepAmount;
                }
                movementStepAmount = Math.max(1, movementStepAmount);
                if (movementStepAmount == 1) {
                  movementStep.vec3_copy(movementToCheck);
                }
              } else {
                movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps;
                if (movementStepAmount > 1) {
                  movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
                }
              }
            }
            let isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
            movementChecked.vec3_zero();
            newFeetPosition.vec3_copy(this._myValidPosition);
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            let atLeastOneNotOnGround = false;
            let isOneOnGroundBetweenNoGround = false;
            let isLastOnGround = false;
            let isOneOnSteepGround = false;
            for (let i = 0; i < movementStepAmount; i++) {
              if (movementStepAmount == 1 || i != movementStepAmount - 1) {
                currentMovementStep.vec3_copy(movementStep);
              } else {
                currentMovementStep = movementToCheck.vec3_sub(movementChecked, currentMovementStep);
              }
              newFeetPosition = newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
              floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
              collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
              getCollisionCheck2(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
              if (!collisionRuntimeParams.myIsOnGround) {
                atLeastOneNotOnGround = true;
              } else {
                if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                  isOneOnSteepGround = true;
                }
                if (atLeastOneNotOnGround) {
                  isOneOnGroundBetweenNoGround = true;
                }
                if (i == movementStepAmount - 1) {
                  isLastOnGround = true;
                }
              }
            }
            let isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
            if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
              if (isOneOnGroundBetweenNoGround) {
                this._myIsHopping = true;
              } else {
                this._myIsLeaning = true;
              }
            } else {
              this._myIsLeaning = false;
              this._myIsHopping = false;
              if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
                this._myIsLeaning = true;
              } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
                this._myIsHopping = true;
              }
            }
            if (this._myIsLeaning) {
              let distance = movementToCheck.vec3_length();
              if (this._myParams.myIsLeaningValidAboveDistance && distance > this._myParams.myLeaningValidDistance) {
                this._myIsLeaning = false;
              }
            }
            if (this._myIsLeaning || this._myIsHopping) {
              if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              }
            }
          }
        }
      }
      movementToCheck = this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
      collisionRuntimeParams.reset();
      transformQuat = this.getTransformHeadQuat(transformQuat);
      newPositionHead.vec3_copy(this._myValidPositionHead);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
        getCollisionCheck2(this._myParams.myEngine).move(movementToCheck, transformQuat, this._myHeadCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          this._myIsHeadColliding = false;
          newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
        } else {
          this._myIsHeadColliding = true;
        }
      }
      if (this.isSynced(this._myParams.mySyncPositionFlagMap) && !this._myParams.mySyncPositionDisabled) {
        this._myValidPosition.vec3_copy(newPosition);
      }
      if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap)) {
        this._myValidPositionHead = this.getPositionHeadReal(newPositionHead);
      }
      if (this.isSynced(this._myParams.mySyncRotationFlagMap)) {
        this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
      }
      if (this.isSynced(this._myParams.mySyncHeightFlagMap)) {
        this._myValidHeight = this._myRealMovementCollisionCheckParams.myHeight;
        this._updateCollisionHeight();
      }
      if (this._myParams.myUpdateRealPositionValid) {
        transformQuat = this.getTransformRealQuat(transformQuat);
        transformUp = transformQuat.quat2_getUp(transformUp);
        rotationQuat = transformQuat.quat2_getRotationQuat(rotationQuat);
        horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
        if (!horizontalDirection.vec3_isZero(1e-5)) {
          horizontalDirection.vec3_normalize(horizontalDirection);
          rotationQuat.quat_setForward(horizontalDirection);
          transformQuat.quat2_setRotationQuat(rotationQuat);
        }
        let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
        this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
        getCollisionCheck2(this._myParams.myEngine).positionCheck(true, transformQuat, this._myParams.myMovementCollisionCheckParams, this._myRealCollisionRuntimeParams);
        this._myIsRealPositionValid = this._myRealCollisionRuntimeParams.myIsPositionOk;
        this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
      }
    }
  };
}();
CleanedPlayerTransformManager.prototype.move = function() {
  let transformQuat = quat2_create();
  let fixedMovement = vec3_create2();
  return function move(movement, outCollisionRuntimeParams = null, forceMove = false) {
    transformQuat = this.getTransformQuat(transformQuat);
    getCollisionCheck2(this._myParams.myEngine).move(movement, transformQuat, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    if (!forceMove) {
      fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
    } else {
      fixedMovement.vec3_copy(movement);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnMove) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            false
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            false
          );
        }
      }
    }
  };
}();
CleanedPlayerTransformManager.prototype.teleportPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function teleportPosition(teleportPosition, outCollisionRuntimeParams = null, forceTeleport = false) {
    teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
  };
}();
CleanedPlayerTransformManager.prototype.teleportTransformQuat = function() {
  let currentPosition = vec3_create2();
  let teleportPositionVec = vec3_create2();
  let teleportRotation = quat_create();
  let rotatedTransformQuat = quat2_create();
  let fixedMovement = vec3_create2();
  return function teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
    currentPosition = this.getPosition(currentPosition);
    teleportPositionVec = teleportTransformQuat.quat2_getPosition(teleportPositionVec);
    teleportRotation = teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
    rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
    getCollisionCheck2(this._myParams.myEngine).teleport(teleportPositionVec, rotatedTransformQuat, this._myParams.myTeleportCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    fixedMovement.vec3_zero();
    if (!forceTeleport) {
      if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
        fixedMovement = this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
        this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
      }
    } else {
      fixedMovement = teleportPositionVec.vec3_sub(currentPosition, fixedMovement);
      this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnTeleport) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            false
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            false
          );
        }
      }
    }
  };
}();
CleanedPlayerTransformManager.prototype.rotateQuat = function() {
  return function rotateQuat(rotationQuat) {
    this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
    this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
  };
}();
CleanedPlayerTransformManager.prototype.setRotationQuat = function() {
  let rotationToPerform = quat_create();
  return function setRotationQuat(rotationQuat) {
    rotationToPerform = this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
    this.rotateQuat(rotationToPerform);
  };
}();
CleanedPlayerTransformManager.prototype.setHeight = function() {
  let transformQuat = quat2_create();
  return function setHeight(height, forceSet = false) {
    let fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight, this._myParams.myMaxHeight);
    let previousHeight = this.getHeight();
    this._myValidHeight = fixedHeight;
    this._updateCollisionHeight();
    transformQuat = this.getTransformQuat(transformQuat);
    getCollisionCheck2(this._myParams.myEngine).positionCheck(true, transformQuat, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (this._myCollisionRuntimeParams.myIsPositionOk || forceSet) {
      this.getPlayerHeadManager().setHeight(this.getHeight(), true);
    } else {
      this._myValidHeight = previousHeight;
    }
    this._updateCollisionHeight();
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/cleaned/player_locomotion_cleaned.js
var CleanedPlayerLocomotion = class {
  constructor(params) {
    this._myParams = params;
    this._myCollisionCheckParamsMovement = new CollisionCheckParams();
    this._setupCollisionCheckParamsMovement();
    this._myCollisionCheckParamsTeleport = null;
    this._setupCollisionCheckParamsTeleport();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myMovementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
    this._myMovementRuntimeParams.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
    {
      let params2 = new PlayerHeadManagerParams(this._myParams.myEngine);
      params2.mySessionChangeResyncEnabled = true;
      params2.myBlurEndResyncEnabled = true;
      params2.myBlurEndResyncRotation = true;
      params2.myEnterSessionResyncHeight = false;
      params2.myExitSessionResyncHeight = false;
      params2.myExitSessionResyncVerticalAngle = true;
      params2.myExitSessionRemoveRightTilt = true;
      params2.myExitSessionAdjustMaxVerticalAngle = true;
      params2.myExitSessionMaxVerticalAngle = 90;
      params2.myHeightOffsetVRWithFloor = 0;
      params2.myHeightOffsetVRWithoutFloor = 1.75;
      params2.myHeightOffsetNonVR = 1.75;
      params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
      params2.myFeetRotationKeepUp = true;
      params2.myDebugActive = false;
      this._myPlayerHeadManager = new PlayerHeadManager(params2);
    }
    {
      let params2 = new PlayerTransformManagerParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myMovementCollisionCheckParams = this._myCollisionCheckParamsMovement;
      params2.myTeleportCollisionCheckParams = null;
      params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
      params2.myTeleportCollisionCheckParamsCheck360 = true;
      params2.myHeadCollisionBlockLayerFlags.copy(params2.myMovementCollisionCheckParams.myHorizontalBlockLayerFlags);
      params2.myHeadCollisionBlockLayerFlags.add(params2.myMovementCollisionCheckParams.myVerticalBlockLayerFlags);
      params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
      let objectsEqualCallback = (first, second) => first.pp_equals(second);
      for (let objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
        params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      params2.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
      params2.myHeadRadius = 0.15;
      params2.myIsMaxDistanceFromRealToSyncEnabled = true;
      params2.myMaxDistanceFromRealToSync = 100;
      params2.myIsFloatingValidIfVerticalMovement = false;
      params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
      params2.myIsFloatingValidIfSteepGround = false;
      params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
      params2.myIsFloatingValidIfRealOnGround = false;
      params2.myIsLeaningValidAboveDistance = true;
      params2.myLeaningValidDistance = 2;
      params2.myFloatingSplitCheckEnabled = true;
      params2.myFloatingSplitCheckMaxLength = 0.2;
      params2.myFloatingSplitCheckMaxSteps = 5;
      params2.myRealMovementAllowVerticalAdjustments = false;
      params2.myUpdateRealPositionValid = true;
      params2.myUpdatePositionValid = true;
      params2.myIsBodyCollidingWhenHeightBelowValue = null;
      params2.myIsBodyCollidingWhenHeightAboveValue = null;
      params2.myResetToValidOnEnterSession = true;
      params2.myResetToValidOnExitSession = true;
      params2.myAlwaysResetRealPositionNonVR = true;
      params2.myAlwaysResetRealRotationNonVR = true;
      params2.myAlwaysResetRealHeightNonVR = true;
      params2.myAlwaysResetRealPositionVR = false;
      params2.myAlwaysResetRealRotationVR = false;
      params2.myAlwaysResetRealHeightVR = false;
      params2.myNeverResetRealPositionNonVR = false;
      params2.myNeverResetRealRotationNonVR = true;
      params2.myNeverResetRealHeightNonVR = false;
      params2.myNeverResetRealPositionVR = false;
      params2.myNeverResetRealRotationVR = false;
      params2.myNeverResetRealHeightVR = true;
      params2.myResetRealOnMove = false;
      params2.myDebugActive = false;
      this._myPlayerTransformManager = new CleanedPlayerTransformManager(params2);
    }
    {
      let params2 = new PlayerObscureManagerParams(this._myParams.myEngine);
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myObscureObject = null;
      params2.myObscureMaterial = null;
      params2.myObscureRadius = 0.1;
      params2.myObscureFadeOutSeconds = 0.25;
      params2.myObscureFadeInSeconds = 0.25;
      params2.myObscureFadeEasingFunction = EasingFunction2.linear;
      params2.myObscureLevelRelativeDistanceEasingFunction = EasingFunction2.linear;
      params2.myDistanceToStartObscureWhenBodyColliding = 0.75;
      params2.myDistanceToStartObscureWhenHeadColliding = 0;
      params2.myDistanceToStartObscureWhenFloating = 0.75;
      params2.myDistanceToStartObscureWhenFar = 0.75;
      params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
      params2.myRelativeDistanceToMaxObscureWhenHeadColliding = 0.1;
      params2.myRelativeDistanceToMaxObscureWhenFloating = 0.5;
      params2.myRelativeDistanceToMaxObscureWhenFar = 0.5;
      this._myPlayerObscureManager = new PlayerObscureManager(params2);
    }
    {
      let params2 = new PlayerLocomotionRotateParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
      params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
      params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
      params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
      if (this._myParams.mySnapTurnSpeedDegrees > LocomotionUtils.EPSILON) {
        params2.mySmoothSnapActive = true;
        params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
      } else {
        params2.mySmoothSnapActive = false;
      }
      params2.myRotationMinStickIntensityThreshold = 0.1;
      params2.mySnapTurnActivateThreshold = 0.5;
      params2.mySnapTurnResetThreshold = 0.4;
      params2.myClampVerticalAngle = true;
      params2.myMaxVerticalAngle = 90;
      this._myPlayerLocomotionRotate = new PlayerLocomotionRotate2(params2);
      params2.myHandedness = InputUtils.getOppositeHandedness(this._myParams.myMainHand);
    }
    {
      {
        let params2 = new PlayerLocomotionSmoothParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsMovement;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myMaxSpeed = this._myParams.myMaxSpeed;
        params2.myMovementMinStickIntensityThreshold = 0.1;
        params2.myFlyEnabled = this._myParams.myFlyEnabled;
        params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
        params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
        params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
        params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
        params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
        params2.myGravityAcceleration = -20;
        params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
        params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
        params2.myMoveThroughCollisionShortcutEnabled = this._myParams.myMoveThroughCollisionShortcutEnabled;
        params2.myMoveHeadShortcutEnabled = this._myParams.myMoveHeadShortcutEnabled;
        this._myPlayerLocomotionSmooth = new CleanedPlayerLocomotionSmooth(params2, this._myMovementRuntimeParams);
      }
      {
        let params2 = new PlayerLocomotionTeleportParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsTeleport;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myDetectionParams.myMaxDistance = 3;
        params2.myDetectionParams.myMaxHeightDifference = 4;
        params2.myDetectionParams.myGroundAngleToIgnoreUpward = this._myCollisionCheckParamsMovement.myGroundAngleToIgnore;
        params2.myDetectionParams.myMustBeOnGround = true;
        params2.myDetectionParams.myTeleportBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFloorLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
        params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
        params2.myDetectionParams.myVisibilityBlockLayerFlags.copy(params2.myDetectionParams.myTeleportBlockLayerFlags);
        params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
        params2.myPerformTeleportAsMovement = false;
        params2.myTeleportAsMovementRemoveVerticalMovement = true;
        params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
        params2.myGravityAcceleration = 0;
        params2.myDebugActive = false;
        params2.myDebugDetectActive = true;
        params2.myDebugShowActive = true;
        params2.myDebugVisibilityActive = false;
        this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport2(params2, this._myMovementRuntimeParams);
      }
    }
    this._setupLocomotionMovementFSM();
    this._myIdle = false;
    this._myStarted = false;
    this._myActive = true;
  }
  start() {
    this._fixAlmostUp();
    this._myPlayerHeadManager.start();
    this._myPlayerTransformManager.start();
    this._myPlayerObscureManager.start();
    this._myPlayerLocomotionRotate.start();
    this._myLocomotionMovementFSM.perform("start");
    this._myStarted = true;
    let currentActive = this._myActive;
    this._myActive = !this._myActive;
    this.setActive(currentActive);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myStarted) {
        if (this._myActive) {
          this._myPlayerObscureManager.start();
          if (!this._myIdle) {
            this._myLocomotionMovementFSM.perform("start");
          }
        } else {
          this._myLocomotionMovementFSM.perform("idle");
          this._myPlayerObscureManager.stop();
        }
      }
      this._myPlayerHeadManager.setActive(this._myActive);
      this._myPlayerTransformManager.setActive(this._myActive);
    }
  }
  isStarted() {
    return this._myStarted;
  }
  canStop() {
    let canStop = false;
    if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
      canStop = true;
    } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
      canStop = true;
    }
    return canStop;
  }
  update(dt) {
    this._myPlayerHeadManager.update(dt);
    this._myPlayerTransformManager.update(dt);
    if (getLeftGamepad(this._myParams.myEngine).getButtonInfo(GamepadButtonID.THUMBSTICK).isPressEnd(2)) {
      if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
        this._myLocomotionMovementFSM.perform("next");
      } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
        this._myLocomotionMovementFSM.perform("next");
      }
    }
    if (this._myPlayerHeadManager.isSynced()) {
      this._updateCollisionHeight();
      if (!this._myIdle) {
        this._myPlayerLocomotionRotate.update(dt);
        this._myLocomotionMovementFSM.update(dt);
      }
    }
    this._myPlayerObscureManager.update(dt);
  }
  setIdle(idle) {
    this._myIdle = idle;
    if (idle) {
      this._myLocomotionMovementFSM.perform("idle");
    } else {
      this._myLocomotionMovementFSM.perform("start");
    }
  }
  _updateCollisionHeight() {
    this._myCollisionCheckParamsMovement.myHeight = this._myPlayerHeadManager.getHeightHead();
    if (this._myCollisionCheckParamsMovement.myHeight <= 1e-6) {
      this._myCollisionCheckParamsMovement.myHeight = 0;
    }
    this._myCollisionCheckParamsTeleport.myHeight = this._myCollisionCheckParamsMovement.myHeight;
  }
  _setupCollisionCheckParamsMovement() {
    let simplifiedParams = new CharacterColliderSetupSimplifiedCreationParams();
    simplifiedParams.myHeight = 1.75;
    simplifiedParams.myRadius = this._myParams.myCharacterRadius;
    simplifiedParams.myAccuracyLevel = CharacterColliderSetupSimplifiedCreationAccuracyLevel.HIGH;
    simplifiedParams.myIsPlayer = true;
    simplifiedParams.myCheckOnlyFeet = false;
    simplifiedParams.myAverageSpeed = this._myParams.myMaxSpeed;
    simplifiedParams.myCanFly = this._myParams.myFlyEnabled;
    simplifiedParams.myShouldSlideAgainstWall = true;
    simplifiedParams.myCollectGroundInfo = true;
    simplifiedParams.myShouldSnapOnGround = true;
    simplifiedParams.myMaxDistanceToSnapOnGround = 0.1;
    simplifiedParams.myMaxWalkableGroundAngle = 30;
    simplifiedParams.myMaxWalkableGroundStepHeight = 0.1;
    simplifiedParams.myShouldNotFallFromEdges = false;
    simplifiedParams.myHorizontalCheckBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
    let physXComponents = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getComponents(PhysXComponent8);
    for (let physXComponent of physXComponents) {
      simplifiedParams.myHorizontalCheckObjectsToIgnore.pp_pushUnique(physXComponent.object, (first, second) => first.pp_equals(second));
    }
    simplifiedParams.myVerticalCheckBlockLayerFlags.copy(simplifiedParams.myHorizontalCheckBlockLayerFlags);
    simplifiedParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedParams.myHorizontalCheckObjectsToIgnore);
    simplifiedParams.myHorizontalCheckDebugActive = false;
    simplifiedParams.myVerticalCheckDebugActive = false;
    let colliderSetup = CharacterColliderUtils.createCharacterColliderSetupSimplified(simplifiedParams);
    this._myCollisionCheckParamsMovement = CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(colliderSetup, this._myCollisionCheckParamsMovement, this._myParams.myEngine);
  }
  _setupCollisionCheckParamsTeleport() {
    this._myCollisionCheckParamsTeleport = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myCollisionCheckParamsMovement);
    this._myCollisionCheckParamsTeleport.myGroundAngleToIgnore = 61;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnIgnorableGroundAngle = true;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnGround = true;
  }
  _fixAlmostUp() {
    let defaultUp = vec3_create2(0, 1, 0);
    let angleWithDefaultUp = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getUp().vec3_angle(defaultUp);
    if (angleWithDefaultUp < 1) {
      let forward = getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_getForward();
      let flatForward = forward.vec3_clone();
      flatForward[1] = 0;
      let defaultForward = vec3_create2(0, 0, 1);
      let angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
      getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_resetRotation();
      getPlayerObjects2(this._myParams.myEngine).myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
    }
  }
  _setupLocomotionMovementFSM() {
    this._myLocomotionMovementFSM = new FSM();
    this._myLocomotionMovementFSM.addState("init");
    this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
    this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
    this._myLocomotionMovementFSM.addState("idleSmooth");
    this._myLocomotionMovementFSM.addState("idleTeleport");
    this._myLocomotionMovementFSM.addTransition("init", "smooth", "start", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "next", function() {
      this._myPlayerLocomotionSmooth.stop();
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "next", function() {
      this._myPlayerLocomotionTeleport.stop();
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
      this._myPlayerLocomotionSmooth.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
      this._myPlayerLocomotionTeleport.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "start", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "start", function() {
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.init("init");
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_component.js
var _myCollisionChecks2 = /* @__PURE__ */ new WeakMap();
function getCollisionCheck2(engine2 = getMainEngine()) {
  return _myCollisionChecks2.get(engine2);
}
function setCollisionCheck2(collisionCheck, engine2 = getMainEngine()) {
  _myCollisionChecks2.set(engine2, collisionCheck);
}
var PlayerLocomotionComponent = class extends Component44 {
  start() {
    setCollisionCheck2(new CollisionCheck(this.engine), this.engine);
    let params = new PlayerLocomotionParams(this.engine);
    params.myMaxSpeed = this._myMaxSpeed;
    params.myMaxRotationSpeed = this._myMaxRotationSpeed;
    params.myCharacterRadius = this._myCharacterRadius;
    params.myIsSnapTurn = this._myIsSnapTurn;
    params.mySnapTurnOnlyVR = this._mySnapTurnOnlyVR;
    params.mySnapTurnAngle = this._mySnapTurnAngle;
    params.mySnapTurnSpeedDegrees = this._mySnapTurnSpeedDegrees;
    params.myFlyEnabled = this._myFlyEnabled;
    params.myMinAngleToFlyUpNonVR = this._myMinAngleToFlyUpNonVR;
    params.myMinAngleToFlyDownNonVR = this._myMinAngleToFlyDownNonVR;
    params.myMinAngleToFlyUpVR = this._myMinAngleToFlyUpVR;
    params.myMinAngleToFlyDownVR = this._myMinAngleToFlyDownVR;
    params.myMinAngleToFlyRight = this._myMinAngleToFlyRight;
    params.myMainHand = InputUtils.getHandednessByIndex(this._myMainHand);
    params.myVRDirectionReferenceType = this._myVRDirectionReferenceType;
    params.myVRDirectionReferenceObject = this._myVRDirectionReferenceObject;
    params.myTeleportParableStartReferenceObject = this._myTeleportParableStartReferenceObject;
    params.myForeheadExtraHeight = 0.1;
    params.myTeleportPositionObject = this._myTeleportPositionObject;
    params.myMoveThroughCollisionShortcutEnabled = this._myMoveThroughCollisionShortcutEnabled;
    params.myMoveHeadShortcutEnabled = this._myMoveHeadShortcutEnabled;
    params.myPhysicsBlockLayerFlags.copy(this._getPhysicsBlockLayersFlags());
    if (this._myUseCleanedVersion) {
      this._myPlayerLocomotion = new CleanedPlayerLocomotion(params);
    } else {
      this._myPlayerLocomotion = new PlayerLocomotion(params);
    }
    this._myStartCounter = 1;
  }
  update(dt) {
    if (this._myStartCounter > 0) {
      this._myStartCounter--;
      if (this._myStartCounter == 0) {
        this._myPlayerLocomotion.start();
        this._myPlayerLocomotion._myPlayerTransformManager.resetReal(true, false, false, true);
        this._myPlayerLocomotion._myPlayerTransformManager.resetHeadToReal();
      }
      this._myPlayerLocomotion._myPlayerHeadManager.update(dt);
    } else {
      getCollisionCheck2(this.engine)._myTotalRaycasts = 0;
      this._myPlayerLocomotion.update(dt);
    }
  }
  onActivate() {
    if (this._myStartCounter == 0) {
      if (this._myPlayerLocomotion != null) {
        this._myPlayerLocomotion.setActive(true);
      }
    }
  }
  onDeactivate() {
    if (this._myStartCounter == 0) {
      if (this._myPlayerLocomotion != null) {
        this._myPlayerLocomotion.setActive(false);
      }
    }
  }
  _getPhysicsBlockLayersFlags() {
    let physicsFlags = new PhysicsLayerFlags();
    let flags = [...this._myPhysicsBlockLayerFlags.split(",")];
    for (let i = 0; i < flags.length; i++) {
      physicsFlags.setFlagActive(i, flags[i].trim() == "1");
    }
    return physicsFlags;
  }
};
__publicField(PlayerLocomotionComponent, "TypeName", "pp-player-locomotion");
__publicField(PlayerLocomotionComponent, "Properties", {
  _myPhysicsBlockLayerFlags: Property44.string("1, 0, 0, 0, 0, 0, 0, 0"),
  _myMaxSpeed: Property44.float(2),
  _myMaxRotationSpeed: Property44.float(100),
  _myCharacterRadius: Property44.float(0.3),
  _myIsSnapTurn: Property44.bool(true),
  _mySnapTurnOnlyVR: Property44.bool(true),
  _mySnapTurnAngle: Property44.float(30),
  _mySnapTurnSpeedDegrees: Property44.float(0),
  _myFlyEnabled: Property44.bool(false),
  _myMinAngleToFlyUpNonVR: Property44.float(30),
  _myMinAngleToFlyDownNonVR: Property44.float(50),
  _myMinAngleToFlyUpVR: Property44.float(60),
  _myMinAngleToFlyDownVR: Property44.float(1),
  _myMinAngleToFlyRight: Property44.float(60),
  _myMainHand: Property44.enum(["Left", "Right"], "Left"),
  _myVRDirectionReferenceType: Property44.enum(["Head", "Hand", "Custom Object"], "Hand"),
  _myVRDirectionReferenceObject: Property44.object(),
  _myTeleportParableStartReferenceObject: Property44.object(),
  _myTeleportPositionObject: Property44.object(),
  _myUseCleanedVersion: Property44.bool(true),
  _myMoveThroughCollisionShortcutEnabled: Property44.bool(false),
  _myMoveHeadShortcutEnabled: Property44.bool(false)
});

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_transform_manager.js
var PlayerTransformManagerSyncFlag = {
  BODY_COLLIDING: 0,
  HEAD_COLLIDING: 1,
  FAR: 2,
  FLOATING: 3
};
var PlayerTransformManagerParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myPlayerHeadManager = null;
    this.myMovementCollisionCheckParams = null;
    this.myTeleportCollisionCheckParams = null;
    this.myTeleportCollisionCheckParamsCopyFromMovement = false;
    this.myTeleportCollisionCheckParamsCheck360 = false;
    this.mySyncEnabledFlagMap = /* @__PURE__ */ new Map();
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
    this.mySyncPositionFlagMap = /* @__PURE__ */ new Map();
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
    this.mySyncPositionHeadFlagMap = /* @__PURE__ */ new Map();
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.mySyncRotationFlagMap = /* @__PURE__ */ new Map();
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.mySyncHeightFlagMap = /* @__PURE__ */ new Map();
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.myIsLeaningValidAboveDistance = false;
    this.myLeaningValidDistance = 0;
    this.myIsFloatingValidIfVerticalMovement = false;
    this.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
    this.myIsFloatingValidIfRealOnGround = false;
    this.myIsFloatingValidIfSteepGround = false;
    this.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
    this.myFloatingSplitCheckEnabled = false;
    this.myFloatingSplitCheckMaxLength = 0;
    this.myFloatingSplitCheckMaxSteps = null;
    this.myFloatingSplitCheckStepEqualLength = false;
    this.myFloatingSplitCheckStepEqualLengthMinLength = 0;
    this.myIsMaxDistanceFromRealToSyncEnabled = false;
    this.myMaxDistanceFromRealToSync = 0;
    this.myHeadRadius = 0;
    this.myHeadCollisionBlockLayerFlags = new PhysicsLayerFlags();
    this.myHeadCollisionObjectsToIgnore = [];
    this.myRotateOnlyIfSynced = false;
    this.myResetRealResetRotationIfUpChanged = true;
    this.myRealMovementAllowVerticalAdjustments = false;
    this.myUpdateRealPositionValid = false;
    this.myUpdatePositionValid = false;
    this.myMinHeight = null;
    this.myMaxHeight = null;
    this.myIsBodyCollidingWhenHeightBelowValue = null;
    this.myIsBodyCollidingWhenHeightAboveValue = null;
    this.myIsBodyCollidingExtraCheckCallback = null;
    this.myIsLeaningExtraCheckCallback = null;
    this.myIsHoppingExtraCheckCallback = null;
    this.myIsFarExtraCheckCallback = null;
    this.myResetToValidOnEnterSession = false;
    this.myResetToValidOnExitSession = false;
    this.myAlwaysResetRealPositionNonVR = false;
    this.myAlwaysResetRealRotationNonVR = false;
    this.myAlwaysResetRealHeightNonVR = false;
    this.myAlwaysResetRealPositionVR = false;
    this.myAlwaysResetRealRotationVR = false;
    this.myAlwaysResetRealHeightVR = false;
    this.myNeverResetRealPositionNonVR = false;
    this.myNeverResetRealRotationNonVR = false;
    this.myNeverResetRealHeightNonVR = false;
    this.myNeverResetRealPositionVR = false;
    this.myNeverResetRealRotationVR = false;
    this.myNeverResetRealHeightVR = false;
    this.myResetRealOnMove = false;
    this.myResetRealOnTeleport = false;
    this.mySyncPositionDisabled = false;
    this.myEngine = engine2;
    this.myDebugActive = false;
  }
};
var PlayerTransformManager = class {
  constructor(params) {
    this._myParams = params;
    this._myRealMovementCollisionCheckParams = null;
    this._generateRealMovementParamsFromMovementParams();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myRealCollisionRuntimeParams = new CollisionRuntimeParams();
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._myHeadCollisionCheckParams = null;
    this._setupHeadCollisionCheckParams();
    this._myValidPosition = vec3_create2();
    this._myValidRotationQuat = quat_create();
    this._myValidHeight = 0;
    this._myValidPositionHead = vec3_create2();
    this._myIsBodyColliding = false;
    this._myIsHeadColliding = false;
    this._myIsLeaning = false;
    this._myIsHopping = false;
    this._myIsFar = false;
    this._myLastValidMovementDirection = vec3_create2();
    this._myIsRealPositionValid = false;
    this._myIsPositionValid = false;
    this._myResetRealOnSynced = false;
  }
  start() {
    this.resetToReal(true);
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  update(dt) {
  }
  move(movement, outCollisionRuntimeParams = null, forceMove = false) {
  }
  teleportPosition(position, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  teleportTransformQuat(transformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  rotateQuat(rotationQuat) {
  }
  setRotationQuat(rotationQuat) {
  }
  setHeight(height, forceSet = false) {
  }
  getPlayer() {
    return this._myParams.myPlayerHeadManager.getPlayer();
  }
  getHead() {
    return this._myParams.myPlayerHeadManager.getHead();
  }
  getTransformQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(this._myValidPosition), this.getRotationQuat(this._myValidRotationQuat));
  }
  getPosition(outPosition = vec3_create2()) {
    return outPosition.vec3_copy(this._myValidPosition);
  }
  getRotationQuat(outRotation = quat_create()) {
    return outRotation.quat_copy(this._myValidRotationQuat);
  }
  getPositionHead(outPosition = vec3_create2()) {
    return outPosition.vec3_copy(this._myValidPositionHead);
  }
  getTransformHeadQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(this._myValidPositionHead), this.getRotationQuat(this._myValidRotationQuat));
  }
  getHeight() {
    return this._myValidHeight;
  }
  getTransformRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
  }
  getTransformHeadRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
  }
  getPositionReal(outPosition = vec3_create2()) {
    return this.getPlayerHeadManager().getPositionFeet(outPosition);
  }
  getPositionHeadReal(outPosition = vec3_create2()) {
    return this.getPlayerHeadManager().getPositionHead(outPosition);
  }
  getRotationRealQuat(outRotation = quat_create()) {
    return this.getPlayerHeadManager().getRotationFeetQuat(outRotation);
  }
  getHeightReal() {
    return this._myParams.myPlayerHeadManager.getHeightHead();
  }
  isSynced(syncFlagMap = null) {
    let isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
    let isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
    let isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
    let isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
    return !isBodyColliding && !isHeadColliding && !isFar && !isFloating;
  }
  resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
  }
  resetHeadToReal() {
    this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
  }
  updateReal() {
    this._updateReal(0, false);
  }
  resetToReal(updateRealFlags = false) {
    this._myValidPosition = this.getPositionReal(this._myValidPosition);
    this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
    this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
    this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    if (updateRealFlags) {
      this._updateReal(0, false);
    }
  }
  isBodyColliding() {
    return this._myIsBodyColliding;
  }
  isHeadColliding() {
    return this._myIsHeadColliding;
  }
  isFloating() {
    return this.isLeaning() || this.isHopping();
  }
  isHopping() {
    return this._myIsHopping;
  }
  isLeaning() {
    return this._myIsLeaning;
  }
  isHopping() {
    return this._myIsHopping;
  }
  isFar() {
    return this._myIsFar;
  }
  getDistanceToReal() {
  }
  getDistanceToRealHead() {
  }
  getPlayerHeadManager() {
    return this._myParams.myPlayerHeadManager;
  }
  getParams() {
    return this._myParams;
  }
  getMovementCollisionCheckParams() {
    return this._myParams.myMovementCollisionCheckParams;
  }
  getTeleportCollisionCheckParams() {
    return this._myParams.myTeleportCollisionCheckParams;
  }
  collisionCheckParamsUpdated() {
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._generateRealMovementParamsFromMovementParams();
  }
  isPositionValid() {
    return this._myIsPositionValid;
  }
  isRealPositionValid() {
    return this._myIsRealPositionValid;
  }
  getCollisionRuntimeParams() {
    return this._myCollisionRuntimeParams;
  }
  getRealCollisionRuntimeParams() {
    return this._myRealCollisionRuntimeParams;
  }
  _updateCollisionHeight() {
    let validHeight = this.getHeight();
    let realHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    this._myParams.myMovementCollisionCheckParams.myHeight = validHeight;
    this._myParams.myTeleportCollisionCheckParams.myHeight = validHeight;
    this._myRealMovementCollisionCheckParams.myHeight = realHeight;
  }
  _setupHeadCollisionCheckParams() {
    this._myHeadCollisionCheckParams = new CollisionCheckParams();
    let params = this._myHeadCollisionCheckParams;
    params.myRadius = this._myParams.myHeadRadius;
    params.myDistanceFromFeetToIgnore = 0;
    params.myDistanceFromHeadToIgnore = 0;
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLength = 0.5;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 2;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.myHorizontalMovementCheckEnabled = true;
    params.myHorizontalMovementRadialStepAmount = 1;
    params.myHorizontalMovementCheckDiagonalOutward = true;
    params.myHorizontalMovementCheckDiagonalInward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
    params.myHorizontalPositionCheckEnabled = true;
    params.myHalfConeAngle = 180;
    params.myHalfConeSliceAmount = 3;
    params.myCheckConeBorder = true;
    params.myCheckConeRay = true;
    params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
    params.myHorizontalPositionCheckVerticalDirectionType = 0;
    params.myHeight = params.myRadius;
    params.myPositionOffsetLocal.vec3_set(0, -params.myRadius / 2, 0);
    params.myCheckHeight = true;
    params.myCheckHeightVerticalMovement = true;
    params.myCheckHeightVerticalPosition = true;
    params.myHeightCheckStepAmountMovement = 2;
    params.myHeightCheckStepAmountPosition = 2;
    params.myCheckHeightTopMovement = true;
    params.myCheckHeightTopPosition = true;
    params.myCheckVerticalStraight = true;
    params.myCheckVerticalFixedForwardEnabled = true;
    params.myCheckVerticalFixedForward = vec3_create2(0, 0, 1);
    params.myCheckHorizontalFixedForwardEnabled = true;
    params.myCheckHorizontalFixedForward = vec3_create2(0, 0, 1);
    params.myVerticalMovementCheckEnabled = true;
    params.myVerticalPositionCheckEnabled = true;
    params.myGroundCircumferenceAddCenter = true;
    params.myGroundCircumferenceSliceAmount = 6;
    params.myGroundCircumferenceStepAmount = 2;
    params.myGroundCircumferenceRotationPerStep = 30;
    params.myFeetRadius = params.myRadius;
    params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myDebugActive = false;
    params.myDebugHorizontalMovementActive = true;
    params.myDebugHorizontalPositionActive = false;
    params.myDebugVerticalMovementActive = false;
    params.myDebugVerticalPositionActive = false;
    params.myDebugSlidingActive = false;
    params.myDebugGroundInfoActive = false;
    params.myDebugCeilingInfoActive = false;
    params.myDebugRuntimeParamsActive = false;
    params.myDebugMovementActive = false;
  }
  _generateTeleportParamsFromMovementParams() {
    if (this._myParams.myTeleportCollisionCheckParams == null) {
      this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
    }
    if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
      this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
    } else {
      this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
    }
  }
  _generateRealMovementParamsFromMovementParams() {
    if (this._myRealMovementCollisionCheckParams == null) {
      this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
    }
    let params = this._myRealMovementCollisionCheckParams;
    params.copy(this._myParams.myMovementCollisionCheckParams);
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLength = 0.5;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 2;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.mySlidingEnabled = false;
    if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
      params.mySnapOnGroundEnabled = false;
      params.mySnapOnCeilingEnabled = false;
      params.myGroundPopOutEnabled = false;
      params.myCeilingPopOutEnabled = false;
      params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
      params.myAdjustVerticalMovementWithGroundAngleUphill = false;
      params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
      params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
      params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
      params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
      params.myVerticalMovementReduceEnabled = false;
    }
    params.myIsOnGroundIfInsideHit = true;
    params.myDebugActive = false;
    params.myDebugHorizontalMovementActive = false;
    params.myDebugHorizontalPositionActive = false;
    params.myDebugVerticalMovementActive = false;
    params.myDebugVerticalPositionActive = false;
    params.myDebugSlidingActive = false;
    params.myDebugGroundInfoActive = true;
    params.myDebugCeilingInfoActive = true;
    params.myDebugRuntimeParamsActive = false;
    params.myDebugMovementActive = false;
  }
  _onXRSessionStart(manualCall, session) {
    if (this._myParams.myResetToValidOnEnterSession) {
      this._myResetRealOnSynced = true;
    }
  }
  _onXRSessionEnd() {
    if (this._myParams.myResetToValidOnExitSession) {
      this._myResetRealOnSynced = true;
    }
  }
  _debugUpdate(dt) {
    getDebugVisualManager2(this._myParams.myEngine).drawPoint(0, this._myValidPosition, vec4_create2(1, 0, 0, 1), 0.05);
    getDebugVisualManager2(this._myParams.myEngine).drawLineEnd(0, this._myValidPosition, this.getPositionReal(), vec4_create2(1, 0, 0, 1), 0.05);
    getDebugVisualManager2(this._myParams.myEngine).drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, vec4_create2(0, 1, 0, 1), 0.025);
    getDebugVisualManager2(this._myParams.myEngine).drawPoint(0, this._myValidPositionHead, vec4_create2(1, 1, 0, 1), 0.05);
  }
};
PlayerTransformManager.prototype.getDistanceToReal = function() {
  let realPosition = vec3_create2();
  return function getDistanceToReal() {
    realPosition = this.getPositionReal(realPosition);
    return realPosition.vec3_distance(this.getPosition());
  };
}();
PlayerTransformManager.prototype.getDistanceToRealHead = function() {
  let realPosition = vec3_create2();
  return function getDistanceToRealHead() {
    realPosition = this.getPositionHeadReal(realPosition);
    return realPosition.vec3_distance(this.getPositionHead());
  };
}();
PlayerTransformManager.prototype.resetReal = function() {
  let realUp = vec3_create2();
  let validUp = vec3_create2();
  let position = vec3_create2();
  let rotationQuat = quat_create();
  return function resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
    let playerHeadManager = this.getPlayerHeadManager();
    if (resetPosition) {
      playerHeadManager.teleportPositionFeet(this.getPosition(position));
    }
    realUp = this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
    validUp = this.getRotationQuat(rotationQuat).quat_getUp(validUp);
    if (resetRotation || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
      playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
    }
    if (resetHeight) {
      playerHeadManager.setHeight(this.getHeight(), true);
    }
    if (updateRealFlags) {
      this._updateReal(0, false);
    }
  };
}();
PlayerTransformManager.prototype.update = function() {
  let transformQuat = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let transformUp = vec3_create2();
  let horizontalDirection = vec3_create2();
  let rotationQuat = quat_create();
  return function update(dt) {
    if (this._myResetRealOnSynced) {
      if (this.getPlayerHeadManager().isSynced()) {
        this._myResetRealOnSynced = false;
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            false
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            false
          );
        }
      }
    }
    this._updateReal(dt);
    if (this._myParams.myUpdatePositionValid) {
      transformQuat = this.getTransformQuat(transformQuat);
      transformUp = transformQuat.quat2_getUp(transformUp);
      rotationQuat = transformQuat.quat2_getRotationQuat(rotationQuat);
      horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setForward(horizontalDirection);
        transformQuat.quat2_setRotationQuat(rotationQuat);
      }
      let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
      this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
      getCollisionCheck2(this._myParams.myEngine).positionCheck(true, transformQuat, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
      this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
      this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
    }
    if (this._myParams.myDebugActive) {
      this._debugUpdate(dt);
    }
  };
}();
PlayerTransformManager.prototype._updateReal = function() {
  let movementToCheck = vec3_create2();
  let position = vec3_create2();
  let positionReal = vec3_create2();
  let transformQuat = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let newPosition = vec3_create2();
  let newPositionHead = vec3_create2();
  let movementStep = vec3_create2();
  let currentMovementStep = vec3_create2();
  let transformUp = vec3_create2();
  let verticalMovement = vec3_create2();
  let movementChecked = vec3_create2();
  let newFeetPosition = vec3_create2();
  let floatingTransformQuat = quat2_create();
  let horizontalDirection = vec3_create2();
  let rotationQuat = quat_create();
  return function _updateReal(dt, resetRealEnabled = true) {
    if (this.getPlayerHeadManager().isSynced()) {
      this._updateCollisionHeight();
      this._myIsBodyColliding = false;
      this._myIsHeadColliding = false;
      this._myIsLeaning = false;
      this._myIsHopping = false;
      this._myIsFar = false;
      movementToCheck = this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
      if (movementToCheck.vec3_length() > 1e-4) {
        this._myLastValidMovementDirection = movementToCheck.vec3_normalize(this._myLastValidMovementDirection);
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
        if (this._myParams.myIsMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
          this._myIsFar = true;
        } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
          this._myIsFar = true;
        }
      }
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      collisionRuntimeParams.myIsOnGround = true;
      transformQuat = this.getTransformQuat(transformQuat);
      newPosition.vec3_copy(this._myValidPosition);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
        getCollisionCheck2(this._myParams.myEngine).move(movementToCheck, transformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          if (Math.pp_clamp(
            this._myRealMovementCollisionCheckParams.myHeight,
            this._myParams.myIsBodyCollidingWhenHeightBelowValue,
            this._myParams.myIsBodyCollidingWhenHeightAboveValue
          ) != this._myRealMovementCollisionCheckParams.myHeight) {
            this._myIsBodyColliding = true;
          } else {
            if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
              this._myIsBodyColliding = true;
            } else {
              this._myIsBodyColliding = false;
              newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
            }
          }
        } else {
          this._myIsBodyColliding = true;
        }
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
        if (!this._myIsBodyColliding) {
          movementToCheck = newPosition.vec3_sub(position, movementToCheck);
        } else {
          movementToCheck = positionReal.vec3_sub(position, movementToCheck);
        }
        collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
        floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
        getCollisionCheck2(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (collisionRuntimeParams.myIsOnGround) {
          transformUp = transformQuat.quat2_getUp(transformUp);
          verticalMovement = movementToCheck.vec3_componentAlongAxis(transformUp, verticalMovement);
          let isVertical = !verticalMovement.vec3_isZero(1e-5);
          if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
            let movementStepAmount = 1;
            movementStep.vec3_copy(movementToCheck);
            if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
              let equalStepLength = movementToCheck.vec3_length() / this._myParams.myFloatingSplitCheckMaxSteps;
              if (!this._myParams.myFloatingSplitCheckStepEqualLength || equalStepLength < this._myParams.myFloatingSplitCheckStepEqualLengthMinLength) {
                let maxLength = this._myParams.myFloatingSplitCheckStepEqualLength ? this._myParams.myFloatingSplitCheckStepEqualLengthMinLength : this._myParams.myFloatingSplitCheckMaxLength;
                movementStepAmount = Math.ceil(movementToCheck.vec3_length() / maxLength);
                if (movementStepAmount > 1) {
                  movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
                  movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps != null ? Math.min(movementStepAmount, this._myParams.myFloatingSplitCheckMaxSteps) : movementStepAmount;
                }
                movementStepAmount = Math.max(1, movementStepAmount);
                if (movementStepAmount == 1) {
                  movementStep.vec3_copy(movementToCheck);
                }
              } else {
                movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps;
                if (movementStepAmount > 1) {
                  movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
                }
              }
            }
            let isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
            movementChecked.vec3_zero();
            newFeetPosition.vec3_copy(this._myValidPosition);
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            let atLeastOneNotOnGround = false;
            let isOneOnGroundBetweenNoGround = false;
            let isLastOnGround = false;
            let isOneOnSteepGround = false;
            for (let i = 0; i < movementStepAmount; i++) {
              if (movementStepAmount == 1 || i != movementStepAmount - 1) {
                currentMovementStep.vec3_copy(movementStep);
              } else {
                currentMovementStep = movementToCheck.vec3_sub(movementChecked, currentMovementStep);
              }
              newFeetPosition = newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
              floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
              collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
              getCollisionCheck2(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
              if (!collisionRuntimeParams.myIsOnGround) {
                atLeastOneNotOnGround = true;
              } else {
                if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                  isOneOnSteepGround = true;
                }
                if (atLeastOneNotOnGround) {
                  isOneOnGroundBetweenNoGround = true;
                }
                if (i == movementStepAmount - 1) {
                  isLastOnGround = true;
                }
              }
            }
            let isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
            if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
              if (isOneOnGroundBetweenNoGround) {
                this._myIsHopping = true;
              } else {
                this._myIsLeaning = true;
              }
            } else {
              this._myIsLeaning = false;
              this._myIsHopping = false;
              if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
                this._myIsLeaning = true;
              } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
                this._myIsHopping = true;
              }
            }
            if (this._myIsLeaning) {
              let distance = movementToCheck.vec3_length();
              if (this._myParams.myIsLeaningValidAboveDistance && distance > this._myParams.myLeaningValidDistance) {
                this._myIsLeaning = false;
              }
            }
            if (this._myIsLeaning || this._myIsHopping) {
              if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              }
            }
          }
        }
      }
      movementToCheck = this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
      collisionRuntimeParams.reset();
      transformQuat = this.getTransformHeadQuat(transformQuat);
      newPositionHead.vec3_copy(this._myValidPositionHead);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
        getCollisionCheck2(this._myParams.myEngine).move(movementToCheck, transformQuat, this._myHeadCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          this._myIsHeadColliding = false;
          newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
        } else {
          this._myIsHeadColliding = true;
        }
      }
      if (this.isSynced(this._myParams.mySyncPositionFlagMap) && !this._myParams.mySyncPositionDisabled) {
        this._myValidPosition.vec3_copy(newPosition);
      }
      if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap)) {
        this._myValidPositionHead = this.getPositionHeadReal(newPositionHead);
      }
      if (this.isSynced(this._myParams.mySyncRotationFlagMap)) {
        this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
      }
      if (this.isSynced(this._myParams.mySyncHeightFlagMap)) {
        this._myValidHeight = this._myRealMovementCollisionCheckParams.myHeight;
        this._updateCollisionHeight();
      }
      if (resetRealEnabled) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          let resetPosition = (this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysResetRealPositionVR) && !this._myParams.myNeverResetRealPositionVR;
          let resetRotation = (this.isSynced(this._myParams.mySyncRotationFlagMap) || this._myParams.myAlwaysResetRealRotationVR) && !this._myParams.myNeverResetRealRotationVR;
          let resetHeight = (this.isSynced(this._myParams.mySyncHeightFlagMap) || this._myParams.myAlwaysResetRealHeightVR) && !this._myParams.myNeverResetRealHeightVR;
          this.resetReal(resetPosition, resetRotation, resetHeight, false);
        } else {
          let resetPosition = (this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysResetRealPositionNonVR) && !this._myParams.myNeverResetRealPositionNonVR;
          let resetRotation = (this.isSynced(this._myParams.mySyncRotationFlagMap) || this._myParams.myAlwaysResetRealRotationNonVR) && !this._myParams.myNeverResetRealRotationNonVR;
          let resetHeight = (this.isSynced(this._myParams.mySyncHeightFlagMap) || this._myParams.myAlwaysResetRealHeightNonVR) && !this._myParams.myNeverResetRealHeightNonVR;
          this.resetReal(resetPosition, resetRotation, resetHeight, false);
        }
      }
      if (this._myParams.myUpdateRealPositionValid) {
        transformQuat = this.getTransformRealQuat(transformQuat);
        transformUp = transformQuat.quat2_getUp(transformUp);
        rotationQuat = transformQuat.quat2_getRotationQuat(rotationQuat);
        horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
        if (!horizontalDirection.vec3_isZero(1e-5)) {
          horizontalDirection.vec3_normalize(horizontalDirection);
          rotationQuat.quat_setForward(horizontalDirection);
          transformQuat.quat2_setRotationQuat(rotationQuat);
        }
        let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
        this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
        getCollisionCheck2(this._myParams.myEngine).positionCheck(true, transformQuat, this._myParams.myMovementCollisionCheckParams, this._myRealCollisionRuntimeParams);
        this._myIsRealPositionValid = this._myRealCollisionRuntimeParams.myIsPositionOk;
        this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
      }
    }
  };
}();
PlayerTransformManager.prototype.move = function() {
  let transformQuat = quat2_create();
  let fixedMovement = vec3_create2();
  return function move(movement, outCollisionRuntimeParams = null, forceMove = false) {
    transformQuat = this.getTransformQuat(transformQuat);
    getCollisionCheck2(this._myParams.myEngine).move(movement, transformQuat, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    if (!forceMove) {
      fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
    } else {
      fixedMovement.vec3_copy(movement);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnMove) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            false
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            false
          );
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.teleportPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function teleportPosition(teleportPosition, outCollisionRuntimeParams = null, forceTeleport = false) {
    teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
  };
}();
PlayerTransformManager.prototype.teleportTransformQuat = function() {
  let currentPosition = vec3_create2();
  let teleportPositionVec = vec3_create2();
  let teleportRotation = quat_create();
  let rotatedTransformQuat = quat2_create();
  let fixedMovement = vec3_create2();
  return function teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
    currentPosition = this.getPosition(currentPosition);
    teleportPositionVec = teleportTransformQuat.quat2_getPosition(teleportPositionVec);
    teleportRotation = teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
    rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
    getCollisionCheck2(this._myParams.myEngine).teleport(teleportPositionVec, rotatedTransformQuat, this._myParams.myTeleportCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    fixedMovement.vec3_zero();
    if (!forceTeleport) {
      if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
        fixedMovement = this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
        this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
      }
    } else {
      fixedMovement = teleportPositionVec.vec3_sub(currentPosition, fixedMovement);
      this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnTeleport) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            false
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            false
          );
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.rotateQuat = function() {
  return function rotateQuat(rotationQuat) {
    this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
    this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
  };
}();
PlayerTransformManager.prototype.setRotationQuat = function() {
  let rotationToPerform = quat_create();
  return function setRotationQuat(rotationQuat) {
    rotationToPerform = this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
    this.rotateQuat(rotationToPerform);
  };
}();
PlayerTransformManager.prototype.setHeight = function() {
  let transformQuat = quat2_create();
  return function setHeight(height, forceSet = false) {
    let fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight, this._myParams.myMaxHeight);
    let previousHeight = this.getHeight();
    this._myValidHeight = fixedHeight;
    this._updateCollisionHeight();
    transformQuat = this.getTransformQuat(transformQuat);
    getCollisionCheck2(this._myParams.myEngine).positionCheck(true, transformQuat, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (this._myCollisionRuntimeParams.myIsPositionOk || forceSet) {
      this.getPlayerHeadManager().setHeight(this.getHeight(), true);
    } else {
      this._myValidHeight = previousHeight;
    }
    this._updateCollisionHeight();
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state_visibility.js
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionVisible = function() {
  let playerUp = vec3_create2();
  let offsetFeetTeleportPosition = vec3_create2();
  let headTeleportPosition = vec3_create2();
  return function _isTeleportPositionVisible(teleportPosition) {
    let isVisible = true;
    if (this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      let isHeadVisible = false;
      let isFeetVisible = false;
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible) {
        let headheight = this._myTeleportParams.myPlayerHeadManager.getHeightHead();
        headTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(headheight, headTeleportPosition), headTeleportPosition);
        isHeadVisible = this._isPositionVisible(headTeleportPosition);
      } else {
        isHeadVisible = true;
      }
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible && isHeadVisible) {
        isFeetVisible = true;
      } else {
        if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible && isHeadVisible) {
          offsetFeetTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myDetectionParams.myVisibilityCheckFeetPositionVerticalOffset, offsetFeetTeleportPosition), offsetFeetTeleportPosition);
          isFeetVisible = this._isPositionVisible(offsetFeetTeleportPosition);
        } else {
          isFeetVisible = true;
        }
      }
      isVisible = isHeadVisible && isFeetVisible;
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isPositionVisible = function() {
  let playerUp = vec3_create2();
  let standardUp = vec3_create2(0, 1, 0);
  let standardForward = vec3_create2(0, 0, 1);
  let referenceUp = vec3_create2();
  let headPosition = vec3_create2();
  let direction = vec3_create2();
  let fixedRight = vec3_create2();
  let fixedForward = vec3_create2();
  let fixedUp = vec3_create2();
  let raycastEndPosition = vec3_create2();
  let raycastSetup = new RaycastSetup();
  let raycastResult2 = new RaycastResults();
  let objectsEqualCallback = (first, second) => first.pp_equals(second);
  return function _isPositionVisible(position) {
    let isVisible = true;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    let currentHead = this._myTeleportParams.myPlayerHeadManager.getHead();
    headPosition = currentHead.pp_getPosition(headPosition);
    direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
    referenceUp.vec3_copy(standardUp);
    if (direction.vec3_angle(standardUp) < 1e-4) {
      referenceUp.vec3_copy(standardForward);
    }
    fixedRight = direction.vec3_cross(referenceUp, fixedRight);
    fixedUp = fixedRight.vec3_cross(direction, fixedUp);
    fixedForward.vec3_copy(direction);
    fixedUp.vec3_normalize(fixedUp);
    fixedForward.vec3_normalize(fixedForward);
    let checkPositions = this._getVisibilityCheckPositions(headPosition, fixedUp, fixedForward);
    let distance = headPosition.vec3_distance(position);
    for (let checkPosition of checkPositions) {
      raycastSetup.myPhysics = this._myTeleportParams.myEngine.physics;
      raycastSetup.myOrigin.vec3_copy(checkPosition);
      raycastSetup.myDirection.vec3_copy(fixedForward);
      raycastSetup.myDistance = distance;
      raycastSetup.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myVisibilityBlockLayerFlags.getMask());
      raycastSetup.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
      for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
        raycastSetup.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      raycastSetup.myIgnoreHitsInsideCollision = true;
      raycastResult2 = PhysicsUtils.raycast(raycastSetup, raycastResult2);
      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugVisibilityActive) {
        getDebugVisualManager2(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult2);
      }
      if (raycastResult2.isColliding()) {
        raycastEndPosition = checkPosition.vec3_add(fixedForward.vec3_scale(distance, raycastEndPosition), raycastEndPosition);
        let hit = raycastResult2.myHits.pp_first();
        if (this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold == 0 || hit.myPosition.vec3_distance(raycastEndPosition) > this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold + 1e-5) {
          isVisible = false;
          break;
        }
      }
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._getVisibilityCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create2());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create2();
  return function _getVisibilityCheckPositions(position, up, forward) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(position);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = this._myTeleportParams.myDetectionParams.myVisibilityCheckRadius / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount;
    let sliceAngle = 360 / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = up.vec3_rotateAxis(currentStepRotation, forward, currentDirection);
      for (let j = 0; j < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, forward, tempCheckPosition);
        checkPositions.push(position.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();

// js/pp/input/cauldron/components/finger_cursor_component.js
import { Collider, CollisionComponent as CollisionComponent3, Component as Component45, Property as Property45 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget4 } from "@wonderlandengine/components";
var FingerCursorComponent = class extends Component45 {
  init() {
    this._myLastTarget = null;
    this._myReferenceSpace = null;
    this._myHandInputSource = null;
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myDoubleClickTimer = 0;
    this._myTripleClickTimer = 0;
    this._myMultipleClickObject = null;
    this._myMultipleClickDelay = 0.3;
  }
  start() {
    this._myCursorObjectRoot = this.object.pp_addObject();
    if (this._myCursorObject == null) {
      this._myCursorObject = this._myCursorObjectRoot.pp_addObject();
    } else {
      this._myCursorObject.pp_setParent(this._myCursorObjectRoot);
    }
    this._myCollisionComponent = this._myCursorObject.pp_addComponent(CollisionComponent3);
    this._myCollisionComponent.collider = Collider.Sphere;
    this._myCollisionComponent.group = 1 << this._myCollisionGroup;
    this._myCollisionComponent.extents = vec3_create2(this._myCollisionSize, this._myCollisionSize, this._myCollisionSize);
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.engine);
  }
  update(dt) {
    if (this._myDoubleClickTimer > 0) {
      this._myDoubleClickTimer -= dt;
    }
    if (this._myTripleClickTimer > 0) {
      this._myTripleClickTimer -= dt;
    }
    this._myCursorObjectRoot.pp_setTransformQuat(getPlayerObjects2(this.engine).myPlayerPivot.pp_getTransformQuat());
    this._updateHand();
    if (this._myHandInputSource) {
      let overlaps = this._myCollisionComponent.queryOverlaps();
      let overlapTarget = null;
      for (let i = 0; i < overlaps.length; ++i) {
        let object = overlaps[i].object;
        let target = object.pp_getComponent(CursorTarget4);
        if (target && (overlapTarget == null || !target.isSurface)) {
          overlapTarget = target;
          if (!target.isSurface) {
            break;
          }
        }
      }
      if (!overlapTarget) {
        this._targetTouchEnd();
      } else if (!overlapTarget.equals(this._myLastTarget)) {
        this._targetTouchEnd();
        this._myLastTarget = overlapTarget;
        this._targetTouchStart();
      }
    } else {
      this._targetTouchEnd();
    }
  }
  _targetTouchStart() {
    this._myLastTarget.onHover(this._myLastTarget.object, this);
    this._myLastTarget.onDown(this._myLastTarget.object, this);
  }
  _targetTouchEnd() {
    if (this._myLastTarget) {
      if (this._myMultipleClicksEnabled && this._myTripleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.pp_equals(this._myLastTarget.object)) {
        this._myLastTarget.onTripleClick(this._myLastTarget.object, this);
        this._myTripleClickTimer = 0;
      } else if (this._myMultipleClicksEnabled && this._myDoubleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.pp_equals(this._myLastTarget.object)) {
        this._myLastTarget.onDoubleClick(this._myLastTarget.object, this);
        this._myTripleClickTimer = this._myMultipleClickDelay;
        this._myDoubleClickTimer = 0;
      } else {
        this._myLastTarget.onClick(this._myLastTarget.object, this);
        this._myTripleClickTimer = 0;
        this._myDoubleClickTimer = this._myMultipleClickDelay;
        this._myMultipleClickObject = this._myLastTarget.object;
      }
      this._myLastTarget.onUp(this._myLastTarget.object, this);
      this._myLastTarget.onUnhover(this._myLastTarget.object, this);
      this._myLastTarget = null;
    }
  }
  onActivate() {
    this._myCursorObjectRoot.pp_setActive(true);
  }
  onDeactivate() {
    this._myCursorObjectRoot.pp_setActive(false);
  }
  _updateHand() {
    this._myHandInputSource = InputUtils.getInputSource(this._myHandednessType, InputSourceType.TRACKED_HAND, this.engine);
    if (this._myHandInputSource) {
      let tip = XRUtils.getFrame(this.engine).getJointPose(this._myHandInputSource.hand.get(TrackedHandJointID.INDEX_FINGER_TIP), this._myReferenceSpace);
      if (tip) {
        this._myCursorObject.pp_setRotationLocalQuat([
          tip.transform.orientation.x,
          tip.transform.orientation.y,
          tip.transform.orientation.z,
          tip.transform.orientation.w
        ]);
        this._myCursorObject.pp_setPositionLocal([
          tip.transform.position.x,
          tip.transform.position.y,
          tip.transform.position.z
        ]);
      }
    }
  }
  _onXRSessionStart(session) {
    session.requestReferenceSpace(XRUtils.getReferenceSpaceType(this.engine)).then(function(referenceSpace) {
      this._myReferenceSpace = referenceSpace;
    }.bind(this));
  }
  _onXRSessionEnd(session) {
    this._myReferenceSpace = null;
  }
};
__publicField(FingerCursorComponent, "TypeName", "pp-finger-cursor");
__publicField(FingerCursorComponent, "Properties", {
  _myHandedness: Property45.enum(["Left", "Right"], "Left"),
  _myMultipleClicksEnabled: Property45.bool(true),
  _myCollisionGroup: Property45.int(1),
  _myCollisionSize: Property45.float(0.0125),
  _myCursorObject: Property45.object(null)
});

// js/pp/input/cauldron/components/switch_hand_object_component.js
import { Component as Component46, Property as Property46 } from "@wonderlandengine/api";
var SwitchHandObjectComponent = class extends Component46 {
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myFirstUpdate = true;
    this._myCurrentInputSourceType = null;
  }
  onActivate() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      this._start();
    }
    let inputSourceType = InputUtils.getInputSourceTypeByHandedness(this._myHandednessType, this.engine);
    if (inputSourceType != null && this._myCurrentInputSourceType != inputSourceType) {
      this._myCurrentInputSourceType = inputSourceType;
      if (inputSourceType == InputSourceType.TRACKED_HAND) {
        if (this._myGamepad != null) {
          this._myGamepad.pp_setActive(false);
        }
        if (this._myTrackedHand != null) {
          this._myTrackedHand.pp_setActive(true);
        }
      } else if (inputSourceType == InputSourceType.GAMEPAD) {
        if (this._myTrackedHand != null) {
          this._myTrackedHand.pp_setActive(false);
        }
        if (this._myGamepad != null) {
          this._myGamepad.pp_setActive(true);
        }
      }
    }
  }
  _start() {
    if (this._myGamepad != null) {
      this._myGamepad.pp_setActive(false);
    }
    if (this._myTrackedHand != null) {
      this._myTrackedHand.pp_setActive(false);
    }
    this._myCurrentInputSourceType = null;
  }
};
__publicField(SwitchHandObjectComponent, "TypeName", "pp-switch-hand-object");
__publicField(SwitchHandObjectComponent, "Properties", {
  _myHandedness: Property46.enum(["Left", "Right"], "Left"),
  _myGamepad: Property46.object(),
  _myTrackedHand: Property46.object()
});

// js/pp/input/cauldron/components/tracked_hand_draw_joint_component.js
import { Component as Component47, MeshComponent as MeshComponent11, Property as Property47 } from "@wonderlandengine/api";

// js/pp/input/pose/tracked_hand_joint_pose.js
var TrackedHandJointPose = class extends BasePose {
  constructor(handedness, trackedHandJointID, basePoseParams = new BasePoseParams2()) {
    super(basePoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myTrackedHandJointID = trackedHandJointID;
    this._myJointRadius = 0;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getTrackedHandJointID() {
    return this._myTrackedHandJointID;
  }
  setTrackedHandJointID(trackedHandJointID) {
    this._myTrackedHandJointID = trackedHandJointID;
  }
  getJointRadius() {
    return this._myJointRadius;
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getJointPose(this._myInputSource.hand.get(this._myTrackedHandJointID), this._myReferenceSpace);
  }
  _updateHook(dt, updateVelocity, xrPose) {
    if (xrPose != null) {
      this._myJointRadius = xrPose.radius;
    }
  }
  _onXRSessionStartHook(manualCall, session) {
    session.addEventListener("inputsourceschange", function(event) {
      if (event.removed) {
        for (let item of event.removed) {
          if (item == this._myInputSource) {
            this._myInputSource = null;
          }
        }
      }
      if (event.added) {
        for (let item of event.added) {
          if (item.handedness == this._myHandedness) {
            if (InputUtils.getInputSourceType(item) == InputSourceType.TRACKED_HAND) {
              this._myInputSource = item;
            }
          }
        }
      }
    }.bind(this));
    if (manualCall && this._myInputSource == null && session.inputSources) {
      for (let item of session.inputSources) {
        if (item.handedness == this._myHandedness) {
          if (InputUtils.getInputSourceType(item) == InputSourceType.TRACKED_HAND) {
            this._myInputSource = item;
          }
        }
      }
    }
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
  }
};

// js/pp/input/cauldron/components/tracked_hand_draw_joint_component.js
var TrackedHandDrawJointComponent = class extends Component47 {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDInternal = InputUtils.getJointIDByIndex(this._myJointID);
    this._myTrackedHandJointPose = new TrackedHandJointPose(this._myHandednessType, this._myJointIDInternal, new BasePoseParams2(this.engine));
    this._myTrackedHandJointPose.setFixForward(this._myFixForward);
  }
  start() {
    this._myTrackedHandJointPose.start();
    this._buildTrackedHandHierarchy();
  }
  update(dt) {
    this._myTrackedHandJointPose.update(dt);
    this._myJointMeshObject.pp_setTransformLocalQuat(this._myTrackedHandJointPose.getTransformQuat());
    this._myJointMeshObject.pp_setScaleLocal(this._myTrackedHandJointPose.getJointRadius());
  }
  _buildTrackedHandHierarchy() {
    this._myJointMeshObject = this.object.pp_addObject();
    let mesh = this._myJointMeshObject.pp_addComponent(MeshComponent11);
    mesh.mesh = this._myJointMesh;
    mesh.material = this._myJointMaterial;
    this._myJointMeshObject.pp_setScaleLocal(0);
  }
};
__publicField(TrackedHandDrawJointComponent, "TypeName", "pp-tracked-hand-draw-joint");
__publicField(TrackedHandDrawJointComponent, "Properties", {
  _myHandedness: Property47.enum(["Left", "Right"], "Left"),
  _myFixForward: Property47.bool(true),
  _myJointID: Property47.enum(
    [
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ],
    "Wrist"
  ),
  _myJointMesh: Property47.mesh(),
  _myJointMaterial: Property47.material()
});

// js/pp/input/cauldron/components/tracked_hand_draw_all_joints_component.js
import { Component as Component48, Property as Property48 } from "@wonderlandengine/api";
var TrackedHandDrawAllJointsComponent = class extends Component48 {
  start() {
    this._buildTrackedHandHierarchy();
  }
  _buildTrackedHandHierarchy() {
    this._myTrackedHandMeshObject = this.object.pp_addObject();
    this._myJointMeshObjectList = [];
    for (let jointIDKey in TrackedHandJointID) {
      let jointID = TrackedHandJointID[jointIDKey];
      if (!this._myHideMetacarpals || jointID != TrackedHandJointID.THUMB_METACARPAL && jointID != TrackedHandJointID.INDEX_FINGER_METACARPAL && jointID != TrackedHandJointID.MIDDLE_FINGER_METACARPAL && jointID != TrackedHandJointID.RING_FINGER_METACARPAL && jointID != TrackedHandJointID.PINKY_FINGER_METACARPAL) {
        let jointObject = this._myTrackedHandMeshObject.pp_addObject();
        this._myJointMeshObjectList[jointID] = jointObject;
        jointObject.pp_addComponent(
          TrackedHandDrawJointComponent,
          {
            "_myHandedness": this._myHandedness,
            "_myFixForward": this._myFixForward,
            "_myJointID": TrackedHandJointIDIndex[jointIDKey],
            "_myJointMesh": this._myJointMesh,
            "_myJointMaterial": this._myJointMaterial
          }
        );
      }
    }
  }
};
__publicField(TrackedHandDrawAllJointsComponent, "TypeName", "pp-tracked-hand-draw-all-joints");
__publicField(TrackedHandDrawAllJointsComponent, "Properties", {
  _myHandedness: Property48.enum(["Left", "Right"], "Left"),
  _myFixForward: Property48.bool(true),
  _myHideMetacarpals: Property48.bool(true),
  _myJointMesh: Property48.mesh(),
  _myJointMaterial: Property48.material()
});

// js/pp/input/cauldron/components/tracked_hand_draw_skin_component.js
import { Component as Component49, Property as Property49 } from "@wonderlandengine/api";

// js/pp/input/pose/tracked_hand_pose.js
var TrackedHandPoseParams = class extends BasePoseParams2 {
  constructor(addAllJointIDs = true, engine2 = getMainEngine2()) {
    super(engine2);
    this.myTrackedHandJointIDList = [];
    if (addAllJointIDs) {
      for (let key in TrackedHandJointID) {
        this.myTrackedHandJointIDList.push([TrackedHandJointID[key]]);
      }
    }
  }
};
var TrackedHandPose = class {
  constructor(handedness, trackedHandPoseParams = new TrackedHandPoseParams()) {
    this._myHandedness = handedness;
    this._myFixForward = trackedHandPoseParams.myFixForward;
    this._myForceEmulatedVelocities = trackedHandPoseParams.myForceEmulatedVelocities;
    this._myReferenceObject = trackedHandPoseParams.myReferenceObject;
    this._myEngine = trackedHandPoseParams.myEngine;
    this._myTrackedHandJointPoseParams = new BasePoseParams2(this._myEngine);
    this._myTrackedHandJointPoseParams.myFixForward = this._myFixForward;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    this._myTrackedHandJointPoseList = [];
    for (let jointID of trackedHandPoseParams.myTrackedHandJointIDList) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoseList[jointID] = trackedHandJointPose;
    }
  }
  start() {
    for (let jointPoseKey in this._myTrackedHandJointPoseList) {
      let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
      jointPose.start();
    }
  }
  update(dt) {
    for (let jointPoseKey in this._myTrackedHandJointPoseList) {
      let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
      jointPose.update(dt);
    }
  }
  getEngine() {
    this._myEngine;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getJointPoseList() {
    return this._myTrackedHandJointPoseList;
  }
  getJointPose(jointID) {
    return this._myTrackedHandJointPoseList[jointID];
  }
  getJointPoseByIndex(jointIDIndex) {
    return this._myTrackedHandJointPoseList[InputUtils.getJointIDByIndex(jointIDIndex)];
  }
  addTrackedHandJointID(jointID) {
    if (!this._myTrackedHandJointPoseList.pp_has((element) => element.getTrackedHandJointID() == jointID)) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoseList.push(trackedHandJointPose);
    }
  }
  removeTrackedHandJointID(jointID) {
    this._myTrackedHandJointPoseList.pp_remove((element) => element.getTrackedHandJointID() == jointID);
  }
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    for (let jointPoseKey in this._myTrackedHandJointPoseList) {
      let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
      jointPose.setReferenceObject(referenceObject);
    }
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setFixForward(fixForward) {
    this._myFixForward = fixForward;
    this._myTrackedHandJointPoseParams.myFixForward = this._myFixForward;
    for (let jointPoseKey in this._myTrackedHandJointPoseList) {
      let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
      jointPose.setFixForward(fixForward);
    }
  }
  isFixForward() {
    return this._myFixForward;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    for (let jointPoseKey in this._myTrackedHandJointPoseList) {
      let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
      jointPose.setForceEmulatedVelocities(forceEmulatedVelocities);
    }
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
};

// js/pp/input/cauldron/components/tracked_hand_draw_skin_component.js
var TrackedHandDrawSkinComponent = class extends Component49 {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myTrackedHandPose = new TrackedHandPose(this._myHandednessType, new TrackedHandPoseParams(true, this.engine));
    this._myTrackedHandPose.setFixForward(this._myFixForward);
  }
  start() {
    this._myTrackedHandPose.start();
    this._prepareJoints();
  }
  update(dt) {
    this._myTrackedHandPose.update(dt);
    for (let i = 0; i < this._myJoints.length; i++) {
      let jointObject = this._myJoints[i];
      let jointID = jointObject.pp_getName();
      let jointPose = this._myTrackedHandPose.getJointPose(jointID);
      jointObject.pp_setTransformLocalQuat(jointPose.getTransformQuat());
    }
  }
  _prepareJoints() {
    this._myJoints = [];
    let skinJointIDs = this._myHandSkin.jointIds;
    for (let i = 0; i < skinJointIDs.length; i++) {
      this._myJoints[i] = this.engine.wrapObject(skinJointIDs[i]);
    }
  }
};
__publicField(TrackedHandDrawSkinComponent, "TypeName", "pp-tracked-hand-draw-skin");
__publicField(TrackedHandDrawSkinComponent, "Properties", {
  _myHandedness: Property49.enum(["Left", "Right"], "Left"),
  _myFixForward: Property49.bool(true),
  _myHandSkin: Property49.skin(null)
});

// js/pp/input/gamepad/cauldron/gamepad_mesh_animator_component.js
import { Component as Component50, Property as Property50 } from "@wonderlandengine/api";
var GamepadMeshAnimatorComponent = class extends Component50 {
  start() {
    let gamepad = null;
    if (this._myHandedness == HandednessIndex.LEFT) {
      gamepad = getLeftGamepad(this.engine);
    } else {
      gamepad = getRightGamepad(this.engine);
    }
    if (this._mySelect != null) {
      this._mySelectOriginalRotation = this._mySelect.pp_getRotationLocalQuat();
      this._mySelectOriginalLeft = this._mySelect.pp_getLeftLocal();
    }
    if (this._mySqueeze != null) {
      this._mySqueezeOriginalPosition = this._mySqueeze.pp_getPositionLocal();
      this._mySqueezeOriginalRotation = this._mySqueeze.pp_getRotationLocalQuat();
      this._mySqueezeOriginalLeft = this._mySqueeze.pp_getLeftLocal();
      this._mySqueezeOriginalForward = this._mySqueeze.pp_getForwardLocal();
    }
    if (this._myThumbstick != null) {
      this._myThumbstickOriginalPosition = this._myThumbstick.pp_getPositionLocal();
      this._myThumbstickOriginalRotation = this._myThumbstick.pp_getRotationLocalQuat();
      this._myThumbstickOriginalLeft = this._myThumbstick.pp_getLeftLocal();
      this._myThumbstickOriginalUp = this._myThumbstick.pp_getUpLocal();
      this._myThumbstickOriginalForward = this._myThumbstick.pp_getForwardLocal();
    }
    if (this._myTopButton != null) {
      this._myTopButtonOriginalPosition = this._myTopButton.pp_getPositionLocal();
      this._myTopButtonOriginalUp = this._myTopButton.pp_getUpLocal();
    }
    if (this._myBottomButton != null) {
      this._myBottomButtonOriginalPosition = this._myBottomButton.pp_getPositionLocal();
      this._myBottomButtonOriginalUp = this._myBottomButton.pp_getUpLocal();
    }
    if (this._myThumbstick != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_START, this, this._thumbstickPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_END, this, this._thumbstickPressedEnd.bind(this));
    }
    if (this._myTopButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_START, this, this._topButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_END, this, this._topButtonPressedEnd.bind(this));
    }
    if (this._myBottomButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_START, this, this._bottomButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_END, this, this._bottomButtonPressedEnd.bind(this));
    }
    if (this._mySelect != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.VALUE_CHANGED, this, this._selectValueChanged.bind(this));
    }
    if (this._mySqueeze != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.VALUE_CHANGED, this, this._squeezeValueChanged.bind(this));
    }
    if (this._myThumbstick != null) {
      gamepad.registerAxesEventListener(GamepadAxesID.THUMBSTICK, GamepadAxesEvent.AXES_CHANGED, this, this._thumbstickValueChanged.bind(this));
    }
  }
  _thumbstickPressedStart() {
  }
  _thumbstickPressedEnd(buttonInfo, gamepad) {
    this._myThumbstick.pp_setPositionLocal(this._myThumbstickOriginalPosition);
  }
  _topButtonPressedStart(buttonInfo, gamepad) {
    this._myTopButton.pp_translateAxisLocal(-this._myTopButtonPressOffset, this._myTopButtonOriginalUp);
  }
  _topButtonPressedEnd(buttonInfo, gamepad) {
    this._myTopButton.pp_setPositionLocal(this._myTopButtonOriginalPosition);
  }
  _bottomButtonPressedStart(buttonInfo, gamepad) {
    this._myBottomButton.pp_translateAxisLocal(-this._myBottomButtonPressOffset, this._myBottomButtonOriginalUp);
  }
  _bottomButtonPressedEnd(buttonInfo, gamepad) {
    this._myBottomButton.pp_setPositionLocal(this._myBottomButtonOriginalPosition);
  }
  _selectValueChanged(buttonInfo, gamepad) {
    this._mySelect.pp_setRotationLocalQuat(this._mySelectOriginalRotation);
    if (buttonInfo.myValue > 1e-5) {
      this._mySelect.pp_rotateAxisLocal(this._mySelectRotateAngle * buttonInfo.myValue, this._mySelectOriginalLeft);
    }
  }
  _squeezeValueChanged(buttonInfo, gamepad) {
    this._mySqueeze.pp_setPositionLocal(this._mySqueezeOriginalPosition);
    this._mySqueeze.pp_setRotationLocalQuat(this._mySqueezeOriginalRotation);
    if (buttonInfo.myValue > 1e-5) {
      if (this._myUsePressForSqueeze) {
        let translation = this._mySqueezePressOffset;
        if (this._myHandedness == 1) {
          translation *= -1;
        }
        this._mySqueeze.pp_translateAxisLocal(translation * buttonInfo.myValue, this._mySqueezeOriginalLeft);
      } else {
        let rotation = -this._mySqueezeRotateAngle;
        if (this._myHandedness == 1) {
          rotation *= -1;
        }
        this._mySqueeze.pp_rotateAxisLocal(rotation * buttonInfo.myValue, this._mySqueezeOriginalForward);
      }
    }
  }
  _thumbstickValueChanged(axesInfo, gamepad) {
    this._myThumbstick.pp_setRotationLocalQuat(this._myThumbstickOriginalRotation);
    let leftRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[1];
    let forwardRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[0];
    if (Math.abs(leftRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(leftRotation, this._myThumbstickOriginalLeft);
    }
    if (Math.abs(forwardRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(forwardRotation, this._myThumbstickOriginalForward);
    }
  }
};
__publicField(GamepadMeshAnimatorComponent, "TypeName", "pp-gamepad-mesh-animator");
__publicField(GamepadMeshAnimatorComponent, "Properties", {
  _myHandedness: Property50.enum(["Left", "Right"], "Left"),
  _mySelect: Property50.object(null),
  _mySqueeze: Property50.object(null),
  _myThumbstick: Property50.object(null),
  _myTopButton: Property50.object(null),
  _myBottomButton: Property50.object(null),
  _mySelectRotateAngle: Property50.float(15),
  _mySqueezeRotateAngle: Property50.float(11),
  _myThumbstickRotateAngle: Property50.float(15),
  _myThumbstickPressOffset: Property50.float(625e-6),
  _myTopButtonPressOffset: Property50.float(15e-4),
  _myBottomButtonPressOffset: Property50.float(15e-4),
  _myUsePressForSqueeze: Property50.bool(false),
  _mySqueezePressOffset: Property50.float(15e-4)
});
GamepadMeshAnimatorComponent.prototype._thumbstickPressedStart = function() {
  let upTranslation = vec3_create2();
  return function _thumbstickPressedStart(buttonInfo, gamepad) {
    this._myThumbstickOriginalUp.vec3_scale(-this._myThumbstickPressOffset, upTranslation);
    this._myThumbstick.pp_translateLocal(upTranslation);
  };
}();

// js/pp/input/gamepad/cauldron/gamepad_utils.js
var _mySimultaneousPressMaxDelay = 0.15;
var _mySimultaneousTouchMaxDelay = 0.15;
function setSimultaneousPressMaxDelay(simultaneousPressMaxDelay) {
  _mySimultaneousPressMaxDelay = simultaneousPressMaxDelay;
}
function setSimultaneousTouchMaxDelay(simultaneousTouchMaxDelay) {
  _mySimultaneousTouchMaxDelay = simultaneousTouchMaxDelay;
}
function getSimultaneousPressMaxDelay() {
  return _mySimultaneousPressMaxDelay;
}
function getSimultaneousTouchMaxDelay() {
  return _mySimultaneousTouchMaxDelay;
}
function isAnyButtonPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let isOnePressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressStart(multiplePressCount)) {
        isOnePressStart = true;
        break;
      }
    }
    if (isOnePressStart) {
      break;
    }
  }
  return isOnePressStart;
}
function areButtonsPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonPressedRecently = true;
  let isOnePressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myIsPressed && (multiplePressCount == null || button.myMultiplePressStartCount == multiplePressCount) && button.myTimePressed < _mySimultaneousPressMaxDelay)) {
        areButtonPressedRecently = false;
        break;
      }
      if (button.isPressStart(multiplePressCount)) {
        isOnePressStart = true;
      }
    }
    if (!areButtonPressedRecently) {
      break;
    }
  }
  return areButtonPressedRecently && isOnePressStart;
}
function isAnyButtonPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let isOnePressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressEnd(multiplePressCount)) {
        isOnePressEnd = true;
        break;
      }
    }
    if (isOnePressEnd) {
      break;
    }
  }
  return isOnePressEnd;
}
function areButtonsPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotPressedRecently = true;
  let isOnePressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myIsPressed && (multiplePressCount == null || button.myMultiplePressEndCount == multiplePressCount) && button.myTimeNotPressed < _mySimultaneousPressMaxDelay)) {
        areButtonNotPressedRecently = false;
        break;
      }
      if (button.isPressEnd(multiplePressCount)) {
        isOnePressEnd = true;
      }
    }
    if (!areButtonNotPressedRecently) {
      break;
    }
  }
  return areButtonNotPressedRecently && isOnePressEnd;
}
function isAnyButtonTouchStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let isOneTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchStart(multiplePressCount)) {
        isOneTouchStart = true;
        break;
      }
    }
    if (isOneTouchStart) {
      break;
    }
  }
  return isOneTouchStart;
}
function areButtonsTouchStart(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonTouchedRecently = true;
  let isOneTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myIsTouched && (multipleTouchCount == null || button.myMultipleTouchStartCount == multipleTouchCount) && button.myTimeTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonTouchedRecently = false;
        break;
      }
      if (button.isTouchStart(multipleTouchCount)) {
        isOneTouchStart = true;
      }
    }
    if (!areButtonTouchedRecently) {
      break;
    }
  }
  return areButtonTouchedRecently && isOneTouchStart;
}
function isAnyButtonTouchEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let isOneTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchEnd(multiplePressCount)) {
        isOneTouchEnd = true;
        break;
      }
    }
    if (isOneTouchEnd) {
      break;
    }
  }
  return isOneTouchEnd;
}
function areButtonsTouchEnd(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotTouchedRecently = true;
  let isOneTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myIsTouched && (multipleTouchCount == null || button.myMultipleTouchEndCount == multipleTouchCount) && button.myTimeNotTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonNotTouchedRecently = false;
        break;
      }
      if (button.isTouchEnd(multipleTouchCount)) {
        isOneTouchEnd = true;
      }
    }
    if (!areButtonNotTouchedRecently) {
      break;
    }
  }
  return areButtonNotTouchedRecently && isOneTouchEnd;
}
var GamepadUtils = {
  setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay,
  getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay,
  isAnyButtonPressStart,
  areButtonsPressStart,
  areButtonsPressEnd,
  isAnyButtonTouchStart,
  areButtonsTouchStart,
  isAnyButtonTouchEnd,
  areButtonsTouchEnd
};

// js/pp/input/gamepad/cauldron/gamepad_control_scheme_component.js
import { Component as Component51, Property as Property51, MeshComponent as MeshComponent12, TextComponent as TextComponent8, Alignment as Alignment3, Justification as Justification3 } from "@wonderlandengine/api";
var GamepadControlSchemeComponent = class extends Component51 {
  start() {
    this._myTextMaterialFinal = this._myTextMaterial != null ? this._myTextMaterial : getDefaultResources(this.engine).myMaterials.myText.clone();
    this._myLineMaterialFinal = this._myLineMaterial != null ? this._myLineMaterial : getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myControlSchemeDirection = this._myHandednessType == Handedness.LEFT ? 1 : -1;
    this._myVisible = false;
    this._mySetVisibleNextUpdate = false;
    this._createControlScheme();
    this.setVisible(this._myShowOnStart);
    this._myVisibleBackup = this._myVisible;
  }
  update(dt) {
    if (this._mySetVisibleNextUpdate) {
      this._mySetVisibleNextUpdate = false;
      this.setVisible(false);
      this.setVisible(this._myVisibleBackup);
    }
  }
  onActivate() {
    this._mySetVisibleNextUpdate = true;
  }
  onDeactivate() {
    this._myVisibleBackup = this._myVisible;
    this.setVisible(false);
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    this._myVisible = visible;
    if (this._myRootObject != null) {
      this._myRootObject.pp_setActive(this._myVisible);
      if (this._myVisible) {
        this._hideEmptySchemes();
      }
    }
  }
  setSelectText(text) {
    this._mySelectText = text;
    this._mySelectTextComponent.text = this._mySelectText;
    this.setVisible(this._myVisible);
  }
  setSqueezeText(text) {
    this._mySqueezeText = text;
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this.setVisible(this._myVisible);
  }
  setThumbstickText(text) {
    this._myThumbstickText = text;
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    this.setVisible(this._myVisible);
  }
  setBottomButtonText(text) {
    this._myBottomButtonText = text;
    this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    this.setVisible(this._myVisible);
  }
  setTopButtonText(text) {
    this._myTopButtonText = text;
    this._myTopButtonTextComponent.text = this._myTopButtonText;
    this.setVisible(this._myVisible);
  }
  _createControlScheme() {
    this._myRootObject = this.object.pp_addObject();
    let distanceFromButton = 0.02 * this._myDistanceFromButtonsMultiplier;
    let lineLength = 0.0935 * this._myLineLengthMultiplier;
    let referenceObject = this._myThumbstick;
    this._mySelectObject = this._myRootObject.pp_addObject();
    this._mySelectTextComponent = this._addScheme(
      this._mySelect,
      referenceObject,
      vec3_create2(0, 0, distanceFromButton),
      vec3_create2(lineLength * this._myControlSchemeDirection, 0, 0),
      this._mySelectObject
    );
    this._mySelectTextComponent.text = this._mySelectText;
    this._mySqueezeObject = this._myRootObject.pp_addObject();
    this._mySqueezeTextComponent = this._addScheme(
      this._mySqueeze,
      referenceObject,
      vec3_create2(distanceFromButton * this._myControlSchemeDirection, 0, 0),
      vec3_create2(lineLength * this._myControlSchemeDirection, 0, 0),
      this._mySqueezeObject
    );
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this._myThumbstickObject = this._myRootObject.pp_addObject();
    this._myThumbstickTextComponent = this._addScheme(
      this._myThumbstick,
      referenceObject,
      vec3_create2(0, distanceFromButton, 0),
      vec3_create2(-lineLength * this._myControlSchemeDirection, 0, 0),
      this._myThumbstickObject
    );
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    let thumbstickPositionLocal = this._myThumbstick.pp_getPositionLocal();
    let thumbstickUpLocal = this._myThumbstick.pp_getUpLocal();
    {
      let bottomButtonPositionLocal = this._myBottomButton.pp_getPositionLocal();
      let difference = bottomButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myBottomButtonObject = this._myRootObject.pp_addObject();
      this._myBottomButtonTextComponent = this._addScheme(
        this._myBottomButton,
        referenceObject,
        vec3_create2(0, distanceFromButton - differenceOnUp, 0),
        vec3_create2(0, 0, -lineLength),
        this._myBottomButtonObject
      );
      this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    }
    {
      let topButtonPositionLocal = this._myTopButton.pp_getPositionLocal();
      let difference = topButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myTopButtonObject = this._myRootObject.pp_addObject();
      this._myTopButtonTextComponent = this._addScheme(
        this._myTopButton,
        referenceObject,
        vec3_create2(0, distanceFromButton - differenceOnUp, 0),
        vec3_create2(-lineLength * this._myControlSchemeDirection, 0, 0).vec3_rotateAxis(-45 * this._myControlSchemeDirection, vec3_create2(0, 1, 0)),
        this._myTopButtonObject
      );
      this._myTopButtonTextComponent.text = this._myTopButtonText;
    }
  }
  _addScheme(buttonObject, referenceObject, startOffset, endOffset, parentObject) {
    let buttonPosition = buttonObject.pp_getPositionLocal();
    let referenceForward = referenceObject.pp_getForwardLocal();
    let referenceRight = referenceObject.pp_getRightLocal();
    let referenceUp = referenceObject.pp_getUpLocal();
    let lineStart = buttonPosition.vec3_add(referenceRight.vec3_scale(startOffset[0]));
    lineStart.vec3_add(referenceUp.vec3_scale(startOffset[1]), lineStart);
    lineStart.vec3_add(referenceForward.vec3_scale(startOffset[2]), lineStart);
    let lineEnd = lineStart.vec3_add(referenceRight.vec3_scale(endOffset[0]));
    lineEnd.vec3_add(referenceUp.vec3_scale(endOffset[1]), lineEnd);
    lineEnd.vec3_add(referenceForward.vec3_scale(endOffset[2]), lineEnd);
    let textOffset = 0.01 * this._myTextOffsetMultiplier;
    let textPosition = lineEnd.vec3_add(referenceForward.vec3_scale(-textOffset));
    this._addLine(lineStart, lineEnd, parentObject);
    let textComponent = this._addText(textPosition, referenceForward, referenceUp, parentObject);
    return textComponent;
  }
  _addLine(start, end, parentObject) {
    let lineDirection = end.vec3_sub(start);
    let length2 = lineDirection.vec3_length();
    lineDirection.vec3_normalize(lineDirection);
    lineRootObject = parentObject.pp_addObject();
    lineObject = lineRootObject.pp_addObject();
    let lineMesh = lineObject.pp_addComponent(MeshComponent12);
    lineMesh.mesh = getDefaultResources(this.engine).myMeshes.myCylinder;
    lineMesh.material = this._myLineMaterialFinal;
    lineRootObject.pp_setPositionLocal(start);
    let thickness = 1e-3 * this._myLineThicknessMultiplier;
    lineObject.pp_scaleObject(vec3_create2(thickness / 2, length2 / 2, thickness / 2));
    lineObject.pp_setUpLocal(lineDirection);
    lineObject.pp_translateObject(vec3_create2(0, length2 / 2, 0));
  }
  _addText(position, forward, up, parentObject) {
    let textObject = parentObject.pp_addObject();
    textObject.pp_setPositionLocal(position);
    textObject.pp_lookToLocal(up, forward);
    textObject.pp_scaleObject(0.0935 * this._myTextScaleMultiplier);
    let textComponent = textObject.pp_addComponent(TextComponent8);
    textComponent.alignment = Alignment3.Center;
    textComponent.justification = Justification3.Top;
    textComponent.material = this._myTextMaterialFinal;
    return textComponent;
  }
  _hideEmptySchemes() {
    if (this._mySelectText.length == 0) {
      this._mySelectObject.pp_setActive(false);
    }
    if (this._mySqueezeText.length == 0) {
      this._mySqueezeObject.pp_setActive(false);
    }
    if (this._myThumbstickText.length == 0) {
      this._myThumbstickObject.pp_setActive(false);
    }
    if (this._myBottomButtonText.length == 0) {
      this._myBottomButtonObject.pp_setActive(false);
    }
    if (this._myTopButtonText.length == 0) {
      this._myTopButtonObject.pp_setActive(false);
    }
  }
};
__publicField(GamepadControlSchemeComponent, "TypeName", "pp-gamepad-control-scheme");
__publicField(GamepadControlSchemeComponent, "Properties", {
  _myShowOnStart: Property51.bool(true),
  _myHandedness: Property51.enum(["Left", "Right"], "Left"),
  _mySelectText: Property51.string(""),
  _mySqueezeText: Property51.string(""),
  _myThumbstickText: Property51.string(""),
  _myBottomButtonText: Property51.string(""),
  _myTopButtonText: Property51.string(""),
  _mySelect: Property51.object(null),
  _mySqueeze: Property51.object(null),
  _myThumbstick: Property51.object(null),
  _myBottomButton: Property51.object(null),
  _myTopButton: Property51.object(null),
  _myTextScaleMultiplier: Property51.float(1),
  _myTextOffsetMultiplier: Property51.float(1),
  _myLineLengthMultiplier: Property51.float(1),
  _myLineThicknessMultiplier: Property51.float(1),
  _myDistanceFromButtonsMultiplier: Property51.float(1),
  _myTextMaterial: Property51.material(),
  _myLineMaterial: Property51.material()
});

// js/pp/input/gamepad/gamepad_cores/virtual_gamepad_gamepad_core.js
var VirtualGamepadGamepadCore = class extends GamepadCore {
  constructor(virtualGamepad, handPose) {
    super(handPose);
    this._myVirtualGamepad = virtualGamepad;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this._myVirtualGamepad.isVisible();
  }
  getButtonData(buttonID) {
    this._myButtonData.myIsPressed = false;
    this._myButtonData.myIsTouched = false;
    this._myButtonData.myValue = 0;
    if (this.isGamepadCoreActive()) {
      if (this._myVirtualGamepad.isButtonPressed(this.getHandedness(), buttonID)) {
        this._myButtonData.myIsPressed = true;
        this._myButtonData.myIsTouched = true;
        this._myButtonData.myValue = 1;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    if (this.isGamepadCoreActive()) {
      this._myVirtualGamepad.getAxes(this.getHandedness(), axesID, this._myAxesData);
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_icon.js
var VirtualGamepadIconType = {
  NONE: 0,
  LABEL: 1,
  IMAGE: 2,
  DOT: 3,
  CIRCLE: 4,
  SQUARE: 5,
  RING: 6,
  FRAME: 7
};
var VirtualGamepadIconParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myBackgroundPressedColor = "";
    this.myIconColor = "";
    this.myIconPressedColor = "";
    this.myIconType = VirtualGamepadIconType.NONE;
    this.myOverallHoveredBrightness = 1;
    this.myLabel = "";
    this.myLabelFontSize = 0;
    this.myLabelFontFamily = "";
    this.myLabelFontWeight = "";
    this.myImageURL = "";
    this.myImagePressedBrightness = 1;
  }
};
var VirtualGamepadIcon = class {
  constructor(iconElementParent, iconParams, minSizeMultiplier, scale) {
    this._myParams = iconParams;
    this._myIconContainerElement = null;
    this._myBackgroundElement = null;
    this._myIconElement = null;
    this._myPressed = false;
    this._myIsMouseHover = false;
    this._myIsMouseHoverActive = true;
    this._build(iconElementParent, minSizeMultiplier, scale);
  }
  update(dt) {
    if (this._myPressed || !this._myIsMouseHover || !this._myIsMouseHoverActive) {
      this._myIconContainerElement.style.filter = "none";
    } else {
      this._myIconContainerElement.style.filter = "brightness(" + this._myParams.myOverallHoveredBrightness + ")";
    }
  }
  reset() {
    this.setPressed(false);
    this._myIsMouseHover = false;
    this._myIconContainerElement.style.filter = "none";
  }
  setPressed(pressed) {
    if (this._myPressed != pressed) {
      this._myPressed = pressed;
      if (this._myPressed) {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundPressedColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconPressedColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconPressedColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "brightness(" + this._myParams.myImagePressedBrightness + ")";
          }
        }
      } else {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "none";
          }
        }
      }
    }
  }
  onMouseEnter() {
    this._myIsMouseHover = true;
  }
  onMouseLeave() {
    this._myIsMouseHover = false;
  }
  setMouseHoverActive(hoverActive) {
    this._myIsMouseHoverActive = hoverActive;
  }
  _build(iconElementParent, minSizeMultiplier, scale) {
    this._myIconContainerElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._myIconContainerElement.style.position = "absolute";
    this._myIconContainerElement.style.width = "100%";
    this._myIconContainerElement.style.height = "100%";
    iconElementParent.appendChild(this._myIconContainerElement);
    this._myBackgroundElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myBackgroundElement.setAttributeNS(null, "cx", "50%");
    this._myBackgroundElement.setAttributeNS(null, "cy", "50%");
    this._myBackgroundElement.setAttributeNS(null, "r", "50%");
    this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
    this._myIconContainerElement.appendChild(this._myBackgroundElement);
    switch (this._myParams.myIconType) {
      case VirtualGamepadIconType.NONE:
        break;
      case VirtualGamepadIconType.LABEL:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        this._myIconElement.setAttributeNS(null, "x", "50%");
        this._myIconElement.setAttributeNS(null, "y", "50%");
        this._myIconElement.style.textAlign = "center";
        this._myIconElement.style.textAnchor = "middle";
        this._myIconElement.style.dominantBaseline = "central";
        this._myIconElement.style.alignmentBaseline = "central";
        this._myIconElement.style.fontFamily = this._myParams.myLabelFontFamily;
        this._myIconElement.style.fontWeight = this._myParams.myLabelFontWeight;
        this._myIconElement.style.fontSize = this._createSizeValue(this._myParams.myLabelFontSize * scale, minSizeMultiplier);
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.textContent = this._myParams.myLabel;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.IMAGE:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
        this._myIconElement.setAttributeNS(null, "x", "0%");
        this._myIconElement.setAttributeNS(null, "y", "0%");
        this._myIconElement.setAttribute("href", this._myParams.myImageURL);
        this._myIconElement.style.width = "100%";
        this._myIconElement.style.height = "100%";
        this._myIconElement.style.filter = "none";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.DOT:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "17.5%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.CIRCLE:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "24%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.SQUARE:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "28%");
        this._myIconElement.setAttributeNS(null, "y", "28%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "44%");
        this._myIconElement.setAttributeNS(null, "height", "44%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.RING:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "20%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.FRAME:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "31.5%");
        this._myIconElement.setAttributeNS(null, "y", "31.5%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "37%");
        this._myIconElement.setAttributeNS(null, "height", "37%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _invertColors() {
    if (this._myIconElement.style.strokeWidth.length > 0) {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.stroke = this._myParams.myBackgroundColor;
    } else {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myBackgroundColor;
    }
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_params.js
var VirtualGamepadButtonParams = class {
  constructor() {
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadThumbstickParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myMaxDistanceFromCenterMultiplier = 1;
    this.myReleaseTransitionSeconds = 0.2;
    this.myMoveTransitionSeconds = 0;
    this.myIncludeBackgroundToDetection = false;
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadParams = class {
  constructor(engine2 = getMainEngine2()) {
    this.myShowOnDesktop = false;
    this.myShowOnMobile = false;
    this.myShowOnHeadset = false;
    this.myAutoUpdateVisibility = false;
    this.myOpacity = 1;
    this.myInterfaceScale = 1;
    this.myMarginScale = 1;
    this.myReleaseOnPointerLeave = true;
    this.myStopPropagatingMouseDownEvents = true;
    this.myButtonParams = [];
    this.myButtonParams[Handedness.LEFT] = [];
    this.myButtonParams[Handedness.RIGHT] = [];
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON] = new VirtualGamepadButtonParams();
    this.myThumbstickParams = [];
    this.myThumbstickParams[Handedness.LEFT] = [];
    this.myThumbstickParams[Handedness.RIGHT] = [];
    this.myThumbstickParams[Handedness.LEFT][GamepadAxesID.THUMBSTICK] = new VirtualGamepadThumbstickParams();
    this.myThumbstickParams[Handedness.RIGHT][GamepadAxesID.THUMBSTICK] = new VirtualGamepadThumbstickParams();
    this.myButtonsOrder = [];
    this.myButtonsOrder[Handedness.LEFT] = [null, null, null, null, null];
    this.myButtonsOrder[Handedness.RIGHT] = [null, null, null, null, null];
    this.myThumbsticksOrder = [];
    this.myThumbsticksOrder[Handedness.LEFT] = [null];
    this.myThumbsticksOrder[Handedness.RIGHT] = [null];
    this.myValidPointerButtons = [];
    this.myMarginLeft = 0;
    this.myMarginRight = 0;
    this.myMarginBottom = 0;
    this.myThumbstickSize = 0;
    this.myButtonSize = 0;
    this.myButtonsRingRadius = 0;
    this.myButtonsRingStartAngle = 0;
    this.myButtonsRingEndAngle = 0;
    this.myFontSize = 0;
    this.myMinSizeMultiplier = 0;
    this.myDisableMouseHoverWhenPressed = false;
    this.myEngine = engine2;
  }
  defaultSetup() {
    this.myShowOnMobile = true;
    this.myAutoUpdateVisibility = true;
    this.myOpacity = 0.5;
    let backgroundColor = "#616161";
    let iconColor = "#e0e0e0";
    let buttonHoveredBrightness = 0.75;
    let thumbstickHoveredBrightness = 0.75;
    let thumbstickIncludeBackgroundToDetection = true;
    for (let handedness in this.myButtonParams) {
      for (let gamepadButtonID in this.myButtonParams[handedness]) {
        let buttonParams = this.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = backgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = iconColor;
        buttonParams.myIconParams.myIconColor = iconColor;
        buttonParams.myIconParams.myIconPressedColor = backgroundColor;
        buttonParams.myIconParams.myOverallHoveredBrightness = buttonHoveredBrightness;
      }
    }
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    for (let handedness in this.myThumbstickParams) {
      for (let gamepadAxesID in this.myThumbstickParams[handedness]) {
        let thumbstickParams = this.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = backgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = iconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = iconColor;
        thumbstickParams.myIconParams.myIconColor = backgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = backgroundColor;
        thumbstickParams.myIconParams.myOverallHoveredBrightness = thumbstickHoveredBrightness;
        thumbstickParams.myIncludeBackgroundToDetection = thumbstickIncludeBackgroundToDetection;
      }
    }
    this.myButtonsOrder[Handedness.LEFT][0] = [Handedness.LEFT, GamepadButtonID.SQUEEZE];
    this.myButtonsOrder[Handedness.LEFT][1] = [Handedness.LEFT, GamepadButtonID.SELECT];
    this.myButtonsOrder[Handedness.LEFT][2] = [Handedness.LEFT, GamepadButtonID.TOP_BUTTON];
    this.myButtonsOrder[Handedness.LEFT][3] = [Handedness.LEFT, GamepadButtonID.BOTTOM_BUTTON];
    this.myButtonsOrder[Handedness.LEFT][4] = [Handedness.LEFT, GamepadButtonID.THUMBSTICK];
    this.myButtonsOrder[Handedness.RIGHT][0] = [Handedness.RIGHT, GamepadButtonID.SQUEEZE];
    this.myButtonsOrder[Handedness.RIGHT][1] = [Handedness.RIGHT, GamepadButtonID.SELECT];
    this.myButtonsOrder[Handedness.RIGHT][2] = [Handedness.RIGHT, GamepadButtonID.TOP_BUTTON];
    this.myButtonsOrder[Handedness.RIGHT][3] = [Handedness.RIGHT, GamepadButtonID.BOTTOM_BUTTON];
    this.myButtonsOrder[Handedness.RIGHT][4] = [Handedness.RIGHT, GamepadButtonID.THUMBSTICK];
    this.myThumbsticksOrder[Handedness.LEFT][0] = [Handedness.LEFT, GamepadAxesID.THUMBSTICK];
    this.myThumbsticksOrder[Handedness.RIGHT][0] = [Handedness.RIGHT, GamepadAxesID.THUMBSTICK];
    this.myMarginLeft = 3;
    this.myMarginRight = 3;
    this.myMarginBottom = 3;
    this.myThumbstickSize = 15;
    this.myButtonSize = 5;
    this.myButtonsRingRadius = 12;
    this.myButtonsRingStartAngle = 385;
    this.myButtonsRingEndAngle = 245;
    this.myMinSizeMultiplier = 5 / 3;
    this.myDisableMouseHoverWhenPressed = true;
    this.myValidPointerButtons = [0];
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_button.js
var VirtualGamepadVirtualButton = class {
  constructor(buttonElementParent, virtualGamepadParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
    this._myButtonElement = null;
    this._myButtonIcon = null;
    this._myButtonDetectionElement = null;
    this._myIsActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myIsPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myButtonParams[gamepadButtonHandedness][gamepadButtonID];
    this._build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex);
    this._myButtonDetectionElement.addEventListener("pointerdown", this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents));
    document.body.addEventListener("pointerup", this._onPointerUp.bind(this));
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      document.body.addEventListener("pointerleave", this._onPointerLeave.bind(this));
    }
    this._myButtonDetectionElement.addEventListener("mouseenter", this._onButtonEnter.bind(this));
    this._myButtonDetectionElement.addEventListener("mouseleave", this._onButtonLeave.bind(this));
  }
  isPressed() {
    return this._myIsActive && this._myIsPressed;
  }
  setActive(active) {
    if (this._myIsActive != active) {
      this.reset();
      this._myButtonIcon.reset();
    }
    this._myIsActive = active;
  }
  setMouseHoverActive(hoverActive) {
    this._myButtonIcon.setMouseHoverActive(hoverActive);
  }
  reset() {
    this._myButtonIcon.setPressed(false);
    this._myIsPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
  }
  update(dt) {
    this._myButtonIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myIsActive)
      return;
    if (this._myIsPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myButtonIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myIsPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myIsActive)
      return;
    if (!this._myIsPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myIsActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onButtonEnter(event) {
    if (!this._myIsActive)
      return;
    this._myButtonIcon.onMouseEnter(event);
  }
  _onButtonLeave(event) {
    if (!this._myIsActive)
      return;
    this._myButtonIcon.onMouseLeave(event);
  }
  _build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex) {
    let buttonSize = this._myVirtualGamepadParams.myButtonSize * this._myVirtualGamepadParams.myInterfaceScale;
    let buttonsRingRadius = this._myVirtualGamepadParams.myButtonsRingRadius * this._myVirtualGamepadParams.myInterfaceScale;
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let buttonRingStartAngle = this._myVirtualGamepadParams.myButtonsRingStartAngle;
    let buttonRingEndAngle = this._myVirtualGamepadParams.myButtonsRingEndAngle;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    let buttonsAmount = this._myVirtualGamepadParams.myButtonsOrder[Handedness.LEFT].length;
    let angleStep = (buttonRingEndAngle - buttonRingStartAngle) / (buttonsAmount - 1);
    let currentAngle = Math.pp_angleClamp(buttonRingStartAngle + angleStep * virtualButtonIndex);
    if (virtualButtonHandedness == Handedness.RIGHT) {
      currentAngle = 270 + (270 - currentAngle);
      currentAngle = Math.pp_angleClamp(currentAngle, true);
    }
    let counterAngle = 360 - currentAngle;
    let buttonPivot = document.createElement("div");
    buttonPivot.style.position = "absolute";
    buttonPivot.style.width = this._createSizeValue(buttonSize, minSizeMultiplier);
    buttonPivot.style.height = this._createSizeValue(buttonSize, minSizeMultiplier);
    let centerOnThumbstickBottom = marginBottom + thumbstickSize / 2 - buttonSize / 2;
    buttonPivot.style.bottom = this._createSizeValue(centerOnThumbstickBottom, minSizeMultiplier);
    if (virtualButtonHandedness == Handedness.LEFT) {
      let centerOnThumbstickLeft = marginLeft + thumbstickSize / 2 - buttonSize / 2;
      buttonPivot.style.left = this._createSizeValue(centerOnThumbstickLeft, minSizeMultiplier);
    } else {
      let centerOnThumbstickRight = marginRight + thumbstickSize / 2 - buttonSize / 2;
      buttonPivot.style.right = this._createSizeValue(centerOnThumbstickRight, minSizeMultiplier);
    }
    buttonPivot.style.transform = "rotate(" + currentAngle + "deg) translateX(" + this._createSizeValue(buttonsRingRadius, minSizeMultiplier) + ")";
    buttonElementParent.appendChild(buttonPivot);
    this._myButtonElement = document.createElement("div");
    this._myButtonElement.style.position = "absolute";
    this._myButtonElement.style.width = "100%";
    this._myButtonElement.style.height = "100%";
    this._myButtonElement.style.transform = "rotate(" + counterAngle + "deg)";
    buttonPivot.appendChild(this._myButtonElement);
    this._myButtonIcon = new VirtualGamepadIcon(this._myButtonElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myInterfaceScale);
    let buttonElementStill = document.createElement("div");
    buttonElementStill.style.position = "absolute";
    buttonElementStill.style.width = "100%";
    buttonElementStill.style.height = "100%";
    buttonElementStill.style.transform = "rotate(" + counterAngle + "deg)";
    buttonPivot.appendChild(buttonElementStill);
    let buttonDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    buttonDetectionElementSVG.style.position = "absolute";
    buttonDetectionElementSVG.style.width = "100%";
    buttonDetectionElementSVG.style.height = "100%";
    buttonElementStill.appendChild(buttonDetectionElementSVG);
    let buttonDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    buttonDetectionElement.setAttributeNS(null, "cx", "50%");
    buttonDetectionElement.setAttributeNS(null, "cy", "50%");
    buttonDetectionElement.setAttributeNS(null, "r", "50%");
    buttonDetectionElement.style.fill = "#00000000";
    buttonDetectionElementSVG.appendChild(buttonDetectionElement);
    this._myButtonDetectionElement = buttonDetectionElement;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_thumbstick.js
var VirtualGamepadVirtualThumbstick = class {
  constructor(thumbstickElementParent, virtualGamepadParams, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID) {
    this._myThumbstickElement = null;
    this._myThumbstickIcon = null;
    this._myThumbstickBackground = null;
    this._myThumbstickDetectionElement = null;
    this._myIsActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickDragStartPosition = vec2_create();
    this._myAxes = vec2_create();
    this._myIsPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myThumbstickParams[gamepadThumbstickHandedness][gamepadAxesID];
    this._build(thumbstickElementParent, virtualThumbstickHandedness);
    this._myThumbstickDetectionElement.addEventListener("pointerdown", this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents));
    document.body.addEventListener("pointerup", this._onPointerUp.bind(this));
    document.body.addEventListener("pointermove", this._onPointerMove.bind(this));
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      document.body.addEventListener("pointerleave", this._onPointerLeave.bind(this));
    }
    this._myThumbstickDetectionElement.addEventListener("mouseenter", this._onThumbstickEnter.bind(this));
    this._myThumbstickDetectionElement.addEventListener("mouseleave", this._onThumbstickLeave.bind(this));
  }
  isPressed() {
    return this._myIsActive && this._myIsPressed;
  }
  getAxes() {
    return this._myAxes;
  }
  setActive(active) {
    if (this._myIsActive != active) {
      this.reset();
      this._myThumbstickIcon.reset();
    }
    this._myIsActive = active;
  }
  setMouseHoverActive(hoverActive) {
    this._myThumbstickIcon.setMouseHoverActive(hoverActive);
  }
  reset() {
    this._myThumbstickIcon.setPressed(false);
    this._myAxes[0] = 0;
    this._myAxes[1] = 0;
    this._myIsPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickElement.style.transition = "all " + this._myParams.myReleaseTransitionSeconds + "s ease 0s";
    this._myThumbstickElement.style.transform = "translate(0px, 0px)";
  }
  update(dt) {
    this._myThumbstickIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myIsActive)
      return;
    if (this._myIsPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myThumbstickIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myThumbstickDragStartPosition[0] = event.clientX;
    this._myThumbstickDragStartPosition[1] = event.clientY;
    this._myIsPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myIsActive)
      return;
    if (!this._myIsPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myIsActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onThumbstickEnter(event) {
    this._myThumbstickIcon.onMouseEnter(event);
  }
  _onThumbstickLeave(event) {
    this._myThumbstickIcon.onMouseLeave(event);
  }
  _onPointerMove(event) {
    if (!this._myIsActive)
      return;
    if (!this._myIsPressed)
      return;
    if (event.pointerId != this._myPointerID)
      return;
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let backgroundRect = this._myThumbstickBackground.getBoundingClientRect();
    let maxDistanceFromCenter = backgroundRect.width / 2 * this._myParams.myMaxDistanceFromCenterMultiplier;
    let xDiff = mouseX - this._myThumbstickDragStartPosition[0];
    let yDiff = mouseY - this._myThumbstickDragStartPosition[1];
    let angle = Math.atan2(yDiff, xDiff);
    let distanceFromDragStart = Math.min(maxDistanceFromCenter, Math.hypot(xDiff, yDiff));
    let translateThumbstickX = distanceFromDragStart * Math.cos(angle);
    let translateThumbstickY = distanceFromDragStart * Math.sin(angle);
    this._myThumbstickElement.style.transition = "all " + this._myParams.myMoveTransitionSeconds + "s ease-out 0s";
    this._myThumbstickElement.style.transform = "translate(" + translateThumbstickX + "px, " + translateThumbstickY + "px)";
    this._myAxes[0] = translateThumbstickX / maxDistanceFromCenter;
    this._myAxes[1] = -(translateThumbstickY / maxDistanceFromCenter);
  }
  _build(thumbstickElementParent, virtualThumbstickHandedness) {
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    let thumbstickContainer = document.createElement("div");
    thumbstickContainer.style.position = "absolute";
    thumbstickContainer.style.width = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    thumbstickContainer.style.height = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    thumbstickContainer.style.bottom = this._createSizeValue(marginBottom, minSizeMultiplier);
    if (virtualThumbstickHandedness == Handedness.LEFT) {
      thumbstickContainer.style.left = this._createSizeValue(marginLeft, minSizeMultiplier);
    } else {
      thumbstickContainer.style.right = this._createSizeValue(marginRight, minSizeMultiplier);
    }
    thumbstickElementParent.appendChild(thumbstickContainer);
    let thumbstickContainerSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    thumbstickContainerSVG.style.position = "absolute";
    thumbstickContainerSVG.style.width = "100%";
    thumbstickContainerSVG.style.height = "100%";
    thumbstickContainer.appendChild(thumbstickContainerSVG);
    this._myThumbstickBackground = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myThumbstickBackground.setAttributeNS(null, "cx", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "cy", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "r", "48%");
    this._myThumbstickBackground.style.fill = this._myParams.myBackgroundColor;
    thumbstickContainerSVG.appendChild(this._myThumbstickBackground);
    this._myThumbstickElement = document.createElement("div");
    this._myThumbstickElement.style.position = "absolute";
    this._myThumbstickElement.style.width = "34%";
    this._myThumbstickElement.style.height = "34%";
    this._myThumbstickElement.style.top = "33%";
    this._myThumbstickElement.style.left = "33%";
    thumbstickContainer.appendChild(this._myThumbstickElement);
    this._myThumbstickIcon = new VirtualGamepadIcon(this._myThumbstickElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myScale);
    if (this._myParams.myIncludeBackgroundToDetection) {
      let thumbstickBackgroundDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickBackgroundDetectionElementSVG.style.position = "absolute";
      thumbstickBackgroundDetectionElementSVG.style.width = "100%";
      thumbstickBackgroundDetectionElementSVG.style.height = "100%";
      thumbstickContainer.appendChild(thumbstickBackgroundDetectionElementSVG);
      let thumbstickBackgroundDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "r", "48%");
      thumbstickBackgroundDetectionElement.style.fill = "#00000000";
      thumbstickBackgroundDetectionElementSVG.appendChild(thumbstickBackgroundDetectionElement);
      this._myThumbstickDetectionElement = thumbstickBackgroundDetectionElement;
    } else {
      let thumbstickElementStill = document.createElement("div");
      thumbstickElementStill.style.position = "absolute";
      thumbstickElementStill.style.width = "34%";
      thumbstickElementStill.style.height = "34%";
      thumbstickElementStill.style.top = "33%";
      thumbstickElementStill.style.left = "33%";
      thumbstickContainer.appendChild(thumbstickElementStill);
      let thumbstickDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickDetectionElementSVG.style.position = "absolute";
      thumbstickDetectionElementSVG.style.width = "100%";
      thumbstickDetectionElementSVG.style.height = "100%";
      thumbstickElementStill.appendChild(thumbstickDetectionElementSVG);
      let thumbstickDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "r", "50%");
      thumbstickDetectionElement.style.fill = "#00000000";
      thumbstickDetectionElementSVG.appendChild(thumbstickDetectionElement);
      this._myThumbstickDetectionElement = thumbstickDetectionElement;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad.js
var VirtualGamepad = class {
  constructor(params = new VirtualGamepadParams()) {
    this._myParams = params;
    this._myVisible = true;
    this._myVirtualGamepadContainer = null;
    this._myVirtualGamepadVirtualButtons = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.SELECT] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.SQUEEZE] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.TOP_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.SELECT] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.SQUEEZE] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON] = null;
    this._myButtonsAmount = this._myVirtualGamepadVirtualButtons[Handedness.LEFT].length;
    this._myVirtualGamepadVirtualThumbsticks = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT][GamepadAxesID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT][GamepadAxesID.THUMBSTICK] = null;
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVirtualGamepadContainer != null) {
        if (this._myVisible) {
          this._myVirtualGamepadContainer.style.display = "block";
        } else {
          this._myVirtualGamepadContainer.style.display = "none";
        }
        for (let handedness in this._myVirtualGamepadVirtualButtons) {
          for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
            let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
            if (button != null) {
              button.setActive(this._myVisible);
            }
          }
        }
        for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
          for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
            let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
            if (thumbstick != null) {
              thumbstick.setActive(this._myVisible);
            }
          }
        }
      }
    }
  }
  isButtonPressed(handedness, gamepadButtonID) {
    if (!this._myVisible)
      return false;
    let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
    if (button != null) {
      return button.isPressed();
    }
    return false;
  }
  getAxes(handedness, gamepadAxesID, outAxes = vec2_create(0, 0)) {
    if (!this._myVisible)
      return outAxes;
    let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
    if (thumbstick != null) {
      outAxes.vec2_copy(thumbstick.getAxes());
    }
    return outAxes;
  }
  start() {
    this._buildVirtualGamepad();
    let currentVisible = this._myVisible;
    this._myVisible = !this._myVisible;
    this.setVisible(currentVisible);
  }
  update(dt) {
    if (this._myParams.myAutoUpdateVisibility) {
      if (XRUtils.isSessionActive(this._myParams.myEngine) && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(false);
      } else if (this._myParams.myShowOnDesktop && BrowserUtils.isDesktop() && !XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnHeadset && BrowserUtils.isDesktop() && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnMobile && BrowserUtils.isMobile()) {
        this.setVisible(true);
      } else {
        this.setVisible(false);
      }
    }
    if (this._myVisible) {
      for (let handedness in this._myVirtualGamepadVirtualButtons) {
        for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
          let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
          if (button != null) {
            button.update(dt);
          }
        }
      }
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
          if (thumbstick != null) {
            thumbstick.update(dt);
          }
        }
      }
      this._setMouseHoverActive(!(this._myParams.myDisableMouseHoverWhenPressed && this._isAnyElementPressed()));
    }
  }
  _buildVirtualGamepad() {
    this._documentBodySetup();
    this._myVirtualGamepadContainer = document.createElement("div");
    this._myVirtualGamepadContainer.style.display = "block";
    this._myVirtualGamepadContainer.style.opacity = this._myParams.myOpacity.toString();
    document.body.appendChild(this._myVirtualGamepadContainer);
    let leftDiv = document.createElement("div");
    this._myVirtualGamepadContainer.appendChild(leftDiv);
    let rightDiv = document.createElement("div");
    this._myVirtualGamepadContainer.appendChild(rightDiv);
    let buttonsAmount = this._myParams.myButtonsOrder[Handedness.LEFT].length;
    for (let i = 0; i < buttonsAmount; i++) {
      if (this._myParams.myButtonsOrder[Handedness.LEFT][i] != null) {
        let gamepadButtonHandedness = this._myParams.myButtonsOrder[Handedness.LEFT][i][0];
        let gamepadButtonID = this._myParams.myButtonsOrder[Handedness.LEFT][i][1];
        this._buildButton(leftDiv, Handedness.LEFT, i, gamepadButtonHandedness, gamepadButtonID);
      }
      if (this._myParams.myButtonsOrder[Handedness.RIGHT][i] != null) {
        let gamepadButtonHandedness = this._myParams.myButtonsOrder[Handedness.RIGHT][i][0];
        let gamepadButtonID = this._myParams.myButtonsOrder[Handedness.RIGHT][i][1];
        this._buildButton(rightDiv, Handedness.RIGHT, i, gamepadButtonHandedness, gamepadButtonID);
      }
    }
    let thumbsticksAmount = this._myParams.myThumbsticksOrder[Handedness.LEFT].length;
    for (let i = 0; i < thumbsticksAmount; i++) {
      if (this._myParams.myThumbsticksOrder[Handedness.LEFT][i] != null) {
        let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[Handedness.LEFT][i][0];
        let gamepadAxesID = this._myParams.myThumbsticksOrder[Handedness.LEFT][i][1];
        this._buildThumbstick(leftDiv, Handedness.LEFT, gamepadThumbstickHandedness, gamepadAxesID);
      }
      if (this._myParams.myThumbsticksOrder[Handedness.RIGHT][i] != null) {
        let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[Handedness.RIGHT][i][0];
        let gamepadAxesID = this._myParams.myThumbsticksOrder[Handedness.RIGHT][i][1];
        this._buildThumbstick(rightDiv, Handedness.RIGHT, gamepadThumbstickHandedness, gamepadAxesID);
      }
    }
  }
  _documentBodySetup() {
    document.body.style.overflow = "hidden";
    document.body.style.userSelect = "none";
    document.body.style.webkitUserSelect = "none";
    document.body.style.webkitTapHighlightColor = "transparent";
    document.body.style.touchAction = "none";
    document.addEventListener("gesturestart", function(e) {
      e.preventDefault();
    });
  }
  _buildButton(buttonElementParent, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
    let virtualGamepadVirtualButton = new VirtualGamepadVirtualButton(buttonElementParent, this._myParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID);
    this._myVirtualGamepadVirtualButtons[gamepadButtonHandedness][gamepadButtonID] = virtualGamepadVirtualButton;
  }
  _buildThumbstick(thumbstickElementParent, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID) {
    let virtualGamepadVirtualThumbstick = new VirtualGamepadVirtualThumbstick(thumbstickElementParent, this._myParams, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID);
    this._myVirtualGamepadVirtualThumbsticks[gamepadThumbstickHandedness][gamepadAxesID] = virtualGamepadVirtualThumbstick;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _isAnyElementPressed() {
    let isAnyElementPressed = false;
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null && button.isPressed()) {
          isAnyElementPressed = true;
          break;
        }
      }
    }
    if (!isAnyElementPressed) {
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
          if (thumbstick != null && thumbstick.isPressed()) {
            isAnyElementPressed = true;
            break;
          }
        }
      }
    }
    return isAnyElementPressed;
  }
  _setMouseHoverActive(hoverActive) {
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null) {
          button.setMouseHoverActive(hoverActive);
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
        if (thumbstick != null) {
          thumbstick.setMouseHoverActive(hoverActive);
        }
      }
    }
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_component.js
import { Component as Component52, Property as Property52 } from "@wonderlandengine/api";
var VirtualGamepadComponent = class extends Component52 {
  start() {
    let params = new VirtualGamepadParams(this.engine);
    params.defaultSetup();
    for (let handedness in params.myButtonParams) {
      for (let gamepadButtonID in params.myButtonParams[handedness]) {
        let buttonParams = params.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = this._myBackgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        buttonParams.myIconParams.myIconColor = this._myIconColor;
        buttonParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    for (let handedness in params.myThumbstickParams) {
      for (let gamepadAxesID in params.myThumbstickParams[handedness]) {
        let thumbstickParams = params.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = this._myIconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        thumbstickParams.myIconParams.myIconColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    params.myOpacity = this._myOpacity;
    params.myInterfaceScale = this._myInterfaceScale;
    params.myMarginScale = this._myMarginScale;
    params.myShowOnDesktop = this._myShowOnDesktop;
    params.myShowOnMobile = this._myShowOnMobile;
    params.myShowOnHeadset = this._myShowOnHeadset;
    if (params.myShowOnDesktop || params.myShowOnMobile || params.myShowOnHeadset) {
      params.myAutoUpdateVisibility = true;
    } else {
      params.myAutoUpdateVisibility = false;
    }
    this._advancedSetup(params);
    this._myVirtualGamepad = new VirtualGamepad(params);
    if (!params.myAutoUpdateVisibility) {
      this._myVirtualGamepad.setVisible(false);
    }
    this._myVirtualGamepad.start();
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      if (this._myAddToUniversalGamepad) {
        let leftVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, getLeftGamepad(this.engine).getGamepadCore("pp_left_xr_gamepad").getHandPose());
        let rightVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, getRightGamepad(this.engine).getGamepadCore("pp_right_xr_gamepad").getHandPose());
        getLeftGamepad(this.engine).addGamepadCore("pp_left_virtual_gamepad", leftVirtualGamepadGamepadCore);
        getRightGamepad(this.engine).addGamepadCore("pp_right_virtual_gamepad", rightVirtualGamepadGamepadCore);
      }
    }
    this._myVirtualGamepad.update(dt);
  }
  _advancedSetup(params) {
    params.myButtonsOrder[Handedness.LEFT] = [null, null, null, null, null];
    params.myButtonsOrder[Handedness.RIGHT] = [null, null, null, null, null];
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT];
      buttonParams.myIconParams.myIconType = this._myLeftSelectButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftSelectButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftSelectButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.SELECT];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE];
      buttonParams.myIconParams.myIconType = this._myLeftSqueezeButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftSqueezeButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftSqueezeButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.SQUEEZE];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK];
      buttonParams.myIconParams.myIconType = this._myLeftThumbstickButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftThumbstickButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftThumbstickButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.THUMBSTICK];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftTopButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftTopButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftTopButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.TOP_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftBottomButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftBottomButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftBottomButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.BOTTOM_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT];
      buttonParams.myIconParams.myIconType = this._myRightSelectButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightSelectButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightSelectButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.SELECT];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE];
      buttonParams.myIconParams.myIconType = this._myRightSqueezeButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightSqueezeButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightSqueezeButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.SQUEEZE];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK];
      buttonParams.myIconParams.myIconType = this._myRightThumbstickButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightThumbstickButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightThumbstickButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.THUMBSTICK];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightTopButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightTopButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightTopButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.TOP_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightBottomButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightBottomButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightBottomButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.BOTTOM_BUTTON];
      }
    }
  }
};
__publicField(VirtualGamepadComponent, "TypeName", "pp-virtual-gamepad");
__publicField(VirtualGamepadComponent, "Properties", {
  _myShowOnDesktop: Property52.bool(false),
  _myShowOnMobile: Property52.bool(true),
  _myShowOnHeadset: Property52.bool(false),
  _myAddToUniversalGamepad: Property52.bool(true),
  _myOpacity: Property52.float(0.5),
  _myIconColor: Property52.string("#e0e0e0"),
  _myBackgroundColor: Property52.string("#616161"),
  _myInterfaceScale: Property52.float(1),
  _myMarginScale: Property52.float(1),
  ADVANCED_PARAMS_BELOW: Property52.string(""),
  _myLabelFontSize: Property52.float(2),
  _myLabelFontFamily: Property52.string("sans-serif"),
  _myLabelFontWeight: Property52.string("bold"),
  _myImagePressedBrightness: Property52.float(0.5),
  _myLeftSelectButtonVisible: Property52.bool(true),
  _myLeftSelectButtonOrderIndex: Property52.int(1),
  _myLeftSelectButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
  _myLeftSelectButtonIconLabelOrImageUrl: Property52.string(""),
  _myLeftSqueezeButtonVisible: Property52.bool(true),
  _myLeftSqueezeButtonOrderIndex: Property52.int(0),
  _myLeftSqueezeButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
  _myLeftSqueezeButtonIconLabelOrImageUrl: Property52.string(""),
  _myLeftThumbstickButtonVisible: Property52.bool(true),
  _myLeftThumbstickButtonOrderIndex: Property52.int(4),
  _myLeftThumbstickButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
  _myLeftThumbstickButtonIconLabelOrImageUrl: Property52.string(""),
  _myLeftTopButtonVisible: Property52.bool(true),
  _myLeftTopButtonOrderIndex: Property52.int(2),
  _myLeftTopButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
  _myLeftTopButtonIconLabelOrImageUrl: Property52.string(""),
  _myLeftBottomButtonVisible: Property52.bool(true),
  _myLeftBottomButtonOrderIndex: Property52.int(3),
  _myLeftBottomButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
  _myLeftBottomButtonIconLabelOrImageUrl: Property52.string(""),
  _myRightSelectButtonVisible: Property52.bool(true),
  _myRightSelectButtonOrderIndex: Property52.int(1),
  _myRightSelectButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
  _myRightSelectButtonIconLabelOrImageUrl: Property52.string(""),
  _myRightSqueezeButtonVisible: Property52.bool(true),
  _myRightSqueezeButtonOrderIndex: Property52.int(0),
  _myRightSqueezeButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
  _myRightSqueezeButtonIconLabelOrImageUrl: Property52.string(""),
  _myRightThumbstickButtonVisible: Property52.bool(true),
  _myRightThumbstickButtonOrderIndex: Property52.int(4),
  _myRightThumbstickButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
  _myRightThumbstickButtonIconLabelOrImageUrl: Property52.string(""),
  _myRightTopButtonVisible: Property52.bool(true),
  _myRightTopButtonOrderIndex: Property52.int(2),
  _myRightTopButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
  _myRightTopButtonIconLabelOrImageUrl: Property52.string(""),
  _myRightBottomButtonVisible: Property52.bool(true),
  _myRightBottomButtonOrderIndex: Property52.int(3),
  _myRightBottomButtonIconType: Property52.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
  _myRightBottomButtonIconLabelOrImageUrl: Property52.string("")
});

// js/pp/input/pose/head_pose.js
var HeadPose = class extends BasePose {
  _getPose(xrFrame) {
    return xrFrame.getViewerPose(this._myReferenceSpace);
  }
};

// js/pp/input/pose/components/set_player_height_component.js
import { Component as Component53, Property as Property53 } from "@wonderlandengine/api";
var SetPlayerHeightComponent = class extends Component53 {
  start() {
    let localPosition = this.object.pp_getPositionLocal();
    this.object.pp_setPositionLocal(vec3_create2(localPosition[0], this._myEyesHeight, localPosition[2]));
    this._myHeightSetOnce = false;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.engine);
  }
  _onXRSessionStart() {
    if (this.active && (!this._mySetOnlyOnStart || !this._myHeightSetOnce)) {
      let localPosition = this.object.pp_getPositionLocal();
      if (XRUtils.isReferenceSpaceLocalFloor(this.engine)) {
        this.object.pp_setPositionLocal(vec3_create2(localPosition[0], 0, localPosition[2]));
      } else if (XRUtils.isDeviceEmulated()) {
        this.object.pp_setPositionLocal(vec3_create2(localPosition[0], 0, localPosition[2]));
      } else {
        this.object.pp_setPositionLocal(vec3_create2(localPosition[0], this._myEyesHeight, localPosition[2]));
      }
      this._myHeightSetOnce = true;
    }
  }
  _onXRSessionEnd() {
    if (this.active && !this._mySetOnlyOnStart) {
      let localPosition = this.object.pp_getPositionLocal();
      this.object.pp_setPositionLocal(vec3_create2(localPosition[0], this._myEyesHeight, localPosition[2]));
    }
  }
};
__publicField(SetPlayerHeightComponent, "TypeName", "pp-set-player-height");
__publicField(SetPlayerHeightComponent, "Properties", {
  _myEyesHeight: Property53.float(1.65),
  _mySetOnlyOnStart: Property53.bool(false)
});

// js/pp/input/pose/components/set_hand_local_transform_component.js
import { Component as Component54, Property as Property54 } from "@wonderlandengine/api";
var SetHandLocalTransformComponent = class extends Component54 {
  init() {
    this._myHandPose = new HandPose(InputUtils.getHandednessByIndex(this._myHandedness), new HandPoseParams(this.engine));
    this._myHandPose.setFixForward(this._myFixForward);
    this._myHandPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
    this._myHandPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  start() {
    this._myHandPose.start();
    this.update(0);
  }
  update(dt) {
    this._myHandPose.update(dt);
  }
  onPoseUpdated() {
  }
};
__publicField(SetHandLocalTransformComponent, "TypeName", "pp-set-hand-local-transform");
__publicField(SetHandLocalTransformComponent, "Properties", {
  _myHandedness: Property54.enum(["Left", "Right"], "Left"),
  _myFixForward: Property54.bool(true),
  _myUpdateOnViewReset: Property54.bool(true)
});
SetHandLocalTransformComponent.prototype.onPoseUpdated = function() {
  let handPoseTransform = quat2_create();
  return function onPoseUpdated() {
    this.object.pp_setTransformLocalQuat(this._myHandPose.getTransformQuat(handPoseTransform));
  };
}();

// js/pp/input/pose/components/set_head_local_transform_component.js
import { Component as Component55, Property as Property55 } from "@wonderlandengine/api";
var SetHeadLocalTransformComponent = class extends Component55 {
  init() {
    this._myHeadPose = new HeadPose(new BasePoseParams2(this.engine));
    this._myHeadPose.setFixForward(this._myFixForward);
    this._myHeadPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
    this._myHeadPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  start() {
    this._myHeadPose.start();
    this.update(0);
  }
  update(dt) {
  }
  onPoseUpdated() {
  }
};
__publicField(SetHeadLocalTransformComponent, "TypeName", "pp-set-head-local-transform");
__publicField(SetHeadLocalTransformComponent, "Properties", {
  _myCameraNonVR: Property55.object(),
  _myFixForward: Property55.bool(true),
  _myUpdateOnViewReset: Property55.bool(true)
});
SetHeadLocalTransformComponent.prototype.update = function() {
  let cameraNonVRRotation = quat_create();
  let cameraNonVRUp = vec3_create2();
  let cameraNonVRPosition = vec3_create2();
  return function update(dt) {
    if (XRUtils.isSessionActive(this.engine)) {
      this._myHeadPose.update(dt);
    } else {
      cameraNonVRRotation = this._myCameraNonVR.pp_getRotationLocalQuat(cameraNonVRRotation);
      if (this._myFixForward) {
        cameraNonVRRotation.quat_rotateAxisRadians(Math.PI, cameraNonVRRotation.quat_getUp(cameraNonVRUp), cameraNonVRRotation);
      }
      this.object.pp_setPositionLocal(this._myCameraNonVR.pp_getPositionLocal(cameraNonVRPosition));
      this.object.pp_setRotationLocalQuat(cameraNonVRRotation);
    }
  };
}();
SetHeadLocalTransformComponent.prototype.onPoseUpdated = function() {
  let headPoseTransform = quat2_create();
  return function onPoseUpdated() {
    if (XRUtils.isSessionActive(this.engine)) {
      this.object.pp_setTransformLocalQuat(this._myHeadPose.getTransformQuat(headPoseTransform));
    }
  };
}();

// js/pp/input/pose/components/set_head_vr_local_transform_component.js
import { Component as Component56, Property as Property56 } from "@wonderlandengine/api";
var SetHeadVRLocalTransformComponent = class extends Component56 {
  init() {
    this._myHeadPose = new HeadPose(new BasePoseParams2(this.engine));
    this._myHeadPose.setFixForward(this._myFixForward);
    this._myHeadPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
    this._myHeadPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  start() {
    this._myHeadPose.start();
    this.update(0);
  }
  update(dt) {
    this._myHeadPose.update(dt);
  }
  onPoseUpdated() {
  }
};
__publicField(SetHeadVRLocalTransformComponent, "TypeName", "pp-set-head-vr-local-transform");
__publicField(SetHeadVRLocalTransformComponent, "Properties", {
  _myFixForward: Property56.bool(true),
  _myUpdateOnViewReset: Property56.bool(true)
});
SetHeadVRLocalTransformComponent.prototype.onPoseUpdated = function() {
  let headPoseTransform = quat2_create();
  return function onPoseUpdated() {
    this.object.pp_setTransformLocalQuat(this._myHeadPose.getTransformQuat(headPoseTransform));
  };
}();

// js/pp/input/pose/components/set_head_non_vr_local_transform_component.js
import { Component as Component57, Property as Property57 } from "@wonderlandengine/api";
var SetHeadNonVRLocalTransformComponent = class extends Component57 {
  start() {
    this.update(0);
  }
  update(dt) {
  }
};
__publicField(SetHeadNonVRLocalTransformComponent, "TypeName", "pp-set-head-non-vr-local-transform");
__publicField(SetHeadNonVRLocalTransformComponent, "Properties", {
  _myCameraNonVR: Property57.object(),
  _myFixForward: Property57.bool(true)
});
SetHeadNonVRLocalTransformComponent.prototype.update = function() {
  let cameraNonVRRotation = quat_create();
  let cameraNonVRUp = vec3_create2();
  let cameraNonVRPosition = vec3_create2();
  return function update(dt) {
    cameraNonVRRotation = this._myCameraNonVR.pp_getRotationLocalQuat(cameraNonVRRotation);
    if (this._myFixForward) {
      cameraNonVRRotation.quat_rotateAxisRadians(Math.PI, cameraNonVRRotation.quat_getUp(cameraNonVRUp), cameraNonVRRotation);
    }
    this.object.pp_setPositionLocal(this._myCameraNonVR.pp_getPositionLocal(cameraNonVRPosition));
    this.object.pp_setRotationLocalQuat(cameraNonVRRotation);
  };
}();

// js/pp/input/pose/components/set_tracked_hand_joint_local_transform_component.js
import { Component as Component58, Property as Property58 } from "@wonderlandengine/api";
var SetTrackedHandJointLocalTransformComponent = class extends Component58 {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDInternal = InputUtils.getJointIDByIndex(this._myJointID);
    this._myTrackedHandJointPose = new TrackedHandJointPose(this._myHandednessType, this._myJointIDInternal, new BasePoseParams(this.engine));
    this._myTrackedHandJointPose.setFixForward(this._myFixForward);
    this._myTrackedHandJointPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
    this._myTrackedHandJointPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  start() {
    this._myTrackedHandJointPose.start();
    this.update(0);
  }
  update(dt) {
    this._myTrackedHandJointPose.update(dt);
  }
  onPoseUpdated() {
  }
};
__publicField(SetTrackedHandJointLocalTransformComponent, "TypeName", "pp-set-tracked-hand-joint-local-transform");
__publicField(SetTrackedHandJointLocalTransformComponent, "Properties", {
  _myHandedness: Property58.enum(["Left", "Right"], "Left"),
  _myFixForward: Property58.bool(true),
  _myUpdateOnViewReset: Property58.bool(true),
  _mySetLocalScaleAsJointRadius: Property58.bool(false),
  _myJointID: Property58.enum(
    [
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ],
    "Wrist"
  )
});
SetTrackedHandJointLocalTransformComponent.prototype.onPoseUpdated = function() {
  let jointPoseTransform = quat2_create();
  return function onPoseUpdated() {
    this.object.pp_setTransformLocalQuat(this._myTrackedHandJointPose.getTransformQuat(jointPoseTransform));
    if (this._mySetLocalScaleAsJointRadius) {
      this.object.pp_setScaleLocal(this._myTrackedHandJointPose.getJointRadius());
    }
  };
}();

// js/pp/input/pose/components/copy_hand_transform_component.js
import { Component as Component59, Property as Property59 } from "@wonderlandengine/api";
var CopyHandTransformComponent = class extends Component59 {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
  }
  update(dt) {
    let hand = getPlayerObjects2(this.engine).myHands[this._myHandednessType];
    this.object.pp_setTransformQuat(hand.pp_getTransformQuat());
    this.object.pp_setScale(hand.pp_getScale());
  }
};
__publicField(CopyHandTransformComponent, "TypeName", "pp-copy-hand-transform");
__publicField(CopyHandTransformComponent, "Properties", {
  _myHandedness: Property59.enum(["Left", "Right"], "Left")
});

// js/pp/input/pose/components/copy_head_transform_component.js
import { Component as Component60, Property as Property60 } from "@wonderlandengine/api";
var CopyHeadTransformComponent = class extends Component60 {
  update(dt) {
    let head = getPlayerObjects2(this.engine).myHead;
    this.object.pp_setTransformQuat(head.pp_getTransformQuat());
    this.object.pp_setScale(head.pp_getScale());
  }
};
__publicField(CopyHeadTransformComponent, "TypeName", "pp-copy-head-transform");
__publicField(CopyHeadTransformComponent, "Properties", {});

// js/pp/input/pose/components/copy_player_transform_component.js
import { Component as Component61, Property as Property61 } from "@wonderlandengine/api";
var CopyPlayerTransformComponent = class extends Component61 {
  update(dt) {
    let player = getPlayerObjects2(this.engine).myPlayer;
    this.object.pp_setTransformQuat(player.pp_getTransformQuat());
    this.object.pp_setScale(player.pp_getScale());
  }
};
__publicField(CopyPlayerTransformComponent, "TypeName", "pp-copy-player-transform");
__publicField(CopyPlayerTransformComponent, "Properties", {});

// js/pp/input/pose/components/copy_player_pivot_transform_component.js
import { Component as Component62, Property as Property62 } from "@wonderlandengine/api";
var CopyPlayerPivotTransformComponent = class extends Component62 {
  update(dt) {
    let playerPivot = getPlayerObjects2(this.engine).myPlayerPivot;
    this.object.pp_setTransformQuat(playerPivot.pp_getTransformQuat());
    this.object.pp_setScale(playerPivot.pp_getScale());
  }
};
__publicField(CopyPlayerPivotTransformComponent, "TypeName", "pp-copy-player-pivot-transform");
__publicField(CopyPlayerPivotTransformComponent, "Properties", {});

// js/pp/tool/cauldron/tool_types.js
var ToolHandedness = {
  NONE: null,
  LEFT: "left",
  RIGHT: "right"
};
var ToolInputSourceType = {
  NONE: null,
  GAMEPAD: 0,
  TRACKED_HAND: 1
};

// js/pp/tool/cauldron/components/tool_cursor_component.js
import { Component as Component63, MeshComponent as MeshComponent13, Property as Property63, ViewComponent as ViewComponent4 } from "@wonderlandengine/api";
import { Cursor as Cursor3, CursorTarget as CursorTarget5 } from "@wonderlandengine/components";
var ToolCursorComponent = class extends Component63 {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myCursorPositionDefaultOffset = vec3_create2(0, -0.035, 0.05);
    this._myCursorRotationDefaultOffset = vec3_create2(30, 0, 0);
    this._myCursorMeshScale = vec3_create2(25e-4, 25e-4, 25e-4);
    this._myCursorColor = vec4_create2(255 / 255, 255 / 255, 255 / 255, 1);
    this._myCursorTargetCollisionGroup = 7;
  }
  start() {
    this._myToolCursorObject = this.object.pp_addObject();
    this._myCursorObjectVR = this._myToolCursorObject.pp_addObject();
    if (this._myApplyDefaultCursorOffset) {
      this._myCursorObjectVR.pp_setPositionLocal(this._myCursorPositionDefaultOffset);
      this._myCursorObjectVR.pp_rotateObject(this._myCursorRotationDefaultOffset);
    }
    {
      this._myCursorMeshobject = this._myCursorObjectVR.pp_addObject();
      this._myCursorMeshobject.pp_setScale(this._myCursorMeshScale);
      let cursorMeshComponent = this._myCursorMeshobject.pp_addComponent(MeshComponent13);
      cursorMeshComponent.mesh = getDefaultResources(this.engine).myMeshes.mySphere;
      cursorMeshComponent.material = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      cursorMeshComponent.material.color = this._myCursorColor;
      this._myCursorComponentVR = this._myCursorObjectVR.pp_addComponent(Cursor3, {
        "collisionGroup": this._myCursorTargetCollisionGroup,
        "handedness": this._myHandedness + 1,
        "cursorObject": this._myCursorMeshobject
      });
      this._myCursorComponentVR.rayCastMode = 0;
      if (this._myPulseOnHover) {
        this._myCursorComponentVR.globalTarget.addHoverFunction(this._pulseOnHover.bind(this));
      }
    }
    this._myCursorObjectNonVR = this._myToolCursorObject.pp_addObject();
    {
      this._myCursorComponentNonVR = this._myCursorObjectNonVR.pp_addComponent(Cursor3, {
        "collisionGroup": this._myCursorTargetCollisionGroup,
        "handedness": this._myHandedness + 1
      });
      this._myCursorComponentNonVR.rayCastMode = 0;
      if (this._myPulseOnHover) {
        this._myCursorComponentNonVR.globalTarget.addHoverFunction(this._pulseOnHover.bind(this));
      }
      this._myCursorComponentNonVR.setViewComponent(getPlayerObjects2(this.engine).myCameraNonVR.pp_getComponent(ViewComponent4));
    }
    let fingerCursorMeshObject = null;
    let fingerCollisionSize = 0.0125;
    if (this._myShowFingerCursor) {
      fingerCursorMeshObject = this._myToolCursorObject.pp_addObject();
      let meshComponent = fingerCursorMeshObject.pp_addComponent(MeshComponent13);
      meshComponent.mesh = getDefaultResources(this.engine).myMeshes.mySphere;
      meshComponent.material = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      meshComponent.material.color = this._myCursorColor;
      fingerCursorMeshObject.pp_setScale(fingerCollisionSize);
    }
    this._myFingerCursorObject = this._myToolCursorObject.pp_addObject();
    this._myFingerCursorComponent = this._myFingerCursorObject.pp_addComponent(FingerCursorComponent, {
      "_myHandedness": this._myHandedness,
      "_myMultipleClicksEnabled": true,
      "_myCollisionGroup": this._myCursorTargetCollisionGroup,
      "_myCollisionSize": fingerCollisionSize,
      "_myCursorObject": fingerCursorMeshObject
    });
    this._myCursorComponentVR.active = false;
    this._myCursorComponentNonVR.active = false;
    this._myFingerCursorComponent.active = false;
  }
  update(dt) {
  }
  _isUsingHand() {
    let isUsingHand = false;
    if (XRUtils.getSession(this.engine) && XRUtils.getSession(this.engine).inputSources) {
      for (let i = 0; i < XRUtils.getSession(this.engine).inputSources.length; i++) {
        let input = XRUtils.getSession(this.engine).inputSources[i];
        if (input.hand && input.handedness == this._myHandednessType) {
          isUsingHand = true;
          break;
        }
      }
    }
    return isUsingHand;
  }
  _pulseOnHover(object) {
    let targetComponent = object.pp_getComponent(CursorTarget5);
    if (targetComponent && !targetComponent.isSurface) {
      if (this._myHandedness == 0) {
        if (getLeftGamepad(this.engine) != null) {
          getLeftGamepad(this.engine).pulse(0.4, 0);
        }
      } else {
        if (getRightGamepad(this.engine) != null) {
          getRightGamepad(this.engine).pulse(0.4, 0);
        }
      }
    }
  }
};
__publicField(ToolCursorComponent, "TypeName", "pp-tool-cursor");
__publicField(ToolCursorComponent, "Properties", {
  _myHandedness: Property63.enum(["Left", "Right"], "Left"),
  _myApplyDefaultCursorOffset: Property63.bool(true),
  _myPulseOnHover: Property63.bool(false),
  _myShowFingerCursor: Property63.bool(false)
});
ToolCursorComponent.prototype.update = function() {
  let transformQuat = quat2_create();
  return function update(dt) {
    let isUsingHand = this._isUsingHand();
    this._myFingerCursorComponent.active = isUsingHand;
    if (isUsingHand) {
      this._myCursorComponentVR.active = false;
      this._myCursorComponentNonVR.active = false;
    } else {
      if (XRUtils.isSessionActive(this.engine)) {
        this._myCursorComponentVR.active = !isUsingHand;
        this._myCursorComponentNonVR.active = false;
      } else {
        this._myCursorComponentNonVR.active = !isUsingHand;
        this._myCursorComponentVR.active = false;
        this._myCursorObjectNonVR.pp_setTransformQuat(getPlayerObjects2(this.engine).myCameraNonVR.pp_getTransformQuat(transformQuat));
      }
    }
  };
}();

// js/pp/tool/console_vr/console_vr_widget_setup.js
import { Alignment as Alignment4, Collider as Collider2, Justification as Justification4 } from "@wonderlandengine/api";

// js/pp/tool/console_vr/console_vr_types.js
var ConsoleVRWidgetConsoleFunction = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3,
  INFO: 4,
  ASSERT: 5
};
var ConsoleVRWidgetSender = {
  BROWSER_CONSOLE: 0,
  CONSOLE_VR: 1,
  WINDOW: 2
};
var ConsoleVRWidgetPulseOnNewMessage = {
  NEVER: 0,
  ALWAYS: 1,
  WHEN_HIDDEN: 2
};
var ConsoleVRWidgetMessageType = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3
};

// js/pp/tool/console_vr/console_vr_widget_setup.js
var ConsoleVRWidgetSetup = class {
  constructor() {
    this._initializeBuildSetup();
    this._initializeRuntimeSetup();
  }
  _initializeBuildSetup() {
    this.myBackgroundColor = vec4_create2(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider2.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create2(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment4.Center;
    this.myTextJustification = Justification4.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myMessageTypeColors = [];
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG] = this.myDefaultTextColor;
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR] = vec4_create2(255 / 255, 40 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN] = vec4_create2(250 / 255, 220 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG] = vec4_create2(60 / 255, 200 / 255, 255 / 255, 1);
    this.myMessagesPanelPosition = vec3_create2(0, 0.075, 0);
    this.myMessagesBackgroundScale = vec3_create2(0.34, 0.15, 1);
    {
      let xPaddingPercentage = 0.03;
      let yPaddingPercentage = xPaddingPercentage * this.myMessagesBackgroundScale[0] / this.myMessagesBackgroundScale[1] * 0.8;
      let xPosition = -this.myMessagesBackgroundScale[0] + this.myMessagesBackgroundScale[0] * xPaddingPercentage;
      let yPosition = this.myMessagesBackgroundScale[1] - this.myMessagesBackgroundScale[1] * yPaddingPercentage;
      this.myMessagesTextsPanelPosition = vec3_create2(xPosition, yPosition, 7e-3);
    }
    this.myMessagesTextsPanelScale = vec3_create2(0.1, 0.1, 0.1);
    this.myMessagesTextStartString = ".\n";
    this.myMessagesTextAlignment = 1;
    this.myMessagesTextJustification = 3;
    this.myMessagesTextPositions = [];
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.LOG] = vec3_create2(0, 0, 1e-5);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.ERROR] = vec3_create2(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.WARN] = vec3_create2(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.DEBUG] = vec3_create2(0, 0, 0);
    this.myMessagesTextColors = [];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myButtonsPanelPosition = vec3_create2(0, -0.11, 0.015);
    this.myButtonBackgroundScale = vec3_create2(0.04, 0.02, 1);
    this.myButtonTextPosition = vec3_create2(0, 0, 7e-3);
    this.myButtonTextScale = vec3_create2(0.18, 0.18, 0.18);
    this.myButtonCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myButtonCursorTargetPosition[2] = this.myButtonTextPosition[2];
    this.myButtonsCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myButtonsCollisionGroup = this.myCursorTargetCollisionGroup;
    this.myButtonsCollisionExtents = this.myButtonBackgroundScale.pp_clone();
    this.myButtonsCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myClearButtonTextLabel = "clear";
    this.myUpButtonTextLabel = "up";
    this.myDownButtonTextLabel = "down";
    this.myFilterButtonsTextColors = [];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myFilterButtonsTextLabel = [];
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.LOG] = "log";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.ERROR] = "error";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.WARN] = "warn";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.DEBUG] = "debug";
    {
      let numberOfButtons = 7;
      let buttonsHorizontalSpace = Math.max(0.68, this.myButtonBackgroundScale[0] * numberOfButtons);
      let numberOfSpacesBetweenButtons = 2 + 3 + 4 + 4 + 1 + 2;
      let spaceWidth = Math.max((buttonsHorizontalSpace - numberOfButtons * this.myButtonBackgroundScale[0] * 2) / numberOfSpacesBetweenButtons, 0);
      let halfButtonWidth = this.myButtonBackgroundScale[0];
      let initialPosition = -buttonsHorizontalSpace / 2;
      this.myFilterButtonsPositions = [];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG] = [initialPosition + spaceWidth * 2 + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myClearButtonPosition = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG][0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myUpButtonPosition = [this.myClearButtonPosition[0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myDownButtonPosition = [this.myUpButtonPosition[0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
    }
    this.myNotifyIconBackgroundScale = vec3_create2(0.01, 0.01, 1);
    this.myNotifyIconPanelPositions = [];
    this.myNotifyIconPanelPositions[ToolHandedness.NONE] = vec3_create2(0, 0, 0);
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][0] = -this.myMessagesBackgroundScale[0] + this.myNotifyIconBackgroundScale[0] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][1] = -this.myMessagesBackgroundScale[1] + this.myNotifyIconBackgroundScale[1] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][2] = this.myMessagesTextsPanelPosition[2] - 1e-5;
    this.myNotifyIconPanelPositions[ToolHandedness.LEFT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconPanelPositions[ToolHandedness.RIGHT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myNotifyIconCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - this.myMessagesTextsPanelPosition[2];
    this.myNotifyIconCollisionExtents = this.myNotifyIconBackgroundScale.pp_clone();
    this.myNotifyIconCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNotifyIconColor = vec4_create2(210 / 255, 210 / 255, 210 / 255, 1);
    this.myPointerCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myPointerCollisionGroup = this.myCursorTargetCollisionGroup;
    {
      let spaceBetweenMessagesAndButtons = Math.abs(this.myMessagesPanelPosition[1] - this.myMessagesBackgroundScale[1] - (this.myButtonsPanelPosition[1] + this.myButtonBackgroundScale[1]));
      let pointerCollisionHalfHeight = this.myMessagesBackgroundScale[1] + this.myButtonBackgroundScale[1] + spaceBetweenMessagesAndButtons / 2;
      this.myPointerCollisionExtents = vec3_create2(this.myMessagesBackgroundScale[0], pointerCollisionHalfHeight, this.myCursorTargetCollisionThickness);
    }
    this.myPointerCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myPointerCursorTargetPosition[1] = this.myMessagesPanelPosition[1] + this.myMessagesBackgroundScale[1] - this.myPointerCollisionExtents[1];
    this.myPointerCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - 1e-4;
  }
  _initializeRuntimeSetup() {
    this.myTabString = "     ";
    this.myAssertStartString = "Assertion failed:";
    this.myMaxCharactersPerLine = 100;
    this.myMaxLineSplits = 50;
    this.myMaxLines = 22;
    this.myMaxMessages = 2e3;
    this.myMaxMessagesDeletePad = 2e3;
    this.myLinesBetweenMessages = 1;
    this.myButtonHoverColor = vec4_create2(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create2(110 / 255, 110 / 255, 110 / 255, 1);
    this.myFilterButtonDisabledTextColor = this.myButtonDisabledTextColor;
    this.myFilterButtonDisabledBackgroundColor = this.myButtonDisabledBackgroundColor;
    this.myScrollDelay = 0.1;
    this.myScrollAmount = 1;
    this.myScrollThumbstickHandedness = ToolHandedness.RIGHT;
    this.myScrollThumbstickDelay = 0.1;
    this.myScrollThumbstickMinThreshold = 0.2;
    this.myScrollThumbstickAmount = 3;
    this.myPulseDelay = 5;
    this.myPulseIntensity = 0.3;
    this.myPulseDuration = 0.085;
    this.myClearBrowserConsoleWhenClearPressed = true;
    this.myGamepadScrollOnlyOnHover = true;
  }
};

// js/pp/tool/console_vr/console_vr_widget_ui.js
import { CollisionComponent as CollisionComponent4, MeshComponent as MeshComponent14, TextComponent as TextComponent9 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget6 } from "@wonderlandengine/components";
var ConsoleVRWidgetUI = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
  }
  build(parentObject, setup, additionalSetup) {
    this._myParentObject = parentObject;
    this._mySetup = setup;
    this._myAdditionalSetup = additionalSetup;
    this._myPlaneMesh = getDefaultResources(this._myEngine).myMeshes.myPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonVR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
  }
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addObject();
    this._createMessagesSkeleton();
    this._createButtonsSkeleton();
    this._createPointerSkeleton();
  }
  _createMessagesSkeleton() {
    this.myMessagesPanel = this.myPivotObject.pp_addObject();
    this.myMessagesBackground = this.myMessagesPanel.pp_addObject();
    this.myMessagesTextsPanel = this.myMessagesPanel.pp_addObject();
    this.myMessagesTexts = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]] = this.myMessagesTextsPanel.pp_addObject();
    }
    this.myNotifyIconPanel = this.myMessagesPanel.pp_addObject();
    this.myNotifyIconBackground = this.myNotifyIconPanel.pp_addObject();
    this.myNotifyIconCursorTarget = this.myNotifyIconPanel.pp_addObject();
  }
  _createButtonsSkeleton() {
    this.myButtonsPanel = this.myPivotObject.pp_addObject();
    this.myFilterButtonsPanels = [];
    this.myFilterButtonsBackgrounds = [];
    this.myFilterButtonsTexts = [];
    this.myFilterButtonsCursorTargets = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]] = this.myButtonsPanel.pp_addObject();
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
    }
    this.myClearButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myClearButtonBackground = this.myClearButtonPanel.pp_addObject();
    this.myClearButtonText = this.myClearButtonPanel.pp_addObject();
    this.myClearButtonCursorTarget = this.myClearButtonPanel.pp_addObject();
    this.myUpButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myUpButtonBackground = this.myUpButtonPanel.pp_addObject();
    this.myUpButtonText = this.myUpButtonPanel.pp_addObject();
    this.myUpButtonCursorTarget = this.myUpButtonPanel.pp_addObject();
    this.myDownButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myDownButtonBackground = this.myDownButtonPanel.pp_addObject();
    this.myDownButtonText = this.myDownButtonPanel.pp_addObject();
    this.myDownButtonCursorTarget = this.myDownButtonPanel.pp_addObject();
  }
  _createPointerSkeleton() {
    this.myPointerCursorTarget = this.myPivotObject.pp_addObject();
  }
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this._setMessagesTransforms();
    this._setButtonsTransforms();
    this._setPointerTransform();
  }
  _setMessagesTransforms() {
    this.myMessagesPanel.pp_setPositionLocal(this._mySetup.myMessagesPanelPosition);
    this.myMessagesBackground.pp_scaleObject(this._mySetup.myMessagesBackgroundScale);
    this.myMessagesTextsPanel.pp_setPositionLocal(this._mySetup.myMessagesTextsPanelPosition);
    this.myMessagesTextsPanel.pp_scaleObject(this._mySetup.myMessagesTextsPanelScale);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._mySetup.myMessagesTextPositions[ConsoleVRWidgetMessageType[key]]);
    }
    this.myNotifyIconPanel.pp_setPositionLocal(this._mySetup.myNotifyIconPanelPositions[this._myAdditionalSetup.myHandedness]);
    this.myNotifyIconBackground.pp_scaleObject(this._mySetup.myNotifyIconBackgroundScale);
    this.myNotifyIconCursorTarget.pp_setPositionLocal(this._mySetup.myNotifyIconCursorTargetPosition);
  }
  _setButtonsTransforms() {
    this.myButtonsPanel.pp_setPositionLocal(this._mySetup.myButtonsPanelPosition);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._mySetup.myFilterButtonsPositions[ConsoleVRWidgetMessageType[key]]);
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._mySetup.myButtonBackgroundScale);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._mySetup.myButtonTextPosition);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._mySetup.myButtonTextScale);
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._mySetup.myButtonCursorTargetPosition);
    }
    {
      this.myClearButtonPanel.pp_setPositionLocal(this._mySetup.myClearButtonPosition);
      this.myClearButtonBackground.pp_scaleObject(this._mySetup.myButtonBackgroundScale);
      this.myClearButtonText.pp_setPositionLocal(this._mySetup.myButtonTextPosition);
      this.myClearButtonText.pp_scaleObject(this._mySetup.myButtonTextScale);
      this.myClearButtonCursorTarget.pp_setPositionLocal(this._mySetup.myButtonCursorTargetPosition);
    }
    {
      this.myUpButtonPanel.pp_setPositionLocal(this._mySetup.myUpButtonPosition);
      this.myUpButtonBackground.pp_scaleObject(this._mySetup.myButtonBackgroundScale);
      this.myUpButtonText.pp_setPositionLocal(this._mySetup.myButtonTextPosition);
      this.myUpButtonText.pp_scaleObject(this._mySetup.myButtonTextScale);
      this.myUpButtonCursorTarget.pp_setPositionLocal(this._mySetup.myButtonCursorTargetPosition);
    }
    {
      this.myDownButtonPanel.pp_setPositionLocal(this._mySetup.myDownButtonPosition);
      this.myDownButtonBackground.pp_scaleObject(this._mySetup.myButtonBackgroundScale);
      this.myDownButtonText.pp_setPositionLocal(this._mySetup.myButtonTextPosition);
      this.myDownButtonText.pp_scaleObject(this._mySetup.myButtonTextScale);
      this.myDownButtonCursorTarget.pp_setPositionLocal(this._mySetup.myButtonCursorTargetPosition);
    }
  }
  _setPointerTransform() {
    this.myPointerCursorTarget.pp_setPositionLocal(this._mySetup.myPointerCursorTargetPosition);
  }
  _addComponents() {
    this._addMessagesComponents();
    this._addButtonsComponents();
    this._addPointerComponents();
  }
  _addMessagesComponents() {
    let messagesBackgroundMeshComp = this.myMessagesBackground.pp_addComponent(MeshComponent14);
    messagesBackgroundMeshComp.mesh = this._myPlaneMesh;
    messagesBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    messagesBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
    this.myMessagesTextComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let textComp = this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent9);
      textComp.alignment = this._mySetup.myMessagesTextAlignment;
      textComp.justification = this._mySetup.myMessagesTextJustification;
      textComp.material = this._myAdditionalSetup.myTextMaterial.clone();
      textComp.material.color = this._mySetup.myMessagesTextColors[ConsoleVRWidgetMessageType[key]];
      textComp.lineSpacing = 1.2;
      textComp.text = this._mySetup.myMessagesTextStartString;
      this.myMessagesTextComponents[ConsoleVRWidgetMessageType[key]] = textComp;
    }
    this.myNotifyIconBackgroundComponent = this.myNotifyIconBackground.pp_addComponent(MeshComponent14);
    this.myNotifyIconBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNotifyIconBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myNotifyIconBackgroundComponent.material.color = this._mySetup.myNotifyIconColor;
    this.myNotifyIconCursorTargetComponent = this.myNotifyIconCursorTarget.pp_addComponent(CursorTarget6);
    this.myNotifyIconCollisionComponent = this.myNotifyIconCursorTarget.pp_addComponent(CollisionComponent4);
    this.myNotifyIconCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myNotifyIconCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myNotifyIconCollisionComponent.extents = this._mySetup.myNotifyIconCollisionExtents;
  }
  _addButtonsComponents() {
    this.myFilterButtonsBackgroundComponents = [];
    this.myFilterButtonsTextComponents = [];
    this.myFilterButtonsCursorTargetComponents = [];
    this.myFilterButtonsCollisionComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let buttonBackgroundMeshComp = this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
      let buttonTextComp = this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.material.color = this._mySetup.myFilterButtonsTextColors[ConsoleVRWidgetMessageType[key]];
      buttonTextComp.text = this._mySetup.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType[key]];
      let buttonCursorTargetComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CursorTarget6);
      let buttonCollisionComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
      this.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]] = buttonBackgroundMeshComp;
      this.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]] = buttonTextComp;
      this.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]] = buttonCursorTargetComp;
      this.myFilterButtonsCollisionComponents[ConsoleVRWidgetMessageType[key]] = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myClearButtonBackground.pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
      let buttonTextComp = this.myClearButtonText.pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._mySetup.myClearButtonTextLabel;
      let buttonCursorTargetComp = this.myClearButtonCursorTarget.pp_addComponent(CursorTarget6);
      let buttonCollisionComp = this.myClearButtonCursorTarget.pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
      this.myClearButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myClearButtonTextComponent = buttonTextComp;
      this.myClearButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myClearButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myUpButtonBackground.pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
      let buttonTextComp = this.myUpButtonText.pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._mySetup.myUpButtonTextLabel;
      let buttonCursorTargetComp = this.myUpButtonCursorTarget.pp_addComponent(CursorTarget6);
      let buttonCollisionComp = this.myUpButtonCursorTarget.pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
      this.myUpButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myUpButtonTextComponent = buttonTextComp;
      this.myUpButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myUpButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myDownButtonBackground.pp_addComponent(MeshComponent14);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
      let buttonTextComp = this.myDownButtonText.pp_addComponent(TextComponent9);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._mySetup.myDownButtonTextLabel;
      let buttonCursorTargetComp = this.myDownButtonCursorTarget.pp_addComponent(CursorTarget6);
      let buttonCollisionComp = this.myDownButtonCursorTarget.pp_addComponent(CollisionComponent4);
      buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
      this.myDownButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myDownButtonTextComponent = buttonTextComp;
      this.myDownButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myDownButtonCollisionComponent = buttonCollisionComp;
    }
  }
  _addPointerComponents() {
    this.myPointerCursorTargetComponent = this.myPointerCursorTarget.pp_addComponent(CursorTarget6);
    this.myPointerCursorTargetComponent.isSurface = true;
    let collisionComp = this.myPointerCursorTarget.pp_addComponent(CollisionComponent4);
    collisionComp.collider = this._mySetup.myPointerCollisionCollider;
    collisionComp.group = 1 << this._mySetup.myPointerCollisionGroup;
    collisionComp.extents = this._mySetup.myPointerCollisionExtents;
    this.myPointerCollisionComponent = collisionComp;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._mySetup.myTextAlignment;
    textComponent.justification = this._mySetup.myTextJustification;
    textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
    textComponent.material.color = this._mySetup.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForVR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonVR();
  }
  _setTransformForVR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._mySetup.myNotifyIconPanelPositions[this._myAdditionalSetup.myHandedness]);
  }
  _setTransformForNonVR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._mySetup.myNotifyIconPanelPositions[ToolHandedness.NONE]);
  }
};

// js/pp/tool/widget_frame/widget_frame_setup.js
import { Alignment as Alignment5, Collider as Collider3, Justification as Justification5 } from "@wonderlandengine/api";
var WidgetFrameSetup = class {
  constructor(widgetLetterID, buttonsColumnIndex) {
    this._initializeBuildSetup(widgetLetterID, buttonsColumnIndex);
    this._initializeRuntimeSetup();
  }
  _initializeBuildSetup(widgetLetterID, buttonsColumnIndex) {
    this.myBackgroundColor = vec4_create2(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider3.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create2(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment5.Center;
    this.myTextJustification = Justification5.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myButtonTextScale = vec3_create2(0.18, 0.18, 0.18);
    this.myVisibilityButtonBackgroundScale = vec3_create2(0.015, 0.015, 1);
    this.myVisibilityButtonTextPosition = vec3_create2(0, 0, 7e-3);
    this.myVisibilityButtonTextScale = this.myButtonTextScale;
    let distanceBetweenToolsVisibilityButtons = 0.01;
    let buttonXOffset = this.myVisibilityButtonBackgroundScale[0] * (2 * buttonsColumnIndex) + distanceBetweenToolsVisibilityButtons * buttonsColumnIndex;
    this.myVisibilityButtonPosition = [];
    this.myVisibilityButtonPosition[ToolHandedness.NONE] = {};
    this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition = vec3_create2(-0.3 + buttonXOffset, -0.205, 0.035);
    this.myVisibilityButtonPosition[ToolHandedness.LEFT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition = vec3_create2(-0.2 + buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition = vec3_create2(0.2 - buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonText = widgetLetterID;
    this.myVisibilityButtonCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myVisibilityButtonCursorTargetPosition[2] = this.myVisibilityButtonTextPosition[2];
    this.myVisibilityButtonCollisionExtents = this.myVisibilityButtonBackgroundScale.pp_clone();
    this.myVisibilityButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myFlagButtonBackgroundScale = vec3_create2(0.0125, 0.0125, 1);
    this.myFlagButtonTextPosition = vec3_create2(0, 0, 7e-3);
    this.myFlagButtonTextScale = vec3_create2(0.15, 0.15, 0.15);
    let distanceBetweenFlagButtons = 75e-4;
    let pinFlagIndex = 0;
    let pinButtonYOffset = this.myVisibilityButtonBackgroundScale[1] + this.myFlagButtonBackgroundScale[1] + distanceBetweenFlagButtons + this.myFlagButtonBackgroundScale[1] * (2 * pinFlagIndex) + distanceBetweenFlagButtons * pinFlagIndex;
    this.myPinButtonPosition = [];
    this.myPinButtonPosition[ToolHandedness.NONE] = {};
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition = this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.LEFT] = {};
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.RIGHT] = {};
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonText = "P";
    this.myPinButtonCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myPinButtonCursorTargetPosition[2] = this.myFlagButtonTextPosition[2];
    this.myPinButtonCollisionExtents = this.myFlagButtonBackgroundScale.pp_clone();
    this.myPinButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _initializeRuntimeSetup() {
    this._initializeObjectsTransforms();
    this.myButtonHoverColor = vec4_create2(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create2(110 / 255, 110 / 255, 110 / 255, 1);
  }
  _initializeObjectsTransforms() {
    this.myPivotObjectTransforms = this._createDefaultObjectTransforms();
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myWidgetObjectTransforms = this._createDefaultObjectTransforms();
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myPosition = vec3_create2(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myPosition = vec3_create2(0.07, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myPosition = vec3_create2(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myPosition = vec3_create2(0.07, 0.23, -0.02);
    this._myPivotObjectDistanceFromHeadNonVR = 0.6;
  }
  _createDefaultObjectTransforms() {
    let defaultObjectTransforms = [];
    for (let inputSourceTypeKey in ToolInputSourceType) {
      let inputSourceType = ToolInputSourceType[inputSourceTypeKey];
      defaultObjectTransforms[inputSourceType] = [];
      for (let handednessKey in ToolHandedness) {
        let handedness = ToolHandedness[handednessKey];
        defaultObjectTransforms[inputSourceType][handedness] = {};
        defaultObjectTransforms[inputSourceType][handedness].myPosition = vec3_create2(0, 0, 0);
        defaultObjectTransforms[inputSourceType][handedness].myRotation = quat_create(0, 0, 0, 1);
      }
    }
    return defaultObjectTransforms;
  }
};

// js/pp/tool/widget_frame/widget_frame_ui.js
import { MeshComponent as MeshComponent15, CollisionComponent as CollisionComponent5, TextComponent as TextComponent10 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget7 } from "@wonderlandengine/components";
var WidgetFrameUI = class {
  constructor(engine2 = getMainEngine2()) {
    this._myInputSourceType = null;
    this._myParentObject = null;
    this._myIsPinned = false;
    this._myWidgetVisible = true;
    this._myVisibilityButtonVisible = true;
    this._myEngine = engine2;
  }
  build(parentObject, setup, additionalSetup) {
    this._myParentObject = parentObject;
    this._mySetup = setup;
    this._myAdditionalSetup = additionalSetup;
    this._myPlaneMesh = getDefaultResources(this._myEngine).myMeshes.myPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonVR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setWidgetVisible(visible) {
    this._myWidgetVisible = visible;
    this.myFlagsButtonPanel.pp_setActive(visible);
    if (visible) {
      this._updateObjectsTransforms(true);
    }
  }
  setVisibilityButtonVisible(visible) {
    this._myVisibilityButtonVisible = visible;
    this.myVisibilityButtonPanel.pp_setActive(visible);
  }
  setPinned(pinned) {
    if (pinned != this._myIsPinned) {
      this._myIsPinned = pinned;
      if (this._myIsPinned) {
        this.myPivotObject.pp_setParent(null);
      } else {
        this.myPivotObject.pp_setParent(this.myFixForwardObject);
        if (!XRUtils.isSessionActive(this._myEngine)) {
          this._setTransformForNonVR();
        }
        this._updateObjectsTransforms(true);
      }
    }
  }
  update(dt) {
    this._updateObjectsTransforms(false);
  }
  _updateObjectsTransforms(forceRefreshObjectsTransforms) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      let inputSourceType = InputUtils.getInputSourceTypeByHandedness(this._myAdditionalSetup.myHandedness, this._myEngine);
      if (inputSourceType != this._myInputSourceType || forceRefreshObjectsTransforms) {
        this._myInputSourceType = inputSourceType;
        if (!this._myIsPinned) {
          this.myPivotObject.pp_setPositionLocal(this._mySetup.myPivotObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myPosition);
          this.myPivotObject.pp_resetRotationLocal();
          this.myPivotObject.pp_rotateObjectQuat(this._mySetup.myPivotObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myRotation);
          this.myWidgetObject.pp_setPositionLocal(this._mySetup.myWidgetObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myPosition);
          this.myWidgetObject.pp_resetRotationLocal();
          this.myWidgetObject.pp_rotateObjectQuat(this._mySetup.myWidgetObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myRotation);
          this.myVisibilityButtonPanel.pp_setPositionLocal(this._mySetup.myVisibilityButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
          this.myPinButtonPanel.pp_setPositionLocal(this._mySetup.myPinButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
        }
      }
    } else {
      this.myVisibilityButtonPanel.pp_setActive(this._myWidgetVisible || this._myVisibilityButtonVisible);
    }
  }
  _createSkeleton() {
    this.myFixForwardObject = this._myParentObject.pp_addObject();
    this.myFixForwardObject.pp_rotateObject(vec3_create2(0, 180, 0));
    this.myPivotObject = this.myFixForwardObject.pp_addObject();
    this.myWidgetObject = this.myPivotObject.pp_addObject();
    this.myVisibilityButtonPanel = this.myPivotObject.pp_addObject();
    this.myVisibilityButtonBackground = this.myVisibilityButtonPanel.pp_addObject();
    this.myVisibilityButtonText = this.myVisibilityButtonPanel.pp_addObject();
    this.myVisibilityButtonCursorTarget = this.myVisibilityButtonPanel.pp_addObject();
    this.myFlagsButtonPanel = this.myPivotObject.pp_addObject();
    this.myPinButtonPanel = this.myFlagsButtonPanel.pp_addObject();
    this.myPinButtonBackground = this.myPinButtonPanel.pp_addObject();
    this.myPinButtonText = this.myPinButtonPanel.pp_addObject();
    this.myPinButtonCursorTarget = this.myPinButtonPanel.pp_addObject();
    this.myNonVRParentObject = getPlayerObjects2(this._myEngine).myCameraNonVR.pp_addObject();
    this.myNonVRParentObject.pp_translateLocal(vec3_create2(0, 0, -this._mySetup._myPivotObjectDistanceFromHeadNonVR));
    this.myNonVRParentObject.pp_lookToLocal(vec3_create2(0, 0, 1), vec3_create2(0, 1, 0));
  }
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this.myVisibilityButtonPanel.pp_setPositionLocal(this._mySetup.myVisibilityButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
    this.myVisibilityButtonBackground.pp_scaleObject(this._mySetup.myVisibilityButtonBackgroundScale);
    this.myVisibilityButtonText.pp_setPositionLocal(this._mySetup.myVisibilityButtonTextPosition);
    this.myVisibilityButtonText.pp_scaleObject(this._mySetup.myVisibilityButtonTextScale);
    this.myVisibilityButtonCursorTarget.pp_setPositionLocal(this._mySetup.myVisibilityButtonCursorTargetPosition);
    this.myPinButtonPanel.pp_setPositionLocal(this._mySetup.myPinButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
    this.myPinButtonBackground.pp_scaleObject(this._mySetup.myFlagButtonBackgroundScale);
    this.myPinButtonText.pp_setPositionLocal(this._mySetup.myFlagButtonTextPosition);
    this.myPinButtonText.pp_scaleObject(this._mySetup.myFlagButtonTextScale);
    this.myPinButtonCursorTarget.pp_setPositionLocal(this._mySetup.myPinButtonCursorTargetPosition);
  }
  _addComponents() {
    this.myVisibilityButtonBackgroundComponent = this.myVisibilityButtonBackground.pp_addComponent(MeshComponent15);
    this.myVisibilityButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myVisibilityButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myVisibilityButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myVisibilityButtonTextComponent = this.myVisibilityButtonText.pp_addComponent(TextComponent10);
    this._setupButtonTextComponent(this.myVisibilityButtonTextComponent);
    this.myVisibilityButtonTextComponent.text = this._mySetup.myVisibilityButtonText;
    this.myVisibilityButtonCursorTargetComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CursorTarget7);
    this.myVisibilityButtonCollisionComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CollisionComponent5);
    this.myVisibilityButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myVisibilityButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myVisibilityButtonCollisionComponent.extents = this._mySetup.myVisibilityButtonCollisionExtents;
    this.myPinButtonBackgroundComponent = this.myPinButtonBackground.pp_addComponent(MeshComponent15);
    this.myPinButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPinButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myPinButtonBackgroundComponent.material.color = this._mySetup.myButtonDisabledBackgroundColor;
    this.myPinButtonTextComponent = this.myPinButtonText.pp_addComponent(TextComponent10);
    this._setupButtonTextComponent(this.myPinButtonTextComponent);
    this.myPinButtonTextComponent.material.color = this._mySetup.myButtonDisabledTextColor;
    this.myPinButtonTextComponent.text = this._mySetup.myPinButtonText;
    this.myPinButtonCursorTargetComponent = this.myPinButtonCursorTarget.pp_addComponent(CursorTarget7);
    this.myPinButtonCollisionComponent = this.myPinButtonCursorTarget.pp_addComponent(CollisionComponent5);
    this.myPinButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPinButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPinButtonCollisionComponent.extents = this._mySetup.myPinButtonCollisionExtents;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._mySetup.myTextAlignment;
    textComponent.justification = this._mySetup.myTextJustification;
    textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
    textComponent.material.color = this._mySetup.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this.myVisibilityButtonPanel.pp_setActive(this._myVisibilityButtonVisible);
    this._setTransformForVR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonVR();
  }
  _setTransformForVR() {
    this.myFixForwardObject.pp_setParent(this._myParentObject);
    this.myFixForwardObject.pp_resetTransformLocal();
    this.myFixForwardObject.pp_rotateObject(vec3_create2(0, 180, 0));
    this._updateObjectsTransforms(true);
  }
  _setTransformForNonVR() {
    if (!this._myIsPinned) {
      this.myFixForwardObject.pp_setParent(this.myNonVRParentObject);
      this.myFixForwardObject.pp_resetTransformLocal();
      this.myPivotObject.pp_setPositionLocal(this._mySetup.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myPivotObject.pp_resetRotationLocal();
      this.myPivotObject.pp_rotateObjectQuat(this._mySetup.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myWidgetObject.pp_setPositionLocal(this._mySetup.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myWidgetObject.pp_resetRotationLocal();
      this.myWidgetObject.pp_rotateObjectQuat(this._mySetup.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myVisibilityButtonPanel.pp_setPositionLocal(this._mySetup.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition);
      this.myPinButtonPanel.pp_setPositionLocal(this._mySetup.myPinButtonPosition[ToolHandedness.NONE].myPosition);
    }
  }
};

// js/pp/tool/widget_frame/widget_frame.js
var WidgetFrame = class {
  constructor(widgetLetterID, buttonsColumnIndex, engine2 = getMainEngine2()) {
    this.myIsWidgetVisible = true;
    this.myIsPinned = false;
    this._mySetup = new WidgetFrameSetup(widgetLetterID, buttonsColumnIndex);
    this._myAdditionalSetup = null;
    this._myUI = new WidgetFrameUI(engine2);
    this._myShowVisibilityButton = false;
    this._myWidgetVisibleChangedCallbacks = /* @__PURE__ */ new Map();
    this._myPinChangedCallbacks = /* @__PURE__ */ new Map();
  }
  getWidgetObject() {
    return this._myUI.myWidgetObject;
  }
  setVisible(visible) {
    this.myIsWidgetVisible = !visible;
    this._toggleVisibility(false, true);
  }
  isVisible() {
    return this.myIsWidgetVisible;
  }
  toggleVisibility() {
    this._toggleVisibility(false, true);
  }
  togglePin() {
    this._togglePin(false);
  }
  registerWidgetVisibleChangedEventListener(id, callback) {
    this._myWidgetVisibleChangedCallbacks.set(id, callback);
  }
  unregisterWidgetVisibleChangedEventListener(id) {
    this._myWidgetVisibleChangedCallbacks.delete(id);
  }
  registerPinChangedEventListener(id, callback) {
    this._myPinChangedCallbacks.set(id, callback);
  }
  unregisterPinChangedEventListener(id) {
    this._myPinChangedCallbacks.delete(id);
  }
  start(parentObject, additionalSetup) {
    this._myAdditionalSetup = additionalSetup;
    this._myUI.build(parentObject, this._mySetup, additionalSetup);
    this._myUI.setVisibilityButtonVisible(additionalSetup.myShowVisibilityButton);
    this._myShowVisibilityButton = additionalSetup.myShowVisibilityButton;
    if (!additionalSetup.myShowOnStart) {
      this._toggleVisibility(false, false);
    }
    this._addListeners();
  }
  update(dt) {
    this._myUI.update(dt);
  }
  _addListeners() {
    let ui = this._myUI;
    ui.myPinButtonCursorTargetComponent.addClickFunction(this._togglePin.bind(this, true));
    ui.myPinButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myPinButtonCursorTargetComponent.addUnHoverFunction(this._pinUnHover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.addClickFunction(this._toggleVisibility.bind(this, true, true));
    ui.myVisibilityButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.addUnHoverFunction(this._visibilityUnHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
  }
  _toggleVisibility(isButton, notify) {
    this.myIsWidgetVisible = !this.myIsWidgetVisible;
    this._myUI.setWidgetVisible(this.myIsWidgetVisible);
    let textMaterial = this._myUI.myVisibilityButtonTextComponent.material;
    let backgroundMaterial = this._myUI.myVisibilityButtonBackgroundComponent.material;
    if (this.myIsWidgetVisible) {
      textMaterial.color = this._mySetup.myDefaultTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._mySetup.myBackgroundColor;
      }
    } else {
      textMaterial.color = this._mySetup.myButtonDisabledTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._mySetup.myButtonDisabledBackgroundColor;
      }
    }
    if (notify) {
      for (let callback of this._myWidgetVisibleChangedCallbacks.values()) {
        callback(this.myIsWidgetVisible);
      }
    }
    this._myUI.setVisibilityButtonVisible(this._myShowVisibilityButton);
  }
  _togglePin(isButton) {
    if (this.myIsWidgetVisible) {
      this.myIsPinned = !this.myIsPinned;
      this._myUI.setPinned(this.myIsPinned);
      let textMaterial = this._myUI.myPinButtonTextComponent.material;
      let backgroundMaterial = this._myUI.myPinButtonBackgroundComponent.material;
      if (this.myIsPinned) {
        textMaterial.color = this._mySetup.myDefaultTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._mySetup.myBackgroundColor;
        }
      } else {
        textMaterial.color = this._mySetup.myButtonDisabledTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._mySetup.myButtonDisabledBackgroundColor;
        }
      }
      for (let callback of this._myPinChangedCallbacks.values()) {
        callback(this.myIsPinned);
      }
    }
  }
  _genericHover(material) {
    material.color = this._mySetup.myButtonHoverColor;
  }
  _visibilityUnHover(material) {
    if (this.myIsWidgetVisible) {
      material.color = this._mySetup.myBackgroundColor;
    } else {
      material.color = this._mySetup.myButtonDisabledBackgroundColor;
    }
  }
  _pinUnHover(material) {
    if (this.myIsPinned) {
      material.color = this._mySetup.myBackgroundColor;
    } else {
      material.color = this._mySetup.myButtonDisabledBackgroundColor;
    }
  }
};

// js/pp/tool/console_vr/console_original_functions.js
var _myOriginalConsoleLog = console.log;
var _myOriginalConsoleError = console.error;
var _myOriginalConsoleWarn = console.warn;
var _myOriginalConsoleInfo = console.info;
var _myOriginalConsoleDebug = console.debug;
var _myOriginalConsoleAssert = console.assert;
var _myOriginalConsoleClear = console.clear;
function getOriginalConsoleLog() {
  return _myOriginalConsoleLog;
}
function getOriginalConsoleError() {
  return _myOriginalConsoleError;
}
function getOriginalConsoleWarn() {
  return _myOriginalConsoleWarn;
}
function getOriginalConsoleInfo() {
  return _myOriginalConsoleInfo;
}
function getOriginalConsoleDebug() {
  return _myOriginalConsoleDebug;
}
function getOriginalConsoleAssert() {
  return _myOriginalConsoleAssert;
}
function getOriginalConsoleClear() {
  return _myOriginalConsoleClear;
}

// js/pp/tool/console_vr/console_vr_global.js
var _myConsoleVRs = /* @__PURE__ */ new WeakMap();
function getConsoleVR(engine2 = getMainEngine2()) {
  return _myConsoleVRs.get(engine2);
}
function setConsoleVR(consoleVR, engine2 = getMainEngine2()) {
  _myConsoleVRs.set(engine2, consoleVR);
}
function removeConsoleVR(engine2 = getMainEngine2()) {
  _myConsoleVRs.delete(engine2);
}
function hasConsoleVR(engine2 = getMainEngine2()) {
  return _myConsoleVRs.has(engine2);
}

// js/pp/tool/console_vr/console_vr_widget.js
var ConsoleVRWidgetAdditionalSetup = class {
  constructor() {
    this.myHandedness = ToolHandedness.NONE;
    this.myOverrideBrowserConsole = false;
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myPulseOnNewMessage = ConsoleVRWidgetPulseOnNewMessage.NEVER;
    this.myPlaneMaterial = null;
    this.myTextMaterial = null;
  }
};
var ConsoleVRWidgetMessage = class {
  constructor(messageType, messageLines) {
    this.myType = messageType;
    this.myLines = messageLines;
    this._myOriginalText = messageLines.join("\n");
    this._myMessagesCount = 1;
  }
  hasSameInfo(message) {
    return this._myOriginalText == message._myOriginalText && this.myType == message.myType;
  }
  increaseCount() {
    this._myMessagesCount += 1;
    let countString = "(x".concat(this._myMessagesCount).concat(") ");
    let text = this._myOriginalText.slice(0);
    text = countString.concat(text);
    this.myLines = text.split("\n");
  }
};
var ConsoleVRWidget = class {
  constructor(engine2 = getMainEngine2()) {
    this._myWidgetFrame = new WidgetFrame("C", 0, engine2);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._mySetup = new ConsoleVRWidgetSetup();
    this._myAdditionalSetup = null;
    this._myUI = new ConsoleVRWidgetUI(engine2);
    this._myMessages = [];
    this._myOldBrowserConsole = [];
    this._myOldConsoleVR = [];
    this._myTypeFilters = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
    }
    this._myScrollUp = false;
    this._myScrollDown = false;
    this._myScrollOffset = 0;
    this._myScrollTimer = 0;
    this._myScrollThumbstickTimer = 0;
    this._myPulseTimer = 0;
    this._myGamepadScrollActive = true;
    if (this._mySetup.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollActive = false;
    }
    this._myEngine = engine2;
  }
  setVisible(visible) {
    this._myWidgetFrame.setVisible(visible);
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, additionalSetup) {
    this._myLeftGamepad = getLeftGamepad(this._myEngine);
    this._myRightGamepad = getRightGamepad(this._myEngine);
    this._myAdditionalSetup = additionalSetup;
    this._myWidgetFrame.start(parentObject, additionalSetup);
    this._myUI.build(this._myWidgetFrame.getWidgetObject(), this._mySetup, additionalSetup);
    this._myUI.setVisible(this._myWidgetFrame.myIsWidgetVisible);
    this._setNotifyIconActive(false);
    this._addListeners();
    this._overrideConsolesFunctions();
  }
  _overrideConsolesFunctions() {
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG] = console.log;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR] = console.error;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN] = console.warn;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO] = console.info;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG] = console.debug;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT] = console.assert;
    this._myOldBrowserConsoleClear = console.clear;
    if (this._myAdditionalSetup.myOverrideBrowserConsole) {
      console.log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      window.addEventListener("error", function(errorEvent) {
        if (errorEvent.error != null) {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.error.stack);
        } else {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.message);
        }
      }.bind(this));
      window.addEventListener("unhandledrejection", function(errorEvent) {
        this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught (in promise)", errorEvent.reason);
      }.bind(this));
    }
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG] = getConsoleVR(this._myEngine).log;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR] = getConsoleVR(this._myEngine).error;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN] = getConsoleVR(this._myEngine).warn;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO] = getConsoleVR(this._myEngine).info;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG] = getConsoleVR(this._myEngine).debug;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT] = getConsoleVR(this._myEngine).assert;
    this._myOldConsoleVRClear = getConsoleVR(this._myEngine).clear;
    getConsoleVR(this._myEngine).log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.CONSOLE_VR);
    getConsoleVR(this._myEngine).error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.CONSOLE_VR);
    getConsoleVR(this._myEngine).warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.CONSOLE_VR);
    getConsoleVR(this._myEngine).info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.CONSOLE_VR);
    getConsoleVR(this._myEngine).debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.CONSOLE_VR);
    getConsoleVR(this._myEngine).assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.CONSOLE_VR);
    getConsoleVR(this._myEngine).clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.CONSOLE_VR);
  }
  update(dt) {
    this._myWidgetFrame.update(dt);
    if (this._myWidgetFrame.myIsWidgetVisible) {
      this._updateScroll(dt);
    }
    this._updateGamepadsExtraActions(dt);
  }
  _updateText(messageType) {
    let consoleText = "";
    if (!this._myTypeFilters[messageType]) {
      let linesCount = 0;
      let i = this._myMessages.length - 1;
      let scrollLinesToSkip = Math.round(this._myScrollOffset);
      while (i >= 0 && linesCount < this._mySetup.myMaxLines) {
        let message = this._myMessages[i];
        if (this._myTypeFilters[message.myType]) {
          i -= 1;
          continue;
        }
        let messageLines = message.myLines.length;
        let linesToSkip = 0;
        if (scrollLinesToSkip > 0) {
          let additionalEmptyLines = 0;
          if (i != this._myMessages.length - 1) {
            additionalEmptyLines = this._mySetup.myLinesBetweenMessages;
          }
          if (scrollLinesToSkip >= messageLines + additionalEmptyLines) {
            scrollLinesToSkip -= messageLines + additionalEmptyLines;
            linesToSkip = messageLines + additionalEmptyLines;
          } else {
            linesToSkip = scrollLinesToSkip;
            scrollLinesToSkip = 0;
          }
        }
        if (i != this._myMessages.length - 1) {
          let emptyLinesToSkip = this._mySetup.myLinesBetweenMessages - Math.max(this._mySetup.myLinesBetweenMessages - linesToSkip, 0);
          let emptyLinesToShow = this._mySetup.myLinesBetweenMessages - emptyLinesToSkip;
          if (linesCount + emptyLinesToShow > this._mySetup.myMaxLines) {
            emptyLinesToShow = this._myMaxLines - linesCount;
          }
          for (let j = 0; j < emptyLinesToShow; j++) {
            consoleText = "\n".concat(consoleText);
          }
          linesCount += emptyLinesToShow;
          linesToSkip -= emptyLinesToSkip;
        }
        let linesToShow = messageLines - linesToSkip;
        if (linesCount + linesToShow > this._mySetup.myMaxLines) {
          linesToShow = this._mySetup.myMaxLines - linesCount;
        }
        if (linesToShow > 0) {
          if (message.myType == messageType) {
            let linesToPrint = message.myLines.slice(messageLines - linesToShow - linesToSkip, messageLines - linesToSkip);
            let text = linesToPrint.join("\n");
            consoleText = text.concat("\n").concat(consoleText);
            linesCount += linesToShow;
          } else {
            for (let j = 0; j < linesToShow; j++) {
              consoleText = "\n".concat(consoleText);
            }
            linesCount += linesToShow;
          }
        }
        i -= 1;
      }
    }
    consoleText = this._mySetup.myMessagesTextStartString.concat(consoleText);
    this._myUI.myMessagesTextComponents[messageType].text = consoleText;
  }
  _consolePrint(consoleFunction, sender, ...args) {
    if (consoleFunction != ConsoleVRWidgetConsoleFunction.ASSERT || args.length > 0 && !args[0]) {
      let message = this._argsToMessage(consoleFunction, ...args);
      this._addMessage(message);
      if (this._myMessages.length >= this._mySetup.myMaxMessages + this._mySetup.myMaxMessagesDeletePad) {
        this._myMessages = this._myMessages.slice(this._myMessages.length - this._mySetup.myMaxMessages);
        this._clampScrollOffset();
      }
      this._updateAllTexts();
      this._pulseGamepad();
    }
    switch (sender) {
      case ConsoleVRWidgetSender.BROWSER_CONSOLE:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
      case ConsoleVRWidgetSender.CONSOLE_VR:
        this._myOldConsoleVR[consoleFunction].apply(getConsoleVR(this._myEngine), args);
        break;
      default:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
    }
  }
  _argsToMessage(consoleFunction, ...args) {
    if (consoleFunction == ConsoleVRWidgetConsoleFunction.ASSERT) {
      args = args.slice(1);
      args.splice(0, 0, this._mySetup.myAssertStartString);
    }
    let messageType = this._consoleFunctionToMessageType(consoleFunction);
    let formattedText = this._formatArgs(...args);
    let lines = this._splitLongLines(formattedText);
    if (messageType == ConsoleVRWidgetMessageType.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else if (messageType == ConsoleVRWidgetMessageType.EXCEPTION || messageType == ConsoleVRWidgetMessageType.ASSERT) {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    let message = new ConsoleVRWidgetMessage(messageType, lines);
    return message;
  }
  _consoleFunctionToMessageType(consoleFunction) {
    let messageType = ConsoleVRWidgetMessageType.LOG;
    if (consoleFunction < ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = consoleFunction;
    } else if (consoleFunction == ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    return messageType;
  }
  _formatArgs(...args) {
    let stringifiedArgs = [];
    for (let i = 0; i < args.length; i++) {
      if (args[i] === void 0) {
        stringifiedArgs.push("undefined");
      } else {
        stringifiedArgs.push(this._stringifyItem(args[i]));
      }
    }
    let formattedString = stringifiedArgs.join(" ");
    return formattedString;
  }
  _stringifyItem(item) {
    if (typeof item === "object") {
      let stringifiedItem = null;
      let linesBetweenItems = 2;
      try {
        stringifiedItem = JSON.stringify(item, this._jsonReplacer.bind(this), linesBetweenItems);
      } catch (error) {
        let cache = /* @__PURE__ */ new WeakSet();
        stringifiedItem = JSON.stringify(item, function(key, value) {
          if (typeof value === "object" && value !== null) {
            if (cache.has(value)) {
              return "<stringify error: object already stringified>";
            }
            cache.add(value);
          }
          return this._jsonReplacer(key, value);
        }.bind(this), linesBetweenItems);
      }
      stringifiedItem = stringifiedItem.replaceAll('"[', "[");
      stringifiedItem = stringifiedItem.replaceAll("'[", "[");
      stringifiedItem = stringifiedItem.replaceAll(']"', "]");
      stringifiedItem = stringifiedItem.replaceAll("]'", "]");
      return stringifiedItem;
    }
    return item;
  }
  _splitLongLines(messageText) {
    let linesToSplit = messageText.split("\n");
    let lines = [];
    for (let i = 0; i < linesToSplit.length; i++) {
      let lineToSplit = linesToSplit[i];
      if (lineToSplit.length > this._mySetup.myMaxCharactersPerLine) {
        let spacesAtStart = this._getSpacesAtStart(lineToSplit);
        let spaceToAdd = this._mySetup.myTabString.concat(spacesAtStart);
        let lineSplits = 0;
        while (lineToSplit.length > this._mySetup.myMaxCharactersPerLine && lineSplits < this._mySetup.myMaxLineSplits) {
          let firstSub = lineToSplit.substr(0, this._mySetup.myMaxCharactersPerLine - 1);
          let secondSub = lineToSplit.substr(this._mySetup.myMaxCharactersPerLine - 1);
          secondSub = spaceToAdd.concat(secondSub);
          lines.push(firstSub);
          lineToSplit = secondSub;
          lineSplits++;
        }
        lines.push(lineToSplit);
      } else {
        lines.push(lineToSplit);
      }
    }
    return lines;
  }
  _getSpacesAtStart(text) {
    let spaces = "";
    let i = 0;
    while (i < text.length && text[i] == " ") {
      spaces = spaces.concat(" ");
      i++;
    }
    return spaces;
  }
  _addMessage(message) {
    let hasSameInfoAsPrev = false;
    if (this._myMessages.length > 0) {
      let lastMessage = this._myMessages[this._myMessages.length - 1];
      if (lastMessage.hasSameInfo(message)) {
        lastMessage.increaseCount();
        hasSameInfoAsPrev = true;
      }
    }
    if (!hasSameInfoAsPrev) {
      this._myMessages.push(message);
    }
    this._adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev);
    this._updateNotifyIcon(message);
  }
  _adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev) {
    if (!hasSameInfoAsPrev && !this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._myScrollOffset += message.myLines.length + this._mySetup.myLinesBetweenMessages;
    }
  }
  _updateAllTexts() {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      for (let key in ConsoleVRWidgetMessageType) {
        this._updateText(ConsoleVRWidgetMessageType[key]);
      }
    }
  }
  _updateNotifyIcon(message) {
    if (!this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._setNotifyIconActive(true);
    }
  }
  _updateScroll(dt) {
    if (this._myScrollUp) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._mySetup.myScrollDelay) {
        this._myScrollTimer -= this._mySetup.myScrollDelay;
        this._myScrollOffset += this._mySetup.myScrollAmount;
      }
    } else if (this._myScrollDown) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._mySetup.myScrollDelay) {
        this._myScrollTimer -= this._mySetup.myScrollDelay;
        this._myScrollOffset -= this._mySetup.myScrollAmount;
      }
    }
    this._clampScrollOffset();
    if (this._myScrollUp || this._myScrollDown) {
      this._updateAllTexts();
    }
    if (this._myScrollOffset == 0) {
      this._setNotifyIconActive(false);
    }
  }
  _clampScrollOffset() {
    let maxScroll = this._getMaxScrollOffset();
    this._myScrollOffset = Math.pp_clamp(this._myScrollOffset, 0, maxScroll);
  }
  _getMaxScrollOffset() {
    return Math.max(this._getLinesCount() - this._mySetup.myMaxLines, 0);
  }
  _getLinesCount() {
    let linesCount = 0;
    for (let message of this._myMessages) {
      if (!this._myTypeFilters[message.myType]) {
        linesCount += message.myLines.length + this._mySetup.myLinesBetweenMessages;
      }
    }
    linesCount -= this._mySetup.myLinesBetweenMessages;
    linesCount = Math.max(linesCount, 0);
    return linesCount;
  }
  _addListeners() {
    let ui = this._myUI;
    for (let key in ConsoleVRWidgetMessageType) {
      let cursorTarget = ui.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]];
      let backgroundMaterial = ui.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
      let textMaterial = ui.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
      cursorTarget.addTripleClickFunction(this._resetFilters.bind(this, ConsoleVRWidgetMessageType[key]));
      cursorTarget.addDoubleClickFunction(this._filterAllButOne.bind(this, ConsoleVRWidgetMessageType[key], textMaterial));
      cursorTarget.addClickFunction(this._toggleFilter.bind(this, ConsoleVRWidgetMessageType[key], textMaterial));
      cursorTarget.addHoverFunction(this._filterHover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
      cursorTarget.addUnHoverFunction(this._filterUnHover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
    }
    {
      let cursorTarget = ui.myClearButtonCursorTargetComponent;
      let backgroundMaterial = ui.myClearButtonBackgroundComponent.material;
      cursorTarget.addClickFunction(this._clearConsole.bind(this, false, null));
      cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myUpButtonCursorTargetComponent;
      let backgroundMaterial = ui.myUpButtonBackgroundComponent.material;
      cursorTarget.addDoubleClickFunction(this._instantScrollUp.bind(this, true));
      cursorTarget.addDownFunction(this._setScrollUp.bind(this, true));
      cursorTarget.addUpFunction(this._setScrollUp.bind(this, false));
      cursorTarget.addUnHoverFunction(this._setScrollUp.bind(this, false));
      cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myDownButtonCursorTargetComponent;
      let backgroundMaterial = ui.myDownButtonBackgroundComponent.material;
      cursorTarget.addDoubleClickFunction(this._instantScrollDown.bind(this));
      cursorTarget.addDownFunction(this._setScrollDown.bind(this, true));
      cursorTarget.addUpFunction(this._setScrollDown.bind(this, false));
      cursorTarget.addUnHoverFunction(this._setScrollDown.bind(this, false));
      cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myNotifyIconCursorTargetComponent;
      let backgroundMaterial = ui.myNotifyIconBackgroundComponent.material;
      cursorTarget.addClickFunction(this._instantScrollDown.bind(this));
      cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.addUnHoverFunction(this._notifyIconUnHover.bind(this));
    }
    ui.myPointerCursorTargetComponent.addHoverFunction(this._setGamepadScrollActive.bind(this, true));
    ui.myPointerCursorTargetComponent.addUnHoverFunction(this._setGamepadScrollActive.bind(this, false));
  }
  _resetFilters(messageType) {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
        filterTextMaterial.color = this._mySetup.myMessageTypeColors[ConsoleVRWidgetMessageType[key]];
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          backgroundMaterial.color = this._mySetup.myBackgroundColor;
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _filterAllButOne(messageType) {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = true;
          backgroundMaterial.color = this._mySetup.myFilterButtonDisabledBackgroundColor;
          filterTextMaterial.color = this._mySetup.myFilterButtonDisabledTextColor;
        } else {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
          filterTextMaterial.color = this._mySetup.myMessageTypeColors[messageType];
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _toggleFilter(messageType, textMaterial) {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      this._myTypeFilters[messageType] = !this._myTypeFilters[messageType];
      if (this._myTypeFilters[messageType]) {
        textMaterial.color = this._mySetup.myFilterButtonDisabledTextColor;
      } else {
        textMaterial.color = this._mySetup.myMessageTypeColors[messageType];
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _clearConsole(codeDrivenClear = false, sender = null) {
    if (this._myWidgetFrame.myIsWidgetVisible || codeDrivenClear) {
      this._myMessages = [];
      this._clampScrollOffset();
      this._updateAllTexts();
      if (codeDrivenClear) {
        switch (sender) {
          case ConsoleVRWidgetSender.BROWSER_CONSOLE:
            this._myOldBrowserConsoleClear.apply(console);
            break;
          case ConsoleVRWidgetSender.CONSOLE_VR:
            this._myOldConsoleVRClear.apply(getConsoleVR(this._myEngine));
            break;
          default:
            break;
        }
      } else if (this._mySetup.myClearBrowserConsoleWhenClearPressed) {
        getOriginalConsoleClear()();
      }
    }
  }
  _setScrollUp(value) {
    if (this._myWidgetFrame.myIsWidgetVisible || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollUp = value;
    }
  }
  _setScrollDown(value) {
    if (this._myWidgetFrame.myIsWidgetVisible || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollDown = value;
    }
  }
  _instantScrollUp() {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      this._myScrollOffset = this._getMaxScrollOffset();
      this._updateAllTexts();
    }
  }
  _instantScrollDown() {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      this._myScrollOffset = 0;
      this._setNotifyIconActive(false);
      this._updateAllTexts();
    }
  }
  _setNotifyIconActive(active) {
    this._myUI.myNotifyIconPanel.pp_setActive(active && this._myWidgetFrame.myIsWidgetVisible);
  }
  _notifyIconUnHover() {
    let material = this._myUI.myNotifyIconBackgroundComponent.material;
    material.color = this._mySetup.myNotifyIconColor;
  }
  _filterHover(messageType, material) {
    this._genericHover(material);
  }
  _filterUnHover(messageType, material) {
    if (this._myTypeFilters[messageType]) {
      material.color = this._mySetup.myFilterButtonDisabledBackgroundColor;
    } else {
      material.color = this._mySetup.myBackgroundColor;
    }
  }
  _genericHover(material) {
    material.color = this._mySetup.myButtonHoverColor;
  }
  _genericUnHover(material) {
    material.color = this._mySetup.myBackgroundColor;
  }
  _updateGamepadsExtraActions(dt) {
    if (this._myLeftGamepad && this._myRightGamepad) {
      if (this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).myIsPressed || this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).myIsPressed) {
        this._toggleVisibility();
      }
      this._myPulseTimer = Math.max(this._myPulseTimer - dt, 0);
      this._updateScrollWithThumbstick(dt);
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    this._myUI.setVisible(visible);
    if (visible) {
      this._updateAllTexts();
    }
  }
  _updateScrollWithThumbstick(dt) {
    if (this._myWidgetFrame.myIsWidgetVisible && this._myGamepadScrollActive) {
      let axes = [0, 0];
      if (this._mySetup.myScrollThumbstickHandedness == ToolHandedness.LEFT) {
        axes = this._myLeftGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      } else if (this._mySetup.myScrollThumbstickHandedness == ToolHandedness.RIGHT) {
        axes = this._myRightGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      }
      if (Math.abs(axes[1]) > this._mySetup.myScrollThumbstickMinThreshold) {
        this._myScrollThumbstickTimer += dt;
        while (this._myScrollThumbstickTimer > this._mySetup.myScrollThumbstickDelay) {
          this._myScrollThumbstickTimer -= this._mySetup.myScrollThumbstickDelay;
          let normalizedScrollAmount = (Math.abs(axes[1]) - this._mySetup.myScrollThumbstickMinThreshold) / (1 - this._mySetup.myScrollThumbstickMinThreshold);
          this._myScrollOffset += Math.sign(axes[1]) * normalizedScrollAmount * this._mySetup.myScrollThumbstickAmount;
        }
        this._clampScrollOffset();
        this._updateAllTexts();
      } else {
        this._myScrollThumbstickTimer = 0;
      }
    }
  }
  _pulseGamepad() {
    if (this._myLeftGamepad && this._myRightGamepad) {
      let pulseType = this._myAdditionalSetup.myPulseOnNewMessage;
      let pulseEnabled = pulseType == ConsoleVRWidgetPulseOnNewMessage.ALWAYS || !this._myWidgetFrame.myIsWidgetVisible && pulseType == ConsoleVRWidgetPulseOnNewMessage.WHEN_HIDDEN;
      if (pulseEnabled && this._myPulseTimer == 0) {
        if (this._myAdditionalSetup.myHandedness == ToolHandedness.RIGHT) {
          this._myRightGamepad.pulse(this._mySetup.myPulseIntensity, this._mySetup.myPulseDuration);
        } else {
          this._myLeftGamepad.pulse(this._mySetup.myPulseIntensity, this._mySetup.myPulseDuration);
        }
        this._myPulseTimer = this._mySetup.myPulseDelay;
      }
    }
  }
  _isSimpleArray(array) {
    if (this._isSpecialSimpleArray(array)) {
      return true;
    } else if (Array.isArray(array)) {
      let isBuiltIn = true;
      for (let element of array) {
        if (element instanceof Object) {
          isBuiltIn = false;
          break;
        }
      }
      return isBuiltIn;
    }
    return false;
  }
  _isSpecialSimpleArray(item) {
    let arrayPrototypesToExtend = [
      Array.prototype,
      Uint8ClampedArray.prototype,
      Uint8Array.prototype,
      Uint16Array.prototype,
      Uint32Array.prototype,
      Int8Array.prototype,
      Int16Array.prototype,
      Int32Array.prototype,
      Float32Array.prototype,
      Float64Array.prototype
    ];
    return item && item.constructor && (item.constructor.name == "Uint8ClampedArray" || item.constructor.name == "Uint8Array" || item.constructor.name == "Uint16Array" || item.constructor.name == "Uint32Array" || item.constructor.name == "Int8Array" || item.constructor.name == "Int16Array" || item.constructor.name == "Int32Array" || item.constructor.name == "Float32Array" || item.constructor.name == "Float64Array");
  }
  _setGamepadScrollActive(active) {
    this._myGamepadScrollActive = active;
    if (!this._mySetup.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollActive = true;
    }
  }
  _jsonReplacer(key, value) {
    if (value instanceof Map) {
      return Array.from(value.entries());
    } else if (this._isSimpleArray(value)) {
      let array = value;
      if (this._isSpecialSimpleArray(array)) {
        let arrayCopy = [];
        for (let i = 0; i < array.length; i++) {
          arrayCopy[i] = array[i];
        }
        array = arrayCopy;
      }
      let stringifiedArray = JSON.stringify(array);
      stringifiedArray = stringifiedArray.split(",").join(", ");
      return stringifiedArray;
    } else {
      return value;
    }
  }
};

// js/pp/tool/console_vr/console_vr.js
var ConsoleVR = class {
  constructor() {
    this._myForwardToBrowserConsole = true;
  }
  log(...args) {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleLog().apply(console, args);
    }
  }
  error(...args) {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleError().apply(console, args);
    }
  }
  warn(...args) {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleWarn().apply(console, args);
    }
  }
  info(...args) {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleInfo().apply(console, args);
    }
  }
  debug(...args) {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleDebug().apply(console, args);
    }
  }
  assert(...args) {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleAssert().apply(console, args);
    }
  }
  clear() {
    if (this._myForwardToBrowserConsole) {
      getOriginalConsoleClear().apply(console);
    }
  }
  setForwardToBrowserConsole(forwardToBrowserConsole) {
    this._myForwardToBrowserConsole = forwardToBrowserConsole;
  }
  isForwardToBrowserConsole() {
    return this._myForwardToBrowserConsole;
  }
};

// js/pp/tool/console_vr/components/console_vr_tool_component.js
import { Component as Component65, Property as Property65 } from "@wonderlandengine/api";

// js/pp/tool/console_vr/components/init_console_vr_component.js
import { Component as Component64, Property as Property64 } from "@wonderlandengine/api";
var InitConsoleVRComponent = class extends Component64 {
  init() {
    this._myConsoleVR = null;
    if (this._myInit) {
      if (!hasConsoleVR(this.engine)) {
        this._myConsoleVR = new ConsoleVR();
        setConsoleVR(this._myConsoleVR, this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myConsoleVR != null && getConsoleVR(this.engine) == this._myConsoleVR) {
      removeConsoleVR(this.engine);
    }
  }
};
__publicField(InitConsoleVRComponent, "TypeName", "pp-init-console-vr");
__publicField(InitConsoleVRComponent, "Properties", {
  _myInit: Property64.bool(true)
});

// js/pp/tool/console_vr/components/console_vr_tool_component.js
var ConsoleVRToolComponent = class extends Component65 {
  init() {
    this.object.pp_addComponent(InitConsoleVRComponent);
    this._myWidget = new ConsoleVRWidget(this.engine);
    this._myStarted = false;
  }
  start() {
    if (isToolEnabled(this.engine)) {
      let additionalSetup = new ConsoleVRWidgetAdditionalSetup(this.engine);
      additionalSetup.myHandedness = [null, "left", "right"][this._myHandedness];
      additionalSetup.myOverrideBrowserConsole = this._myOverrideBrowserConsole;
      additionalSetup.myShowOnStart = this._myShowOnStart;
      additionalSetup.myShowVisibilityButton = this._myShowVisibilityButton;
      additionalSetup.myPulseOnNewMessage = this._myPulseOnNewMessage;
      additionalSetup.myPlaneMaterial = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      additionalSetup.myTextMaterial = getDefaultResources(this.engine).myMaterials.myText.clone();
      this._myWidget.start(this.object, additionalSetup);
      this._myWidgetVisibleBackup = this._myWidget.isVisible();
      this._mySetVisibleNextUpdate = false;
      this._myStarted = true;
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myStarted) {
        if (this._mySetVisibleNextUpdate) {
          this._mySetVisibleNextUpdate = false;
          this._myWidget.setVisible(false);
          this._myWidget.setVisible(this._myWidgetVisibleBackup);
        }
        this._myWidget.update(dt);
      }
    }
  }
  onActivate() {
    if (isToolEnabled(this.engine)) {
      if (this._myStarted) {
        this._mySetVisibleNextUpdate = true;
      }
    }
  }
  onDeactivate() {
    if (isToolEnabled(this.engine)) {
      if (this._myStarted) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
        this._myWidget.setVisible(false);
      }
    }
  }
};
__publicField(ConsoleVRToolComponent, "TypeName", "pp-console-vr-tool");
__publicField(ConsoleVRToolComponent, "Properties", {
  _myHandedness: Property65.enum(["None", "Left", "Right"], "None"),
  _myOverrideBrowserConsole: Property65.bool(true),
  _myShowOnStart: Property65.bool(false),
  _myShowVisibilityButton: Property65.bool(false),
  _myPulseOnNewMessage: Property65.enum(["Never", "Always", "When Hidden"], "Never")
});

// js/pp/tool/easy_tune/components/easy_tune_tool_component.js
import { Component as Component66, Property as Property66 } from "@wonderlandengine/api";

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget.js
var EasyTuneBaseWidgetParams = class {
  constructor() {
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneBaseWidget = class {
  constructor(params) {
    this._mySetup = null;
    this._myUI = null;
    this._myParams = params;
    this._myAdditionalSetup = null;
    this._myVariable = null;
    this._myIsVisible = true;
    this._myScrollVariableRequestCallbacks = /* @__PURE__ */ new Map();
    this._myAppendToVariableName = "";
    this._myScrollVariableActive = false;
    this._myScrollDirection = 0;
    this._myScrollVariableTimer = 0;
    this._myHasScrolled = false;
    this._myResetImportLabelTimer = new Timer(0, false);
    this._myResetExportLabelTimer = new Timer(0, false);
  }
  setVisible(visible) {
    if (visible) {
      this._refreshUI();
    }
    this._myUI.setVisible(visible);
    this._myIsVisible = visible;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    this._myVariable = variable;
    if (typeof appendToVariableName !== void 0) {
      this._myAppendToVariableName = appendToVariableName;
    } else {
      this._myAppendToVariableName = "";
    }
    this._setEasyTuneVariableHook();
    this._refreshUI();
  }
  isScrollVariableActive() {
    return this._myScrollVariableActive;
  }
  getScrollVariableDirection() {
    return this._myScrollDirection;
  }
  setScrollVariableActive(active, scrollDirection) {
    this._myScrollVariableActive = active;
    this._myScrollDirection = scrollDirection;
    this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
    this._myHasScrolled = false;
  }
  getWidget() {
    return this;
  }
  syncWidget(otherEasyTuneWidget) {
    if (otherEasyTuneWidget != null) {
      if (otherEasyTuneWidget._myResetImportLabelTimer.isRunning()) {
        this._myResetImportLabelTimer.start(otherEasyTuneWidget._myResetImportLabelTimer.getTimeLeft());
      } else {
        this._myResetImportLabelTimer.reset();
      }
      if (otherEasyTuneWidget._myResetExportLabelTimer.isRunning()) {
        this._myResetExportLabelTimer.start(otherEasyTuneWidget._myResetExportLabelTimer.getTimeLeft());
      } else {
        this._myResetExportLabelTimer.reset();
      }
      this._myUI.myImportButtonTextComponent.text = otherEasyTuneWidget._myUI.myImportButtonTextComponent.text;
      this._myUI.myExportButtonTextComponent.text = otherEasyTuneWidget._myUI.myExportButtonTextComponent.text;
      this.setScrollVariableActive(otherEasyTuneWidget.isScrollVariableActive(), otherEasyTuneWidget.getScrollVariableDirection());
    } else {
      this._myResetImportLabelTimer.reset();
      this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportButtonText;
      this._myResetExportLabelTimer.reset();
      this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportButtonText;
    }
  }
  onImportSuccess() {
    this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportSuccessButtonText;
    this._myResetImportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
  }
  onImportFailure() {
    this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportFailureButtonText;
    this._myResetImportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
  }
  onExportSuccess() {
    this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportSuccessButtonText;
    this._myResetExportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
  }
  onExportFailure() {
    this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportFailureButtonText;
    this._myResetExportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
  }
  registerScrollVariableRequestEventListener(id, callback) {
    this._myScrollVariableRequestCallbacks.set(id, callback);
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestCallbacks.delete(id);
  }
  start(parentObject, additionalSetup) {
    this._myAdditionalSetup = additionalSetup;
    this._mySetup.build();
    this._myResetImportLabelTimer.setDuration(this._mySetup.myImportExportResetLabelSeconds);
    this._myResetExportLabelTimer.setDuration(this._mySetup.myImportExportResetLabelSeconds);
    this._myUI.build(parentObject, this._mySetup, additionalSetup);
    this._myUI.setImportExportButtonsActive(this._myAdditionalSetup.myVariablesImportExportButtonsEnabled);
    this._startHook(parentObject, additionalSetup);
    this._addListeners();
  }
  update(dt) {
    if (this._isActive()) {
      this._updateHook(dt);
      this._updateScrollVariable(dt);
      this._updateImportExportLabel(dt);
    }
  }
  _setEasyTuneVariableHook() {
  }
  _refreshUIHook() {
  }
  _startHook(parentObject, additionalSetup) {
  }
  _addListenersHook() {
  }
  _updateHook(dt) {
  }
  _refreshUI() {
    if (this._myVariable) {
      if (this._myVariable.myName != null) {
        this._myUI.myVariableLabelTextComponent.text = this._myVariable.myName.concat(this._myAppendToVariableName);
      } else {
        let name = "Unknown";
        this._myUI.myVariableLabelTextComponent.text = name.concat(this._myAppendToVariableName);
      }
      this._refreshUIHook();
    }
  }
  _updateScrollVariable(dt) {
    if (this._myScrollVariableActive) {
      if (this._myScrollVariableTimer <= 0) {
        this._scrollVariableRequest(this._myScrollDirection);
        this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
        this._myHasScrolled = true;
      } else {
        this._myScrollVariableTimer -= dt;
      }
    }
  }
  _updateImportExportLabel(dt) {
    if (this._myResetImportLabelTimer.isRunning(dt)) {
      this._myResetImportLabelTimer.update(dt);
      if (this._myResetImportLabelTimer.isDone()) {
        this._myResetImportLabelTimer.reset();
        this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportButtonText;
      }
    }
    if (this._myResetExportLabelTimer.isRunning(dt)) {
      this._myResetExportLabelTimer.update(dt);
      if (this._myResetExportLabelTimer.isDone()) {
        this._myResetExportLabelTimer.reset();
        this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportButtonText;
      }
    }
  }
  _isActive() {
    return this._myIsVisible && this._myVariable;
  }
  _addListeners() {
    let ui = this._myUI;
    ui.myNextButtonCursorTargetComponent.addDownFunction(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.addDownOnHoverFunction(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.addUpFunction(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myNextButtonCursorTargetComponent.addUpWithNoDownFunction(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.addDownFunction(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.addDownOnHoverFunction(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.addUpFunction(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myPreviousButtonCursorTargetComponent.addUpWithNoDownFunction(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.addUpFunction(this._importVariables.bind(this));
    ui.myImportButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.addUpFunction(this._exportVariables.bind(this));
    ui.myExportButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myExportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myExportButtonBackgroundComponent.material));
    this._addListenersHook();
  }
  _setScrollVariableActive(active, scrollDirection, skipForceScroll) {
    if (this._isActive() || !active) {
      let forceScroll = !active && !this._myHasScrolled && !skipForceScroll;
      let oldScrollDirection = this._myScrollDirection;
      this.setScrollVariableActive(active, scrollDirection);
      if (forceScroll) {
        this._scrollVariableRequest(oldScrollDirection);
      }
    }
  }
  _scrollVariableRequest(amount) {
    if (this._isActive() && amount != 0) {
      for (let callback of this._myScrollVariableRequestCallbacks.values()) {
        callback(amount);
      }
    }
  }
  _genericHover(material) {
    material.color = this._mySetup.myButtonHoverColor;
  }
  _genericUnHover(material) {
    material.color = this._mySetup.myBackgroundColor;
  }
  _importVariables() {
    if (this._myUI.myImportButtonTextComponent.text == this._mySetup.myImportButtonText) {
      this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportingButtonText;
      this._myResetImportLabelTimer.reset();
      this._myParams.myVariablesImportCallback();
    }
  }
  _exportVariables() {
    if (this._myUI.myExportButtonTextComponent.text == this._mySetup.myExportButtonText) {
      this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportingButtonText;
      this._myResetExportLabelTimer.reset();
      this._myParams.myVariablesExportCallback();
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_array_widget_selector.js
var EasyTuneBaseArrayWidgetSelector = class {
  constructor(params, gamepad, engine2 = getMainEngine2()) {
    this._myGamepad = gamepad;
    this._myParentObject = null;
    this._myParams = params;
    this._myAdditionalSetup = null;
    this._myWidgets = /* @__PURE__ */ new Map();
    this._myVariable = null;
    this._myIsVisible = true;
    this._myAppendToVariableName = null;
    this._myScrollVariableRequestCallbacks = /* @__PURE__ */ new Map();
    this._myCurrentArraySize = 0;
    this._myEngine = engine2;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    this._myVariable = variable;
    this._myCurrentArraySize = this._myVariable.myValue.length;
    this._myAppendToVariableName = appendToVariableName;
    if (!this._myWidgets.has(this._myCurrentArraySize)) {
      this._createWidget(this._myCurrentArraySize);
    }
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setEasyTuneVariable(variable, appendToVariableName);
    }
    this.setVisible(this._myIsVisible);
  }
  setVisible(visible) {
    for (let widget of this._myWidgets.values()) {
      widget.setVisible(false);
    }
    if (this._myVariable) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.setVisible(visible);
      }
    }
    this._myIsVisible = visible;
  }
  isScrollVariableActive() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.isScrollVariableActive();
    }
    return false;
  }
  getScrollVariableDirection() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.getScrollVariableDirection();
    }
    return 0;
  }
  setScrollVariableActive(active, scrollDirection) {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setScrollVariableActive(active, scrollDirection);
    }
  }
  getWidget() {
    return this._myWidgets.get(this._myCurrentArraySize);
  }
  registerScrollVariableRequestEventListener(id, callback) {
    this._myScrollVariableRequestCallbacks.set(id, callback);
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestCallbacks.delete(id);
  }
  start(parentObject, additionalSetup) {
    this._myParentObject = parentObject;
    this._myAdditionalSetup = additionalSetup;
    this._createWidget(1);
    if (this._myVariable) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  update(dt) {
    if (this._isActive()) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.update(dt);
      }
    }
  }
  onImportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportSuccess();
    }
  }
  onImportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportFailure();
    }
  }
  onExportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportSuccess();
    }
  }
  onExportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportFailure();
    }
  }
  _isActive() {
    return this._myIsVisible && this._myVariable;
  }
  _scrollVariableRequest(amount) {
    for (let callback of this._myScrollVariableRequestCallbacks.values()) {
      callback(amount);
    }
  }
  _createWidget(arraySize) {
    this._myWidgets.set(arraySize, this._getEasyTuneArrayWidget(arraySize));
    this._myWidgets.get(arraySize).start(this._myParentObject, this._myAdditionalSetup);
    this._myWidgets.get(arraySize).setVisible(false);
    this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariableRequest.bind(this));
  }
  _sizeChangedCheck() {
    if (this._myVariable.myValue.length != this._myCurrentArraySize) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  _getEasyTuneArrayWidget(arraySize) {
    return null;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_setup.js
import { Alignment as Alignment6, Collider as Collider4, Justification as Justification6 } from "@wonderlandengine/api";
var EasyTuneBaseWidgetSetup = class {
  constructor() {
  }
  build() {
    this._initializeBuildSetup();
    this._initializeRuntimeSetup();
  }
  _getBackPanelMaxY() {
    return this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + this._mySideButtonDistanceFromBorder * 1.25;
  }
  _getBackPanelMinY() {
    return this.myDisplayPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getBackPanelMaxX() {
    return this._mySideButtonPanelHalfWidth;
  }
  _getBackPanelMinX() {
    return -this._mySideButtonPanelHalfWidth;
  }
  _getPivotZOffset() {
    return 0;
  }
  _initializeBuildSetupHook() {
  }
  _initializeRuntimeSetupHook() {
  }
  _initializeBuildSetup() {
    this.myBackgroundColor = vec4_create2(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider4.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create2(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment6.Center;
    this.myTextJustification = Justification6.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myLabelTextScale = vec3_create2(0.19, 0.19, 0.19);
    this.myButtonTextScale = vec3_create2(0.18, 0.18, 0.18);
    this._myPanelZOffset = 0.01;
    this._myColliderZOffset = 0.017;
    this._mySideButtonDistanceFromBorder = 0.0125;
    this._mySideButtonPanelHalfWidth = 0.2;
    this.myPivotObjectPositions = [];
    this.myPivotObjectPositions[ToolHandedness.NONE] = vec3_create2(0, 0, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.LEFT] = vec3_create2(-0.04, 0.02, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.RIGHT] = vec3_create2(-0.08, 0.02, this._getPivotZOffset());
    this.mySideButtonBackgroundScale = vec3_create2(0.015, 0.015, 1);
    this.mySideButtonTextScale = this.myButtonTextScale;
    this.mySideButtonTextPosition = vec3_create2(0, 0, 7e-3);
    this.mySideButtonCursorTargetPosition = vec3_create2(0, 0, 0);
    this.mySideButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.pp_clone();
    this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myLeftSideButtonPosition = vec3_create2(0, 0, -1e-5);
    this.myLeftSideButtonPosition[0] = -this._mySideButtonPanelHalfWidth + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
    this.myRightSideButtonPosition = vec3_create2(0, 0, -1e-5);
    this.myRightSideButtonPosition[0] = -this.myLeftSideButtonPosition[0];
    this.myDisplayPanelPosition = vec3_create2(0, 0.1, 0);
    this.myVariableLabelPanelPosition = vec3_create2(0, 0.025, this._myPanelZOffset);
    this.myVariableLabelTextScale = this.myLabelTextScale;
    this.myVariableLabelCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myVariableLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myVariableLabelCollisionExtents = vec3_create2(0.065, 0.0175, 1);
    this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNextButtonText = ">";
    this.myPreviousButtonText = "<";
    this._initializeBuildSetupHook();
    {
      let maxX = this._getBackPanelMaxX();
      let minX = this._getBackPanelMinX();
      let maxY = this._getBackPanelMaxY();
      let minY = this._getBackPanelMinY();
      this.myBackPanelPosition = [(maxX + minX) / 2, (maxY + minY) / 2, 0];
      this.myBackBackgroundScale = [(maxX - minX) / 2, (maxY - minY) / 2, 1];
      this.myBackBackgroundColor = vec4_create2(70 / 255, 70 / 255, 70 / 255, 1);
    }
    this.myImportExportButtonBackgroundScale = vec3_create2(0.04, 0.02, 1);
    this.myImportExportButtonTextScale = this.myButtonTextScale;
    this.myImportExportButtonTextPosition = vec3_create2(0, 0, 7e-3);
    this.myImportExportPanelPosition = [0, this._getBackPanelMaxY() + this._mySideButtonDistanceFromBorder + this.myImportExportButtonBackgroundScale[1], this._myPanelZOffset];
    this.myImportExportButtonCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myImportExportButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myImportExportButtonCollisionExtents = this.myImportExportButtonBackgroundScale.pp_clone();
    this.myImportExportButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myImportButtonText = "Import";
    this.myExportButtonText = "Export";
    this.myImportExportResetLabelSeconds = 2;
    this.myImportingButtonText = "...";
    this.myImportSuccessButtonText = "Done";
    this.myImportFailureButtonText = "Error";
    this.myExportingButtonText = "...";
    this.myExportSuccessButtonText = "Done";
    this.myExportFailureButtonText = "Error";
    this.myImportButtonPosition = vec3_create2(0, 0, -1e-5);
    this.myImportButtonPosition[0] = -this.myImportExportButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder / 2;
    this.myExportButtonPosition = vec3_create2(0, 0, -1e-5);
    this.myExportButtonPosition[0] = -this.myImportButtonPosition[0];
    this.myPointerCollisionExtents = this.myBackBackgroundScale.pp_clone();
    this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myPointerCursorTargetPosition = this.myBackPanelPosition.pp_clone();
    this.myPointerCursorTargetPosition[2] = this._myColliderZOffset - 1e-4;
  }
  _initializeRuntimeSetup() {
    this.myButtonHoverColor = vec4_create2(150 / 255, 150 / 255, 150 / 255, 1);
    this.myScrollVariableDelay = 0.5;
    this._initializeRuntimeSetupHook();
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_setup.js
var EasyTuneBoolArrayWidgetSetup = class extends EasyTuneBaseWidgetSetup {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    return super._getBackPanelMinY() + this.myValuesPanelPosition[1] + valuePanelLastPosition;
  }
  _getPivotZOffset() {
    return 802713e-8;
  }
  _initializeBuildSetupHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create2(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create2(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create2(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
  }
  _initializeRuntimeSetupHook() {
    this.myTextHoverScaleMultiplier = vec3_create2(1.25, 1.25, 1.25);
    this.myThumbstickToggleThreshold = 0.6;
    this.myButtonEditDelay = 0;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
import { CollisionComponent as CollisionComponent7, MeshComponent as MeshComponent17, TextComponent as TextComponent12 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget9 } from "@wonderlandengine/components";

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_ui.js
import { CollisionComponent as CollisionComponent6, MeshComponent as MeshComponent16, TextComponent as TextComponent11 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget8 } from "@wonderlandengine/components";
var EasyTuneBaseWidgetUI = class {
  constructor(engine2 = getMainEngine2()) {
    this._myEngine = engine2;
  }
  build(parentObject, setup, additionalSetup) {
    this._myParentObject = parentObject;
    this._mySetup = setup;
    this._myAdditionalSetup = additionalSetup;
    this._myImportExportButtonsActive = true;
    this._myPlaneMesh = getDefaultResources(this._myEngine).myMeshes.myPlane;
    this._buildHook();
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonVR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
    if (visible) {
      this.setImportExportButtonsActive(this._myImportExportButtonsActive);
    }
    this._setVisibleHook(visible);
  }
  setImportExportButtonsActive(active) {
    this._myImportExportButtonsActive = active;
    this.myImportExportPanel.pp_setActive(this._myImportExportButtonsActive);
  }
  _buildHook() {
  }
  _setVisibleHook(visible) {
  }
  _createSkeletonHook() {
  }
  _setTransformHook() {
  }
  _addComponentsHook() {
  }
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addObject();
    this.myBackPanel = this.myPivotObject.pp_addObject();
    this.myBackBackground = this.myBackPanel.pp_addObject();
    this.myDisplayPanel = this.myPivotObject.pp_addObject();
    this.myVariableLabelPanel = this.myDisplayPanel.pp_addObject();
    this.myVariableLabelText = this.myVariableLabelPanel.pp_addObject();
    this.myVariableLabelCursorTarget = this.myVariableLabelPanel.pp_addObject();
    this.myNextButtonPanel = this.myVariableLabelPanel.pp_addObject();
    this.myNextButtonBackground = this.myNextButtonPanel.pp_addObject();
    this.myNextButtonText = this.myNextButtonPanel.pp_addObject();
    this.myNextButtonCursorTarget = this.myNextButtonPanel.pp_addObject();
    this.myPreviousButtonPanel = this.myVariableLabelPanel.pp_addObject();
    this.myPreviousButtonBackground = this.myPreviousButtonPanel.pp_addObject();
    this.myPreviousButtonText = this.myPreviousButtonPanel.pp_addObject();
    this.myPreviousButtonCursorTarget = this.myPreviousButtonPanel.pp_addObject();
    this.myImportExportPanel = this.myPivotObject.pp_addObject();
    this.myImportButtonPanel = this.myImportExportPanel.pp_addObject();
    this.myImportButtonBackground = this.myImportButtonPanel.pp_addObject();
    this.myImportButtonText = this.myImportButtonPanel.pp_addObject();
    this.myImportButtonCursorTarget = this.myImportButtonPanel.pp_addObject();
    this.myExportButtonPanel = this.myImportExportPanel.pp_addObject();
    this.myExportButtonBackground = this.myExportButtonPanel.pp_addObject();
    this.myExportButtonText = this.myExportButtonPanel.pp_addObject();
    this.myExportButtonCursorTarget = this.myExportButtonPanel.pp_addObject();
    this.myPointerCursorTarget = this.myPivotObject.pp_addObject();
    this._createSkeletonHook();
  }
  _setTransforms() {
    this.myPivotObject.pp_setPositionLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);
    this.myBackPanel.pp_setPositionLocal(this._mySetup.myBackPanelPosition);
    this.myBackBackground.pp_scaleObject(this._mySetup.myBackBackgroundScale);
    this.myDisplayPanel.pp_setPositionLocal(this._mySetup.myDisplayPanelPosition);
    this.myVariableLabelPanel.pp_setPositionLocal(this._mySetup.myVariableLabelPanelPosition);
    this.myVariableLabelText.pp_scaleObject(this._mySetup.myVariableLabelTextScale);
    this.myVariableLabelCursorTarget.pp_setPositionLocal(this._mySetup.myVariableLabelCursorTargetPosition);
    this.myNextButtonPanel.pp_setPositionLocal(this._mySetup.myRightSideButtonPosition);
    this.myNextButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myNextButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myNextButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myNextButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myPreviousButtonPanel.pp_setPositionLocal(this._mySetup.myLeftSideButtonPosition);
    this.myPreviousButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myPreviousButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myPreviousButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myPreviousButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myImportExportPanel.pp_setPositionLocal(this._mySetup.myImportExportPanelPosition);
    this.myImportButtonPanel.pp_setPositionLocal(this._mySetup.myImportButtonPosition);
    this.myImportButtonBackground.pp_scaleObject(this._mySetup.myImportExportButtonBackgroundScale);
    this.myImportButtonText.pp_setPositionLocal(this._mySetup.myImportExportButtonTextPosition);
    this.myImportButtonText.pp_scaleObject(this._mySetup.myImportExportButtonTextScale);
    this.myImportButtonCursorTarget.pp_setPositionLocal(this._mySetup.myImportExportButtonCursorTargetPosition);
    this.myExportButtonPanel.pp_setPositionLocal(this._mySetup.myExportButtonPosition);
    this.myExportButtonBackground.pp_scaleObject(this._mySetup.myImportExportButtonBackgroundScale);
    this.myExportButtonText.pp_setPositionLocal(this._mySetup.myImportExportButtonTextPosition);
    this.myExportButtonText.pp_scaleObject(this._mySetup.myImportExportButtonTextScale);
    this.myExportButtonCursorTarget.pp_setPositionLocal(this._mySetup.myImportExportButtonCursorTargetPosition);
    this.myPointerCursorTarget.pp_setPositionLocal(this._mySetup.myPointerCursorTargetPosition);
    this._setTransformHook();
  }
  _addComponents() {
    this.myBackBackgroundComponent = this.myBackBackground.pp_addComponent(MeshComponent16);
    this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
    this.myBackBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myBackBackgroundComponent.material.color = this._mySetup.myBackBackgroundColor;
    this.myVariableLabelTextComponent = this.myVariableLabelText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myVariableLabelTextComponent);
    this.myVariableLabelTextComponent.text = " ";
    this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.pp_addComponent(CursorTarget8);
    this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.pp_addComponent(CollisionComponent6);
    this.myVariableLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myVariableLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myVariableLabelCollisionComponent.extents = this._mySetup.myVariableLabelCollisionExtents;
    this.myNextButtonBackgroundComponent = this.myNextButtonBackground.pp_addComponent(MeshComponent16);
    this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNextButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myNextButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myNextButtonTextComponent = this.myNextButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myNextButtonTextComponent);
    this.myNextButtonTextComponent.text = this._mySetup.myNextButtonText;
    this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.pp_addComponent(CursorTarget8);
    this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myNextButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myNextButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myNextButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.pp_addComponent(MeshComponent16);
    this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPreviousButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myPreviousButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myPreviousButtonTextComponent = this.myPreviousButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myPreviousButtonTextComponent);
    this.myPreviousButtonTextComponent.text = this._mySetup.myPreviousButtonText;
    this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CursorTarget8);
    this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myPreviousButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPreviousButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPreviousButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myImportButtonBackgroundComponent = this.myImportButtonBackground.pp_addComponent(MeshComponent16);
    this.myImportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myImportButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myImportButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myImportButtonTextComponent = this.myImportButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myImportButtonTextComponent);
    this.myImportButtonTextComponent.text = this._mySetup.myImportButtonText;
    this.myImportButtonCursorTargetComponent = this.myImportButtonCursorTarget.pp_addComponent(CursorTarget8);
    this.myImportButtonCollisionComponent = this.myImportButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myImportButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myImportButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myImportButtonCollisionComponent.extents = this._mySetup.myImportExportButtonCollisionExtents;
    this.myExportButtonBackgroundComponent = this.myExportButtonBackground.pp_addComponent(MeshComponent16);
    this.myExportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myExportButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myExportButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myExportButtonTextComponent = this.myExportButtonText.pp_addComponent(TextComponent11);
    this._setupTextComponent(this.myExportButtonTextComponent);
    this.myExportButtonTextComponent.text = this._mySetup.myExportButtonText;
    this.myExportButtonCursorTargetComponent = this.myExportButtonCursorTarget.pp_addComponent(CursorTarget8);
    this.myExportButtonCollisionComponent = this.myExportButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myExportButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myExportButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myExportButtonCollisionComponent.extents = this._mySetup.myImportExportButtonCollisionExtents;
    this.myPointerCollisionComponent = this.myPointerCursorTarget.pp_addComponent(CollisionComponent6);
    this.myPointerCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPointerCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPointerCollisionComponent.extents = this._mySetup.myPointerCollisionExtents;
    this._addComponentsHook();
  }
  _setupTextComponent(textComponent) {
    textComponent.alignment = this._mySetup.myTextAlignment;
    textComponent.justification = this._mySetup.myTextJustification;
    textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
    textComponent.material.color = this._mySetup.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForVR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonVR();
  }
  _setTransformForVR() {
    this.myPivotObject.pp_setPositionLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);
  }
  _setTransformForNonVR() {
    this.myPivotObject.pp_setPositionLocal(this._mySetup.myPivotObjectPositions[ToolHandedness.NONE]);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
var EasyTuneBoolArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  setAdditionalButtonsActive(active) {
    this._myAdditionalButtonsActive = active;
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
    }
  }
  _buildHook() {
    this._myAdditionalButtonsActive = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addObject();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addObject();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addObject();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
    }
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._mySetup.myValuesPanelPosition);
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._mySetup.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._mySetup.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._mySetup.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    }
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent12);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget9);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent7);
      this.myValueCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent17);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent12);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget9);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent7);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent17);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent12);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget9);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent7);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
    }
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget.js
var EasyTuneBoolArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine2 = getMainEngine2()) {
    super(params);
    this._mySetup = new EasyTuneBoolArrayWidgetSetup(arraySize);
    this._myUI = new EasyTuneBoolArrayWidgetUI(engine2);
    this._myGamepad = gamepad;
    this._myValueEditIndex = 0;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myValueEditActive = false;
  }
  _refreshUIHook() {
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i] ? "true" : "false";
    }
  }
  _startHook(parentObject, additionalSetup) {
    this._myUI.setAdditionalButtonsActive(additionalSetup.myAdditionalButtonsEnabled);
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      stickVariableIntensity = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
    }
    let valueIntensity = 0;
    if (this._myValueEditActive) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (Math.abs(valueIntensity) > this._mySetup.myThumbstickToggleThreshold) {
      this._myVariable.myValue[this._myValueEditIndex] = valueIntensity > 0;
      this._refreshUI();
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], false));
    }
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setValueEditActive(index, text, active) {
    if (this._isActive() || !active) {
      if (active) {
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleWorld(this._mySetup.myValueTextScale);
      }
      this._myValueEditActive = active;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myVariable.myValue[index] = this._myVariable.myDefaultValue[index];
      this._myUI.myValueTextComponents[index].text = this._myVariable.myValue[index] ? "true" : "false";
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
  }
  _genericTextUnHover(text, originalScale) {
    text.pp_setScaleWorld(originalScale);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_selector.js
var EasyTuneBoolArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneBoolArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget_setup.js
var EasyTuneWidgetSetup = class {
  constructor() {
    this._initializeRuntimeSetup();
  }
  _initializeRuntimeSetup() {
    this.myGamepadHandedness = ToolHandedness.RIGHT;
    this.myScrollVariableDelay = 0.5;
    this.myScrollVariableMinXThreshold = 0.6;
    this.myScrollVariableMaxYThreshold = 0.25;
    this.myScrollVariableButtonID = null;
    this.myRefreshVariablesDelay = null;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_setup.js
var EasyTuneNoneWidgetSetup = class extends EasyTuneBaseWidgetSetup {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myTypeNotSupportedPanelPosition[1];
  }
  _getPivotZOffset() {
    return 804713e-8;
  }
  _initializeBuildSetupHook() {
    this.myTypeNotSupportedPanelPosition = vec3_create2(0, -0.03, this._myPanelZOffset);
    this.myTypeNotSupportedTextScale = vec3_create2(0.275, 0.275, 0.275);
    this.myTypeNotSupportedText = "Type Not Supported";
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_ui.js
import { TextComponent as TextComponent13 } from "@wonderlandengine/api";
var EasyTuneNoneWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  _createSkeletonHook() {
    this.myTypeNotSupportedPanel = this.myDisplayPanel.pp_addObject();
    this.myTypeNotSupportedText = this.myTypeNotSupportedPanel.pp_addObject();
    this.myTypeNotSupportedCursorTarget = this.myTypeNotSupportedPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myTypeNotSupportedPanel.pp_setPositionLocal(this._mySetup.myTypeNotSupportedPanelPosition);
    this.myTypeNotSupportedText.pp_scaleObject(this._mySetup.myTypeNotSupportedTextScale);
  }
  _addComponentsHook() {
    this.myTypeNotSupportedTextComponent = this.myTypeNotSupportedText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myTypeNotSupportedTextComponent);
    this.myTypeNotSupportedTextComponent.text = this._mySetup.myTypeNotSupportedText;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget.js
var EasyTuneNoneWidget = class extends EasyTuneBaseWidget {
  constructor(params, engine2 = getMainEngine2()) {
    super(params);
    this._mySetup = new EasyTuneNoneWidgetSetup();
    this._myUI = new EasyTuneNoneWidgetUI(engine2);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_setup.js
var EasyTuneNumberArrayWidgetSetup = class extends EasyTuneBaseWidgetSetup {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    return this.myStepPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getPivotZOffset() {
    return 803713e-8;
  }
  _initializeBuildSetupHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create2(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create2(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create2(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    this.myStepPanelPosition = [0, this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create2(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _initializeRuntimeSetupHook() {
    this.myTextHoverScaleMultiplier = vec3_create2(1.25, 1.25, 1.25);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_ui.js
import { CollisionComponent as CollisionComponent8, MeshComponent as MeshComponent18, TextComponent as TextComponent14 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget10 } from "@wonderlandengine/components";
var EasyTuneNumberArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  setAdditionalButtonsActive(active) {
    this._myAdditionalButtonsActive = active;
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
    }
    this.myStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
    this.myStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
  }
  _buildHook() {
    this._myAdditionalButtonsActive = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addObject();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addObject();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addObject();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
    }
    this.myStepPanel = this.myPivotObject.pp_addObject();
    this.myStepText = this.myStepPanel.pp_addObject();
    this.myStepCursorTarget = this.myStepPanel.pp_addObject();
    this.myStepIncreaseButtonPanel = this.myStepPanel.pp_addObject();
    this.myStepIncreaseButtonBackground = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepIncreaseButtonText = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepIncreaseButtonCursorTarget = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonPanel = this.myStepPanel.pp_addObject();
    this.myStepDecreaseButtonBackground = this.myStepDecreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonText = this.myStepDecreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonCursorTarget = this.myStepDecreaseButtonPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._mySetup.myValuesPanelPosition);
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._mySetup.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._mySetup.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._mySetup.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    }
    this.myStepPanel.pp_setPositionLocal(this._mySetup.myStepPanelPosition);
    this.myStepText.pp_scaleObject(this._mySetup.myStepTextScale);
    this.myStepCursorTarget.pp_setPositionLocal(this._mySetup.myStepCursorTargetPosition);
    this.myStepIncreaseButtonPanel.pp_setPositionLocal(this._mySetup.myRightSideButtonPosition);
    this.myStepIncreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myStepIncreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myStepIncreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myStepDecreaseButtonPanel.pp_setPositionLocal(this._mySetup.myLeftSideButtonPosition);
    this.myStepDecreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myStepDecreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myStepDecreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget10);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent18);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget10);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent18);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget10);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
    }
    this.myStepTextComponent = this.myStepText.pp_addComponent(TextComponent14);
    this._setupTextComponent(this.myStepTextComponent);
    this.myStepTextComponent.text = " ";
    this.myStepCursorTargetComponent = this.myStepCursorTarget.pp_addComponent(CursorTarget10);
    this.myStepCollisionComponent = this.myStepCursorTarget.pp_addComponent(CollisionComponent8);
    this.myStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myStepIncreaseButtonBackgroundComponent = this.myStepIncreaseButtonBackground.pp_addComponent(MeshComponent18);
    this.myStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myStepIncreaseButtonTextComponent = this.myStepIncreaseButtonText.pp_addComponent(TextComponent14);
    this._setupTextComponent(this.myStepIncreaseButtonTextComponent);
    this.myStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myStepIncreaseButtonCursorTargetComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget10);
    this.myStepIncreaseButtonCollisionComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent8);
    this.myStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myStepDecreaseButtonBackgroundComponent = this.myStepDecreaseButtonBackground.pp_addComponent(MeshComponent18);
    this.myStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myStepDecreaseButtonTextComponent = this.myStepDecreaseButtonText.pp_addComponent(TextComponent14);
    this._setupTextComponent(this.myStepDecreaseButtonTextComponent);
    this.myStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myStepDecreaseButtonCursorTargetComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget10);
    this.myStepDecreaseButtonCollisionComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent8);
    this.myStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget.js
var EasyTuneNumberArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine2 = getMainEngine2()) {
    super(params);
    this._myGamepad = gamepad;
    this._mySetup = new EasyTuneNumberArrayWidgetSetup(arraySize);
    this._myUI = new EasyTuneNumberArrayWidgetUI(engine2);
    this._myValueEditIndex = -1;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditActive = false;
    this._myStepEditActive = false;
    this._myValueRealValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
  }
  _setEasyTuneVariableHook() {
    if (this._myValueEditIndex >= 0) {
      this._myValueRealValue = this._myVariable.myValue[this._myValueEditIndex];
    }
  }
  _refreshUIHook() {
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i].toFixed(this._myVariable.myDecimalPlaces);
    }
    this._myUI.myStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myStepPerSecond);
  }
  _startHook(parentObject, additionalSetup) {
    this._myUI.setAdditionalButtonsActive(additionalSetup.myAdditionalButtonsEnabled);
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._mySetup.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._mySetup.myEditThumbstickMinThreshold) / (1 - this._mySetup.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditActive) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (valueIntensity != 0) {
      let amountToAdd = valueIntensity * this._myVariable.myStepPerSecond * dt;
      this._myValueRealValue += amountToAdd;
      if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
        this._myValueRealValue = Math.pp_clamp(this._myValueRealValue, this._myVariable.myMin, this._myVariable.myMax);
      } else if (this._myVariable.myMin != null) {
        this._myValueRealValue = Math.max(this._myValueRealValue, this._myVariable.myMin);
      } else if (this._myVariable.myMax != null) {
        this._myValueRealValue = Math.min(this._myValueRealValue, this._myVariable.myMax);
      }
      let decimalPlacesMultiplier = Math.pow(10, this._myVariable.myDecimalPlaces);
      if (this._myVariable.myEditAllValuesTogether) {
        let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
        let difference = newValue - this._myVariable.myValue[this._myValueEditIndex];
        for (let i = 0; i < this._mySetup.myArraySize; i++) {
          this._myVariable.myValue[i] = Math.round((this._myVariable.myValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
            this._myVariable.myValue[i] = Math.pp_clamp(this._myVariable.myValue[i], this._myVariable.myMin, this._myVariable.myMax);
          } else if (this._myVariable.myMin != null) {
            this._myVariable.myValue[i] = Math.max(this._myVariable.myValue[i], this._myVariable.myMin);
          } else if (this._myVariable.myMax != null) {
            this._myVariable.myValue[i] = Math.min(this._myVariable.myValue[i], this._myVariable.myMax);
          }
          this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i].toFixed(this._myVariable.myDecimalPlaces);
        }
      } else {
        this._myVariable.myValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
        if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
          this._myVariable.myValue[this._myValueEditIndex] = Math.pp_clamp(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMin, this._myVariable.myMax);
        } else if (this._myVariable.myMin != null) {
          this._myVariable.myValue[this._myValueEditIndex] = Math.max(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMin);
        } else if (this._myVariable.myMax != null) {
          this._myVariable.myValue[this._myValueEditIndex] = Math.min(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMax);
        }
        this._myUI.myValueTextComponents[this._myValueEditIndex].text = this._myVariable.myValue[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
      }
    } else {
      this._myValueRealValue = this._myVariable.myValue[this._myValueEditIndex];
    }
    let stepIntensity = 0;
    if (this._myStepEditActive) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._mySetup.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myVariable.myStepPerSecond * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myVariable.myStepPerSecond * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], false));
    }
    ui.myStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this));
    ui.myStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, ui.myStepText, true));
    ui.myStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, ui.myStepText, false));
    ui.myStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
        this._myValueRealValue = this._myVariable.myValue[index];
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
    }
  }
  _setValueEditActive(index, text, active) {
    if (this._isActive() || !active) {
      if (active) {
        this._myValueRealValue = this._myVariable.myValue[index];
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleWorld(this._mySetup.myValueTextScale);
      }
      this._myValueEditActive = active;
    }
  }
  _setStepEditActive(text, active) {
    if (this._isActive() || !active) {
      if (active) {
        text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleWorld(this._mySetup.myStepTextScale);
      }
      this._myStepEditActive = active;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myVariable.myValue[index] = this._myVariable.myDefaultValue[index];
      this._myUI.myValueTextComponents[index].text = this._myVariable.myValue[index].toFixed(this._myVariable.myDecimalPlaces);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._mySetup.myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _resetStep() {
    if (this._isActive()) {
      this._changeStep(this._myVariable.myDefaultStepPerSecond);
    }
  }
  _changeStep(step) {
    step = Math.pp_roundDecimal(step, 10);
    this._myVariable.myStepPerSecond = step;
    this._myUI.myStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myStepPerSecond);
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
  }
  _genericTextUnHover(text, originalScale) {
    text.pp_setScaleWorld(originalScale);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_widget_selector.js
var EasyTuneNumberArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneNumberArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_setup.js
var EasyTuneTransformWidgetSetup = class extends EasyTuneBaseWidgetSetup {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myPositionPanelPosition[1] + this.myStepPanelPosition[1];
  }
  _getBackPanelMaxX() {
    return this.myDisplayPanelPosition[0] + this.myRotationPanelPosition[0] + this.myIncreaseButtonPosition[0] + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
  }
  _getBackPanelMinX() {
    return this.myDisplayPanelPosition[0] + this.myScalePanelPosition[0] + this.myDecreaseButtonPosition[0] - this.mySideButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder;
  }
  _getPivotZOffset() {
    return 805713e-8;
  }
  _initializeBuildSetupHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this.myDecreaseButtonPosition = vec3_create2(-0.13, 0, -1e-5);
    this.myIncreaseButtonPosition = vec3_create2(-this.myDecreaseButtonPosition[0], 0, -1e-5);
    let distanceBetweenComponents = Math.abs(this.myIncreaseButtonPosition[0]) + Math.abs(this.myRightSideButtonPosition[0]);
    let distanceFromVariableLabel = 0.045;
    this.myPositionPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myRotationPanelPosition = [this.myPositionPanelPosition[0] + distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myScalePanelPosition = [this.myPositionPanelPosition[0] - distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myPositionText = "Position";
    this.myRotationText = "Rotation";
    this.myScaleText = "Scale";
    this.myComponentLabelTextScale = this.myLabelTextScale;
    this.myComponentLabelCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myComponentLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myComponentLabelCollisionExtents = vec3_create2(0.065, 0.0175, 1);
    this.myComponentLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValueTextScale = vec3_create2(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create2(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create2(0, -this._myValuePanelDistanceFromVariableLabelPanel, 0);
    for (let i = 1; i < 3; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[2][1];
    this.myStepPanelPosition = [0, valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, 0];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create2(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create2(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _initializeRuntimeSetupHook() {
    this.myTextHoverScaleMultiplier = vec3_create2(1.25, 1.25, 1.25);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_ui.js
import { CollisionComponent as CollisionComponent9, MeshComponent as MeshComponent19, TextComponent as TextComponent15 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget11 } from "@wonderlandengine/components";
var EasyTuneTransformWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  setAdditionalButtonsActive(active) {
    this._myAdditionalButtonsActive = active;
    for (let i = 0; i < 3; i++) {
      this.myPositionIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
      this.myPositionDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
    }
    this.myPositionStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
    this.myPositionStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
    for (let i = 0; i < 3; i++) {
      this.myRotationIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
      this.myRotationDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
    }
    this.myRotationStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
    this.myRotationStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
    for (let i = 0; i < 3; i++) {
      this.myScaleIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
      this.myScaleDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsActive);
    }
    this.myScaleStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
    this.myScaleStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsActive);
  }
  _buildHook() {
    this._myAdditionalButtonsActive = true;
  }
  _createSkeletonHook() {
    this.myPositionPanel = this.myDisplayPanel.pp_addObject();
    this.myPositionLabelText = this.myPositionPanel.pp_addObject();
    this.myPositionLabelCursorTarget = this.myPositionPanel.pp_addObject();
    this.myPositionPanels = [];
    this.myPositionTexts = [];
    this.myPositionCursorTargets = [];
    this.myPositionIncreaseButtonPanels = [];
    this.myPositionIncreaseButtonBackgrounds = [];
    this.myPositionIncreaseButtonTexts = [];
    this.myPositionIncreaseButtonCursorTargets = [];
    this.myPositionDecreaseButtonPanels = [];
    this.myPositionDecreaseButtonBackgrounds = [];
    this.myPositionDecreaseButtonTexts = [];
    this.myPositionDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i] = this.myPositionPanel.pp_addObject();
      this.myPositionTexts[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionCursorTargets[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionIncreaseButtonPanels[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionIncreaseButtonBackgrounds[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionIncreaseButtonTexts[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionIncreaseButtonCursorTargets[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonPanels[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionDecreaseButtonBackgrounds[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonTexts[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonCursorTargets[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
    }
    this.myRotationPanel = this.myDisplayPanel.pp_addObject();
    this.myRotationLabelText = this.myRotationPanel.pp_addObject();
    this.myRotationLabelCursorTarget = this.myRotationPanel.pp_addObject();
    this.myRotationPanels = [];
    this.myRotationTexts = [];
    this.myRotationCursorTargets = [];
    this.myRotationIncreaseButtonPanels = [];
    this.myRotationIncreaseButtonBackgrounds = [];
    this.myRotationIncreaseButtonTexts = [];
    this.myRotationIncreaseButtonCursorTargets = [];
    this.myRotationDecreaseButtonPanels = [];
    this.myRotationDecreaseButtonBackgrounds = [];
    this.myRotationDecreaseButtonTexts = [];
    this.myRotationDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i] = this.myRotationPanel.pp_addObject();
      this.myRotationTexts[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationCursorTargets[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationIncreaseButtonPanels[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationIncreaseButtonBackgrounds[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationIncreaseButtonTexts[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationIncreaseButtonCursorTargets[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonPanels[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationDecreaseButtonBackgrounds[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonTexts[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonCursorTargets[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
    }
    this.myScalePanel = this.myDisplayPanel.pp_addObject();
    this.myScaleLabelText = this.myScalePanel.pp_addObject();
    this.myScaleLabelCursorTarget = this.myScalePanel.pp_addObject();
    this.myScalePanels = [];
    this.myScaleTexts = [];
    this.myScaleCursorTargets = [];
    this.myScaleIncreaseButtonPanels = [];
    this.myScaleIncreaseButtonBackgrounds = [];
    this.myScaleIncreaseButtonTexts = [];
    this.myScaleIncreaseButtonCursorTargets = [];
    this.myScaleDecreaseButtonPanels = [];
    this.myScaleDecreaseButtonBackgrounds = [];
    this.myScaleDecreaseButtonTexts = [];
    this.myScaleDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i] = this.myScalePanel.pp_addObject();
      this.myScaleTexts[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleCursorTargets[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleIncreaseButtonPanels[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleIncreaseButtonBackgrounds[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleIncreaseButtonTexts[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleIncreaseButtonCursorTargets[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonPanels[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleDecreaseButtonBackgrounds[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonTexts[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonCursorTargets[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
    }
    this.myPositionStepPanel = this.myPositionPanel.pp_addObject();
    this.myPositionStepText = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepCursorTarget = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepIncreaseButtonPanel = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepIncreaseButtonBackground = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepIncreaseButtonText = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepIncreaseButtonCursorTarget = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonPanel = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepDecreaseButtonBackground = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonText = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonCursorTarget = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepPanel = this.myRotationPanel.pp_addObject();
    this.myRotationStepText = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepCursorTarget = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepIncreaseButtonPanel = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepIncreaseButtonBackground = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepIncreaseButtonText = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepIncreaseButtonCursorTarget = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonPanel = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepDecreaseButtonBackground = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonText = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonCursorTarget = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepPanel = this.myScalePanel.pp_addObject();
    this.myScaleStepText = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepCursorTarget = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepIncreaseButtonPanel = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepIncreaseButtonBackground = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepIncreaseButtonText = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepIncreaseButtonCursorTarget = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonPanel = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepDecreaseButtonBackground = this.myScaleStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonText = this.myScaleStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonCursorTarget = this.myScaleStepDecreaseButtonPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myPositionPanel.pp_setPositionLocal(this._mySetup.myPositionPanelPosition);
    this.myPositionLabelText.pp_scaleObject(this._mySetup.myComponentLabelTextScale);
    this.myPositionLabelCursorTarget.pp_setPositionLocal(this._mySetup.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i].pp_setPositionLocal(this._mySetup.myValuePanelsPositions[i]);
      this.myPositionTexts[i].pp_scaleObject(this._mySetup.myValueTextScale);
      this.myPositionCursorTargets[i].pp_setPositionLocal(this._mySetup.myValueCursorTargetPosition);
      this.myPositionIncreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myIncreaseButtonPosition);
      this.myPositionIncreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myPositionIncreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myPositionIncreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myPositionIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
      this.myPositionDecreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myDecreaseButtonPosition);
      this.myPositionDecreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myPositionDecreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myPositionDecreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myPositionDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    }
    this.myRotationPanel.pp_setPositionLocal(this._mySetup.myRotationPanelPosition);
    this.myRotationLabelText.pp_scaleObject(this._mySetup.myComponentLabelTextScale);
    this.myRotationLabelCursorTarget.pp_setPositionLocal(this._mySetup.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i].pp_setPositionLocal(this._mySetup.myValuePanelsPositions[i]);
      this.myRotationTexts[i].pp_scaleObject(this._mySetup.myValueTextScale);
      this.myRotationCursorTargets[i].pp_setPositionLocal(this._mySetup.myValueCursorTargetPosition);
      this.myRotationIncreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myIncreaseButtonPosition);
      this.myRotationIncreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myRotationIncreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myRotationIncreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myRotationIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
      this.myRotationDecreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myDecreaseButtonPosition);
      this.myRotationDecreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myRotationDecreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myRotationDecreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myRotationDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    }
    this.myScalePanel.pp_setPositionLocal(this._mySetup.myScalePanelPosition);
    this.myScaleLabelText.pp_scaleObject(this._mySetup.myComponentLabelTextScale);
    this.myScaleLabelCursorTarget.pp_setPositionLocal(this._mySetup.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i].pp_setPositionLocal(this._mySetup.myValuePanelsPositions[i]);
      this.myScaleTexts[i].pp_scaleObject(this._mySetup.myValueTextScale);
      this.myScaleCursorTargets[i].pp_setPositionLocal(this._mySetup.myValueCursorTargetPosition);
      this.myScaleIncreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myIncreaseButtonPosition);
      this.myScaleIncreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myScaleIncreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myScaleIncreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myScaleIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
      this.myScaleDecreaseButtonPanels[i].pp_setPositionLocal(this._mySetup.myDecreaseButtonPosition);
      this.myScaleDecreaseButtonBackgrounds[i].pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
      this.myScaleDecreaseButtonTexts[i].pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
      this.myScaleDecreaseButtonTexts[i].pp_scaleObject(this._mySetup.mySideButtonTextScale);
      this.myScaleDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    }
    this.myPositionStepPanel.pp_setPositionLocal(this._mySetup.myStepPanelPosition);
    this.myPositionStepText.pp_scaleObject(this._mySetup.myStepTextScale);
    this.myPositionStepCursorTarget.pp_setPositionLocal(this._mySetup.myStepCursorTargetPosition);
    this.myPositionStepIncreaseButtonPanel.pp_setPositionLocal(this._mySetup.myIncreaseButtonPosition);
    this.myPositionStepIncreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myPositionStepIncreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myPositionStepIncreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myPositionStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myPositionStepDecreaseButtonPanel.pp_setPositionLocal(this._mySetup.myDecreaseButtonPosition);
    this.myPositionStepDecreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myPositionStepDecreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myPositionStepDecreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myPositionStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myRotationStepPanel.pp_setPositionLocal(this._mySetup.myStepPanelPosition);
    this.myRotationStepText.pp_scaleObject(this._mySetup.myStepTextScale);
    this.myRotationStepCursorTarget.pp_setPositionLocal(this._mySetup.myStepCursorTargetPosition);
    this.myRotationStepIncreaseButtonPanel.pp_setPositionLocal(this._mySetup.myIncreaseButtonPosition);
    this.myRotationStepIncreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myRotationStepIncreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myRotationStepIncreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myRotationStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myRotationStepDecreaseButtonPanel.pp_setPositionLocal(this._mySetup.myDecreaseButtonPosition);
    this.myRotationStepDecreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myRotationStepDecreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myRotationStepDecreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myRotationStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myScaleStepPanel.pp_setPositionLocal(this._mySetup.myStepPanelPosition);
    this.myScaleStepText.pp_scaleObject(this._mySetup.myStepTextScale);
    this.myScaleStepCursorTarget.pp_setPositionLocal(this._mySetup.myStepCursorTargetPosition);
    this.myScaleStepIncreaseButtonPanel.pp_setPositionLocal(this._mySetup.myIncreaseButtonPosition);
    this.myScaleStepIncreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myScaleStepIncreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myScaleStepIncreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myScaleStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
    this.myScaleStepDecreaseButtonPanel.pp_setPositionLocal(this._mySetup.myDecreaseButtonPosition);
    this.myScaleStepDecreaseButtonBackground.pp_scaleObject(this._mySetup.mySideButtonBackgroundScale);
    this.myScaleStepDecreaseButtonText.pp_setPositionLocal(this._mySetup.mySideButtonTextPosition);
    this.myScaleStepDecreaseButtonText.pp_scaleObject(this._mySetup.mySideButtonTextScale);
    this.myScaleStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._mySetup.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myPositionLabelTextComponent = this.myPositionLabelText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionLabelTextComponent);
    this.myPositionLabelTextComponent.text = this._mySetup.myPositionText;
    this.myPositionLabelCursorTargetComponent = this.myPositionLabelCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionLabelCollisionComponent = this.myPositionLabelCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;
    this.myPositionTextComponents = [];
    this.myPositionCursorTargetComponents = [];
    this.myPositionCollisionComponents = [];
    this.myPositionIncreaseButtonBackgroundComponents = [];
    this.myPositionIncreaseButtonTextComponents = [];
    this.myPositionIncreaseButtonCursorTargetComponents = [];
    this.myPositionIncreaseButtonCollisionComponents = [];
    this.myPositionDecreaseButtonBackgroundComponents = [];
    this.myPositionDecreaseButtonTextComponents = [];
    this.myPositionDecreaseButtonCursorTargetComponents = [];
    this.myPositionDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionTextComponents[i] = this.myPositionTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myPositionTextComponents[i]);
      this.myPositionTextComponents[i].text = " ";
      this.myPositionCursorTargetComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myPositionCollisionComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myPositionCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myPositionCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myPositionCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
      this.myPositionIncreaseButtonBackgroundComponents[i] = this.myPositionIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myPositionIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myPositionIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myPositionIncreaseButtonTextComponents[i] = this.myPositionIncreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myPositionIncreaseButtonTextComponents[i]);
      this.myPositionIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
      this.myPositionIncreaseButtonCursorTargetComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myPositionIncreaseButtonCollisionComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myPositionIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myPositionIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myPositionIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
      this.myPositionDecreaseButtonBackgroundComponents[i] = this.myPositionDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myPositionDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myPositionDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myPositionDecreaseButtonTextComponents[i] = this.myPositionDecreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myPositionDecreaseButtonTextComponents[i]);
      this.myPositionDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
      this.myPositionDecreaseButtonCursorTargetComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myPositionDecreaseButtonCollisionComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myPositionDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myPositionDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myPositionDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
    }
    this.myRotationLabelTextComponent = this.myRotationLabelText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationLabelTextComponent);
    this.myRotationLabelTextComponent.text = this._mySetup.myRotationText;
    this.myRotationLabelCursorTargetComponent = this.myRotationLabelCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationLabelCollisionComponent = this.myRotationLabelCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;
    this.myRotationTextComponents = [];
    this.myRotationCursorTargetComponents = [];
    this.myRotationCollisionComponents = [];
    this.myRotationIncreaseButtonBackgroundComponents = [];
    this.myRotationIncreaseButtonTextComponents = [];
    this.myRotationIncreaseButtonCursorTargetComponents = [];
    this.myRotationIncreaseButtonCollisionComponents = [];
    this.myRotationDecreaseButtonBackgroundComponents = [];
    this.myRotationDecreaseButtonTextComponents = [];
    this.myRotationDecreaseButtonCursorTargetComponents = [];
    this.myRotationDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationTextComponents[i] = this.myRotationTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myRotationTextComponents[i]);
      this.myRotationTextComponents[i].text = " ";
      this.myRotationCursorTargetComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myRotationCollisionComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myRotationCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myRotationCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myRotationCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
      this.myRotationIncreaseButtonBackgroundComponents[i] = this.myRotationIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myRotationIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myRotationIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myRotationIncreaseButtonTextComponents[i] = this.myRotationIncreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myRotationIncreaseButtonTextComponents[i]);
      this.myRotationIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
      this.myRotationIncreaseButtonCursorTargetComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myRotationIncreaseButtonCollisionComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myRotationIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myRotationIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myRotationIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
      this.myRotationDecreaseButtonBackgroundComponents[i] = this.myRotationDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myRotationDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myRotationDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myRotationDecreaseButtonTextComponents[i] = this.myRotationDecreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myRotationDecreaseButtonTextComponents[i]);
      this.myRotationDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
      this.myRotationDecreaseButtonCursorTargetComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myRotationDecreaseButtonCollisionComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myRotationDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myRotationDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myRotationDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
    }
    this.myScaleLabelTextComponent = this.myScaleLabelText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleLabelTextComponent);
    this.myScaleLabelTextComponent.text = this._mySetup.myScaleText;
    this.myScaleLabelCursorTargetComponent = this.myScaleLabelCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleLabelCollisionComponent = this.myScaleLabelCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;
    this.myScaleTextComponents = [];
    this.myScaleCursorTargetComponents = [];
    this.myScaleCollisionComponents = [];
    this.myScaleIncreaseButtonBackgroundComponents = [];
    this.myScaleIncreaseButtonTextComponents = [];
    this.myScaleIncreaseButtonCursorTargetComponents = [];
    this.myScaleIncreaseButtonCollisionComponents = [];
    this.myScaleDecreaseButtonBackgroundComponents = [];
    this.myScaleDecreaseButtonTextComponents = [];
    this.myScaleDecreaseButtonCursorTargetComponents = [];
    this.myScaleDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myScaleTextComponents[i] = this.myScaleTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myScaleTextComponents[i]);
      this.myScaleTextComponents[i].text = " ";
      this.myScaleCursorTargetComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myScaleCollisionComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myScaleCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myScaleCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myScaleCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
      this.myScaleIncreaseButtonBackgroundComponents[i] = this.myScaleIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myScaleIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myScaleIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myScaleIncreaseButtonTextComponents[i] = this.myScaleIncreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myScaleIncreaseButtonTextComponents[i]);
      this.myScaleIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
      this.myScaleIncreaseButtonCursorTargetComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myScaleIncreaseButtonCollisionComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myScaleIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myScaleIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myScaleIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
      this.myScaleDecreaseButtonBackgroundComponents[i] = this.myScaleDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myScaleDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
      this.myScaleDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
      this.myScaleDecreaseButtonTextComponents[i] = this.myScaleDecreaseButtonTexts[i].pp_addComponent(TextComponent15);
      this._setupTextComponent(this.myScaleDecreaseButtonTextComponents[i]);
      this.myScaleDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
      this.myScaleDecreaseButtonCursorTargetComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget11);
      this.myScaleDecreaseButtonCollisionComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myScaleDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
      this.myScaleDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
      this.myScaleDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
    }
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
  }
  _addStepComponents() {
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget.js
var EasyTuneTransformWidget = class extends EasyTuneBaseWidget {
  constructor(params, gamepad, engine2 = getMainEngine2()) {
    super(params);
    this._myGamepad = gamepad;
    this._mySetup = new EasyTuneTransformWidgetSetup();
    this._myUI = new EasyTuneTransformWidgetUI(engine2);
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditActive = false;
    this._myStepEditActive = false;
    this._myValueRealValue = 0;
    this._myComponentStepValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myValueEditIndex = -1;
    this._myComponentIndex = 0;
    this._myStepIndex = 0;
  }
  _setEasyTuneVariableHook() {
    if (this._myValueEditIndex >= 0) {
      switch (this._myComponentIndex) {
        case 0:
          this._myValueRealValue = this._myVariable.myPosition[this._myValueEditIndex];
          this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
          break;
        case 1:
          this._myValueRealValue = this._myVariable.myRotation[this._myValueEditIndex];
          this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
          break;
        case 2:
          this._myValueRealValue = this._myVariable.myScale[this._myValueEditIndex];
          this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
          break;
      }
    }
  }
  _refreshUIHook() {
    for (let i = 0; i < 3; i++) {
      this._myUI.myPositionTextComponents[i].text = this._myVariable.myPosition[i].toFixed(this._myVariable.myDecimalPlaces);
    }
    this._myUI.myPositionStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myPositionStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myRotationTextComponents[i].text = this._myVariable.myRotation[i].toFixed(this._myVariable.myDecimalPlaces);
    }
    this._myUI.myRotationStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myRotationStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myScaleTextComponents[i].text = this._myVariable.myScale[i].toFixed(this._myVariable.myDecimalPlaces);
    }
    this._myUI.myScaleStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myScaleStepPerSecond);
  }
  _startHook(parentObject, additionalSetup) {
    this._myUI.setAdditionalButtonsActive(additionalSetup.myAdditionalButtonsEnabled);
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._mySetup.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._mySetup.myEditThumbstickMinThreshold) / (1 - this._mySetup.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditActive) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (valueIntensity != 0) {
      let amountToAdd = valueIntensity * this._myComponentStepValue * dt;
      this._myValueRealValue += amountToAdd;
      let decimalPlacesMultiplier = Math.pow(10, this._myVariable.myDecimalPlaces);
      switch (this._myComponentIndex) {
        case 0:
          this._myVariable.myPosition[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          this._myUI.myPositionTextComponents[this._myValueEditIndex].text = this._myVariable.myPosition[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
          break;
        case 1:
          if (this._myValueRealValue > 180) {
            while (this._myValueRealValue > 180) {
              this._myValueRealValue -= 180;
            }
            this._myValueRealValue = -180 + this._myValueRealValue;
          }
          if (this._myValueRealValue < -180) {
            while (this._myValueRealValue < -180) {
              this._myValueRealValue += 180;
            }
            this._myValueRealValue = 180 - this._myValueRealValue;
          }
          this._myVariable.myRotation[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          this._myUI.myRotationTextComponents[this._myValueEditIndex].text = this._myVariable.myRotation[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
          break;
        case 2:
          if (this._myValueRealValue <= 0) {
            this._myValueRealValue = 1 / decimalPlacesMultiplier;
          }
          if (this._myVariable.myScaleAsOne) {
            let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            let difference = newValue - this._myVariable.myScale[this._myValueEditIndex];
            for (let i = 0; i < 3; i++) {
              this._myVariable.myScale[i] = Math.round((this._myVariable.myScale[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              this._myVariable.myScale[i] = Math.max(this._myVariable.myScale[i], 1 / decimalPlacesMultiplier);
              this._myUI.myScaleTextComponents[i].text = this._myVariable.myScale[i].toFixed(this._myVariable.myDecimalPlaces);
            }
          } else {
            this._myVariable.myScale[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myVariable.myScale[this._myValueEditIndex] = Math.max(this._myVariable.myScale[this._myValueEditIndex], 1 / decimalPlacesMultiplier);
            this._myUI.myScaleTextComponents[this._myValueEditIndex].text = this._myVariable.myScale[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
          }
          break;
      }
    } else {
      switch (this._myComponentIndex) {
        case 0:
          this._myValueRealValue = this._myVariable.myPosition[this._myValueEditIndex];
          break;
        case 1:
          this._myValueRealValue = this._myVariable.myRotation[this._myValueEditIndex];
          break;
        case 2:
          this._myValueRealValue = this._myVariable.myScale[this._myValueEditIndex];
          break;
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditActive) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._mySetup.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        let stepValue = 0;
        switch (this._myStepIndex) {
          case 0:
            stepValue = this._myVariable.myPositionStepPerSecond;
            break;
          case 1:
            stepValue = this._myVariable.myRotationStepPerSecond;
            break;
          case 2:
            stepValue = this._myVariable.myScaleStepPerSecond;
            break;
          default:
            stepValue = 0;
        }
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myStepIndex, stepValue * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myStepIndex, stepValue * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));
    ui.myPositionLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 0));
    ui.myPositionLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myPositionLabelText));
    ui.myPositionLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myPositionLabelText, this._mySetup.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 0, i));
      ui.myPositionCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 0, i, ui.myPositionTexts[i], true));
      ui.myPositionCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 0, i, ui.myPositionTexts[i], false));
    }
    ui.myRotationLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 1));
    ui.myRotationLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myRotationLabelText));
    ui.myRotationLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myRotationLabelText, this._mySetup.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 1, i));
      ui.myRotationCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 1, i, ui.myRotationTexts[i], true));
      ui.myRotationCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 1, i, ui.myRotationTexts[i], false));
    }
    ui.myScaleLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 2));
    ui.myScaleLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myScaleLabelText));
    ui.myScaleLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myScaleLabelText, this._mySetup.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 2, i));
      ui.myScaleCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 2, i, ui.myScaleTexts[i], true));
      ui.myScaleCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 2, i, ui.myScaleTexts[i], false));
    }
    ui.myPositionStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 0));
    ui.myPositionStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 0, ui.myPositionStepText, true));
    ui.myPositionStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 0, ui.myPositionStepText, false));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 1));
    ui.myRotationStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 1, ui.myRotationStepText, true));
    ui.myRotationStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 1, ui.myRotationStepText, false));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 2));
    ui.myScaleStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 2, ui.myScaleStepText, true));
    ui.myScaleStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 2, ui.myScaleStepText, false));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(componentIndex, index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable.myPosition[index];
            this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable.myRotation[index];
            this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable.myScale[index];
            this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
            break;
        }
        this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
      this._myStepIndex = index;
    }
  }
  _setValueEditActive(componentIndex, index, text, active) {
    if (this._isActive() || !active) {
      if (active) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable.myPosition[index];
            this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable.myRotation[index];
            this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable.myScale[index];
            this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
            break;
        }
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
        text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleWorld(this._mySetup.myValueTextScale);
      }
      this._myValueEditActive = active;
    }
  }
  _setStepEditActive(index, text, active) {
    if (this._isActive() || !active) {
      if (active) {
        text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleWorld(this._mySetup.myStepTextScale);
      }
      this._myStepEditActive = active;
      this._myStepIndex = index;
    }
  }
  _resetValue(componentIndex, index) {
    if (this._isActive()) {
      switch (componentIndex) {
        case 0:
          this._myVariable.myPosition[index] = this._myVariable.myDefaultPosition[index];
          this._myUI.myPositionTextComponents[index].text = this._myVariable.myPosition[index].toFixed(this._myVariable.myDecimalPlaces);
          break;
        case 1:
          this._myVariable.myRotation[index] = this._myVariable.myDefaultRotation[index];
          this._myUI.myRotationTextComponents[index].text = this._myVariable.myRotation[index].toFixed(this._myVariable.myDecimalPlaces);
          break;
        case 2:
          this._myVariable.myScale[index] = this._myVariable.myDefaultScale[index];
          this._myUI.myScaleTextComponents[index].text = this._myVariable.myScale[index].toFixed(this._myVariable.myDecimalPlaces);
          break;
        default:
          defaultValue = 0;
      }
    }
  }
  _resetAllValues() {
    for (let i = 0; i < 3; i++) {
      this._resetComponentValues(i);
    }
  }
  _resetComponentValues(index) {
    for (let i = 0; i < 3; i++) {
      this._resetValue(index, i);
    }
  }
  _resetStep(index) {
    if (this._isActive()) {
      let defaultValue2 = 0;
      switch (index) {
        case 0:
          defaultValue2 = this._myVariable.myDefaultPositionStepPerSecond;
          break;
        case 1:
          defaultValue2 = this._myVariable.myDefaultRotationStepPerSecond;
          break;
        case 2:
          defaultValue2 = this._myVariable.myDefaultScaleStepPerSecond;
          break;
        default:
          defaultValue2 = 0;
      }
      this._changeStep(index, defaultValue2);
    }
  }
  _changeStep(index, step) {
    step = Math.pp_roundDecimal(step, 10);
    switch (index) {
      case 0:
        this._myVariable.myPositionStepPerSecond = step;
        this._myUI.myPositionStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myPositionStepPerSecond);
        break;
      case 1:
        this._myVariable.myRotationStepPerSecond = step;
        this._myUI.myRotationStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myRotationStepPerSecond);
        break;
      case 2:
        this._myVariable.myScaleStepPerSecond = step;
        this._myUI.myScaleStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myScaleStepPerSecond);
        break;
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._mySetup.myTextHoverScaleMultiplier);
  }
  _genericTextUnHover(text, originalScale) {
    text.pp_setScaleWorld(originalScale);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget.js
var EasyTuneWidgetAdditionalSetup = class {
  constructor() {
    this.myHandedness = ToolHandedness.NONE;
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myAdditionalButtonsEnabled = false;
    this.myGamepadScrollVariableEnabled = false;
    this.myPlaneMaterial = null;
    this.myTextMaterial = null;
    this.myVariablesImportExportButtonsEnabled = false;
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneWidget = class {
  constructor(engine2 = getMainEngine()) {
    this._myIsStarted = false;
    this._myStartVariable = null;
    this._myWidgetFrame = new WidgetFrame("E", 1, engine2);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._mySetup = new EasyTuneWidgetSetup();
    this._myAdditionalSetup = null;
    this._myWidgets = [];
    this._myEasyTuneVariables = null;
    this._myEasyTuneLastSize = 0;
    this._myVariableNames = null;
    this._myCurrentWidget = null;
    this._myCurrentVariable = null;
    this._myScrollVariableTimer = 0;
    this._myGamepad = null;
    this._myRefreshVariablesTimer = 0;
    this._myDirty = false;
    this._myEngine = engine2;
  }
  setActiveVariable(variableName) {
    if (!this._myIsStarted) {
      this._myStartVariable = variableName;
    } else if (this._myEasyTuneVariables.has(variableName)) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(variableName);
      this._selectCurrentWidget();
    } else {
      console.log("Can't set easy tune active variable");
    }
  }
  refresh() {
    if (this._myWidgetFrame.myIsWidgetVisible) {
      this._myDirty = true;
    }
  }
  setVisible(visible) {
    this._myWidgetFrame.setVisible(visible);
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, additionalSetup, easyTuneVariables) {
    this._myRightGamepad = getRightGamepad(this._myEngine);
    this._myLeftGamepad = getLeftGamepad(this._myEngine);
    if (this._mySetup.myGamepadHandedness == ToolHandedness.RIGHT) {
      this._myGamepad = this._myRightGamepad;
    } else if (this._mySetup.myGamepadHandedness == ToolHandedness.LEFT) {
      this._myGamepad = this._myLeftGamepad;
    }
    this._myIsStarted = true;
    this._myAdditionalSetup = additionalSetup;
    this._myWidgetFrame.start(parentObject, additionalSetup);
    this._myEasyTuneVariables = easyTuneVariables;
    this._myEasyTuneLastSize = this._myEasyTuneVariables.length();
    this._myVariableNames = this._myEasyTuneVariables.getEasyTuneVariablesNames();
    if (this._myEasyTuneVariables.length() > 0) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    if (this._myStartVariable) {
      if (this._myEasyTuneVariables.has(this._myStartVariable)) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myStartVariable);
      } else {
        console.log("Can't set easy tune active variable");
      }
    }
    this._initializeWidgets();
  }
  update(dt) {
    this._myWidgetFrame.update(dt);
    if (this._myEasyTuneVariables.length() != this._myEasyTuneLastSize || this._myDirty) {
      this._refreshEasyTuneVariables();
    }
    if (this._myWidgetFrame.myIsWidgetVisible && this._myEasyTuneVariables.length() > 0) {
      if (this._mySetup.myRefreshVariablesDelay != null) {
        this._myRefreshVariablesTimer += dt;
        if (this._myRefreshVariablesTimer > this._mySetup.myRefreshVariablesDelay) {
          this._myRefreshVariablesTimer = 0;
          this._refreshEasyTuneVariables();
        }
      }
      if (this._myCurrentWidget) {
        this._myCurrentWidget.update(dt);
      }
      if (this._myAdditionalSetup.myGamepadScrollVariableEnabled) {
        this._updateGamepadScrollVariable(dt);
      }
    }
    this._updateGamepadWidgetVisibility();
    this._updateActiveVariable();
  }
  _initializeWidgets() {
    let widgetParams = new EasyTuneBaseWidgetParams();
    widgetParams.myVariablesImportCallback = this._importVariables.bind(this);
    widgetParams.myVariablesExportCallback = this._exportVariables.bind(this);
    this._myWidgets[EasyTuneVariableType.NONE] = new EasyTuneNoneWidget(widgetParams, this._myEngine);
    this._myWidgets[EasyTuneVariableType.NUMBER] = new EasyTuneNumberArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.BOOL] = new EasyTuneBoolArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.TRANSFORM] = new EasyTuneTransformWidget(widgetParams, this._myGamepad, this._myEngine);
    for (let widget of this._myWidgets) {
      if (widget != null) {
        widget.start(this._myWidgetFrame.getWidgetObject(), this._myAdditionalSetup);
        widget.setVisible(false);
        widget.registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
      }
    }
    this._selectCurrentWidget();
  }
  _selectCurrentWidget() {
    if (this._myEasyTuneVariables.length() <= 0) {
      return;
    }
    let prevWidget = null;
    if (this._myCurrentWidget != null) {
      prevWidget = this._myCurrentWidget.getWidget();
    }
    if (this._myCurrentVariable.myType in this._myWidgets) {
      this._myCurrentWidget = this._myWidgets[this._myCurrentVariable.myType];
    } else {
      this._myCurrentWidget = this._myWidgets[EasyTuneVariableType.NONE];
    }
    this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
    this._myCurrentWidget.getWidget().syncWidget(prevWidget);
    if (prevWidget != null) {
      prevWidget.setVisible(false);
    }
    this._myCurrentWidget.setVisible(this._myWidgetFrame.myIsWidgetVisible);
  }
  _refreshEasyTuneVariables() {
    this._myVariableNames = this._myEasyTuneVariables.getEasyTuneVariablesNames();
    this._myEasyTuneLastSize = this._myEasyTuneVariables.length();
    if (this._myEasyTuneVariables.length() > 0) {
      if (this._myCurrentVariable && this._myEasyTuneVariables.has(this._myCurrentVariable.myName)) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myCurrentVariable.myName);
      } else {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
      }
      this._selectCurrentWidget();
    } else {
      this._myCurrentVariable = null;
      if (this._myCurrentWidget) {
        this._myCurrentWidget.setVisible(false);
        this._myCurrentWidget = null;
      }
    }
    this._myDirty = false;
  }
  _updateGamepadWidgetVisibility() {
    if (this._myGamepad) {
      if (this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed || this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).myIsPressed) {
        this._toggleVisibility();
      }
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    for (let widget of this._myWidgets) {
      if (widget != null) {
        widget.setVisible(false);
      }
    }
    if (this._myCurrentWidget) {
      if (this._myEasyTuneVariables.length() > 0) {
        this._myCurrentWidget.setVisible(visible);
      } else {
        this._myCurrentWidget.setVisible(false);
      }
    }
    if (visible) {
      this._refreshEasyTuneVariables();
    }
  }
  _updateGamepadScrollVariable(dt) {
    if (this._myGamepad && (!this._mySetup.myScrollVariableButtonID || this._myGamepad.getButtonInfo(this._mySetup.myScrollVariableButtonID).myIsPressed)) {
      let x = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[0];
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(x) > this._mySetup.myScrollVariableMinXThreshold && Math.abs(y) < this._mySetup.myScrollVariableMaxYThreshold) {
        this._myScrollVariableTimer += dt;
        while (this._myScrollVariableTimer > this._mySetup.myScrollVariableDelay) {
          this._myScrollVariableTimer -= this._mySetup.myScrollVariableDelay;
          this._scrollVariable(Math.sign(x));
        }
      } else {
        this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
      }
    } else {
      this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
    }
  }
  _scrollVariable(amount) {
    if (this._myEasyTuneVariables.length() <= 0) {
      return;
    }
    let variableIndex = this._getVariableIndex(this._myCurrentVariable);
    if (variableIndex >= 0) {
      let newIndex = ((variableIndex + amount) % this._myVariableNames.length + this._myVariableNames.length) % this._myVariableNames.length;
      if (this._myEasyTuneVariables.has(this._myVariableNames[newIndex])) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[newIndex]);
        this._selectCurrentWidget();
      } else {
        this._refreshEasyTuneVariables();
      }
    } else {
      this._refreshEasyTuneVariables();
    }
  }
  _createIndexString() {
    let indexString = " (";
    let index = (this._getVariableIndex(this._myCurrentVariable) + 1).toString();
    let length2 = this._myEasyTuneVariables.length().toString();
    while (index.length < length2.length) {
      index = "0".concat(index);
    }
    indexString = indexString.concat(index).concat(" - ").concat(length2).concat(")");
    return indexString;
  }
  _getVariableIndex(variable) {
    let variableIndex = this._myVariableNames.indexOf(variable.myName);
    return variableIndex;
  }
  _updateActiveVariable() {
    this._myEasyTuneVariables.getEasyTuneVariablesList().forEach(function(value) {
      value.myIsActive = false;
    });
    if (this._myWidgetFrame.myIsWidgetVisible && this._myCurrentVariable) {
      this._myCurrentVariable.myIsActive = true;
    }
  }
  _importVariables() {
    this._myAdditionalSetup.myVariablesImportCallback(this._onImportSuccess.bind(this), this._onImportFailure.bind(this));
  }
  _exportVariables() {
    this._myAdditionalSetup.myVariablesExportCallback(this._onExportSuccess.bind(this), this._onExportFailure.bind(this));
  }
  _onImportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportSuccess();
    }
  }
  _onImportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportFailure();
    }
  }
  _onExportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportSuccess();
    }
  }
  _onExportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportFailure();
    }
  }
};

// js/pp/tool/easy_tune/components/easy_tune_tool_component.js
var EasyTuneToolComponent = class extends Component66 {
  init() {
    this.object.pp_addComponent(InitEasyTuneVariablesComponent);
    this._myWidget = new EasyTuneWidget(this.engine);
    EasyTuneUtils.addSetEasyTuneWidgetActiveVariableCallback(this, function(variableName) {
      this._myWidget.setActiveVariable(variableName);
    }.bind(this), this.engine);
    EasyTuneUtils.addRefreshEasyTuneWidgetCallback(this, function() {
      this._myWidget.refresh();
    }.bind(this), this.engine);
    this._myStarted = false;
  }
  start() {
    if (isToolEnabled(this.engine)) {
      let additionalSetup = new EasyTuneWidgetAdditionalSetup();
      additionalSetup.myHandedness = [null, "left", "right"][this._myHandedness];
      additionalSetup.myShowOnStart = this._myShowOnStart;
      additionalSetup.myShowVisibilityButton = this._myShowVisibilityButton;
      additionalSetup.myAdditionalButtonsEnabled = true;
      additionalSetup.myGamepadScrollVariableEnabled = this._myGamepadScrollVariableEnabled;
      additionalSetup.myPlaneMaterial = getDefaultResources(this.engine).myMaterials.myFlatOpaque.clone();
      additionalSetup.myTextMaterial = getDefaultResources(this.engine).myMaterials.myText.clone();
      additionalSetup.myVariablesImportExportButtonsEnabled = this._myVariablesImportExportButtonsEnabled;
      additionalSetup.myVariablesImportCallback = function(onSuccessCallback, onFailureCallback) {
        EasyTuneUtils.importEasyTuneVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, onSuccessCallback, onFailureCallback, this.engine);
      }.bind(this);
      additionalSetup.myVariablesExportCallback = function(onSuccessCallback, onFailureCallback) {
        EasyTuneUtils.exportEasyTuneVariables(this._myVariablesExportURL, onSuccessCallback, onFailureCallback, this.engine);
      }.bind(this);
      this._myWidget.start(this.object, additionalSetup, getEasyTuneVariables(this.engine));
      this._myWidgetVisibleBackup = this._myWidget.isVisible();
      this._mySetVisibleNextUpdate = false;
      this._myStarted = true;
      this._myFirstUpdate = true;
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myStarted) {
        if (this._myFirstUpdate) {
          this._myFirstUpdate = false;
          if (this._myImportVariablesOnStart) {
            EasyTuneUtils.importEasyTuneVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, void 0, void 0, this.engine);
          }
        }
        if (this._mySetVisibleNextUpdate) {
          this._mySetVisibleNextUpdate = false;
          this._myWidget.setVisible(false);
          this._myWidget.setVisible(this._myWidgetVisibleBackup);
        }
        this._myWidget.update(dt);
      }
    }
  }
  onActivate() {
    if (isToolEnabled(this.engine)) {
      if (this._myStarted) {
        this._mySetVisibleNextUpdate = true;
      }
    }
  }
  onDeactivate() {
    if (isToolEnabled(this.engine)) {
      if (this._myStarted) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
        this._myWidget.setVisible(false);
      }
    }
  }
};
__publicField(EasyTuneToolComponent, "TypeName", "pp-easy-tune-tool");
__publicField(EasyTuneToolComponent, "Properties", {
  _myHandedness: Property66.enum(["None", "Left", "Right"], "None"),
  _myShowOnStart: Property66.bool(false),
  _myShowVisibilityButton: Property66.bool(false),
  _myGamepadScrollVariableEnabled: Property66.bool(true),
  _myVariablesImportExportButtonsEnabled: Property66.bool(false),
  _myVariablesImportURL: Property66.string(""),
  _myVariablesExportURL: Property66.string(""),
  _myImportVariablesOnStart: Property66.bool(false),
  _myResetVariablesDefaultValueOnImport: Property66.bool(false)
});

// js/pp/tool/easy_tune/components/easy_tune_import_variables_component.js
import { Component as Component67, Property as Property67 } from "@wonderlandengine/api";
var EasyTuneImportVariablesComponent = class extends Component67 {
  start() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      EasyTuneUtils.importEasyTuneVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, void 0, void 0, this.engine);
    }
  }
};
__publicField(EasyTuneImportVariablesComponent, "TypeName", "pp-easy-tune-import-variables");
__publicField(EasyTuneImportVariablesComponent, "Properties", {
  _myVariablesImportURL: Property67.string(""),
  _myResetVariablesDefaultValueOnImport: Property67.bool(true)
});

// js/pp/tool/easy_tune/easy_object_tuners/easy_light_attenuation.js
import { LightComponent as LightComponent2 } from "@wonderlandengine/api";
var EasyLightAttenuation = class extends EasyObjectTuner {
  constructor(object, variableName, setAsDefault, useTuneTarget) {
    super(object, variableName, setAsDefault, useTuneTarget);
  }
  _getVariableNamePrefix() {
    let nameFirstPart = "Light Attenuation ";
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), 0.01, 3, 0, 1);
  }
  _getObjectValue(object) {
    let attenuation = this._getLightAttenuation(object);
    return attenuation;
  }
  _getDefaultValue() {
    return 0;
  }
  _updateObjectValue(object, value) {
    let attenuation = value;
    let light = object.pp_getComponent(LightComponent2);
    if (light) {
      light.color[3] = attenuation;
    }
  }
  _getLightAttenuation(object) {
    let attenuation = this._getDefaultValue();
    let light = object.pp_getComponent(LightComponent2);
    if (light) {
      attenuation = light.color[3];
    }
    return attenuation;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_light_color.js
import { LightComponent as LightComponent3 } from "@wonderlandengine/api";
var EasyLightColor = class extends EasyObjectTuner {
  constructor(colorModel, object, variableName, setAsDefault, useTuneTarget, engine2) {
    super(object, variableName, setAsDefault, useTuneTarget, engine2);
    this._myColorModel = colorModel;
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Light RGB ";
    } else {
      nameFirstPart = "Light HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
  }
  _getObjectValue(object) {
    let color = null;
    let lightColor = this._getLightColor(object);
    if (lightColor) {
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbCodeToHuman(lightColor);
      } else {
        color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHsv(lightColor));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec3_create2();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.rgbHumanToCode(color);
    } else {
      color = ColorUtils.hsvToRgb(ColorUtils.hsvHumanToCode(color));
    }
    let light = object.pp_getComponent(LightComponent3);
    if (light) {
      light.color[0] = color[0];
      light.color[1] = color[1];
      light.color[2] = color[2];
      light.color[3] = light.color[3];
    }
    if (getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed || getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed) {
      let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHsv(color));
      let rgbColor = ColorUtils.color1To255(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getLightColor(object) {
    let color = null;
    let light = object.pp_getComponent(LightComponent3);
    if (light) {
      color = light.color.slice(0, 3);
    }
    return color;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_color.js
var EasyMeshColor = class extends EasyObjectTuner {
  constructor(colorModel, colorType, object, variableName, setAsDefault, useTuneTarget, engine2) {
    super(object, variableName, setAsDefault, useTuneTarget, engine2);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
    this._myColorVariableNames = ["color", "diffuseColor", "ambientColor", "specularColor", "emissiveColor", "fogColor", "ambientFactor"];
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Mesh RGB ";
    } else {
      nameFirstPart = "Mesh HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    if (this._myColorType == 6) {
      return new EasyTuneNumberArray(variableName, this._getDefaultValue(), 0.1, 3, 0, 1);
    }
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
  }
  _getObjectValue(object) {
    let color = null;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      if (this._myColorType != 6) {
        color = meshMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
        if (this._myColorModel == 0) {
          color = ColorUtils.rgbCodeToHuman(color);
        } else {
          color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHsv(color));
        }
      } else {
        color = [meshMaterial[this._myColorVariableNames[this._myColorType]]];
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    if (this._myColorType == 6) {
      return [0];
    }
    return vec4_create2();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorType != 6) {
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbHumanToCode(color);
      } else {
        color = ColorUtils.hsvToRgb(ColorUtils.hsvHumanToCode(color));
      }
    }
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial[this._myColorVariableNames[this._myColorType]] = color;
    }
    if (this._myColorType != 6) {
      if (getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed || getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed) {
        let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHsv(color));
        let rgbColor = ColorUtils.color1To255(color);
        console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
      }
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    let mesh = object.pp_getComponent(MeshComponent);
    if (mesh) {
      material = mesh.material;
    }
    return material;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_scale.js
var EasyScale = class extends EasyObjectTuner {
  constructor(isLocal, scaleAsOne, object, variableName, setAsDefault, useTuneTarget, engine2) {
    super(object, variableName, setAsDefault, useTuneTarget, engine2);
    this._myIsLocal = isLocal;
    this._myScaleAsOne = scaleAsOne;
  }
  _getVariableNamePrefix() {
    return "Scale ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumberArray(variableName, this._getDefaultValue(), 1, 3, 1e-3, null, this._myScaleAsOne);
  }
  _getObjectValue(object) {
    return this._myIsLocal ? object.pp_getScaleLocal() : object.pp_getScale();
  }
  _getDefaultValue() {
    return vec3_create2(1, 1, 1);
  }
  _updateObjectValue(object, value) {
    if (this._myIsLocal) {
      object.pp_setScaleLocal(value);
    } else {
      object.pp_setScale(value);
    }
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_ambient_factor.js
var EasyMeshAmbientFactor = class extends EasyObjectTuner {
  constructor(object, variableName, setAsDefault, useTuneTarget, engine2) {
    super(object, variableName, setAsDefault, useTuneTarget, engine2);
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Mesh AF ";
    } else {
      nameFirstPart = "Mesh AF ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), 0.1, 3, 0, 1);
  }
  _getObjectValue(object) {
    let ambientFactor = null;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      ambientFactor = meshMaterial.ambientFactor;
    } else {
      ambientFactor = this._getDefaultValue();
    }
    return ambientFactor;
  }
  _getDefaultValue() {
    return 0;
  }
  _updateObjectValue(object, value) {
    let ambientFactor = value;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial.ambientFactor = ambientFactor;
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    let mesh = object.pp_getComponent(MeshComponent);
    if (mesh) {
      material = mesh.material;
    }
    return material;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_text_color.js
var EasyTextColor = class extends EasyObjectTuner {
  constructor(colorModel, colorType, object, variableName, setAsDefault, useTuneTarget, engine2) {
    super(object, variableName, setAsDefault, useTuneTarget, engine2);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
    this._myColorVariableNames = ["color", "effectColor"];
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Text RGB ";
    } else {
      nameFirstPart = "Text HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
  }
  _getObjectValue(object) {
    let color = null;
    let textMaterial = this._getTextMaterial(object);
    if (textMaterial) {
      color = textMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbCodeToHuman(color);
      } else {
        color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHsv(color));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec4_create2();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.rgbHumanToCode(color);
    } else {
      color = ColorUtils.hsvToRgb(ColorUtils.hsvHumanToCode(color));
    }
    let textMaterial = this._getTextMaterial(object);
    if (textMaterial) {
      textMaterial[this._myColorVariableNames[this._myColorType]] = color;
    }
    if (getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed || getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).myIsPressed) {
      let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHsv(color));
      let rgbColor = ColorUtils.color1To255(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getTextMaterial(object) {
    let material = null;
    let text = object.pp_getComponent(TextComponent);
    if (text) {
      material = text.material;
    }
    return material;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_light_attenuation_component.js
import { Component as Component68, Property as Property68 } from "@wonderlandengine/api";
var EasyLightAttenuationComponent = class extends Component68 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyLightAttenuation(this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyLightAttenuationComponent, "TypeName", "pp-easy-light-attenuation");
__publicField(EasyLightAttenuationComponent, "Properties", {
  _myVariableName: Property68.string(""),
  _mySetAsDefault: Property68.bool(false),
  _myUseTuneTarget: Property68.bool(false)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_light_color_component.js
import { Component as Component69, Property as Property69 } from "@wonderlandengine/api";
var EasyLightColorComponent = class extends Component69 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyLightColor(this._myColorModel, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyLightColorComponent, "TypeName", "pp-easy-light-color");
__publicField(EasyLightColorComponent, "Properties", {
  _myVariableName: Property69.string(""),
  _mySetAsDefault: Property69.bool(false),
  _myUseTuneTarget: Property69.bool(false),
  _myColorModel: Property69.enum(["RGB", "HSV"], "HSV")
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_mesh_ambient_factor_component.js
import { Component as Component70, Property as Property70 } from "@wonderlandengine/api";
var EasyMeshAmbientFactorComponent = class extends Component70 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyMeshAmbientFactor(this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = targetObject.pp_addComponent(this.type, {
      "_myVariableName": this._myVariableName,
      "_mySetAsDefault": this._mySetAsDefault,
      "_myUseTuneTarget": this._myUseTuneTarget
    });
    clonedComponent.active = this.active;
    return clonedComponent;
  }
};
__publicField(EasyMeshAmbientFactorComponent, "TypeName", "pp-easy-mesh-ambient-factor");
__publicField(EasyMeshAmbientFactorComponent, "Properties", {
  _myVariableName: Property70.string(""),
  _myUseTuneTarget: Property70.bool(false),
  _mySetAsDefault: Property70.bool(false)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_mesh_color_component.js
import { Component as Component71, Property as Property71 } from "@wonderlandengine/api";
var EasyMeshColorComponent = class extends Component71 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyMeshColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = targetObject.pp_addComponent(this.type, {
      "_myVariableName": this._myVariableName,
      "_mySetAsDefault": this._mySetAsDefault,
      "_myUseTuneTarget": this._myUseTuneTarget,
      "_myColorModel": this._myColorModel,
      "_myColorType": this._myColorType
    });
    clonedComponent.active = this.active;
    return clonedComponent;
  }
};
__publicField(EasyMeshColorComponent, "TypeName", "pp-easy-mesh-color");
__publicField(EasyMeshColorComponent, "Properties", {
  _myVariableName: Property71.string(""),
  _myUseTuneTarget: Property71.bool(false),
  _mySetAsDefault: Property71.bool(false),
  _myColorModel: Property71.enum(["RGB", "HSV"], "HSV"),
  _myColorType: Property71.enum(["Color", "Diffuse Color", "Ambient Color", "Specular Color", "Emissive Color", "Fog Color", "Ambient Factor"], "Color")
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_scale_component.js
import { Component as Component72, Property as Property72 } from "@wonderlandengine/api";
var EasyScaleComponent = class extends Component72 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyScale(this._myIsLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyScaleComponent, "TypeName", "pp-easy-scale");
__publicField(EasyScaleComponent, "Properties", {
  _myVariableName: Property72.string(""),
  _mySetAsDefault: Property72.bool(false),
  _myUseTuneTarget: Property72.bool(false),
  _myIsLocal: Property72.bool(false),
  _myScaleAsOne: Property72.bool(true)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_child_number_component.js
import { Component as Component73, Property as Property73 } from "@wonderlandengine/api";
var EasySetTuneTargetChildNumberComponent = class extends Component73 {
  start() {
    if (isToolEnabled(this.engine)) {
      this._myEasyTuneVariableName = "Target Child ";
      if (this._myVariableName == "") {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this.object.pp_getID());
      } else {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this._myVariableName);
      }
      let childrenCount = this.object.pp_getChildren().length;
      let min = 1;
      let max = childrenCount;
      if (childrenCount == 0) {
        min = 0;
        max = 0;
      }
      getEasyTuneVariables(this.engine).add(new EasyTuneInt(this._myEasyTuneVariableName, 0, 10, min, max));
      if (this._mySetAsDefault) {
        EasyTuneUtils.setEasyTuneWidgetActiveVariable(this._myEasyTuneVariableName, this.engine);
      }
      this._myCurrentChildIndex = -1;
      this._myCurrentChildrenCount = childrenCount;
      this._myEasyTuneTarget = null;
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (getEasyTuneVariables(this.engine).isActive(this._myEasyTuneVariableName)) {
        let childrenCount = this.object.pp_getChildren().length;
        if (childrenCount != this._myCurrentChildrenCount) {
          this._myCurrentChildrenCount = childrenCount;
          let min = 1;
          let max = childrenCount;
          if (childrenCount == 0) {
            min = 0;
            max = 0;
          }
          let easyTuneVariable = getEasyTuneVariables(this.engine).getEasyTuneVariable(this._myEasyTuneVariableName);
          easyTuneVariable.setMin(min);
          easyTuneVariable.setMax(max);
        }
        let childIndex = getEasyTuneVariables(this.engine).get(this._myEasyTuneVariableName);
        if (childIndex != this._myCurrentChildIndex) {
          if (childIndex == 0 && this._myCurrentChildIndex != -1) {
            if (getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
              removeEasyTuneTarget(this.engine);
            }
            this._myEasyTuneTarget = null;
          } else if (childIndex > 0) {
            this._myEasyTuneTarget = this.object.pp_getChildren()[childIndex - 1];
            setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
          }
          this._myCurrentChildIndex = childIndex;
        }
      }
    }
  }
};
__publicField(EasySetTuneTargetChildNumberComponent, "TypeName", "pp-easy-set-tune-target-child-number");
__publicField(EasySetTuneTargetChildNumberComponent, "Properties", {
  _myVariableName: Property73.string(""),
  _mySetAsDefault: Property73.bool(false)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_grab_component.js
import { Component as Component74, Property as Property74 } from "@wonderlandengine/api";
var EasySetTuneTargeetGrabComponent = class extends Component74 {
  start() {
    this._myGrabber = null;
    if (isToolEnabled(this.engine)) {
      this._myGrabber = this.object.pp_getComponent(GrabberHandComponent);
      this._myEasyTuneTarget = null;
    }
  }
  _onRelease(grabber, grabbable) {
    this._myEasyTuneTarget = grabbable.object;
    setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
  }
  _onGrab(grabber, grabbable) {
    if (getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
      removeEasyTuneTarget(this.engine);
    }
    this._myEasyTuneTarget = null;
  }
  onActivate() {
    if (isToolEnabled(this.engine)) {
      if (this._myGrabber != null) {
        this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
      }
    }
  }
  onDeactivate() {
    if (isToolEnabled(this.engine)) {
      if (this._myGrabber != null) {
        this._myGrabber.unregisterThrowEventListener(this);
      }
    }
  }
};
__publicField(EasySetTuneTargeetGrabComponent, "TypeName", "pp-easy-set-tune-target-grab");
__publicField(EasySetTuneTargeetGrabComponent, "Properties", {});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_text_color_component.js
import { Component as Component75, Property as Property75 } from "@wonderlandengine/api";
var EasyTextColorComponent = class extends Component75 {
  init() {
    this._myEasyObjectTuner = null;
    if (isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyTextColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
    }
  }
  start() {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyTextColorComponent, "TypeName", "pp-easy-text-color");
__publicField(EasyTextColorComponent, "Properties", {
  _myVariableName: Property75.string(""),
  _mySetAsDefault: Property75.bool(false),
  _myUseTuneTarget: Property75.bool(false),
  _myColorModel: Property75.enum(["RGB", "HSV"], "HSV"),
  _myColorType: Property75.enum(["Color", "Effect Color"], "Color")
});
export {
  AddPPToWindowComponent,
  AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent,
  AudioEvent,
  AudioManager,
  AudioManagerComponent,
  AudioPlayer,
  AudioSetup,
  AudioUtils,
  BaseGamepad,
  BasePose,
  BasePoseParams2 as BasePoseParams,
  BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent,
  BrowserUtils,
  CADisplayLeaderboardComponent,
  CADummyServer,
  CAError,
  CAUtils2 as CAUtils,
  CharacterColliderAdditionalSetup,
  CharacterColliderDebugSetup,
  CharacterColliderHorizontalCheckSetup,
  CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementSetup,
  CharacterColliderSurfaceSetup,
  CharacterColliderUtils,
  CharacterColliderVerticalCheckSetup,
  CharacterColliderWallSlideSetup,
  CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType,
  CharacterCollisionDebugResults,
  CharacterCollisionInternalResults,
  CharacterCollisionMovementResults,
  CharacterCollisionResults,
  CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults,
  CharacterCollisionSystem,
  CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults,
  CharacterController,
  CharacterControllerComponent,
  CharacterControllerUtils,
  ClassicGamepadCore,
  CleanedPlayerLocomotion,
  CleanedPlayerLocomotionSmooth,
  CleanedPlayerTransformManager,
  ClearConsoleOnXRSessionStartComponent,
  CloneParams,
  CollisionCheck,
  CollisionCheckBridge,
  CollisionCheckParams,
  CollisionCheckUtils,
  CollisionRuntimeParams,
  ColorUtils,
  ConsoleVR,
  ConsoleVRToolComponent,
  ConsoleVRWidget,
  ConsoleVRWidgetAdditionalSetup,
  ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType,
  ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender,
  ConsoleVRWidgetSetup,
  ConsoleVRWidgetUI,
  CopyHandTransformComponent,
  CopyHeadTransformComponent,
  CopyPlayerPivotTransformComponent,
  CopyPlayerTransformComponent,
  CustomCloneParams,
  DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager,
  DebugManagerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent,
  DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent,
  DeepCloneParams,
  DefaultResources,
  DefaultResourcesMaterials,
  DefaultResourcesMeshes,
  Direction2DTo3DConverter,
  Direction2DTo3DConverterParams,
  EPSILON,
  EPSILON_DEGREES,
  EasingFunction2 as EasingFunction,
  EasyLightAttenuation,
  EasyLightAttenuationComponent,
  EasyLightColor,
  EasyLightColorComponent,
  EasyMeshAmbientFactor,
  EasyMeshAmbientFactorComponent,
  EasyMeshColor,
  EasyMeshColorComponent,
  EasyObjectTuner,
  EasyScale,
  EasyScaleComponent,
  EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent,
  EasyTextColor,
  EasyTextColorComponent,
  EasyTransform,
  EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget,
  EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetSetup,
  EasyTuneBaseWidgetUI,
  EasyTuneBool,
  EasyTuneBoolArray,
  EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetSetup,
  EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent,
  EasyTuneInt2 as EasyTuneInt,
  EasyTuneIntArray,
  EasyTuneNoneWidget,
  EasyTuneNoneWidgetSetup,
  EasyTuneNoneWidgetUI,
  EasyTuneNumber,
  EasyTuneNumberArray,
  EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetSetup,
  EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent,
  EasyTuneTransform,
  EasyTuneTransformWidget,
  EasyTuneTransformWidgetSetup,
  EasyTuneTransformWidgetUI,
  EasyTuneUtils,
  EasyTuneVariable,
  EasyTuneVariableArray,
  EasyTuneVariableType,
  EasyTuneVariables,
  EasyTuneWidget,
  EasyTuneWidgetAdditionalSetup,
  EasyTuneWidgetSetup,
  EnableDebugsComponent,
  EnableToolsComponent,
  ExtensionUtils,
  FSM,
  FingerCursorComponent,
  GamepadAxesEvent,
  GamepadAxesID,
  GamepadAxesInfo,
  GamepadButtonEvent,
  GamepadButtonID,
  GamepadButtonInfo,
  GamepadControlSchemeComponent,
  GamepadCore,
  GamepadMeshAnimatorComponent,
  GamepadPulseInfo,
  GamepadUtils,
  GamepadsManager,
  GetDefaultResourcesComponent,
  GetPlayerObjectsComponent,
  GlobalGravityComponent,
  GrabbableComponent,
  GrabberHandComponent,
  HandPose,
  HandPoseParams,
  Handedness,
  HandednessIndex,
  HeadPose,
  HowlerAudioPlayer,
  InitConsoleVRComponent,
  InitEasyTuneVariablesComponent,
  InputManager,
  InputManagerComponent,
  InputSourceType,
  InputUtils,
  IntOverValue,
  IntRangeOverValue,
  JSUtils,
  KeyID,
  Keyboard,
  KeyboardGamepadCore,
  LocomotionUtils,
  MaterialUtils,
  MeshCreationParams,
  MeshCreationTriangleParams,
  MeshCreationVertexParams,
  MeshUtils,
  Mouse,
  MouseButtonID,
  MuteEverythingComponent,
  NumberOverValue,
  NumberRangeOverValue,
  ObjectPool,
  ObjectPoolParams,
  ObjectPoolsManager,
  PPGatewayComponent,
  PerformDelayedMode,
  PerformMode,
  PhysicsCollisionCollector,
  PhysicsLayerFlags,
  PhysicsUtils,
  PlayerCharacterController,
  PlayerCharacterControllerComponent,
  PlayerHandCharacterController,
  PlayerHandCharacterControllerComponent,
  PlayerHeadCharacterController,
  PlayerHeadCharacterControllerComponent,
  PlayerHeadController,
  PlayerHeadControllerComponent,
  PlayerHeadManager,
  PlayerHeadManagerParams,
  PlayerLocomotion,
  PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionGravity,
  PlayerLocomotionGravityComponent,
  PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams,
  PlayerLocomotionRotateComponent,
  PlayerLocomotionRotateParams,
  PlayerLocomotionSmoothComponent,
  PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleportComponent,
  PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType,
  PlayerObjects,
  PlayerObscureManager,
  PlayerObscureManagerParams,
  PlayerTransformManager,
  PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag,
  PlayerViewOcclusion,
  PlayerViewOcclusionComponent,
  RaycastHit,
  RaycastResults,
  RaycastSetup,
  SaveManager,
  SaveUtils,
  SetActiveComponent,
  SetHandLocalTransformComponent,
  SetHeadLocalTransformComponent,
  SetHeadNonVRLocalTransformComponent,
  SetHeadVRLocalTransformComponent,
  SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent,
  SkipStateFunction,
  SpatialAudioListenerComponent,
  State,
  StateData,
  SwitchHandObjectComponent,
  SyncedCharacterController,
  TextUtils,
  Timer,
  TimerState,
  ToolCursorComponent,
  ToolHandedness,
  ToolInputSourceType,
  TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent,
  TrackedHandJointID,
  TrackedHandJointIDIndex,
  TrackedHandJointPose,
  TrackedHandPose,
  TrackedHandPoseParams,
  Transition,
  TransitionData,
  UniversalGamepad,
  VirtualGamepad,
  VirtualGamepadButtonParams,
  VirtualGamepadComponent,
  VirtualGamepadGamepadCore,
  VirtualGamepadIcon,
  VirtualGamepadIconParams,
  VirtualGamepadIconType,
  VirtualGamepadParams,
  VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick,
  VisualArrow,
  VisualArrowParams,
  VisualData,
  VisualDataMaterials,
  VisualElementType,
  VisualLine,
  VisualLineParams,
  VisualManager,
  VisualManagerComponent,
  VisualMesh,
  VisualMeshParams,
  VisualPoint,
  VisualPointParams,
  VisualRaycast,
  VisualRaycastParams,
  VisualText,
  VisualTextParams,
  VisualTorus,
  VisualTorusParams,
  VisualTransform,
  VisualTransformParams,
  WidgetFrame,
  WidgetFrameSetup,
  WidgetFrameUI,
  XRGamepadCore,
  XRUtils,
  addEngine,
  addRefreshEasyTuneWidgetCallback,
  addSetEasyTuneWidgetActiveVariableCallback,
  areButtonsPressEnd,
  areButtonsPressStart,
  areButtonsTouchEnd,
  areButtonsTouchStart,
  assignProperties,
  checkMovement,
  checkTeleportToTransform,
  checkTransform,
  cleanObjectProperties,
  clear,
  cloneMesh,
  color1To255,
  color255To1,
  computeCeilingPerceivedAngle,
  computeGroundPerceivedAngle,
  convertCharacterColliderSetupToCollisionCheckParams,
  convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults,
  copyObjectProperties,
  createCharacterColliderSetupSimplified,
  createMesh,
  createPlaneMesh,
  createTeleportColliderFromMovementCollider,
  doesObjectPropertyUseAccessors,
  exportEasyTuneVariables,
  generate360TeleportParamsFromMovementParams,
  getAudioManager,
  getCharacterCollisionSystem,
  getComponentObjects,
  getComponentsObjects,
  getConsoleVR,
  getDebugManager,
  getDebugVisualManager2 as getDebugVisualManager,
  getDefaultResources,
  getDummyServer,
  getEasyTuneTarget,
  getEasyTuneVariables,
  getEngines,
  getFrame,
  getGamepads,
  getGamepadsManager,
  getGlobalGravityAcceleration,
  getGlobalGravityDirection,
  getHandednessByIndex,
  getInputManager,
  getInputSource,
  getInputSourceType,
  getInputSourceTypeByHandedness,
  getJointIDByIndex,
  getKeyboard,
  getLayerFlagsNames,
  getLeaderboard,
  getLeaderboardDummy,
  getLeftGamepad,
  getMainEngine2 as getMainEngine,
  getMouse,
  getObjectByIDObjects,
  getObjectByNameObjects,
  getObjectFromPath,
  getObjectNameFromPath,
  getObjectParentFromPath,
  getObjectProperty,
  getObjectPropertyDescriptor,
  getObjectPropertyNames,
  getObjectPropertyOwnParent,
  getObjectPropertyOwnParents,
  getObjectPrototypes,
  getObjectsByIDObjects,
  getObjectsByNameObjects,
  getOppositeHandedness,
  getOriginalConsoleAssert,
  getOriginalConsoleClear,
  getOriginalConsoleDebug,
  getOriginalConsoleError,
  getOriginalConsoleInfo,
  getOriginalConsoleLog,
  getOriginalConsoleWarn,
  getPlayerObjects2 as getPlayerObjects,
  getReferenceSpaceType,
  getRightGamepad,
  getSession,
  getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay,
  getUser,
  getUserDummy,
  getVisualData,
  getVisualManager,
  getWebXR,
  has,
  hasAudioManager,
  hasCharacterCollisionSystem,
  hasConsoleVR,
  hasDebugEnabled,
  hasDebugManager,
  hasDefaultResources,
  hasEasyTuneTarget,
  hasEasyTuneVariables,
  hasEngine,
  hasGlobalGravityAcceleration,
  hasGlobalGravityDirection,
  hasInputManager,
  hasPlayerObjects,
  hasToolEnabled,
  hasVisualData,
  hasVisualManager,
  hsvCodeToHuman,
  hsvHumanToCode,
  hsvToRgb,
  importEasyTuneVariables,
  initArrayExtension,
  initArrayExtensionProtoype,
  initBridge,
  initComponentCloneMod,
  initComponentMods,
  initCursorComponentMod,
  initCursorComponentModPrototype,
  initCursorTargetComponentMod,
  initCursorTargetComponentModPrototype,
  initEngine,
  initJSExtensions,
  initJSPlugins,
  initMathExtension,
  initMathExtensionStatic,
  initMouseLookComponentMod,
  initMouseLookComponentModPrototype,
  initNumberExtension,
  initNumberExtensionPrototype,
  initObjectExtension,
  initObjectExtensionProtoype,
  initPP,
  initPlugins,
  initSceneExtension,
  initSceneExtensionPrototype,
  initWLExtensions,
  initWLMods,
  initWLPlugins,
  invertMesh,
  isARSupported,
  isAnyButtonPressEnd,
  isAnyButtonPressStart,
  isAnyButtonTouchEnd,
  isAnyButtonTouchStart,
  isAudioPlaybackBlocked,
  isClassByName,
  isDebugEnabled,
  isDesktop,
  isDeviceEmulated,
  isFunctionByName,
  isMobile,
  isObjectByName,
  isReferenceSpaceLocalFloor,
  isSDKAvailable,
  isSessionActive,
  isToolEnabled,
  isUseDummyServerOnError,
  isUseDummyServerOnSDKMissing,
  isVRSupported,
  load,
  loadBool,
  loadNumber,
  loadString,
  mat3_create,
  mat4_create,
  mat4_fromPositionRotation,
  mat4_fromPositionRotationDegrees,
  mat4_fromPositionRotationDegreesScale,
  mat4_fromPositionRotationQuat,
  mat4_fromPositionRotationQuatScale,
  mat4_fromPositionRotationRadians,
  mat4_fromPositionRotationRadiansScale,
  mat4_fromPositionRotationScale,
  overwriteObjectProperty,
  quat2_create,
  quat2_fromPositionRotation,
  quat2_fromPositionRotationDegrees,
  quat2_fromPositionRotationQuat,
  quat2_fromPositionRotationRadians,
  quat_create,
  raycast,
  refreshEasyTuneWidget,
  registerPPComponents,
  registerSessionEndEventListener,
  registerSessionStartEndEventListeners,
  registerSessionStartEventListener,
  registerWLComponents,
  remove,
  removeAudioManager,
  removeCharacterCollisionSystem,
  removeConsoleVR,
  removeDebugEnabled,
  removeDebugManager,
  removeDefaultResources,
  removeEasyTuneTarget,
  removeEasyTuneVariables,
  removeEngine,
  removeGlobalGravityAcceleration,
  removeGlobalGravityDirection,
  removeInputManager,
  removePlayerObjects,
  removeRefreshEasyTuneWidgetCallback,
  removeSetEasyTuneWidgetActiveVariableCallback,
  removeToolEnabled,
  removeVisualData,
  removeVisualManager,
  rgbCodeToHuman,
  rgbHumanToCode,
  rgbToHsv,
  save,
  setActiveObjects,
  setAlpha,
  setAudioManager,
  setCharacterCollisionSystem,
  setClonedMaterials,
  setConsoleVR,
  setDebugEnabled,
  setDebugManager,
  setDefaultResources,
  setDummyServer,
  setEasyTuneTarget,
  setEasyTuneVariables,
  setEasyTuneWidgetActiveVariable,
  setGlobalGravityAcceleration,
  setGlobalGravityDirection,
  setInputManager,
  setLayerFlagsNames,
  setMainEngine,
  setObjectAlpha,
  setObjectClonedMaterials,
  setObjectFogColor,
  setObjectMaterial,
  setObjectProperty,
  setObjectSpecularColor,
  setPlayerObjects,
  setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay,
  setToolEnabled,
  setUseDummyServerOnError,
  setUseDummyServerOnSDKMissing,
  setVisualData,
  setVisualManager,
  submitScore,
  submitScoreDummy,
  unregisterSessionEndEventListener,
  unregisterSessionStartEndEventListeners,
  unregisterSessionStartEventListener,
  updateCeilingInfo,
  updateGroundInfo,
  vec2_create,
  vec3_create2 as vec3_create,
  vec4_create2 as vec4_create
};
//# sourceMappingURL=wle_pp_bundle.js.map
